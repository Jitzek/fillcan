import{S as ve,i as Ee,s as be,N as gn,e as d,c as g,a as E,d as l,b as z,g as h,O as _n,P as vn,Q as En,q as b,o as w,V as Pa,W as Ps,G as o,z as so,X as Ba,Y as bo,u as wo,C as ks,Z as Io,t as i,h as f,j as $s,_ as ao,l as dn,$ as oo,E as Oe,k as j,m as Y,J as Vs,a0 as lo,a1 as Us,w as I,x as S,y as D,B as C,n as An,p as Pn,a2 as Do,I as io,K as Co,M as So,a3 as Ro,a4 as Ao,f as Po,L as Bo,a5 as Lo,A as ko}from"../chunks/index-5cee6edc.js";import{H as To,f as La}from"../chunks/HamburgerMenuIcon-d70e24a9.js";import{g as je,s as Oo}from"../chunks/StateStore-3027a606.js";import{b as Ts}from"../chunks/paths-fbc4d9fe.js";function Vo(c){let e,t;const r=c[3].default,$=gn(r,c,c[2],null);return{c(){e=d("a"),$&&$.c(),this.h()},l(n){e=g(n,"A",{href:!0,target:!0,class:!0});var s=E(e);$&&$.l(s),s.forEach(l),this.h()},h(){z(e,"href",c[0]),z(e,"target",c[1]),z(e,"class","svelte-1i4e1zt")},m(n,s){h(n,e,s),$&&$.m(e,null),t=!0},p(n,[s]){$&&$.p&&(!t||s&4)&&_n($,r,n,n[2],t?En(r,n[2],s,null):vn(n[2]),null),(!t||s&1)&&z(e,"href",n[0]),(!t||s&2)&&z(e,"target",n[1])},i(n){t||(b($,n),t=!0)},o(n){w($,n),t=!1},d(n){n&&l(e),$&&$.d(n)}}}function yo(c,e,t){let{$$slots:r={},$$scope:$}=e,{href:n}=e,{target:s=""}=e;return c.$$set=a=>{"href"in a&&t(0,n=a.href),"target"in a&&t(1,s=a.target),"$$scope"in a&&t(2,$=a.$$scope)},[n,s,$,r]}class fe extends ve{constructor(e){super(),Ee(this,e,yo,Vo,be,{href:0,target:1})}}var Gs={exports:{}};function Hs(c){return c instanceof Map?c.clear=c.delete=c.set=function(){throw new Error("map is read-only")}:c instanceof Set&&(c.add=c.clear=c.delete=function(){throw new Error("set is read-only")}),Object.freeze(c),Object.getOwnPropertyNames(c).forEach(function(e){var t=c[e];typeof t=="object"&&!Object.isFrozen(t)&&Hs(t)}),c}Gs.exports=Hs;Gs.exports.default=Hs;var Mo=Gs.exports;class ka{constructor(e){e.data===void 0&&(e.data={}),this.data=e.data,this.isMatchIgnored=!1}ignoreMatch(){this.isMatchIgnored=!0}}function fo(c){return c.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function Nn(c,...e){const t=Object.create(null);for(const r in c)t[r]=c[r];return e.forEach(function(r){for(const $ in r)t[$]=r[$]}),t}const Fo="</span>",Ta=c=>!!c.kind,xo=(c,{prefix:e})=>{if(c.includes(".")){const t=c.split(".");return[`${e}${t.shift()}`,...t.map((r,$)=>`${r}${"_".repeat($+1)}`)].join(" ")}return`${e}${c}`};class No{constructor(e,t){this.buffer="",this.classPrefix=t.classPrefix,e.walk(this)}addText(e){this.buffer+=fo(e)}openNode(e){if(!Ta(e))return;let t=e.kind;e.sublanguage?t=`language-${t}`:t=xo(t,{prefix:this.classPrefix}),this.span(t)}closeNode(e){!Ta(e)||(this.buffer+=Fo)}value(){return this.buffer}span(e){this.buffer+=`<span class="${e}">`}}class qs{constructor(){this.rootNode={children:[]},this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){this.top.children.push(e)}openNode(e){const t={kind:e,children:[]};this.add(t),this.stack.push(t)}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,t){return typeof t=="string"?e.addText(t):t.children&&(e.openNode(t),t.children.forEach(r=>this._walk(e,r)),e.closeNode(t)),e}static _collapse(e){typeof e!="string"&&(!e.children||(e.children.every(t=>typeof t=="string")?e.children=[e.children.join("")]:e.children.forEach(t=>{qs._collapse(t)})))}}class Uo extends qs{constructor(e){super(),this.options=e}addKeyword(e,t){e!==""&&(this.openNode(t),this.addText(e),this.closeNode())}addText(e){e!==""&&this.add(e)}addSublanguage(e,t){const r=e.root;r.kind=t,r.sublanguage=!0,this.add(r)}toHTML(){return new No(this,this.options).value()}finalize(){return!0}}function Is(c){return c?typeof c=="string"?c:c.source:null}function co(c){return Gn("(?=",c,")")}function Go(c){return Gn("(?:",c,")*")}function Ho(c){return Gn("(?:",c,")?")}function Gn(...c){return c.map(t=>Is(t)).join("")}function qo(c){const e=c[c.length-1];return typeof e=="object"&&e.constructor===Object?(c.splice(c.length-1,1),e):{}}function Ws(...c){const e=qo(c);return"("+(e.capture?"":"?:")+c.map(r=>Is(r)).join("|")+")"}function $o(c){return new RegExp(c.toString()+"|").exec("").length-1}function Wo(c,e){const t=c&&c.exec(e);return t&&t.index===0}const Qo=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function Qs(c,{joinWith:e}){let t=0;return c.map(r=>{t+=1;const $=t;let n=Is(r),s="";for(;n.length>0;){const a=Qo.exec(n);if(!a){s+=n;break}s+=n.substring(0,a.index),n=n.substring(a.index+a[0].length),a[0][0]==="\\"&&a[1]?s+="\\"+String(Number(a[1])+$):(s+=a[0],a[0]==="("&&t++)}return s}).map(r=>`(${r})`).join(e)}const Ko=/\b\B/,uo="[a-zA-Z]\\w*",Ks="[a-zA-Z_]\\w*",po="\\b\\d+(\\.\\d+)?",mo="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",ho="\\b(0b[01]+)",zo="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",jo=(c={})=>{const e=/^#![ ]*\//;return c.binary&&(c.begin=Gn(e,/.*\b/,c.binary,/\b.*/)),Nn({scope:"meta",begin:e,end:/$/,relevance:0,"on:begin":(t,r)=>{t.index!==0&&r.ignoreMatch()}},c)},Ds={begin:"\\\\[\\s\\S]",relevance:0},Yo={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[Ds]},Xo={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[Ds]},Zo={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},ys=function(c,e,t={}){const r=Nn({scope:"comment",begin:c,end:e,contains:[]},t);r.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});const $=Ws("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return r.contains.push({begin:Gn(/[ ]+/,"(",$,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),r},Jo=ys("//","$"),el=ys("/\\*","\\*/"),tl=ys("#","$"),rl={scope:"number",begin:po,relevance:0},nl={scope:"number",begin:mo,relevance:0},sl={scope:"number",begin:ho,relevance:0},al={begin:/(?=\/[^/\n]*\/)/,contains:[{scope:"regexp",begin:/\//,end:/\/[gimuy]*/,illegal:/\n/,contains:[Ds,{begin:/\[/,end:/\]/,relevance:0,contains:[Ds]}]}]},ol={scope:"title",begin:uo,relevance:0},ll={scope:"title",begin:Ks,relevance:0},il={begin:"\\.\\s*"+Ks,relevance:0},fl=function(c){return Object.assign(c,{"on:begin":(e,t)=>{t.data._beginMatch=e[1]},"on:end":(e,t)=>{t.data._beginMatch!==e[1]&&t.ignoreMatch()}})};var Bs=Object.freeze({__proto__:null,MATCH_NOTHING_RE:Ko,IDENT_RE:uo,UNDERSCORE_IDENT_RE:Ks,NUMBER_RE:po,C_NUMBER_RE:mo,BINARY_NUMBER_RE:ho,RE_STARTERS_RE:zo,SHEBANG:jo,BACKSLASH_ESCAPE:Ds,APOS_STRING_MODE:Yo,QUOTE_STRING_MODE:Xo,PHRASAL_WORDS_MODE:Zo,COMMENT:ys,C_LINE_COMMENT_MODE:Jo,C_BLOCK_COMMENT_MODE:el,HASH_COMMENT_MODE:tl,NUMBER_MODE:rl,C_NUMBER_MODE:nl,BINARY_NUMBER_MODE:sl,REGEXP_MODE:al,TITLE_MODE:ol,UNDERSCORE_TITLE_MODE:ll,METHOD_GUARD:il,END_SAME_AS_BEGIN:fl});function cl(c,e){c.input[c.index-1]==="."&&e.ignoreMatch()}function $l(c,e){c.className!==void 0&&(c.scope=c.className,delete c.className)}function ul(c,e){!e||!c.beginKeywords||(c.begin="\\b("+c.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",c.__beforeBegin=cl,c.keywords=c.keywords||c.beginKeywords,delete c.beginKeywords,c.relevance===void 0&&(c.relevance=0))}function pl(c,e){!Array.isArray(c.illegal)||(c.illegal=Ws(...c.illegal))}function ml(c,e){if(!!c.match){if(c.begin||c.end)throw new Error("begin & end are not supported with match");c.begin=c.match,delete c.match}}function hl(c,e){c.relevance===void 0&&(c.relevance=1)}const dl=(c,e)=>{if(!c.beforeMatch)return;if(c.starts)throw new Error("beforeMatch cannot be used with starts");const t=Object.assign({},c);Object.keys(c).forEach(r=>{delete c[r]}),c.keywords=t.keywords,c.begin=Gn(t.beforeMatch,co(t.begin)),c.starts={relevance:0,contains:[Object.assign(t,{endsParent:!0})]},c.relevance=0,delete t.beforeMatch},gl=["of","and","for","in","not","or","if","then","parent","list","value"],_l="keyword";function go(c,e,t=_l){const r=Object.create(null);return typeof c=="string"?$(t,c.split(" ")):Array.isArray(c)?$(t,c):Object.keys(c).forEach(function(n){Object.assign(r,go(c[n],e,n))}),r;function $(n,s){e&&(s=s.map(a=>a.toLowerCase())),s.forEach(function(a){const u=a.split("|");r[u[0]]=[n,vl(u[0],u[1])]})}}function vl(c,e){return e?Number(e):El(c)?0:1}function El(c){return gl.includes(c.toLowerCase())}const Oa={},Un=c=>{console.error(c)},Va=(c,...e)=>{console.log(`WARN: ${c}`,...e)},cs=(c,e)=>{Oa[`${c}/${e}`]||(console.log(`Deprecated as of ${c}. ${e}`),Oa[`${c}/${e}`]=!0)},Os=new Error;function _o(c,e,{key:t}){let r=0;const $=c[t],n={},s={};for(let a=1;a<=e.length;a++)s[a+r]=$[a],n[a+r]=!0,r+=$o(e[a-1]);c[t]=s,c[t]._emit=n,c[t]._multi=!0}function bl(c){if(!!Array.isArray(c.begin)){if(c.skip||c.excludeBegin||c.returnBegin)throw Un("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),Os;if(typeof c.beginScope!="object"||c.beginScope===null)throw Un("beginScope must be object"),Os;_o(c,c.begin,{key:"beginScope"}),c.begin=Qs(c.begin,{joinWith:""})}}function wl(c){if(!!Array.isArray(c.end)){if(c.skip||c.excludeEnd||c.returnEnd)throw Un("skip, excludeEnd, returnEnd not compatible with endScope: {}"),Os;if(typeof c.endScope!="object"||c.endScope===null)throw Un("endScope must be object"),Os;_o(c,c.end,{key:"endScope"}),c.end=Qs(c.end,{joinWith:""})}}function Il(c){c.scope&&typeof c.scope=="object"&&c.scope!==null&&(c.beginScope=c.scope,delete c.scope)}function Dl(c){Il(c),typeof c.beginScope=="string"&&(c.beginScope={_wrap:c.beginScope}),typeof c.endScope=="string"&&(c.endScope={_wrap:c.endScope}),bl(c),wl(c)}function Cl(c){function e(s,a){return new RegExp(Is(s),"m"+(c.case_insensitive?"i":"")+(c.unicodeRegex?"u":"")+(a?"g":""))}class t{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(a,u){u.position=this.position++,this.matchIndexes[this.matchAt]=u,this.regexes.push([u,a]),this.matchAt+=$o(a)+1}compile(){this.regexes.length===0&&(this.exec=()=>null);const a=this.regexes.map(u=>u[1]);this.matcherRe=e(Qs(a,{joinWith:"|"}),!0),this.lastIndex=0}exec(a){this.matcherRe.lastIndex=this.lastIndex;const u=this.matcherRe.exec(a);if(!u)return null;const p=u.findIndex((_,v)=>v>0&&_!==void 0),m=this.matchIndexes[p];return u.splice(0,p),Object.assign(u,m)}}class r{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(a){if(this.multiRegexes[a])return this.multiRegexes[a];const u=new t;return this.rules.slice(a).forEach(([p,m])=>u.addRule(p,m)),u.compile(),this.multiRegexes[a]=u,u}resumingScanAtSamePosition(){return this.regexIndex!==0}considerAll(){this.regexIndex=0}addRule(a,u){this.rules.push([a,u]),u.type==="begin"&&this.count++}exec(a){const u=this.getMatcher(this.regexIndex);u.lastIndex=this.lastIndex;let p=u.exec(a);if(this.resumingScanAtSamePosition()&&!(p&&p.index===this.lastIndex)){const m=this.getMatcher(0);m.lastIndex=this.lastIndex+1,p=m.exec(a)}return p&&(this.regexIndex+=p.position+1,this.regexIndex===this.count&&this.considerAll()),p}}function $(s){const a=new r;return s.contains.forEach(u=>a.addRule(u.begin,{rule:u,type:"begin"})),s.terminatorEnd&&a.addRule(s.terminatorEnd,{type:"end"}),s.illegal&&a.addRule(s.illegal,{type:"illegal"}),a}function n(s,a){const u=s;if(s.isCompiled)return u;[$l,ml,Dl,dl].forEach(m=>m(s,a)),c.compilerExtensions.forEach(m=>m(s,a)),s.__beforeBegin=null,[ul,pl,hl].forEach(m=>m(s,a)),s.isCompiled=!0;let p=null;return typeof s.keywords=="object"&&s.keywords.$pattern&&(s.keywords=Object.assign({},s.keywords),p=s.keywords.$pattern,delete s.keywords.$pattern),p=p||/\w+/,s.keywords&&(s.keywords=go(s.keywords,c.case_insensitive)),u.keywordPatternRe=e(p,!0),a&&(s.begin||(s.begin=/\B|\b/),u.beginRe=e(u.begin),!s.end&&!s.endsWithParent&&(s.end=/\B|\b/),s.end&&(u.endRe=e(u.end)),u.terminatorEnd=Is(u.end)||"",s.endsWithParent&&a.terminatorEnd&&(u.terminatorEnd+=(s.end?"|":"")+a.terminatorEnd)),s.illegal&&(u.illegalRe=e(s.illegal)),s.contains||(s.contains=[]),s.contains=[].concat(...s.contains.map(function(m){return Sl(m==="self"?s:m)})),s.contains.forEach(function(m){n(m,u)}),s.starts&&n(s.starts,a),u.matcher=$(u),u}if(c.compilerExtensions||(c.compilerExtensions=[]),c.contains&&c.contains.includes("self"))throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return c.classNameAliases=Nn(c.classNameAliases||{}),n(c)}function vo(c){return c?c.endsWithParent||vo(c.starts):!1}function Sl(c){return c.variants&&!c.cachedVariants&&(c.cachedVariants=c.variants.map(function(e){return Nn(c,{variants:null},e)})),c.cachedVariants?c.cachedVariants:vo(c)?Nn(c,{starts:c.starts?Nn(c.starts):null}):Object.isFrozen(c)?Nn(c):c}var Rl="11.5.0";class Al extends Error{constructor(e,t){super(e),this.name="HTMLInjectionError",this.html=t}}const xs=fo,ya=Nn,Ma=Symbol("nomatch"),Pl=7,Bl=function(c){const e=Object.create(null),t=Object.create(null),r=[];let $=!0;const n="Could not find the language '{}', did you forget to load/include a language module?",s={disableAutodetect:!0,name:"Plain text",contains:[]};let a={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:Uo};function u(U){return a.noHighlightRe.test(U)}function p(U){let G=U.className+" ";G+=U.parentNode?U.parentNode.className:"";const te=a.languageDetectRe.exec(G);if(te){const ee=k(te[1]);return ee||(Va(n.replace("{}",te[1])),Va("Falling back to no-highlight mode for this block.",U)),ee?te[1]:"no-highlight"}return G.split(/\s+/).find(ee=>u(ee)||k(ee))}function m(U,G,te){let ee="",ne="";typeof G=="object"?(ee=U,te=G.ignoreIllegals,ne=G.language):(cs("10.7.0","highlight(lang, code, ...args) has been deprecated."),cs("10.7.0",`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`),ne=U,ee=G),te===void 0&&(te=!0);const le={code:ee,language:ne};K("before:highlight",le);const ae=le.result?le.result:_(le.language,le.code,te);return ae.code=le.code,K("after:highlight",ae),ae}function _(U,G,te,ee){const ne=Object.create(null);function le(ke,Te){return ke.keywords[Te]}function ae(){if(!re.keywords){Ae.addText(Ve);return}let ke=0;re.keywordPatternRe.lastIndex=0;let Te=re.keywordPatternRe.exec(Ve),Me="";for(;Te;){Me+=Ve.substring(ke,Te.index);const Ue=Re.case_insensitive?Te[0].toLowerCase():Te[0],qe=le(re,Ue);if(qe){const[xe,Ge]=qe;if(Ae.addText(Me),Me="",ne[Ue]=(ne[Ue]||0)+1,ne[Ue]<=Pl&&(oe+=Ge),xe.startsWith("_"))Me+=Te[0];else{const ye=Re.classNameAliases[xe]||xe;Ae.addKeyword(Te[0],ye)}}else Me+=Te[0];ke=re.keywordPatternRe.lastIndex,Te=re.keywordPatternRe.exec(Ve)}Me+=Ve.substr(ke),Ae.addText(Me)}function J(){if(Ve==="")return;let ke=null;if(typeof re.subLanguage=="string"){if(!e[re.subLanguage]){Ae.addText(Ve);return}ke=_(re.subLanguage,Ve,!0,he[re.subLanguage]),he[re.subLanguage]=ke._top}else ke=R(Ve,re.subLanguage.length?re.subLanguage:null);re.relevance>0&&(oe+=ke.relevance),Ae.addSublanguage(ke._emitter,ke.language)}function ue(){re.subLanguage!=null?J():ae(),Ve=""}function De(ke,Te){let Me=1;const Ue=Te.length-1;for(;Me<=Ue;){if(!ke._emit[Me]){Me++;continue}const qe=Re.classNameAliases[ke[Me]]||ke[Me],xe=Te[Me];qe?Ae.addKeyword(xe,qe):(Ve=xe,ae(),Ve=""),Me++}}function de(ke,Te){return ke.scope&&typeof ke.scope=="string"&&Ae.openNode(Re.classNameAliases[ke.scope]||ke.scope),ke.beginScope&&(ke.beginScope._wrap?(Ae.addKeyword(Ve,Re.classNameAliases[ke.beginScope._wrap]||ke.beginScope._wrap),Ve=""):ke.beginScope._multi&&(De(ke.beginScope,Te),Ve="")),re=Object.create(ke,{parent:{value:re}}),re}function me(ke,Te,Me){let Ue=Wo(ke.endRe,Me);if(Ue){if(ke["on:end"]){const qe=new ka(ke);ke["on:end"](Te,qe),qe.isMatchIgnored&&(Ue=!1)}if(Ue){for(;ke.endsParent&&ke.parent;)ke=ke.parent;return ke}}if(ke.endsWithParent)return me(ke.parent,Te,Me)}function Ce(ke){return re.matcher.regexIndex===0?(Ve+=ke[0],1):(Fe=!0,0)}function _e(ke){const Te=ke[0],Me=ke.rule,Ue=new ka(Me),qe=[Me.__beforeBegin,Me["on:begin"]];for(const xe of qe)if(!!xe&&(xe(ke,Ue),Ue.isMatchIgnored))return Ce(Te);return Me.skip?Ve+=Te:(Me.excludeBegin&&(Ve+=Te),ue(),!Me.returnBegin&&!Me.excludeBegin&&(Ve=Te)),de(Me,ke),Me.returnBegin?0:Te.length}function se(ke){const Te=ke[0],Me=G.substr(ke.index),Ue=me(re,ke,Me);if(!Ue)return Ma;const qe=re;re.endScope&&re.endScope._wrap?(ue(),Ae.addKeyword(Te,re.endScope._wrap)):re.endScope&&re.endScope._multi?(ue(),De(re.endScope,ke)):qe.skip?Ve+=Te:(qe.returnEnd||qe.excludeEnd||(Ve+=Te),ue(),qe.excludeEnd&&(Ve=Te));do re.scope&&Ae.closeNode(),!re.skip&&!re.subLanguage&&(oe+=re.relevance),re=re.parent;while(re!==Ue.parent);return Ue.starts&&de(Ue.starts,ke),qe.returnEnd?0:Te.length}function ie(){const ke=[];for(let Te=re;Te!==Re;Te=Te.parent)Te.scope&&ke.unshift(Te.scope);ke.forEach(Te=>Ae.openNode(Te))}let ge={};function we(ke,Te){const Me=Te&&Te[0];if(Ve+=ke,Me==null)return ue(),0;if(ge.type==="begin"&&Te.type==="end"&&ge.index===Te.index&&Me===""){if(Ve+=G.slice(Te.index,Te.index+1),!$){const Ue=new Error(`0 width match regex (${U})`);throw Ue.languageName=U,Ue.badRule=ge.rule,Ue}return 1}if(ge=Te,Te.type==="begin")return _e(Te);if(Te.type==="illegal"&&!te){const Ue=new Error('Illegal lexeme "'+Me+'" for mode "'+(re.scope||"<unnamed>")+'"');throw Ue.mode=re,Ue}else if(Te.type==="end"){const Ue=se(Te);if(Ue!==Ma)return Ue}if(Te.type==="illegal"&&Me==="")return 1;if(Pe>1e5&&Pe>Te.index*3)throw new Error("potential infinite loop, way more iterations than matches");return Ve+=Me,Me.length}const Re=k(U);if(!Re)throw Un(n.replace("{}",U)),new Error('Unknown language: "'+U+'"');const Be=Cl(Re);let Ie="",re=ee||Be;const he={},Ae=new a.__emitter(a);ie();let Ve="",oe=0,ce=0,Pe=0,Fe=!1;try{for(re.matcher.considerAll();;){Pe++,Fe?Fe=!1:re.matcher.considerAll(),re.matcher.lastIndex=ce;const ke=re.matcher.exec(G);if(!ke)break;const Te=G.substring(ce,ke.index),Me=we(Te,ke);ce=ke.index+Me}return we(G.substr(ce)),Ae.closeAllNodes(),Ae.finalize(),Ie=Ae.toHTML(),{language:U,value:Ie,relevance:oe,illegal:!1,_emitter:Ae,_top:re}}catch(ke){if(ke.message&&ke.message.includes("Illegal"))return{language:U,value:xs(G),illegal:!0,relevance:0,_illegalBy:{message:ke.message,index:ce,context:G.slice(ce-100,ce+100),mode:ke.mode,resultSoFar:Ie},_emitter:Ae};if($)return{language:U,value:xs(G),illegal:!1,relevance:0,errorRaised:ke,_emitter:Ae,_top:re};throw ke}}function v(U){const G={value:xs(U),illegal:!1,relevance:0,_top:s,_emitter:new a.__emitter(a)};return G._emitter.addText(U),G}function R(U,G){G=G||a.languages||Object.keys(e);const te=v(U),ee=G.filter(k).filter(Q).map(ue=>_(ue,U,!1));ee.unshift(te);const ne=ee.sort((ue,De)=>{if(ue.relevance!==De.relevance)return De.relevance-ue.relevance;if(ue.language&&De.language){if(k(ue.language).supersetOf===De.language)return 1;if(k(De.language).supersetOf===ue.language)return-1}return 0}),[le,ae]=ne,J=le;return J.secondBest=ae,J}function P(U,G,te){const ee=G&&t[G]||te;U.classList.add("hljs"),U.classList.add(`language-${ee}`)}function A(U){let G=null;const te=p(U);if(u(te))return;if(K("before:highlightElement",{el:U,language:te}),U.children.length>0&&(a.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(U)),a.throwUnescapedHTML))throw new Al("One of your code blocks includes unescaped HTML.",U.innerHTML);G=U;const ee=G.textContent,ne=te?m(ee,{language:te,ignoreIllegals:!0}):R(ee);U.innerHTML=ne.value,P(U,te,ne.language),U.result={language:ne.language,re:ne.relevance,relevance:ne.relevance},ne.secondBest&&(U.secondBest={language:ne.secondBest.language,relevance:ne.secondBest.relevance}),K("after:highlightElement",{el:U,result:ne,text:ee})}function T(U){a=ya(a,U)}const y=()=>{O(),cs("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")};function B(){O(),cs("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}let M=!1;function O(){if(document.readyState==="loading"){M=!0;return}document.querySelectorAll(a.cssSelector).forEach(A)}function x(){M&&O()}typeof window!="undefined"&&window.addEventListener&&window.addEventListener("DOMContentLoaded",x,!1);function F(U,G){let te=null;try{te=G(c)}catch(ee){if(Un("Language definition for '{}' could not be registered.".replace("{}",U)),$)Un(ee);else throw ee;te=s}te.name||(te.name=U),e[U]=te,te.rawDefinition=G.bind(null,c),te.aliases&&N(te.aliases,{languageName:U})}function V(U){delete e[U];for(const G of Object.keys(t))t[G]===U&&delete t[G]}function q(){return Object.keys(e)}function k(U){return U=(U||"").toLowerCase(),e[U]||e[t[U]]}function N(U,{languageName:G}){typeof U=="string"&&(U=[U]),U.forEach(te=>{t[te.toLowerCase()]=G})}function Q(U){const G=k(U);return G&&!G.disableAutodetect}function X(U){U["before:highlightBlock"]&&!U["before:highlightElement"]&&(U["before:highlightElement"]=G=>{U["before:highlightBlock"](Object.assign({block:G.el},G))}),U["after:highlightBlock"]&&!U["after:highlightElement"]&&(U["after:highlightElement"]=G=>{U["after:highlightBlock"](Object.assign({block:G.el},G))})}function Z(U){X(U),r.push(U)}function K(U,G){const te=U;r.forEach(function(ee){ee[te]&&ee[te](G)})}function W(U){return cs("10.7.0","highlightBlock will be removed entirely in v12.0"),cs("10.7.0","Please use highlightElement now."),A(U)}Object.assign(c,{highlight:m,highlightAuto:R,highlightAll:O,highlightElement:A,highlightBlock:W,configure:T,initHighlighting:y,initHighlightingOnLoad:B,registerLanguage:F,unregisterLanguage:V,listLanguages:q,getLanguage:k,registerAliases:N,autoDetection:Q,inherit:ya,addPlugin:Z}),c.debugMode=function(){$=!1},c.safeMode=function(){$=!0},c.versionString=Rl,c.regex={concat:Gn,lookahead:co,either:Ws,optional:Ho,anyNumberOfTimes:Go};for(const U in Bs)typeof Bs[U]=="object"&&Mo(Bs[U]);return Object.assign(c,Bs),c};var Cs=Bl({}),Ll=Cs;Cs.HighlightJS=Cs;Cs.default=Cs;var Fa=Ll;const kl=c=>({highlighted:c&8}),xa=c=>({highlighted:c[3]});function Tl(c){let e;return{c(){e=i(c[1])},l(t){e=f(t,c[1])},m(t,r){h(t,e,r)},p(t,r){r&2&&$s(e,t[1])},d(t){t&&l(e)}}}function Ol(c){let e,t;return{c(){e=new ao(!1),t=dn(),this.h()},l(r){e=oo(r,!1),t=dn(),this.h()},h(){e.a=t},m(r,$){e.m(c[3],r,$),h(r,t,$)},p(r,$){$&8&&e.p(r[3])},d(r){r&&l(t),r&&e.d()}}}function Vl(c){let e,t,r;function $(p,m){return p[3]!==void 0?Ol:Tl}let n=$(c),s=n(c),a=[{"data-language":r=c[0].name||"plaintext"},c[4]],u={};for(let p=0;p<a.length;p+=1)u=ks(u,a[p]);return{c(){e=d("pre"),t=d("code"),s.c(),this.h()},l(p){e=g(p,"PRE",{"data-language":!0});var m=E(e);t=g(m,"CODE",{class:!0});var _=E(t);s.l(_),_.forEach(l),m.forEach(l),this.h()},h(){z(t,"class","hljs"),Pa(e,u),Ps(e,"langtag",c[2]),Ps(e,"svelte-4cqgwq",!0)},m(p,m){h(p,e,m),o(e,t),s.m(t,null)},p(p,m){n===(n=$(p))&&s?s.p(p,m):(s.d(1),s=n(p),s&&(s.c(),s.m(t,null))),Pa(e,u=so(a,[m&1&&r!==(r=p[0].name||"plaintext")&&{"data-language":r},m&16&&p[4]])),Ps(e,"langtag",p[2]),Ps(e,"svelte-4cqgwq",!0)},d(p){p&&l(e),s.d()}}}function yl(c){let e;const t=c[6].default,r=gn(t,c,c[5],xa),$=r||Vl(c);return{c(){$&&$.c()},l(n){$&&$.l(n)},m(n,s){$&&$.m(n,s),e=!0},p(n,[s]){r?r.p&&(!e||s&40)&&_n(r,t,n,n[5],e?En(t,n[5],s,kl):vn(n[5]),xa):$&&$.p&&(!e||s&31)&&$.p(n,e?s:-1)},i(n){e||(b($,n),e=!0)},o(n){w($,n),e=!1},d(n){$&&$.d(n)}}}function Ml(c,e,t){const r=["language","code","langtag"];let $=Ba(e,r),{$$slots:n={},$$scope:s}=e,{language:a={name:void 0,register:void 0}}=e,{code:u=void 0}=e,{langtag:p=!1}=e;const m=bo();let _;return wo(()=>{_&&m("highlight",{highlighted:_})}),c.$$set=v=>{e=ks(ks({},e),Io(v)),t(4,$=Ba(e,r)),"language"in v&&t(0,a=v.language),"code"in v&&t(1,u=v.code),"langtag"in v&&t(2,p=v.langtag),"$$scope"in v&&t(5,s=v.$$scope)},c.$$.update=()=>{c.$$.dirty&3&&a.name&&a.register&&(Fa.registerLanguage(a.name,a.register),t(3,_=Fa.highlight(u,{language:a.name}).value))},[a,u,p,_,$,s,n]}class $e extends ve{constructor(e){super(),Ee(this,e,Ml,yl,be,{language:0,code:1,langtag:2})}}function Fl(c){const e=c.regex,t=c.COMMENT("//","$",{contains:[{begin:/\\\n/}]}),r="decltype\\(auto\\)",$="[a-zA-Z_]\\w*::",n="<[^<>]+>",s="(?!struct)("+r+"|"+e.optional($)+"[a-zA-Z_]\\w*"+e.optional(n)+")",a={className:"type",begin:"\\b[a-z\\d_]*_t\\b"},u="\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)",p={className:"string",variants:[{begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[c.BACKSLASH_ESCAPE]},{begin:"(u8?|U|L)?'("+u+"|.)",end:"'",illegal:"."},c.END_SAME_AS_BEGIN({begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},m={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},_={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},c.inherit(p,{className:"string"}),{className:"string",begin:/<.*?>/},t,c.C_BLOCK_COMMENT_MODE]},v={className:"title",begin:e.optional($)+c.IDENT_RE,relevance:0},R=e.optional($)+c.IDENT_RE+"\\s*\\(",P=["alignas","alignof","and","and_eq","asm","atomic_cancel","atomic_commit","atomic_noexcept","auto","bitand","bitor","break","case","catch","class","co_await","co_return","co_yield","compl","concept","const_cast|10","consteval","constexpr","constinit","continue","decltype","default","delete","do","dynamic_cast|10","else","enum","explicit","export","extern","false","final","for","friend","goto","if","import","inline","module","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","override","private","protected","public","reflexpr","register","reinterpret_cast|10","requires","return","sizeof","static_assert","static_cast|10","struct","switch","synchronized","template","this","thread_local","throw","transaction_safe","transaction_safe_dynamic","true","try","typedef","typeid","typename","union","using","virtual","volatile","while","xor","xor_eq"],A=["bool","char","char16_t","char32_t","char8_t","double","float","int","long","short","void","wchar_t","unsigned","signed","const","static"],T=["any","auto_ptr","barrier","binary_semaphore","bitset","complex","condition_variable","condition_variable_any","counting_semaphore","deque","false_type","future","imaginary","initializer_list","istringstream","jthread","latch","lock_guard","multimap","multiset","mutex","optional","ostringstream","packaged_task","pair","promise","priority_queue","queue","recursive_mutex","recursive_timed_mutex","scoped_lock","set","shared_future","shared_lock","shared_mutex","shared_timed_mutex","shared_ptr","stack","string_view","stringstream","timed_mutex","thread","true_type","tuple","unique_lock","unique_ptr","unordered_map","unordered_multimap","unordered_multiset","unordered_set","variant","vector","weak_ptr","wstring","wstring_view"],y=["abort","abs","acos","apply","as_const","asin","atan","atan2","calloc","ceil","cerr","cin","clog","cos","cosh","cout","declval","endl","exchange","exit","exp","fabs","floor","fmod","forward","fprintf","fputs","free","frexp","fscanf","future","invoke","isalnum","isalpha","iscntrl","isdigit","isgraph","islower","isprint","ispunct","isspace","isupper","isxdigit","labs","launder","ldexp","log","log10","make_pair","make_shared","make_shared_for_overwrite","make_tuple","make_unique","malloc","memchr","memcmp","memcpy","memset","modf","move","pow","printf","putchar","puts","realloc","scanf","sin","sinh","snprintf","sprintf","sqrt","sscanf","std","stderr","stdin","stdout","strcat","strchr","strcmp","strcpy","strcspn","strlen","strncat","strncmp","strncpy","strpbrk","strrchr","strspn","strstr","swap","tan","tanh","terminate","to_underlying","tolower","toupper","vfprintf","visit","vprintf","vsprintf"],O={type:A,keyword:P,literal:["NULL","false","nullopt","nullptr","true"],built_in:["_Pragma"],_type_hints:T},x={className:"function.dispatch",relevance:0,keywords:{_hint:y},begin:e.concat(/\b/,/(?!decltype)/,/(?!if)/,/(?!for)/,/(?!switch)/,/(?!while)/,c.IDENT_RE,e.lookahead(/(<[^<>]+>|)\s*\(/))},F=[x,_,a,t,c.C_BLOCK_COMMENT_MODE,m,p],V={variants:[{begin:/=/,end:/;/},{begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],keywords:O,contains:F.concat([{begin:/\(/,end:/\)/,keywords:O,contains:F.concat(["self"]),relevance:0}]),relevance:0},q={className:"function",begin:"("+s+"[\\*&\\s]+)+"+R,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,keywords:O,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:r,keywords:O,relevance:0},{begin:R,returnBegin:!0,contains:[v],relevance:0},{begin:/::/,relevance:0},{begin:/:/,endsWithParent:!0,contains:[p,m]},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,keywords:O,relevance:0,contains:[t,c.C_BLOCK_COMMENT_MODE,p,m,a,{begin:/\(/,end:/\)/,keywords:O,relevance:0,contains:["self",t,c.C_BLOCK_COMMENT_MODE,p,m,a]}]},a,t,c.C_BLOCK_COMMENT_MODE,_]};return{name:"C++",aliases:["cc","c++","h++","hpp","hh","hxx","cxx"],keywords:O,illegal:"</",classNameAliases:{"function.dispatch":"built_in"},contains:[].concat(V,q,x,F,[_,{begin:"\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",end:">",keywords:O,contains:["self",a]},{begin:c.IDENT_RE+"::",keywords:O},{match:[/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,/\s+/,/\w+/],className:{1:"keyword",3:"title.class"}}])}}const xl={name:"cpp",register:Fl};var pe=xl;function Nl(c){return{name:"CMake",aliases:["cmake.in"],case_insensitive:!0,keywords:{keyword:"break cmake_host_system_information cmake_minimum_required cmake_parse_arguments cmake_policy configure_file continue elseif else endforeach endfunction endif endmacro endwhile execute_process file find_file find_library find_package find_path find_program foreach function get_cmake_property get_directory_property get_filename_component get_property if include include_guard list macro mark_as_advanced math message option return separate_arguments set_directory_properties set_property set site_name string unset variable_watch while add_compile_definitions add_compile_options add_custom_command add_custom_target add_definitions add_dependencies add_executable add_library add_link_options add_subdirectory add_test aux_source_directory build_command create_test_sourcelist define_property enable_language enable_testing export fltk_wrap_ui get_source_file_property get_target_property get_test_property include_directories include_external_msproject include_regular_expression install link_directories link_libraries load_cache project qt_wrap_cpp qt_wrap_ui remove_definitions set_source_files_properties set_target_properties set_tests_properties source_group target_compile_definitions target_compile_features target_compile_options target_include_directories target_link_directories target_link_libraries target_link_options target_sources try_compile try_run ctest_build ctest_configure ctest_coverage ctest_empty_binary_directory ctest_memcheck ctest_read_custom_files ctest_run_script ctest_sleep ctest_start ctest_submit ctest_test ctest_update ctest_upload build_name exec_program export_library_dependencies install_files install_programs install_targets load_command make_directory output_required_files remove subdir_depends subdirs use_mangled_mesa utility_source variable_requires write_file qt5_use_modules qt5_use_package qt5_wrap_cpp on off true false and or not command policy target test exists is_newer_than is_directory is_symlink is_absolute matches less greater equal less_equal greater_equal strless strgreater strequal strless_equal strgreater_equal version_less version_greater version_equal version_less_equal version_greater_equal in_list defined"},contains:[{className:"variable",begin:/\$\{/,end:/\}/},c.HASH_COMMENT_MODE,c.QUOTE_STRING_MODE,c.NUMBER_MODE]}}const Ul={name:"cmake",register:Nl};var Ns=Ul;const Gl="<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#2e3440}.hljs,.hljs-subst{color:#d8dee9}.hljs-selector-tag{color:#81a1c1}.hljs-selector-id{color:#8fbcbb;font-weight:700}.hljs-selector-attr,.hljs-selector-class{color:#8fbcbb}.hljs-property,.hljs-selector-pseudo{color:#88c0d0}.hljs-addition{background-color:rgba(163,190,140,.5)}.hljs-deletion{background-color:rgba(191,97,106,.5)}.hljs-built_in,.hljs-class,.hljs-type{color:#8fbcbb}.hljs-function,.hljs-function>.hljs-title,.hljs-title.hljs-function{color:#88c0d0}.hljs-keyword,.hljs-literal,.hljs-symbol{color:#81a1c1}.hljs-number{color:#b48ead}.hljs-regexp{color:#ebcb8b}.hljs-string{color:#a3be8c}.hljs-title{color:#8fbcbb}.hljs-params{color:#d8dee9}.hljs-bullet{color:#81a1c1}.hljs-code{color:#8fbcbb}.hljs-emphasis{font-style:italic}.hljs-formula{color:#8fbcbb}.hljs-strong{font-weight:700}.hljs-link:hover{text-decoration:underline}.hljs-comment,.hljs-quote{color:#4c566a}.hljs-doctag{color:#8fbcbb}.hljs-meta,.hljs-meta .hljs-keyword{color:#5e81ac}.hljs-meta .hljs-string{color:#a3be8c}.hljs-attr{color:#8fbcbb}.hljs-attribute{color:#d8dee9}.hljs-name{color:#81a1c1}.hljs-section{color:#88c0d0}.hljs-tag{color:#81a1c1}.hljs-template-variable,.hljs-variable{color:#d8dee9}.hljs-template-tag{color:#5e81ac}.language-abnf .hljs-attribute{color:#88c0d0}.language-abnf .hljs-symbol{color:#ebcb8b}.language-apache .hljs-attribute{color:#88c0d0}.language-apache .hljs-section{color:#81a1c1}.language-arduino .hljs-built_in{color:#88c0d0}.language-aspectj .hljs-meta{color:#d08770}.language-aspectj>.hljs-title{color:#88c0d0}.language-bnf .hljs-attribute{color:#8fbcbb}.language-clojure .hljs-name{color:#88c0d0}.language-clojure .hljs-symbol{color:#ebcb8b}.language-coq .hljs-built_in{color:#88c0d0}.language-cpp .hljs-meta .hljs-string{color:#8fbcbb}.language-css .hljs-built_in{color:#88c0d0}.language-css .hljs-keyword{color:#d08770}.language-diff .hljs-meta,.language-ebnf .hljs-attribute{color:#8fbcbb}.language-glsl .hljs-built_in{color:#88c0d0}.language-groovy .hljs-meta:not(:first-child),.language-haxe .hljs-meta,.language-java .hljs-meta{color:#d08770}.language-ldif .hljs-attribute{color:#8fbcbb}.language-lisp .hljs-name,.language-lua .hljs-built_in,.language-moonscript .hljs-built_in,.language-nginx .hljs-attribute{color:#88c0d0}.language-nginx .hljs-section{color:#5e81ac}.language-pf .hljs-built_in,.language-processing .hljs-built_in{color:#88c0d0}.language-scss .hljs-keyword,.language-stylus .hljs-keyword{color:#81a1c1}.language-swift .hljs-meta{color:#d08770}.language-vim .hljs-built_in{color:#88c0d0;font-style:italic}.language-yaml .hljs-meta{color:#d08770}</style>";var Hl=Gl,L=(c=>(c.GETTING_STARTED="Getting-Started",c.CMAKE="CMake",c.FILLCAN="Fillcan",c.FILLCAN_Constructor="Fillcan-Constructor",c.FILLCAN_getSupportedPhysicalDevices="Fillcan-getSupportedPhysicalDevices",c.FILLCAN_selectDevice="Fillcan-selectDevice",c.FILLCAN_getCurrentDevice="Fillcan-getCurrentDevice",c.FILLCAN_createShaderModule="Fillcan-createShaderModule",c.FILLCAN_GRAPHICS="Fillcan-Graphics",c.FILLCAN_GRAPHICS_Constructor="Fillcan-Graphics-Constructor",c.FILLCAN_GRAPHICS_getWindow="Fillcan-Graphics-getWindow",c.FILLCAN_GRAPHICS_mainLoop="Fillcan-Graphics-mainLoop",c.FILLCAN_GRAPHICS_createSwapchain="Fillcan-Graphics-createSwapchain",c.FILLCAN_GRAPHICS_recreateSwapchain="Fillcan-Graphics-recreateSwapchain",c.FILLCAN_GRAPHICS_getSwapchain="Fillcan-Graphics-getSwapchain",c.FILLCAN_GRAPHICS_getSwapchains="Fillcan-Graphics-getSwapchains",c.FILLCAN_GRAPHICS_destroySwapchain="Fillcan-Graphics-destroySwapchain",c.FILLCAN_GRAPHICS_getAssetManager="Fillcan-Graphics-getAssetManager",c.WINDOW="Window",c.WINDOW_Constructor="Window-Constructor",c.WINDOW_shouldClose="Window-shouldClose",c.WINDOW_wasResized="Window-wasResized",c.WINDOW_pollEvents="Window-pollEvents",c.WINDOW_getRequiredExtensions="Window-getRequiredExtensions",c.WINDOW_createSurface="Window-createSurface",c.WINDOW_getSurface="Window-getSurface",c.WINDOW_getExtent="Window-getExtent",c.INSTANCE="Instance",c.INSTANCE_Constructor="Instance-Constructor",c.INSTANCE_getInstanceHandle="Instance-getInstanceHandle",c.DEVICE_POOL="Device-Pool",c.DEVICE_POOL_Constructor="Device-Pool-Constructor",c.DEVICE_POOL_getSupportedPhysicalDevices="Device-Pool-getSupportedPhysicalDevices",c.DEVICE_POOL_selectDevice="Device-Pool-selectDevice",c.DEVICE_POOL_getCurrentDevice="Device-Pool-getCurrentDevice",c.PHYSICAL_DEVICE="Physical-Device",c.PHYSICAL_DEVICE_Constructor="Physical-Device-Constructor",c.PHYSICAL_DEVICE_getPhysicalDeviceHandle="Physical-Device-getPhysicalDeviceHandle",c.PHYSICAL_DEVICE_getRequiredExtensions="Physical-Device-getRequiredExtensions",c.PHYSICAL_DEVICE_areExtensionsSupported="Physical-Device-areExtensionsSupported",c.PHYSICAL_DEVICE_getRequiredFeatures="Physical-Device-getRequiredFeatures",c.PHYSICAL_DEVICE_areFeaturesSupported="Physical-Device-areFeaturesSupported",c.PHYSICAL_DEVICE_getFeatures="Physical-Device-getFeatures",c.PHYSICAL_DEVICE_getProperties="Physical-Device-getProperties",c.PHYSICAL_DEVICE_getSurfaceCapabilitiesKHR="Physical-Device-getSurfaceCapabilitiesKHR",c.PHYSICAL_DEVICE_getSurfaceFormatsKHR="Physical-Device-getSurfaceFormatsKHR",c.PHYSICAL_DEVICE_getSurfacePresentModesKHR="Physical-Device-getSurfacePresentModesKHR",c.PHYSICAL_DEVICE_getQueueFamilyProperties="Physical-Device-getQueueFamilyProperties",c.PHYSICAL_DEVICE_getFormatProperties="Physical-Device-getFormatProperties",c.PHYSICAL_DEVICE_getMemoryProperties="Physical-Device-getMemoryProperties",c.PHYSICAL_DEVICE_findSupportedFormat="Physical-Device-findSupportedFormat",c.PHYSICAL_DEVICE_getGraphicsQueueFamilyIndices="Physical-Device-getGraphicsQueueFamilyIndices",c.PHYSICAL_DEVICE_getPresentQueueFamilyIndices="Physical-Device-getPresentQueueFamilyIndices",c.PHYSICAL_DEVICE_getComputeQueueFamilyIndices="Physical-Device-getComputeQueueFamilyIndices",c.LOGICAL_DEVICE="Logical-Device",c.LOGICAL_DEVICE_Constructor="Logical-Device-Constructor",c.LOGICAL_DEVICE_getLogicalDeviceHandle="Logical-Device-getLogicalDeviceHandle",c.LOGICAL_DEVICE_getPhysicalDevice="Logical-Device-getPhysicalDevice",c.LOGICAL_DEVICE_waitIdle="Logical-Device-waitIdle",c.LOGICAL_DEVICE_getGraphicsQueue="Logical-Device-getGraphicsQueue",c.LOGICAL_DEVICE_getPresentQueue="Logical-Device-getPresentQueue",c.LOGICAL_DEVICE_getComputeQueue="Logical-Device-getComputeQueue",c.LOGICAL_DEVICE_beginSingleTimeCommandRecording="Logical-Device-beginSingleTimeCommandRecording",c.LOGICAL_DEVICE_endSingleTimeCommandRecording="Logical-Device-endSingleTimeCommandRecording",c.QUEUE="Queue",c.QUEUE_Constructor="Queue-Constructor",c.QUEUE_getQueueHandle="Queue-getQueueHandle",c.QUEUE_getQueueFamilyIndex="Queue-getQueueFamilyIndex",c.QUEUE_getQueueIndex="Queue-getQueueIndex",c.QUEUE_createCommandPool="Queue-createCommandPool",c.QUEUE_getCommandPools="Queue-getCommandPools",c.QUEUE_getCommandPool="Queue-getCommandPool",c.QUEUE_destroyCommandPool="Queue-destroyCommandPool",c.QUEUE_createRecording="Queue-createRecording",c.QUEUE_submitRecordings="Queue-submitRecordings",c.QUEUE_resetRecording="Queue-resetRecording",c.QUEUE_freeRecording="Queue-freeRecording",c.QUEUE_waitIdle="Queue-waitIdle",c.COMMAND_POOL="Command-Pool",c.COMMAND_POOL_Constructor="Command-Pool-Constructor",c.COMMAND_POOL_getCommandPoolHandle="Command-Pool-getCommandPoolHandle",c.COMMAND_POOL_allocateCommandBuffers="Command-Pool-allocateCommandBuffers",c.COMMAND_POOL_freeCommandBuffers="Command-Pool-freeCommandBuffers",c.COMMAND_POOL_reset="Command-Pool-reset",c.COMMAND_BUFFER="Command-Buffer",c.COMMAND_BUFFER_Constructor="Command-Buffer-Constructor",c.COMMAND_BUFFER_getCommandBufferHandle="Command-Buffer-getCommandBufferHandle",c.COMMAND_BUFFER_getLevel="Command-Buffer-getLevel",c.COMMAND_BUFFER_begin="Command-Buffer-begin",c.COMMAND_BUFFER_end="Command-Buffer-end",c.COMMAND_BUFFER_reset="Command-Buffer-reset",c.COMMAND_RECORDING="Command-Recording",c.COMMAND_RECORDING_endAll="Command-Recording-endAll",c.COMMAND_RECORDING_submit="Command-Recording-submit",c.COMMAND_RECORDING_reset="Command-Recording-reset",c.COMMAND_RECORDING_free="Command-Recording-free",c.COMMAND_RECORDING_createFence="Command-Recording-createFence",c.COMMAND_RECORDING_waitForFence="Command-Recording-waitForFence",c.SWAPCHAIN="Swapchain",c.SWAPCHAIN_Swapchain_Image="Swapchain-Swapchain-Image",c.SWAPCHAIN_Constructor="Swapchain-Constructor",c.SWAPCHAIN_getSwapchainHandle="Swapchain-getSwapchainHandle",c.SWAPCHAIN_getNextImage="Swapchain-getNextImage",c.SWAPCHAIN_getSurfaceFormat="Swapchain-getSurfaceFormat",c.SWAPCHAIN_getImageCount="Swapchain-getImageCount",c.SWAPCHAIN_getImageArrayLayers="Swapchain-getImageArrayLayers",c.SWAPCHAIN_getImageUsage="Swapchain-getImageUsage",c.SWAPCHAIN_getImageSharingMode="Swapchain-getImageSharingMode",c.SWAPCHAIN_getImageExtent="Swapchain-getImageExtent",c.SWAPCHAIN_getPresentMode="Swapchain-getPresentMode",c.SWAPCHAIN_getQueueFamilyIndices="Swapchain-getQueueFamilyIndices",c.SWAPCHAIN_present="Swapchain-present",c.BUFFER="Buffer",c.BUFFER_Constructor="Buffer-Constructor",c.BUFFER_getBufferHandle="Buffer-getBufferHandle",c.BUFFER_getFlags="Buffer-getFlags",c.BUFFER_getSize="Buffer-getSize",c.BUFFER_getUsage="Buffer-getUsage",c.BUFFER_getSharingMode="Buffer-getSharingMode",c.BUFFER_getQueueFamilyIndices="Buffer-getQueueFamilyIndices",c.BUFFER_bindMemory="Buffer-bindMemory",c.BUFFER_getMemory="Buffer-getMemory",c.BUFFER_createBufferView="Buffer-createBufferView",c.BUFFER_getBufferViews="Buffer-getBufferViews",c.BUFFER_getBufferView="Buffer-getBufferView",c.BUFFER_destroyBufferViews="Buffer-destroyBufferViews",c.BUFFER_destroyBufferView="Buffer-destroyBufferView",c.BUFFER_copyTo="Buffer-copyTo",c.BUFFER_VIEW="Buffer-View",c.BUFFER_VIEW_Constructor="Buffer-View-Constructor",c.BUFFER_VIEW_getBufferViewHandle="Buffer-View-getBufferViewHandle",c.BUFFER_DIRECTOR="Buffer-Director",c.BUFFER_DIRECTOR_Constructor="Buffer-Director-Constructor",c.BUFFER_DIRECTOR_makeVertexBuffer="Buffer-Director-makeVertexBuffer",c.BUFFER_DIRECTOR_makeVertexTransferDestinationBuffer="Buffer-Director-makeVertexTransferDestinationBuffer",c.BUFFER_DIRECTOR_makeUniformBuffer="Buffer-Director-makeUniformBuffer",c.BUFFER_DIRECTOR_makeStorageBuffer="Buffer-Director-makeStorageBuffer",c.BUFFER_DIRECTOR_makeUniformTexelBuffer="Buffer-Director-makeUniformTexelBuffer",c.BUFFER_DIRECTOR_makeStorageTexelBuffer="Buffer-Director-makeStorageTexelBuffer",c.BUFFER_DIRECTOR_makeIndexBuffer="Buffer-Director-makeIndexBuffer",c.BUFFER_DIRECTOR_makeIndexTransferDestinationBuffer="Buffer-Director-makeIndexTransferDestinationBuffer",c.BUFFER_DIRECTOR_makeIndirectBuffer="Buffer-Director-makeIndirectBuffer",c.BUFFER_DIRECTOR_makeStagingBuffer="Buffer-Director-makeStagingBuffer",c.BUFFER_BUILDER="Buffer-Builder",c.BUFFER_BUILDER_Constructor="Buffer-Builder-Constructor",c.BUFFER_BUILDER_setLogicalDevice="Buffer-Builder-setLogicalDevice",c.BUFFER_BUILDER_setFlags="Buffer-Builder-setFlags",c.BUFFER_BUILDER_setSize="Buffer-Builder-setSize",c.BUFFER_BUILDER_setUsage="Buffer-Builder-setUsage",c.BUFFER_BUILDER_setSharingMode="Buffer-Builder-setSharingMode",c.BUFFER_BUILDER_setQueueFamilyIndices="Buffer-Builder-setQueueFamilyIndices",c.BUFFER_BUILDER_getResult="Buffer-Builder-getResult",c.BUFFER_BUILDER_reset="Buffer-Builder-reset",c.IMAGE="Image",c.IMAGE_Constructor="Image-Constructor",c.IMAGE_getImageHandle="Image-getImageHandle",c.IMAGE_getFlags="Image-getFlags",c.IMAGE_getUsage="Image-getUsage",c.IMAGE_getSharingMode="Image-getSharingMode",c.IMAGE_getQueueFamilyIndices="Image-getQueueFamilyIndices",c.IMAGE_getType="Image-getType",c.IMAGE_getFormat="Image-getFormat",c.IMAGE_getExtent="Image-getExtent",c.IMAGE_getMipLevels="Image-getMipLevels",c.IMAGE_getArrayLayers="Image-getArrayLayers",c.IMAGE_getSamples="Image-getSamples",c.IMAGE_getTiling="Image-getTiling",c.IMAGE_getInitialLayout="Image-getInitialLayout",c.IMAGE_bindMemory="Image-bindMemory",c.IMAGE_getMemory="Image-getMemory",c.IMAGE_createImageView="Image-createImageView",c.IMAGE_getImageViews="Image-getImageViews",c.IMAGE_getImageView="Image-getImageView",c.IMAGE_destroyImageViews="Image-destroyImageViews",c.IMAGE_destroyImageView="Image-destroyImageView",c.IMAGE_copyTo="Image-copyTo",c.IMAGE_transitionImageLayout="Image-transitionImageLayout",c.IMAGE_VIEW="Image-View",c.IMAGE_VIEW_Constructor="Image-View-Constructor",c.IMAGE_VIEW_getImageViewHandle="Image-View-getImageViewHandle",c.IMAGE_DIRECTOR="Image-Director",c.IMAGE_DIRECTOR_Constructor="Image-Director-Constructor",c.IMAGE_DIRECTOR_make2DTexture="Image-Director-make2DTexture",c.IMAGE_DIRECTOR_makeDepthImage="Image-Director-makeDepthImage",c.IMAGE_BUILDER="Image-Builder",c.IMAGE_BUILDER_Constructor="Image-Builder-Constructor",c.IMAGE_BUILDER_setLogicalDevice="Image-Builder-setLogicalDevice",c.IMAGE_BUILDER_setFlags="Image-Builder-setFlags",c.IMAGE_BUILDER_setImageType="Image-Builder-setImageType",c.IMAGE_BUILDER_setFormat="Image-Builder-setFormat",c.IMAGE_BUILDER_setExtent="Image-Builder-setExtent",c.IMAGE_BUILDER_setMipLevels="Image-Builder-setMipLevels",c.IMAGE_BUILDER_setArrayLayers="Image-Builder-setArrayLayers",c.IMAGE_BUILDER_setSamples="Image-Builder-setSamples",c.IMAGE_BUILDER_setImageTiling="Image-Builder-setImageTiling",c.IMAGE_BUILDER_setImageUsage="Image-Builder-setImageUsage",c.IMAGE_BUILDER_setSharingMode="Image-Builder-setSharingMode",c.IMAGE_BUILDER_setQueueFamilyIndices="Image-Builder-setQueueFamilyIndices",c.IMAGE_BUILDER_setInitialLayout="Image-Builder-setInitialLayout",c.IMAGE_BUILDER_reset="Image-Builder-reset",c.IMAGE_BUILDER_getResult="Image-Builder-getResult",c.SAMPLER_BUILDER="Sampler-Builder",c.SAMPLER_BUILDER_Constructor="Sampler-Builder-Constructor",c.SAMPLER_BUILDER_setLogicalDevice="Sampler-Builder-setLogicalDevice",c.SAMPLER_BUILDER_setFilters="Sampler-Builder-setFilters",c.SAMPLER_BUILDER_setMipmapMode="Sampler-Builder-setMipmapMode",c.SAMPLER_BUILDER_setAddressModes="Sampler-Builder-setAddressModes",c.SAMPLER_BUILDER_setMipLodBias="Sampler-Builder-setMipLodBias",c.SAMPLER_BUILDER_setMaxAnisotropy="Sampler-Builder-setMaxAnisotropy",c.SAMPLER_BUILDER_unsetMaxAnisotropy="Sampler-Builder-unsetMaxAnisotropy",c.SAMPLER_BUILDER_setCompareOp="Sampler-Builder-setCompareOp",c.SAMPLER_BUILDER_unsetCompareOp="Sampler-Builder-unsetCompareOp",c.SAMPLER_BUILDER_setLod="Sampler-Builder-setLod",c.SAMPLER_BUILDER_setBorderColor="Sampler-Builder-setBorderColor",c.SAMPLER_BUILDER_enableUnnormalizedCoordinates="Sampler-Builder-enableUnnormalizedCoordinates",c.SAMPLER_BUILDER_disableUnnormalizedCoordinates="Sampler-Builder-disableUnnormalizedCoordinates",c.SAMPLER_BUILDER_getResult="Sampler-Builder-getResult",c.SAMPLER_BUILDER_reset="Sampler-Builder-reset",c.SAMPLER="Sampler",c.SAMPLER_Constructor="Sampler-Constructor",c.SAMPLER_getSamplerHandle="Sampler-getSamplerHandle",c.MEMORY="Memory",c.MEMORY_Constructor="Memory-Constructor",c.MEMORY_getMemoryHandle="Memory-getMemoryHandle",c.MEMORY_map="Memory-map",c.MEMORY_unmap="Memory-unmap",c.MEMORY_getData="Memory-getData",c.MEMORY_flush="Memory-flush",c.MEMORY_invalidate="Memory-invalidate",c.SEMAPHORE="Semaphore",c.SEMAPHORE_Constructor="Semaphore-Constructor",c.SEMAPHORE_getSemaphoreHandle="Semaphore-getSemaphoreHandle",c.FENCE="Fence",c.FENCE_Constructor="Fence-Constructor",c.FENCE_getFenceHandle="Fence-getFenceHandle",c.FENCE_waitFor="Fence-waitFor",c.FENCE_reset="Fence-reset",c.FENCE_s_waitForAll="Fence-s_waitForAll",c.FENCE_s_resetAll="Fence-s_resetAll",c.SHADER_MODULE="Shader-Module",c.SHADER_MODULE_Constructor="Shader-Module-Constructor",c.SHADER_MODULE_getShaderModuleHandle="Shader-Module-getShaderModuleHandle",c.SHADER_MODULE_getDescriptorSetLayouts="Shader-Module-getDescriptorSetLayouts",c.SHADER_MODULE_getDescriptorPool="Shader-Module-getDescriptorPool",c.DESCRIPTOR_SET_LAYOUT_BUILDER="Descriptor-Set-Layout-Builder",c.DESCRIPTOR_SET_LAYOUT_BUILDER_Constructor="Descriptor-Set-Layout-Builder-Constructor",c.DESCRIPTOR_SET_LAYOUT_BUILDER_setLogicalDevice="Descriptor-Set-Layout-Builder-setLogicalDevice",c.DESCRIPTOR_SET_LAYOUT_BUILDER_addBinding="Descriptor-Set-Layout-Builder-addBinding",c.DESCRIPTOR_SET_LAYOUT_BUILDER_getResult="Descriptor-Set-Layout-Builder-getResult",c.DESCRIPTOR_SET_LAYOUT_BUILDER_reset="Descriptor-Set-Layout-Builder-reset",c.DESCRIPTOR_SET_LAYOUT="Descriptor-Set-Layout",c.DESCRIPTOR_SET_LAYOUT_Constructor="Descriptor-Set-Layout-Constructor",c.DESCRIPTOR_SET_LAYOUT_getDescriptorSetLayoutHandle="Descriptor-Set-Layout-getDescriptorSetLayoutHandle",c.DESCRIPTOR_SET_LAYOUT_getBindings="Descriptor-Set-Layout-getBindings",c.DESCRIPTOR_POOL_BUILDER="Descriptor-Pool-Builder",c.DESCRIPTOR_POOL_BUILDER_Constructor="Descriptor-Pool-Builder-Constructor",c.DESCRIPTOR_POOL_BUILDER_setLogicalDevice="Descriptor-Pool-Builder-setLogicalDevice",c.DESCRIPTOR_POOL_BUILDER_setFlags="Descriptor-Pool-Builder-setFlags",c.DESCRIPTOR_POOL_BUILDER_addSet="Descriptor-Pool-Builder-addSet",c.DESCRIPTOR_POOL_BUILDER_getResult="Descriptor-Pool-Builder-getResult",c.DESCRIPTOR_POOL_BUILDER_reset="Descriptor-Pool-Builder-reset",c.DESCRIPTOR_POOL="Descriptor-Pool",c.DESCRIPTOR_POOL_Constructor="Descriptor-Pool-Constructor",c.DESCRIPTOR_POOL_getDescriptorPoolHandle="Descriptor-Pool-getDescriptorPoolHandle",c.DESCRIPTOR_POOL_allocateDescriptorSet="Descriptor-Pool-allocateDescriptorSet",c.DESCRIPTOR_POOL_getDescriptorSets="Descriptor-Pool-getDescriptorSets",c.DESCRIPTOR_POOL_getDescriptorSet="Descriptor-Pool-getDescriptorSet",c.DESCRIPTOR_POOL_freeDescriptorSets="Descriptor-Pool-freeDescriptorSets",c.DESCRIPTOR_POOL_reset="Descriptor-Pool-reset",c.DESCRIPTOR_SET="Descriptor-Set",c.DESCRIPTOR_SET_Constructor="Descriptor-Set-Constructor",c.DESCRIPTOR_SET_getDescriptorSetHandle="Descriptor-Set-getDescriptorSetHandle",c.DESCRIPTOR_SET_getLayout="Descriptor-Set-getLayout",c.DESCRIPTOR_SET_getName="Descriptor-Set-getName",c.DESCRIPTOR_SET_writeImage="Descriptor-Set-writeImage",c.DESCRIPTOR_SET_writeBuffer="Descriptor-Set-writeBuffer",c.DESCRIPTOR_SET_writeTexelBufferView="Descriptor-Set-writeTexelBufferView",c.DESCRIPTOR_SET_copy="Descriptor-Set-copy",c.PIPELINE_BUILDER="Pipeline-Builder",c.PIPELINE_BUILDER_Constructor="Pipeline-Builder-Constructor",c.PIPELINE_BUILDER_setLogicalDevice="Pipeline-Builder-setLogicalDevice",c.PIPELINE_BUILDER_setFlags="Pipeline-Builder-setFlags",c.PIPELINE_BUILDER_addPushConstant="Pipeline-Builder-addPushConstant",c.PIPELINE_BUILDER_setPipelineCache="Pipeline-Builder-setPipelineCache",c.PIPELINE_BUILDER_setBasePipeline="Pipeline-Builder-setBasePipeline",c.PIPELINE_BUILDER_reset="Pipeline-Builder-reset",c.PIPELINE_LAYOUT="Pipeline-Layout",c.PIPELINE_LAYOUT_PUSH_CONSTANT="Pipeline-Layout-Push-Constant",c.PIPELINE_LAYOUT_Constructor="Pipeline-Layout-Constructor",c.PIPELINE_LAYOUT_getPipelineLayoutHandle="Pipeline-Layout-getPipelineLayoutHandle",c.PIPELINE_LAYOUT_pushConstantData="Pipeline-Layout-pushConstantData",c.PIPELINE="Pipeline",c.PIPELINE_PIPELINE_SHADER_STAGE="Pipeline-Pipeline-Shader-Stage",c.PIPELINE_Constructor="Pipeline-Constructor",c.PIPELINE_getPipelineHandle="Pipeline-getPipelineHandle",c.PIPELINE_getPipelineLayout="Pipeline-getPipelineLayout",c.PIPELINE_bindToCommandBuffer="Pipeline-bindToCommandBuffer",c.PIPELINE_getCommandBuffer="Pipeline-getCommandBuffer",c.PIPELINE_bindDescriptorSets="Pipeline-bindDescriptorSets",c.PIPELINE_getDescriptorSets="Pipeline-getDescriptorSets",c.PIPELINE_getDescriptorSet="Pipeline-getDescriptorSet",c.PIPELINE_pushConstantData="Pipeline-pushConstantData",c.COMPUTE_PIPELINE="Compute-Pipeline",c.COMPUTE_PIPELINE_Constructor="Compute Pipeline-Constructor",c.COMPUTE_PIPELINE_BUILDER="Compute-Pipeline-Builder",c.COMPUTE_PIPELINE_BUILDER_Constructor="Compute-Pipeline-Builder-Constructor",c.COMPUTE_PIPELINE_BUILDER_setShaderStage="Compute-Pipeline-Builder-setShaderStage",c.COMPUTE_PIPELINE_BUILDER_getResult="Compute-Pipeline-Builder-getResult",c.COMPUTE_PIPELINE_BUILDER_reset="Compute-Pipeline-Builder-reset",c.RENDER_PASS="Render-Pass",c.RENDER_PASS_Constructor="Render-Pass-Constructor",c.RENDER_PASS_getRenderPassHandle="Render-Pass-getRenderPassHandle",c.RENDER_PASS_getAttachments="Render-Pass-getAttachments",c.RENDER_PASS_getSubpasses="Render-Pass-getSubpasses",c.RENDER_PASS_getDependencies="Render-Pass-getDependencies",c.RENDER_PASS_begin="Render-Pass-begin",c.RENDER_PASS_end="Render-Pass-end",c.RENDER_PASS_BUILDER="Render-Pass-Builder",c.RENDER_PASS_BUILDER_Constructor="Render-Pass-Builder-Constructor",c.RENDER_PASS_BUILDER_setLogicalDevice="Render-Pass-Builder-setLogicalDevice",c.RENDER_PASS_BUILDER_addAttachment="Render-Pass-Builder-addAttachment",c.RENDER_PASS_BUILDER_addInputAttachment="Render-Pass-Builder-addInputAttachment",c.RENDER_PASS_BUILDER_addColorAttachment="Render-Pass-Builder-addColorAttachment",c.RENDER_PASS_BUILDER_setDepthStencilAttachment="Render-Pass-Builder-setDepthStencilAttachment",c.RENDER_PASS_BUILDER_resolveCurrentAttachments="Render-Pass-Builder-resolveCurrentAttachments",c.RENDER_PASS_BUILDER_constructSubpass="Render-Pass-Builder-constructSubpass",c.RENDER_PASS_BUILDER_addDependency="Render-Pass-Builder-addDependency",c.RENDER_PASS_BUILDER_getResult="Render-Pass-Builder-getResult",c.RENDER_PASS_BUILDER_reset="Render-Pass-Builder-reset",c.FRAMEBUFFER="Framebuffer",c.FRAMEBUFFER_Constructor="Framebuffer-Constructor",c.FRAMEBUFFER_getFramebufferHandle="Framebuffer-getFramebufferHandle",c.FRAMEBUFFER_getExtent="Framebuffer-getExtent",c.FRAMEBUFFER_getLayers="Framebuffer-getLayers",c.GRAPHICS_PIPELINE_BUILDER="Graphics-Pipeline-Builder",c.GRAPHICS_PIPELINE_BUILDER_Constructor="Graphics-Pipeline-Builder-Constructor",c.GRAPHICS_PIPELINE_BUILDER_addShaderStage="Graphics-Pipeline-Builder-addShaderStage",c.GRAPHICS_PIPELINE_BUILDER_setInputAssemblyState="Graphics-Pipeline-Builder-setInputAssemblyState",c.GRAPHICS_PIPELINE_BUILDER_setVertexInputState="Graphics-Pipeline-Builder-setVertexInputState",c.GRAPHICS_PIPELINE_BUILDER_setTessellationState="Graphics-Pipeline-Builder-setTessellationState",c.GRAPHICS_PIPELINE_BUILDER_addViewportState="Graphics-Pipeline-Builder-addViewportState",c.GRAPHICS_PIPELINE_BUILDER_setRasterizationState="Graphics-Pipeline-Builder-setRasterizationState",c.GRAPHICS_PIPELINE_BUILDER_setMultisampleState="Graphics-Pipeline-Builder-setMultisampleState",c.GRAPHICS_PIPELINE_BUILDER_setDepthStencilState="Graphics-Pipeline-Builder-setDepthStencilState",c.GRAPHICS_PIPELINE_BUILDER_setColorBlendState="Graphics-Pipeline-Builder-setColorBlendState",c.GRAPHICS_PIPELINE_BUILDER_setDynamicState="Graphics-Pipeline-Builder-setDynamicState",c.GRAPHICS_PIPELINE_BUILDER_setRenderPass="Graphics-Pipeline-Builder-setRenderPass",c.GRAPHICS_PIPELINE_BUILDER_setSubpass="Graphics-Pipeline-Builder-setSubpass",c.GRAPHICS_PIPELINE_BUILDER_getResult="Graphics-Pipeline-Builder-getResult",c.GRAPHICS_PIPELINE_BUILDER_reset="Graphics-Pipeline-Builder-reset",c.GRAPHICS_PIPELINE="Graphics-Pipeline",c.GRAPHICS_PIPELINE_Constructor="Graphics-Pipeline-Constructor",c.GRAPHICS_PIPELINE_getRenderPass="Graphics-Pipeline-getRenderPass",c.ASSET_MANAGER="Asset-Manager",c))(L||{});function ql(c){let e;return{c(){e=d("p")},l(t){e=g(t,"P",{});var r=E(e);r.forEach(l)},m(t,r){h(t,e,r)},p:Oe,i:Oe,o:Oe,d(t){t&&l(e)}}}class Wl extends ve{constructor(e){super(),Ee(this,e,null,ql,be,{})}}const{window:Ql}=lo;function Kl(c){let e,t;return{c(){e=d("h5"),t=i(c[1]),this.h()},l(r){e=g(r,"H5",{class:!0});var $=E(e);t=f($,c[1]),$.forEach(l),this.h()},h(){z(e,"class","svelte-nw7co4")},m(r,$){h(r,e,$),o(e,t)},p(r,$){$&2&&$s(t,r[1])},d(r){r&&l(e)}}}function zl(c){let e,t;return{c(){e=d("h4"),t=i(c[1]),this.h()},l(r){e=g(r,"H4",{class:!0});var $=E(e);t=f($,c[1]),$.forEach(l),this.h()},h(){z(e,"class","svelte-nw7co4")},m(r,$){h(r,e,$),o(e,t)},p(r,$){$&2&&$s(t,r[1])},d(r){r&&l(e)}}}function jl(c){let e,t;return{c(){e=d("h3"),t=i(c[1]),this.h()},l(r){e=g(r,"H3",{class:!0});var $=E(e);t=f($,c[1]),$.forEach(l),this.h()},h(){z(e,"class","svelte-nw7co4")},m(r,$){h(r,e,$),o(e,t)},p(r,$){$&2&&$s(t,r[1])},d(r){r&&l(e)}}}function Yl(c){let e,t;return{c(){e=d("h2"),t=i(c[1]),this.h()},l(r){e=g(r,"H2",{class:!0});var $=E(e);t=f($,c[1]),$.forEach(l),this.h()},h(){z(e,"class","svelte-nw7co4")},m(r,$){h(r,e,$),o(e,t)},p(r,$){$&2&&$s(t,r[1])},d(r){r&&l(e)}}}function Xl(c){let e,t,r,$,n;function s(_,v){if(_[2]===2)return Yl;if(_[2]===3)return jl;if(_[2]===4)return zl;if(_[2]===5)return Kl}let a=s(c),u=a&&a(c);const p=c[7].default,m=gn(p,c,c[6],null);return{c(){e=d("section"),u&&u.c(),t=j(),m&&m.c(),this.h()},l(_){e=g(_,"SECTION",{id:!0});var v=E(e);u&&u.l(v),t=Y(v),m&&m.l(v),v.forEach(l),this.h()},h(){z(e,"id",c[0])},m(_,v){h(_,e,v),u&&u.m(e,null),o(e,t),m&&m.m(e,null),c[8](e),r=!0,$||(n=Vs(Ql,"scroll",c[4]),$=!0)},p(_,[v]){a===(a=s(_))&&u?u.p(_,v):(u&&u.d(1),u=a&&a(_),u&&(u.c(),u.m(e,t))),m&&m.p&&(!r||v&64)&&_n(m,p,_,_[6],r?En(p,_[6],v,null):vn(_[6]),null),(!r||v&1)&&z(e,"id",_[0])},i(_){r||(b(m,_),r=!0)},o(_){w(m,_),r=!1},d(_){_&&l(e),u&&u.d(),m&&m.d(_),c[8](null),$=!1,n()}}}let Ls=100;function Zl(c,e,t){let{$$slots:r={},$$scope:$}=e,{id:n="undefined"}=e,{label:s="undefined"}=e,{heading:a}=e,{visible:u=!1}=e,p;function m(v){const R=p==null?void 0:p.getBoundingClientRect();t(5,u=R.top+R.height>=Ls&&R.left>=Ls&&R.bottom-R.height<=(window.innerHeight-Ls||document.documentElement.clientHeight-Ls)&&R.right<=(window.innerWidth||document.documentElement.clientWidth))}function _(v){Us[v?"unshift":"push"](()=>{p=v,t(3,p)})}return c.$$set=v=>{"id"in v&&t(0,n=v.id),"label"in v&&t(1,s=v.label),"heading"in v&&t(2,a=v.heading),"visible"in v&&t(5,u=v.visible),"$$scope"in v&&t(6,$=v.$$scope)},[n,s,a,p,m,u,$,r,_]}class Jl extends ve{constructor(e){super(),Ee(this,e,Zl,Xl,be,{id:0,label:1,heading:2,visible:5})}}function ei(c){let e;return{c(){e=i("CMake")},l(t){e=f(t,"CMake")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ti(c){let e;return{c(){e=i("GLFW")},l(t){e=f(t,"GLFW")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ri(c){let e;return{c(){e=i("GLM")},l(t){e=f(t,"GLM")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ni(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function si(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te;return t=new fe({props:{href:"https://cmake.org/",target:"_blank",$$slots:{default:[ei]},$$scope:{ctx:c}}}),a=new $e({props:{language:Ns,code:'set(Fillcan_DIRECTORY "${CMAKE_SOURCE_DIR}/lib/fillcan")\ntarget_include_directories(${PROJECT_NAME} PUBLIC ${Fillcan_DIRECTORY} ${PROJECT_BINARY_DIR})'}}),m=new $e({props:{language:Ns,code:"add_subdirectory(${Fillcan_DIRECTORY})"}}),R=new $e({props:{language:Ns,code:"target_link_libraries(${PROJECT_NAME} Fillcan)"}}),F=new fe({props:{href:"https://www.glfw.org/",target:"_blank",$$slots:{default:[ti]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://github.com/g-truc/glm",target:"_blank",$$slots:{default:[ri]},$$scope:{ctx:c}}}),U=new fe({props:{href:"https://github.com/google/shaderc",target:"_blank",$$slots:{default:[ni]},$$scope:{ctx:c}}}),{c(){e=i("Fillcan makes use of "),I(t.$$.fragment),r=i(" and as such has a CMakeLists.txt file."),$=d("br"),n=d("br"),s=i(`
To add Fillcan to your project as a library you first have to add it's directory
to the compiler's search list for include files:
`),I(a.$$.fragment),u=d("br"),p=i(`
Next you need to add Fillcan as a subdirectory to the project. This indicates to
the compiler where the CMakeLists.txt and code files of Fillcan are located:
`),I(m.$$.fragment),_=d("br"),v=i(`
Finally you can link the Fillcan library to the project:
`),I(R.$$.fragment),P=d("br"),A=i(`
Within Fillcan's CMakeLists.txt several libraries are added. These libraries are
as follows:
`),T=d("h4"),y=i("1. Vulkan"),B=i(`
The Vulkan Library will be looked for on the system. And if it can not be found a
bundled version will be used instead.
`),M=d("h4"),O=i("2. GLFW"),x=j(),I(F.$$.fragment),V=i(` is used for creating
windows, contexts and surfaces and receiving input and window events.
`),q=d("h4"),k=i("3. GLM"),N=j(),I(Q.$$.fragment),X=i(` is a header
only C++ mathematics library for graphics software based on the OpenGL Shading Language
(GLSL) specifications.
`),Z=d("h4"),K=i("4. Shaderc"),W=j(),I(U.$$.fragment),G=i(` is a collection of tools for shader compilation. It is used within Fillcan to validate
GLSL shader-code and to compile it to SPIR-V.`),this.h()},l(ee){e=f(ee,"Fillcan makes use of "),S(t.$$.fragment,ee),r=f(ee," and as such has a CMakeLists.txt file."),$=g(ee,"BR",{}),n=g(ee,"BR",{}),s=f(ee,`
To add Fillcan to your project as a library you first have to add it's directory
to the compiler's search list for include files:
`),S(a.$$.fragment,ee),u=g(ee,"BR",{}),p=f(ee,`
Next you need to add Fillcan as a subdirectory to the project. This indicates to
the compiler where the CMakeLists.txt and code files of Fillcan are located:
`),S(m.$$.fragment,ee),_=g(ee,"BR",{}),v=f(ee,`
Finally you can link the Fillcan library to the project:
`),S(R.$$.fragment,ee),P=g(ee,"BR",{}),A=f(ee,`
Within Fillcan's CMakeLists.txt several libraries are added. These libraries are
as follows:
`),T=g(ee,"H4",{id:!0,class:!0});var ne=E(T);y=f(ne,"1. Vulkan"),ne.forEach(l),B=f(ee,`
The Vulkan Library will be looked for on the system. And if it can not be found a
bundled version will be used instead.
`),M=g(ee,"H4",{id:!0,class:!0});var le=E(M);O=f(le,"2. GLFW"),le.forEach(l),x=Y(ee),S(F.$$.fragment,ee),V=f(ee,` is used for creating
windows, contexts and surfaces and receiving input and window events.
`),q=g(ee,"H4",{id:!0,class:!0});var ae=E(q);k=f(ae,"3. GLM"),ae.forEach(l),N=Y(ee),S(Q.$$.fragment,ee),X=f(ee,` is a header
only C++ mathematics library for graphics software based on the OpenGL Shading Language
(GLSL) specifications.
`),Z=g(ee,"H4",{id:!0,class:!0});var J=E(Z);K=f(J,"4. Shaderc"),J.forEach(l),W=Y(ee),S(U.$$.fragment,ee),G=f(ee,` is a collection of tools for shader compilation. It is used within Fillcan to validate
GLSL shader-code and to compile it to SPIR-V.`),this.h()},h(){z(T,"id","cmake-vulkan"),z(T,"class","svelte-1tuq2yd"),z(M,"id","cmake-glfw"),z(M,"class","svelte-1tuq2yd"),z(q,"id","cmake-glm"),z(q,"class","svelte-1tuq2yd"),z(Z,"id","cmake-shaderc"),z(Z,"class","svelte-1tuq2yd")},m(ee,ne){h(ee,e,ne),D(t,ee,ne),h(ee,r,ne),h(ee,$,ne),h(ee,n,ne),h(ee,s,ne),D(a,ee,ne),h(ee,u,ne),h(ee,p,ne),D(m,ee,ne),h(ee,_,ne),h(ee,v,ne),D(R,ee,ne),h(ee,P,ne),h(ee,A,ne),h(ee,T,ne),o(T,y),h(ee,B,ne),h(ee,M,ne),o(M,O),h(ee,x,ne),D(F,ee,ne),h(ee,V,ne),h(ee,q,ne),o(q,k),h(ee,N,ne),D(Q,ee,ne),h(ee,X,ne),h(ee,Z,ne),o(Z,K),h(ee,W,ne),D(U,ee,ne),h(ee,G,ne),te=!0},p(ee,[ne]){const le={};ne&1&&(le.$$scope={dirty:ne,ctx:ee}),t.$set(le);const ae={};ne&1&&(ae.$$scope={dirty:ne,ctx:ee}),F.$set(ae);const J={};ne&1&&(J.$$scope={dirty:ne,ctx:ee}),Q.$set(J);const ue={};ne&1&&(ue.$$scope={dirty:ne,ctx:ee}),U.$set(ue)},i(ee){te||(b(t.$$.fragment,ee),b(a.$$.fragment,ee),b(m.$$.fragment,ee),b(R.$$.fragment,ee),b(F.$$.fragment,ee),b(Q.$$.fragment,ee),b(U.$$.fragment,ee),te=!0)},o(ee){w(t.$$.fragment,ee),w(a.$$.fragment,ee),w(m.$$.fragment,ee),w(R.$$.fragment,ee),w(F.$$.fragment,ee),w(Q.$$.fragment,ee),w(U.$$.fragment,ee),te=!1},d(ee){ee&&l(e),C(t,ee),ee&&l(r),ee&&l($),ee&&l(n),ee&&l(s),C(a,ee),ee&&l(u),ee&&l(p),C(m,ee),ee&&l(_),ee&&l(v),C(R,ee),ee&&l(P),ee&&l(A),ee&&l(T),ee&&l(B),ee&&l(M),ee&&l(x),C(F,ee),ee&&l(V),ee&&l(q),ee&&l(N),C(Q,ee),ee&&l(X),ee&&l(Z),ee&&l(W),C(U,ee),ee&&l(G)}}}class ai extends ve{constructor(e){super(),Ee(this,e,null,si,be,{})}}function oi(c){let e,t,r,$,n,s;return e=new $e({props:{language:pe,code:"#include <fillcan/fillcan.hpp>"}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Fillcan"),n=i(` class is the API through which the application can talk
with Vulkan.`)},l(a){S(e.$$.fragment,a),t=f(a,`
The `),r=g(a,"CODE",{});var u=E(r);$=f(u,"Fillcan"),u.forEach(l),n=f(a,` class is the API through which the application can talk
with Vulkan.`)},m(a,u){D(e,a,u),h(a,t,u),h(a,r,u),o(r,$),h(a,n,u),s=!0},p:Oe,i(a){s||(b(e.$$.fragment,a),s=!0)},o(a){w(e.$$.fragment,a),s=!1},d(a){C(e,a),a&&l(t),a&&l(r),a&&l(n)}}}class li extends ve{constructor(e){super(),Ee(this,e,null,oi,be,{})}}const ii=c=>({}),Na=c=>({}),fi=c=>({}),Ua=c=>({}),ci=c=>({}),Ga=c=>({}),$i=c=>({}),Ha=c=>({}),ui=c=>({}),qa=c=>({});function Wa(c){let e,t;const r=c[2].details,$=gn(r,c,c[1],qa);return{c(){e=d("div"),$&&$.c(),this.h()},l(n){e=g(n,"DIV",{class:!0});var s=E(e);$&&$.l(s),s.forEach(l),this.h()},h(){z(e,"class","details svelte-3cp1as")},m(n,s){h(n,e,s),$&&$.m(e,null),t=!0},p(n,s){$&&$.p&&(!t||s&2)&&_n($,r,n,n[1],t?En(r,n[1],s,ui):vn(n[1]),qa)},i(n){t||(b($,n),t=!0)},o(n){w($,n),t=!1},d(n){n&&l(e),$&&$.d(n)}}}function Qa(c){let e,t,r;const $=c[2].params,n=gn($,c,c[1],Ha);return{c(){e=d("ul"),t=d("div"),n&&n.c(),this.h()},l(s){e=g(s,"UL",{class:!0});var a=E(e);t=g(a,"DIV",{class:!0});var u=E(t);n&&n.l(u),u.forEach(l),a.forEach(l),this.h()},h(){z(t,"class","params svelte-3cp1as"),z(e,"class","method-description svelte-3cp1as")},m(s,a){h(s,e,a),o(e,t),n&&n.m(t,null),r=!0},p(s,a){n&&n.p&&(!r||a&2)&&_n(n,$,s,s[1],r?En($,s[1],a,$i):vn(s[1]),Ha)},i(s){r||(b(n,s),r=!0)},o(s){w(n,s),r=!1},d(s){s&&l(e),n&&n.d(s)}}}function Ka(c){let e,t,r,$,n;const s=c[2].return,a=gn(s,c,c[1],Ga);return{c(){e=d("div"),t=d("code"),r=i("@return"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{class:!0});var m=E(t);r=f(m,"@return"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(t,"class","svelte-3cp1as"),z(e,"class","return svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&_n(a,s,u,u[1],n?En(s,u[1],p,ci):vn(u[1]),Ga)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function za(c){let e,t,r,$,n;const s=c[2].throws,a=gn(s,c,c[1],Ua);return{c(){e=d("div"),t=d("code"),r=i("@throws"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{class:!0});var m=E(t);r=f(m,"@throws"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(t,"class","svelte-3cp1as"),z(e,"class","throws svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&_n(a,s,u,u[1],n?En(s,u[1],p,fi):vn(u[1]),Ua)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function ja(c){let e,t,r,$,n;const s=c[2].note,a=gn(s,c,c[1],Na);return{c(){e=d("div"),t=d("code"),r=i("@note"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"@note"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(e,"class","note svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&_n(a,s,u,u[1],n?En(s,u[1],p,ii):vn(u[1]),Na)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function pi(c){let e,t,r,$,n,s,a=c[0].details&&Wa(c),u=c[0].params&&Qa(c),p=c[0].return&&Ka(c),m=c[0].throws&&za(c),_=c[0].note&&ja(c);return{c(){a&&a.c(),e=j(),u&&u.c(),t=j(),p&&p.c(),r=j(),m&&m.c(),$=j(),_&&_.c(),n=dn()},l(v){a&&a.l(v),e=Y(v),u&&u.l(v),t=Y(v),p&&p.l(v),r=Y(v),m&&m.l(v),$=Y(v),_&&_.l(v),n=dn()},m(v,R){a&&a.m(v,R),h(v,e,R),u&&u.m(v,R),h(v,t,R),p&&p.m(v,R),h(v,r,R),m&&m.m(v,R),h(v,$,R),_&&_.m(v,R),h(v,n,R),s=!0},p(v,[R]){v[0].details?a?(a.p(v,R),R&1&&b(a,1)):(a=Wa(v),a.c(),b(a,1),a.m(e.parentNode,e)):a&&(An(),w(a,1,1,()=>{a=null}),Pn()),v[0].params?u?(u.p(v,R),R&1&&b(u,1)):(u=Qa(v),u.c(),b(u,1),u.m(t.parentNode,t)):u&&(An(),w(u,1,1,()=>{u=null}),Pn()),v[0].return?p?(p.p(v,R),R&1&&b(p,1)):(p=Ka(v),p.c(),b(p,1),p.m(r.parentNode,r)):p&&(An(),w(p,1,1,()=>{p=null}),Pn()),v[0].throws?m?(m.p(v,R),R&1&&b(m,1)):(m=za(v),m.c(),b(m,1),m.m($.parentNode,$)):m&&(An(),w(m,1,1,()=>{m=null}),Pn()),v[0].note?_?(_.p(v,R),R&1&&b(_,1)):(_=ja(v),_.c(),b(_,1),_.m(n.parentNode,n)):_&&(An(),w(_,1,1,()=>{_=null}),Pn())},i(v){s||(b(a),b(u),b(p),b(m),b(_),s=!0)},o(v){w(a),w(u),w(p),w(m),w(_),s=!1},d(v){a&&a.d(v),v&&l(e),u&&u.d(v),v&&l(t),p&&p.d(v),v&&l(r),m&&m.d(v),v&&l($),_&&_.d(v),v&&l(n)}}}function mi(c,e,t){let{$$slots:r={},$$scope:$}=e;const n=Do(r);return c.$$set=s=>{"$$scope"in s&&t(1,$=s.$$scope)},[n,$,r]}class Se extends ve{constructor(e){super(),Ee(this,e,mi,pi,be,{})}}function hi(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function di(c){let e;return{c(){e=i("Device Pool")},l(t){e=f(t,"Device Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gi(c){let e,t,r,$,n,s,a,u,p;return n=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[hi]},$$scope:{ctx:c}}}),a=new fe({props:{href:je().URL.documentation+"#"+L.DEVICE_POOL,$$slots:{default:[di]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Intialize the Fillcan API."),r=d("br"),$=i(`
        Initializes `),I(n.$$.fragment),s=i(" and "),I(a.$$.fragment),u=i(`.
    `),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Intialize the Fillcan API."),r=g(_,"BR",{}),$=f(_,`
        Initializes `),S(n.$$.fragment,_),s=f(_," and "),S(a.$$.fragment,_),u=f(_,`.
    `),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function _i(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vi(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ei(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bi(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ii(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Di(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se;return M=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[_i]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[vi]},$$scope:{ctx:c}}}),W=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Ei]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[bi]},$$scope:{ctx:c}}}),le=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[wi]},$$scope:{ctx:c}}}),de=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[Ii]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=j(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),R=j(),P=d("li"),A=d("code"),T=i("requiredDeviceFeatures"),y=d("br"),B=i(`
            The features a `),I(M.$$.fragment),O=i(" should have for the purposes of the application."),x=d("br"),F=i(`
            This should be a `),I(V.$$.fragment),q=i("-structure where each required feature should be set to true."),k=j(),N=d("li"),Q=d("code"),X=i("requiredDeviceExtensions"),Z=d("br"),K=i(`
            The extensions a `),I(W.$$.fragment),U=i(" should support for the purposes of the application."),G=d("br"),te=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(ee.$$.fragment),ne=i(". To be able to use a "),I(le.$$.fragment),ae=i(` this list should contain
            `),J=d("code"),ue=i("VK_KHR_SWAPCHAIN_EXTENSION_NAME"),De=i(" ("),I(de.$$.fragment),me=i(" contains this by default)."),Ce=d("br"),_e=j(),this.h()},l(ie){e=g(ie,"DIV",{slot:!0});var ge=E(e);t=g(ge,"LI",{});var we=E(t);r=g(we,"CODE",{});var Re=E(r);$=f(Re,"pApplicationName"),Re.forEach(l),n=g(we,"BR",{}),s=f(we,`
            The name of the application.`),we.forEach(l),a=Y(ge),u=g(ge,"LI",{});var Be=E(u);p=g(Be,"CODE",{});var Ie=E(p);m=f(Ie,"applicationVersion"),Ie.forEach(l),_=g(Be,"BR",{}),v=f(Be,`
            The version of the application.`),Be.forEach(l),R=Y(ge),P=g(ge,"LI",{});var re=E(P);A=g(re,"CODE",{});var he=E(A);T=f(he,"requiredDeviceFeatures"),he.forEach(l),y=g(re,"BR",{}),B=f(re,`
            The features a `),S(M.$$.fragment,re),O=f(re," should have for the purposes of the application."),x=g(re,"BR",{}),F=f(re,`
            This should be a `),S(V.$$.fragment,re),q=f(re,"-structure where each required feature should be set to true."),re.forEach(l),k=Y(ge),N=g(ge,"LI",{});var Ae=E(N);Q=g(Ae,"CODE",{});var Ve=E(Q);X=f(Ve,"requiredDeviceExtensions"),Ve.forEach(l),Z=g(Ae,"BR",{}),K=f(Ae,`
            The extensions a `),S(W.$$.fragment,Ae),U=f(Ae," should support for the purposes of the application."),G=g(Ae,"BR",{}),te=f(Ae,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(ee.$$.fragment,Ae),ne=f(Ae,". To be able to use a "),S(le.$$.fragment,Ae),ae=f(Ae,` this list should contain
            `),J=g(Ae,"CODE",{});var oe=E(J);ue=f(oe,"VK_KHR_SWAPCHAIN_EXTENSION_NAME"),oe.forEach(l),De=f(Ae," ("),S(de.$$.fragment,Ae),me=f(Ae," contains this by default)."),Ce=g(Ae,"BR",{}),Ae.forEach(l),_e=Y(ge),ge.forEach(l),this.h()},h(){z(e,"slot","params")},m(ie,ge){h(ie,e,ge),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B),D(M,P,null),o(P,O),o(P,x),o(P,F),D(V,P,null),o(P,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(N,G),o(N,te),D(ee,N,null),o(N,ne),D(le,N,null),o(N,ae),o(N,J),o(J,ue),o(N,De),D(de,N,null),o(N,me),o(N,Ce),o(e,_e),se=!0},p(ie,ge){const we={};ge&1&&(we.$$scope={dirty:ge,ctx:ie}),M.$set(we);const Re={};ge&1&&(Re.$$scope={dirty:ge,ctx:ie}),V.$set(Re);const Be={};ge&1&&(Be.$$scope={dirty:ge,ctx:ie}),W.$set(Be);const Ie={};ge&1&&(Ie.$$scope={dirty:ge,ctx:ie}),ee.$set(Ie);const re={};ge&1&&(re.$$scope={dirty:ge,ctx:ie}),le.$set(re);const he={};ge&1&&(he.$$scope={dirty:ge,ctx:ie}),de.$set(he)},i(ie){se||(b(M.$$.fragment,ie),b(V.$$.fragment,ie),b(W.$$.fragment,ie),b(ee.$$.fragment,ie),b(le.$$.fragment,ie),b(de.$$.fragment,ie),se=!0)},o(ie){w(M.$$.fragment,ie),w(V.$$.fragment,ie),w(W.$$.fragment,ie),w(ee.$$.fragment,ie),w(le.$$.fragment,ie),w(de.$$.fragment,ie),se=!1},d(ie){ie&&l(e),C(M),C(V),C(W),C(ee),C(le),C(de)}}}function Ci(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:`Fillcan(
        const char* pApplicationName, 
        uint32_t applicationVersion, 
        VkPhysicalDeviceFeatures requiredDeviceFeatures = {}, 
        std::vector<const char*> requiredDeviceExtensions = {}
);`}}),r=new Se({props:{$$slots:{params:[Di],details:[gi]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:'fillcan::Fillcan fillcan = fillcan::Fillcan("Example Application", 1.0);'}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class Si extends ve{constructor(e){super(),Ee(this,e,null,Ci,be,{})}}function Ri(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ai(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Ri]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the supported "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the supported "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Pi(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bi(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Pi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of all the "),I(r.$$.fragment),$=i(" that meet the requirements for the purposes of this implementation."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of all the "),S(r.$$.fragment,a),$=f(a," that meet the requirements for the purposes of this implementation."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Li(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<PhysicalDevice> getSupportedPhysicalDevices() const;"}}),r=new Se({props:{$$slots:{return:[Bi],details:[Ai]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ki extends ve{constructor(e){super(),Ee(this,e,null,Li,be,{})}}function Ti(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oi(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vi(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Ti]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Oi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Select a "),I(r.$$.fragment),$=i(" by index to create a "),I(n.$$.fragment),s=i(` of.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Select a "),S(r.$$.fragment,p),$=f(p," by index to create a "),S(n.$$.fragment,p),s=f(p,` of.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function yi(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mi(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[yi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i(`.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,`.
    `),a.forEach(l),this.h()},h(){z(e,"slot","returns")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Fi(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xi(c){let e;return{c(){e=i("getCurrentDevice")},l(t){e=f(t,"getCurrentDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ni(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:"LogicalDevice* selectDevice(unsigned int deviceIndex = 0);"}}),r=new Se({props:{$$slots:{returns:[Mi],details:[Vi]},$$scope:{ctx:c}}}),s=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Fi]},$$scope:{ctx:c}}}),u=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_getCurrentDevice,$$slots:{default:[xi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
If a device is selected, a pointer to the `),I(s.$$.fragment),a=i(` can also be retrieved using
`),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=Y(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=f(_,`
If a device is selected, a pointer to the `),S(s.$$.fragment,_),a=f(_,` can also be retrieved using
`),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),s.$set(P);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),u.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class Ui extends ve{constructor(e){super(),Ee(this,e,null,Ni,be,{})}}function Gi(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hi(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qi(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Gi]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_selectDevice,$$slots:{default:[Hi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the currently selected "),I(r.$$.fragment),$=i(" (selected with "),I(n.$$.fragment),s=i(")"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the currently selected "),S(r.$$.fragment,p),$=f(p," (selected with "),S(n.$$.fragment,p),s=f(p,")"),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Wi(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qi(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Wi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the currently selected "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the currently selected "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ki(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"LogicalDevice* getCurrentDevice();"}}),r=new Se({props:{$$slots:{return:[Qi],details:[qi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zi extends ve{constructor(e){super(),Ee(this,e,null,Ki,be,{})}}function ji(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yi(c){let e,t,r,$;return r=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[ji]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get the "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function Xi(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zi(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Xi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ji(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Window* getWindow();"}}),r=new Se({props:{$$slots:{return:[Zi],details:[Yi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ef extends ve{constructor(e){super(),Ee(this,e,null,Ji,be,{})}}function tf(c){let e;const t=c[1].default,r=gn(t,c,c[2],null);return{c(){r&&r.c()},l($){r&&r.l($)},m($,n){r&&r.m($,n),e=!0},p($,n){r&&r.p&&(!e||n&4)&&_n(r,t,$,$[2],e?En(t,$[2],n,null):vn($[2]),null)},i($){e||(b(r,$),e=!0)},o($){w(r,$),e=!1},d($){r&&r.d($)}}}function rf(c){let e,t;return e=new fe({props:{href:Ts+"/documentation#"+c[0],$$slots:{default:[tf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment)},l(r){S(e.$$.fragment,r)},m(r,$){D(e,r,$),t=!0},p(r,[$]){const n={};$&1&&(n.href=Ts+"/documentation#"+r[0]),$&4&&(n.$$scope={dirty:$,ctx:r}),e.$set(n)},i(r){t||(b(e.$$.fragment,r),t=!0)},o(r){w(e.$$.fragment,r),t=!1},d(r){C(e,r)}}}function nf(c,e,t){let{$$slots:r={},$$scope:$}=e,{sectionID:n}=e;return c.$$set=s=>{"sectionID"in s&&t(0,n=s.sectionID),"$$scope"in s&&t(2,$=s.$$scope)},[n,r,$]}class H extends ve{constructor(e){super(),Ee(this,e,nf,rf,be,{sectionID:0})}}function sf(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function af(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function of(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lf(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ff(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cf(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return n=new fe({props:{href:"https://github.com/google/shaderc",$$slots:{default:[sf]},$$scope:{ctx:c}}}),R=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[af]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[of]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[lf]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[ff]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a Shader Module object."),r=d("br"),$=i(`
        Uses `),I(n.$$.fragment),s=i(` to
        compile a file (defined by `),a=d("code"),u=i("shaderDirectory"),p=i(` and
        `),m=d("code"),_=i("shaderFileName"),v=i(") from "),I(R.$$.fragment),P=i(" to "),I(A.$$.fragment),T=i(`. Any resources the shader might need should be passed using the
        descriptor set layouts and the descriptor pool, both are `),I(y.$$.fragment),B=i(" which ownerships should be moved to the Shader Module using "),I(M.$$.fragment),O=i(`.
    `),this.h()},l(F){e=g(F,"SPAN",{slot:!0});var V=E(e);t=f(V,"Create a Shader Module object."),r=g(V,"BR",{}),$=f(V,`
        Uses `),S(n.$$.fragment,V),s=f(V,` to
        compile a file (defined by `),a=g(V,"CODE",{});var q=E(a);u=f(q,"shaderDirectory"),q.forEach(l),p=f(V,` and
        `),m=g(V,"CODE",{});var k=E(m);_=f(k,"shaderFileName"),k.forEach(l),v=f(V,") from "),S(R.$$.fragment,V),P=f(V," to "),S(A.$$.fragment,V),T=f(V,`. Any resources the shader might need should be passed using the
        descriptor set layouts and the descriptor pool, both are `),S(y.$$.fragment,V),B=f(V," which ownerships should be moved to the Shader Module using "),S(M.$$.fragment,V),O=f(V,`.
    `),V.forEach(l),this.h()},h(){z(e,"slot","details")},m(F,V){h(F,e,V),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(R,e,null),o(e,P),D(A,e,null),o(e,T),D(y,e,null),o(e,B),D(M,e,null),o(e,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),n.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),R.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),A.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),y.$set(Q);const X={};V&1&&(X.$$scope={dirty:V,ctx:F}),M.$set(X)},i(F){x||(b(n.$$.fragment,F),b(R.$$.fragment,F),b(A.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(n.$$.fragment,F),w(R.$$.fragment,F),w(A.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(n),C(R),C(A),C(y),C(M)}}}function $f(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uf(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pf(c){let e;return{c(){e=i("shaderc.h line 36 - 90")},l(t){e=f(t,"shaderc.h line 36 - 90")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mf(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hf(c){let e;return{c(){e=i("Descriptor Set Layouts")},l(t){e=f(t,"Descriptor Set Layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function df(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gf(c){let e;return{c(){e=i("DescriptorSetLayoutBuilder")},l(t){e=f(t,"DescriptorSetLayoutBuilder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _f(c){let e;return{c(){e=i("Descriptor Set Layouts")},l(t){e=f(t,"Descriptor Set Layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vf(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ef(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bf(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wf(c){let e;return{c(){e=i("DescriptorPoolBuilder")},l(t){e=f(t,"DescriptorPoolBuilder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function If(c){let e;return{c(){e=i("Descriptor Pools")},l(t){e=f(t,"Descriptor Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Df(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cf(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt;return a=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[$f]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[uf]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://github.com/google/shaderc/blob/1bbf43f210941ba69a2cd05cf3529063f1ff5bb9/libshaderc/include/shaderc/shaderc.h#L36",target:"_blank",$$slots:{default:[pf]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[mf]},$$scope:{ctx:c}}}),G=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[hf]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[df]},$$scope:{ctx:c}}}),le=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[gf]},$$scope:{ctx:c}}}),J=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[_f]},$$scope:{ctx:c}}}),ie=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_POOL,$$slots:{default:[vf]},$$scope:{ctx:c}}}),we=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_SET,$$slots:{default:[Ef]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[bf]},$$scope:{ctx:c}}}),re=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_POOL_BUILDER,$$slots:{default:[wf]},$$scope:{ctx:c}}}),Ae=new fe({props:{href:je().URL.documentation+"#"+L.DESCRIPTOR_POOL,$$slots:{default:[If]},$$scope:{ctx:c}}}),Me=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[Df]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("shaderDirectory"),n=d("br"),s=i(`
            The directory where the `),I(a.$$.fragment),u=i(" shader file is located."),p=j(),m=d("li"),_=d("code"),v=i("shaderFileName"),R=d("br"),P=i(`
            The name of the `),I(A.$$.fragment),T=i(" shader file."),y=j(),B=d("li"),M=d("code"),O=i("shaderKind"),x=d("br"),F=i(`
            The kind of shader (see `),I(V.$$.fragment),q=i(")"),k=j(),N=d("li"),Q=d("code"),X=i("upDescriptorSetLayouts"),Z=d("br"),K=i(`
            A `),I(W.$$.fragment),U=i(" to a list of the "),I(G.$$.fragment),te=i(` describing the resources the shader should have access to. Please use
            `),I(ee.$$.fragment),ne=i(" to transfer ownership. See "),I(le.$$.fragment),ae=i(" for creating "),I(J.$$.fragment),ue=i("."),De=j(),de=d("li"),me=d("code"),Ce=i("upDescriptorPool"),_e=d("br"),se=i(`
            A unique pointer to the `),I(ie.$$.fragment),ge=i(" where the "),I(we.$$.fragment),Re=i(` can be retrieved from. Please use
            `),I(Be.$$.fragment),Ie=i(" to transfer ownership. See "),I(re.$$.fragment),he=i(" for creating "),I(Ae.$$.fragment),Ve=i("."),oe=j(),ce=d("li"),Pe=d("code"),Fe=i("preprocess"),ke=d("br"),Te=i(`
            Whether to preprocess the shader to validate the `),I(Me.$$.fragment),Ue=i(" code. This will throw an exception if the shader failed to compile."),qe=j(),xe=d("li"),Ge=d("code"),ye=i("optimize"),We=d("br"),ze=i(`
            Whether the optimize the shader.`),Ye=j(),this.h()},l(Ne){e=g(Ne,"DIV",{slot:!0});var He=E(e);t=g(He,"LI",{});var $t=E(t);r=g($t,"CODE",{});var ut=E(r);$=f(ut,"shaderDirectory"),ut.forEach(l),n=g($t,"BR",{}),s=f($t,`
            The directory where the `),S(a.$$.fragment,$t),u=f($t," shader file is located."),$t.forEach(l),p=Y(He),m=g(He,"LI",{});var ht=E(m);_=g(ht,"CODE",{});var Je=E(_);v=f(Je,"shaderFileName"),Je.forEach(l),R=g(ht,"BR",{}),P=f(ht,`
            The name of the `),S(A.$$.fragment,ht),T=f(ht," shader file."),ht.forEach(l),y=Y(He),B=g(He,"LI",{});var dt=E(B);M=g(dt,"CODE",{});var et=E(M);O=f(et,"shaderKind"),et.forEach(l),x=g(dt,"BR",{}),F=f(dt,`
            The kind of shader (see `),S(V.$$.fragment,dt),q=f(dt,")"),dt.forEach(l),k=Y(He),N=g(He,"LI",{});var Ze=E(N);Q=g(Ze,"CODE",{});var nt=E(Q);X=f(nt,"upDescriptorSetLayouts"),nt.forEach(l),Z=g(Ze,"BR",{}),K=f(Ze,`
            A `),S(W.$$.fragment,Ze),U=f(Ze," to a list of the "),S(G.$$.fragment,Ze),te=f(Ze,` describing the resources the shader should have access to. Please use
            `),S(ee.$$.fragment,Ze),ne=f(Ze," to transfer ownership. See "),S(le.$$.fragment,Ze),ae=f(Ze," for creating "),S(J.$$.fragment,Ze),ue=f(Ze,"."),Ze.forEach(l),De=Y(He),de=g(He,"LI",{});var Ke=E(de);me=g(Ke,"CODE",{});var ct=E(me);Ce=f(ct,"upDescriptorPool"),ct.forEach(l),_e=g(Ke,"BR",{}),se=f(Ke,`
            A unique pointer to the `),S(ie.$$.fragment,Ke),ge=f(Ke," where the "),S(we.$$.fragment,Ke),Re=f(Ke,` can be retrieved from. Please use
            `),S(Be.$$.fragment,Ke),Ie=f(Ke," to transfer ownership. See "),S(re.$$.fragment,Ke),he=f(Ke," for creating "),S(Ae.$$.fragment,Ke),Ve=f(Ke,"."),Ke.forEach(l),oe=Y(He),ce=g(He,"LI",{});var st=E(ce);Pe=g(st,"CODE",{});var Qe=E(Pe);Fe=f(Qe,"preprocess"),Qe.forEach(l),ke=g(st,"BR",{}),Te=f(st,`
            Whether to preprocess the shader to validate the `),S(Me.$$.fragment,st),Ue=f(st," code. This will throw an exception if the shader failed to compile."),st.forEach(l),qe=Y(He),xe=g(He,"LI",{});var at=E(xe);Ge=g(at,"CODE",{});var bt=E(Ge);ye=f(bt,"optimize"),bt.forEach(l),We=g(at,"BR",{}),ze=f(at,`
            Whether the optimize the shader.`),at.forEach(l),Ye=Y(He),He.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ne,He){h(Ne,e,He),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),D(G,N,null),o(N,te),D(ee,N,null),o(N,ne),D(le,N,null),o(N,ae),D(J,N,null),o(N,ue),o(e,De),o(e,de),o(de,me),o(me,Ce),o(de,_e),o(de,se),D(ie,de,null),o(de,ge),D(we,de,null),o(de,Re),D(Be,de,null),o(de,Ie),D(re,de,null),o(de,he),D(Ae,de,null),o(de,Ve),o(e,oe),o(e,ce),o(ce,Pe),o(Pe,Fe),o(ce,ke),o(ce,Te),D(Me,ce,null),o(ce,Ue),o(e,qe),o(e,xe),o(xe,Ge),o(Ge,ye),o(xe,We),o(xe,ze),o(e,Ye),rt=!0},p(Ne,He){const $t={};He&1&&($t.$$scope={dirty:He,ctx:Ne}),a.$set($t);const ut={};He&1&&(ut.$$scope={dirty:He,ctx:Ne}),A.$set(ut);const ht={};He&1&&(ht.$$scope={dirty:He,ctx:Ne}),V.$set(ht);const Je={};He&1&&(Je.$$scope={dirty:He,ctx:Ne}),W.$set(Je);const dt={};He&1&&(dt.$$scope={dirty:He,ctx:Ne}),G.$set(dt);const et={};He&1&&(et.$$scope={dirty:He,ctx:Ne}),ee.$set(et);const Ze={};He&1&&(Ze.$$scope={dirty:He,ctx:Ne}),le.$set(Ze);const nt={};He&1&&(nt.$$scope={dirty:He,ctx:Ne}),J.$set(nt);const Ke={};He&1&&(Ke.$$scope={dirty:He,ctx:Ne}),ie.$set(Ke);const ct={};He&1&&(ct.$$scope={dirty:He,ctx:Ne}),we.$set(ct);const st={};He&1&&(st.$$scope={dirty:He,ctx:Ne}),Be.$set(st);const Qe={};He&1&&(Qe.$$scope={dirty:He,ctx:Ne}),re.$set(Qe);const at={};He&1&&(at.$$scope={dirty:He,ctx:Ne}),Ae.$set(at);const bt={};He&1&&(bt.$$scope={dirty:He,ctx:Ne}),Me.$set(bt)},i(Ne){rt||(b(a.$$.fragment,Ne),b(A.$$.fragment,Ne),b(V.$$.fragment,Ne),b(W.$$.fragment,Ne),b(G.$$.fragment,Ne),b(ee.$$.fragment,Ne),b(le.$$.fragment,Ne),b(J.$$.fragment,Ne),b(ie.$$.fragment,Ne),b(we.$$.fragment,Ne),b(Be.$$.fragment,Ne),b(re.$$.fragment,Ne),b(Ae.$$.fragment,Ne),b(Me.$$.fragment,Ne),rt=!0)},o(Ne){w(a.$$.fragment,Ne),w(A.$$.fragment,Ne),w(V.$$.fragment,Ne),w(W.$$.fragment,Ne),w(G.$$.fragment,Ne),w(ee.$$.fragment,Ne),w(le.$$.fragment,Ne),w(J.$$.fragment,Ne),w(ie.$$.fragment,Ne),w(we.$$.fragment,Ne),w(Be.$$.fragment,Ne),w(re.$$.fragment,Ne),w(Ae.$$.fragment,Ne),w(Me.$$.fragment,Ne),rt=!1},d(Ne){Ne&&l(e),C(a),C(A),C(V),C(W),C(G),C(ee),C(le),C(J),C(ie),C(we),C(Be),C(re),C(Ae),C(Me)}}}function Sf(c){let e;return{c(){e=i("Shader Module")},l(t){e=f(t,"Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rf(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[Sf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A unique pointer to the created "),I(r.$$.fragment),$=i(` (ownership will be transferred to the implementation).
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A unique pointer to the created "),S(r.$$.fragment,a),$=f(a,` (ownership will be transferred to the implementation).
    `),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Af(c){let e;return{c(){e=i("Shader Module")},l(t){e=f(t,"Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pf(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[Af]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Bf(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:`std::unique_ptr<ShaderModule> createShaderModule(
        const std::string shaderDirectory, 
        const std::string shaderFileName,
        shaderc_shader_kind shaderKind,
        std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
        std::unique_ptr<DescriptorPool> upDescriptorPool, 
        bool preprocess = true,
        bool optimize = false
);`}}),r=new Se({props:{$$slots:{throws:[Pf],return:[Rf],params:[Cf],details:[cf]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`std::vector<std::unique_ptr<fillcan::DescriptorSetLayout>> upFragmentDescriptorSetLayouts = ...;
std::unique_ptr<fillcan::DescriptorPool> upFragmentDescriptorPool = ...;

std::unique_ptr<fillcan::ShaderModule> upVertexShaderModule =
    fillcan.createShaderModule(
        this->APP_DIR + "/shaders", 
        "shader.vert", 
        shaderc_vertex_shader, 
        {}, 
        nullptr, 
        true, 
        false
);

std::unique_ptr<fillcan::ShaderModule> upFragmentShaderModule =
    fillcan.createShaderModule(
        this->APP_DIR + "/shaders", 
        "shader.frag", 
        shaderc_fragment_shader,
        std::move(upFragmentDescriptorSetLayouts), 
        std::move(upFragmentDescriptorPool), 
        true, 
        false
);`}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class Lf extends ve{constructor(e){super(),Ee(this,e,null,Bf,be,{})}}function kf(c){let e,t;return{c(){e=d("code"),t=i("Fillcan")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"Fillcan"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Tf(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:"#include <fillcan/fillcan_graphics.hpp>"}}),u=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[kf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
Vulkan is primarily a graphics API in the sense that most of Vulkan's functionality
is devoted to image generation and processing. Most Vulkan applications are designed
to display their results to the user. This is a process known as presentation. Because
the variety of platforms that Vulkan runs on is large and because not all applications
need to present the output to the user visually, the presentation is not a core part
of the API, but is handled by a series of extensions. `),r=d("br"),$=i(`
The `),n=d("code"),s=i("FillcanGraphics"),a=i(" class extends the "),I(u.$$.fragment),p=i(` class to enable these extensions and offer functionality exclusive to the graphics
portion of Vulkan.`)},l(_){S(e.$$.fragment,_),t=f(_,`
Vulkan is primarily a graphics API in the sense that most of Vulkan's functionality
is devoted to image generation and processing. Most Vulkan applications are designed
to display their results to the user. This is a process known as presentation. Because
the variety of platforms that Vulkan runs on is large and because not all applications
need to present the output to the user visually, the presentation is not a core part
of the API, but is handled by a series of extensions. `),r=g(_,"BR",{}),$=f(_,`
The `),n=g(_,"CODE",{});var v=E(n);s=f(v,"FillcanGraphics"),v.forEach(l),a=f(_," class extends the "),S(u.$$.fragment,_),p=f(_,` class to enable these extensions and offer functionality exclusive to the graphics
portion of Vulkan.`)},m(_,v){D(e,_,v),h(_,t,v),h(_,r,v),h(_,$,v),h(_,n,v),o(n,s),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(e.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),_&&l(r),_&&l($),_&&l(n),_&&l(a),C(u,_),_&&l(p)}}}class Of extends ve{constructor(e){super(),Ee(this,e,null,Tf,be,{})}}function Vf(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yf(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mf(c){let e;return{c(){e=i("Device Pool")},l(t){e=f(t,"Device Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ff(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Vf]},$$scope:{ctx:c}}}),a=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[yf]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.DEVICE_POOL,$$slots:{default:[Mf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Intialize the Fillcan Graphics API."),r=d("br"),$=i(`
        Initializes the `),I(n.$$.fragment),s=i(", "),I(a.$$.fragment),u=i(", and "),I(p.$$.fragment),m=i(`.
    `),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=f(R,"Intialize the Fillcan Graphics API."),r=g(R,"BR",{}),$=f(R,`
        Initializes the `),S(n.$$.fragment,R),s=f(R,", "),S(a.$$.fragment,R),u=f(R,", and "),S(p.$$.fragment,R),m=f(R,`.
    `),R.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,R){h(v,e,R),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),n.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),a.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:v}),p.$set(T)},i(v){_||(b(n.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(a),C(p)}}}function xf(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nf(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uf(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gf(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hf(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qf(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wf(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qf(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe;return M=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[xf]},$$scope:{ctx:c}}}),Q=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Nf]},$$scope:{ctx:c}}}),ee=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Uf]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[Gf]},$$scope:{ctx:c}}}),ie=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Hf]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[qf]},$$scope:{ctx:c}}}),re=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Wf]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=j(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),R=j(),P=d("li"),A=d("code"),T=i("windowWidth"),y=d("br"),B=i(`
            The initial width the `),I(M.$$.fragment),O=i("."),x=j(),F=d("li"),V=d("code"),q=i("windowHeight"),k=d("br"),N=i(`
            The initial height the `),I(Q.$$.fragment),X=i("."),Z=j(),K=d("li"),W=d("code"),U=i("requiredDeviceFeatures"),G=d("br"),te=i(`
            The features a `),I(ee.$$.fragment),ne=i(" should have for the purposes of the application."),le=d("br"),ae=i(`
            This should be a `),I(J.$$.fragment),ue=i("-structure where each required feature should be set to true."),De=j(),de=d("li"),me=d("code"),Ce=i("requiredDeviceExtensions"),_e=d("br"),se=i(`
            The extensions a `),I(ie.$$.fragment),ge=i(" should enable for the purposes of the application."),we=d("br"),Re=i(`
            This should be a list of strings containing the names of the extensions
            to enable. The available extensions can be retrieved using `),I(Be.$$.fragment),Ie=i(". To be able to use a "),I(re.$$.fragment),he=i(` this list should contain
            `),Ae=d("code"),Ve=i("VK_KHR_SWAPCHAIN_EXTENSION_NAME"),oe=i(`, this is included by
            default.`),ce=d("br"),Pe=j(),this.h()},l(ke){e=g(ke,"DIV",{slot:!0});var Te=E(e);t=g(Te,"LI",{});var Me=E(t);r=g(Me,"CODE",{});var Ue=E(r);$=f(Ue,"pApplicationName"),Ue.forEach(l),n=g(Me,"BR",{}),s=f(Me,`
            The name of the application.`),Me.forEach(l),a=Y(Te),u=g(Te,"LI",{});var qe=E(u);p=g(qe,"CODE",{});var xe=E(p);m=f(xe,"applicationVersion"),xe.forEach(l),_=g(qe,"BR",{}),v=f(qe,`
            The version of the application.`),qe.forEach(l),R=Y(Te),P=g(Te,"LI",{});var Ge=E(P);A=g(Ge,"CODE",{});var ye=E(A);T=f(ye,"windowWidth"),ye.forEach(l),y=g(Ge,"BR",{}),B=f(Ge,`
            The initial width the `),S(M.$$.fragment,Ge),O=f(Ge,"."),Ge.forEach(l),x=Y(Te),F=g(Te,"LI",{});var We=E(F);V=g(We,"CODE",{});var ze=E(V);q=f(ze,"windowHeight"),ze.forEach(l),k=g(We,"BR",{}),N=f(We,`
            The initial height the `),S(Q.$$.fragment,We),X=f(We,"."),We.forEach(l),Z=Y(Te),K=g(Te,"LI",{});var Ye=E(K);W=g(Ye,"CODE",{});var rt=E(W);U=f(rt,"requiredDeviceFeatures"),rt.forEach(l),G=g(Ye,"BR",{}),te=f(Ye,`
            The features a `),S(ee.$$.fragment,Ye),ne=f(Ye," should have for the purposes of the application."),le=g(Ye,"BR",{}),ae=f(Ye,`
            This should be a `),S(J.$$.fragment,Ye),ue=f(Ye,"-structure where each required feature should be set to true."),Ye.forEach(l),De=Y(Te),de=g(Te,"LI",{});var Ne=E(de);me=g(Ne,"CODE",{});var He=E(me);Ce=f(He,"requiredDeviceExtensions"),He.forEach(l),_e=g(Ne,"BR",{}),se=f(Ne,`
            The extensions a `),S(ie.$$.fragment,Ne),ge=f(Ne," should enable for the purposes of the application."),we=g(Ne,"BR",{}),Re=f(Ne,`
            This should be a list of strings containing the names of the extensions
            to enable. The available extensions can be retrieved using `),S(Be.$$.fragment,Ne),Ie=f(Ne,". To be able to use a "),S(re.$$.fragment,Ne),he=f(Ne,` this list should contain
            `),Ae=g(Ne,"CODE",{});var $t=E(Ae);Ve=f($t,"VK_KHR_SWAPCHAIN_EXTENSION_NAME"),$t.forEach(l),oe=f(Ne,`, this is included by
            default.`),ce=g(Ne,"BR",{}),Ne.forEach(l),Pe=Y(Te),Te.forEach(l),this.h()},h(){z(e,"slot","params")},m(ke,Te){h(ke,e,Te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B),D(M,P,null),o(P,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),D(ee,K,null),o(K,ne),o(K,le),o(K,ae),D(J,K,null),o(K,ue),o(e,De),o(e,de),o(de,me),o(me,Ce),o(de,_e),o(de,se),D(ie,de,null),o(de,ge),o(de,we),o(de,Re),D(Be,de,null),o(de,Ie),D(re,de,null),o(de,he),o(de,Ae),o(Ae,Ve),o(de,oe),o(de,ce),o(e,Pe),Fe=!0},p(ke,Te){const Me={};Te&1&&(Me.$$scope={dirty:Te,ctx:ke}),M.$set(Me);const Ue={};Te&1&&(Ue.$$scope={dirty:Te,ctx:ke}),Q.$set(Ue);const qe={};Te&1&&(qe.$$scope={dirty:Te,ctx:ke}),ee.$set(qe);const xe={};Te&1&&(xe.$$scope={dirty:Te,ctx:ke}),J.$set(xe);const Ge={};Te&1&&(Ge.$$scope={dirty:Te,ctx:ke}),ie.$set(Ge);const ye={};Te&1&&(ye.$$scope={dirty:Te,ctx:ke}),Be.$set(ye);const We={};Te&1&&(We.$$scope={dirty:Te,ctx:ke}),re.$set(We)},i(ke){Fe||(b(M.$$.fragment,ke),b(Q.$$.fragment,ke),b(ee.$$.fragment,ke),b(J.$$.fragment,ke),b(ie.$$.fragment,ke),b(Be.$$.fragment,ke),b(re.$$.fragment,ke),Fe=!0)},o(ke){w(M.$$.fragment,ke),w(Q.$$.fragment,ke),w(ee.$$.fragment,ke),w(J.$$.fragment,ke),w(ie.$$.fragment,ke),w(Be.$$.fragment,ke),w(re.$$.fragment,ke),Fe=!1},d(ke){ke&&l(e),C(M),C(Q),C(ee),C(J),C(ie),C(Be),C(re)}}}function Kf(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:`FillcanGraphics(
        const char* pApplicationName, 
        uint32_t applicationVersion, 
        unsigned int windowWidth, 
        unsigned int windowHeight,
        VkPhysicalDeviceFeatures requiredDeviceFeatures = {},
        std::vector<const char*> requiredDeviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME}
);`}}),r=new Se({props:{$$slots:{params:[Qf],details:[Ff]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`VkPhysicalDeviceFeatures requiredDeviceFeatures = {};
requiredDeviceFeatures.samplerAnisotropy = true;
fillcan::FillcanGraphics fillcan = fillcan::FillcanGraphics("Example Application", 800, 600, 1.0, requiredDeviceFeatures);`}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class zf extends ve{constructor(e){super(),Ee(this,e,null,Kf,be,{})}}function jf(c){let e,t;return{c(){e=d("span"),t=i(`The main loop of the Fillcan Graphics API. The main loop of the Fillcan
        Graphics API gives access to a callback function with the deltaTime. The
        main loop calls this callback every frame.
    `),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`The main loop of the Fillcan Graphics API. The main loop of the Fillcan
        Graphics API gives access to a callback function with the deltaTime. The
        main loop calls this callback every frame.
    `),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Yf(c){let e,t,r,$,n,s,a;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("callback"),n=d("br"),s=i(`
            The callback with the deltaTime which will be called every frame.`),a=j(),this.h()},l(u){e=g(u,"DIV",{slot:!0});var p=E(e);t=g(p,"LI",{});var m=E(t);r=g(m,"CODE",{});var _=E(r);$=f(_,"callback"),_.forEach(l),n=g(m,"BR",{}),s=f(m,`
            The callback with the deltaTime which will be called every frame.`),m.forEach(l),a=Y(p),p.forEach(l),this.h()},h(){z(e,"slot","params")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function Xf(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:"void mainLoop(std::function<void(double)> callback);"}}),r=new Se({props:{$$slots:{params:[Yf],details:[jf]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`{
    ...
    fillcan.mainLoop(std::bind(&App::update, this, std::placeholders::_1));
}

void App::update(double deltaTime) {
    // Called every frame
}`}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class Zf extends ve{constructor(e){super(),Ee(this,e,null,Xf,be,{})}}function Jf(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ec(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Jf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tc(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sc(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ac(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[tc]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[rc]},$$scope:{ctx:c}}}),y=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[nc]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[sc]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("imageCount"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should have."),_=j(),v=d("li"),R=d("code"),P=i("presentMode"),A=d("br"),T=i(`
            The present mode of the `),I(y.$$.fragment),B=i(". This should be member of the "),I(M.$$.fragment),O=i("-struct."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"imageCount"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            The amount of `),S(a.$$.fragment,q),u=f(q," the "),S(p.$$.fragment,q),m=f(q," should have."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"presentMode"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The present mode of the `),S(y.$$.fragment,N),B=f(N,". This should be member of the "),S(M.$$.fragment,N),O=f(N,"-struct."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function oc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[oc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ic(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fc(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[ic]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function cc(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int createSwapchain(uint32_t imageCount = 3, VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR);"}}),r=new Se({props:{$$slots:{throws:[fc],return:[lc],params:[ac],details:[ec]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $c extends ve{constructor(e){super(),Ee(this,e,null,cc,be,{})}}function uc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[uc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Recreate a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Recreate a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mc(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gc(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _c(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vc(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ec(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[mc]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[hc]},$$scope:{ctx:c}}}),y=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[dc]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[gc]},$$scope:{ctx:c}}}),Q=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[_c]},$$scope:{ctx:c}}}),Z=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[vc]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("imageCount"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" the recreated "),I(p.$$.fragment),m=i(" should have."),_=j(),v=d("li"),R=d("code"),P=i("presentMode"),A=d("br"),T=i(`
            The present mode of the recreated `),I(y.$$.fragment),B=i(". This should be member of the "),I(M.$$.fragment),O=i("-struct"),x=j(),F=d("li"),V=d("code"),q=i("index"),k=d("br"),N=i(`
            The index of the Swapchain returned by `),I(Q.$$.fragment),X=i(" or "),I(Z.$$.fragment),K=i(" to be recreated."),W=j(),this.h()},l(G){e=g(G,"DIV",{slot:!0});var te=E(e);t=g(te,"LI",{});var ee=E(t);r=g(ee,"CODE",{});var ne=E(r);$=f(ne,"imageCount"),ne.forEach(l),n=g(ee,"BR",{}),s=f(ee,`
            The amount of `),S(a.$$.fragment,ee),u=f(ee," the recreated "),S(p.$$.fragment,ee),m=f(ee," should have."),ee.forEach(l),_=Y(te),v=g(te,"LI",{});var le=E(v);R=g(le,"CODE",{});var ae=E(R);P=f(ae,"presentMode"),ae.forEach(l),A=g(le,"BR",{}),T=f(le,`
            The present mode of the recreated `),S(y.$$.fragment,le),B=f(le,". This should be member of the "),S(M.$$.fragment,le),O=f(le,"-struct"),le.forEach(l),x=Y(te),F=g(te,"LI",{});var J=E(F);V=g(J,"CODE",{});var ue=E(V);q=f(ue,"index"),ue.forEach(l),k=g(J,"BR",{}),N=f(J,`
            The index of the Swapchain returned by `),S(Q.$$.fragment,J),X=f(J," or "),S(Z.$$.fragment,J),K=f(J," to be recreated."),J.forEach(l),W=Y(te),te.forEach(l),this.h()},h(){z(e,"slot","params")},m(G,te){h(G,e,te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),D(Z,F,null),o(F,K),o(e,W),U=!0},p(G,te){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:G}),a.$set(ee);const ne={};te&1&&(ne.$$scope={dirty:te,ctx:G}),p.$set(ne);const le={};te&1&&(le.$$scope={dirty:te,ctx:G}),y.$set(le);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:G}),M.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:G}),Q.$set(J);const ue={};te&1&&(ue.$$scope={dirty:te,ctx:G}),Z.$set(ue)},i(G){U||(b(a.$$.fragment,G),b(p.$$.fragment,G),b(y.$$.fragment,G),b(M.$$.fragment,G),b(Q.$$.fragment,G),b(Z.$$.fragment,G),U=!0)},o(G){w(a.$$.fragment,G),w(p.$$.fragment,G),w(y.$$.fragment,G),w(M.$$.fragment,G),w(Q.$$.fragment,G),w(Z.$$.fragment,G),U=!1},d(G){G&&l(e),C(a),C(p),C(y),C(M),C(Q),C(Z)}}}function bc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[bc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the recreated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the recreated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ic(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dc(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Ic]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be recreated.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be recreated.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Cc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Cc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Recreate a "),I(r.$$.fragment),$=i(" using it's original values."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Recreate a "),S(r.$$.fragment,a),$=f(a," using it's original values."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Rc(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ac(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pc(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[Rc]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[Ac]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the Swapchain returned by `),I(a.$$.fragment),u=i(" or "),I(p.$$.fragment),m=i(" to be recreated."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The index of the Swapchain returned by `),S(a.$$.fragment,P),u=f(P," or "),S(p.$$.fragment,P),m=f(P," to be recreated."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Bc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Bc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the recreated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the recreated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function kc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tc(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[kc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be recreated."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be recreated."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Oc(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"unsigned int recreateSwapchain(uint32_t imageCount, VkPresentModeKHR presentMode, unsigned int index = 0);"}}),r=new Se({props:{$$slots:{throws:[Dc],return:[wc],params:[Ec],details:[pc]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:"unsigned int recreateSwapchain(unsigned int index = 0);"}}),u=new Se({props:{$$slots:{throws:[Tc],return:[Lc],params:[Pc],details:[Sc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Vc extends ve{constructor(e){super(),Ee(this,e,null,Oc,be,{})}}function yc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[yc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a "),I(r.$$.fragment),$=i(" at a given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a "),S(r.$$.fragment,a),$=f(a," at a given index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Fc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xc(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nc(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uc(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return a=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Fc]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[xc]},$$scope:{ctx:c}}}),_=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[Nc]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" returned by "),I(p.$$.fragment),m=i(" or "),I(_.$$.fragment),v=i(" to retrieve."),this.h()},l(P){e=g(P,"DIV",{slot:!0});var A=E(e);t=g(A,"LI",{});var T=E(t);r=g(T,"CODE",{});var y=E(r);$=f(y,"index"),y.forEach(l),n=g(T,"BR",{}),s=f(T,`
            The index of the `),S(a.$$.fragment,T),u=f(T," returned by "),S(p.$$.fragment,T),m=f(T," or "),S(_.$$.fragment,T),v=f(T," to retrieve."),T.forEach(l),A.forEach(l),this.h()},h(){z(e,"slot","params")},m(P,A){h(P,e,A),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),a.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),p.$set(y);const B={};A&1&&(B.$$scope={dirty:A,ctx:P}),_.$set(B)},i(P){R||(b(a.$$.fragment,P),b(p.$$.fragment,P),b(_.$$.fragment,P),R=!0)},o(P){w(a.$$.fragment,P),w(p.$$.fragment,P),w(_.$$.fragment,P),R=!1},d(P){P&&l(e),C(a),C(p),C(_)}}}function Gc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Gc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" at the given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," at the given index."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qc(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Swapchain* getSwapchain(unsigned int index = 0);"}}),r=new Se({props:{$$slots:{return:[Hc],params:[Uc],details:[Mc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Wc extends ve{constructor(e){super(),Ee(this,e,null,qc,be,{})}}function Qc(c){let e;return{c(){e=i("Swapchains")},l(t){e=f(t,"Swapchains")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kc(c){let e,t,r,$;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Qc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get all the created "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function zc(c){let e;return{c(){e=i("Swapchains")},l(t){e=f(t,"Swapchains")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[zc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Yc(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<Swapchain*> getSwapchains();"}}),r=new Se({props:{$$slots:{return:[jc],details:[Kc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Xc extends ve{constructor(e){super(),Ee(this,e,null,Yc,be,{})}}function Zc(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jc(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Zc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" at a given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," at a given index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function e$(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t$(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r$(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n$(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return a=new fe({props:{href:je().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[e$]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[t$]},$$scope:{ctx:c}}}),_=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[r$]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" returned by "),I(p.$$.fragment),m=i(" or "),I(_.$$.fragment),v=i(" to destroy."),this.h()},l(P){e=g(P,"DIV",{slot:!0});var A=E(e);t=g(A,"LI",{});var T=E(t);r=g(T,"CODE",{});var y=E(r);$=f(y,"index"),y.forEach(l),n=g(T,"BR",{}),s=f(T,`
            The index of the `),S(a.$$.fragment,T),u=f(T," returned by "),S(p.$$.fragment,T),m=f(T," or "),S(_.$$.fragment,T),v=f(T," to destroy."),T.forEach(l),A.forEach(l),this.h()},h(){z(e,"slot","params")},m(P,A){h(P,e,A),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),a.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),p.$set(y);const B={};A&1&&(B.$$scope={dirty:A,ctx:P}),_.$set(B)},i(P){R||(b(a.$$.fragment,P),b(p.$$.fragment,P),b(_.$$.fragment,P),R=!0)},o(P){w(a.$$.fragment,P),w(p.$$.fragment,P),w(_.$$.fragment,P),R=!1},d(P){P&&l(e),C(a),C(p),C(_)}}}function s$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroySwapchain(unsigned int index = 0);"}}),r=new Se({props:{$$slots:{params:[n$],details:[Jc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class a$ extends ve{constructor(e){super(),Ee(this,e,null,s$,be,{})}}function o$(c){let e;return{c(){e=i("Asset Manager")},l(t){e=f(t,"Asset Manager")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l$(c){let e,t,r,$;return r=new fe({props:{href:je().URL.documentation+"#"+L.ASSET_MANAGER,$$slots:{default:[o$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get the "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function i$(c){let e;return{c(){e=i("Asset Manager")},l(t){e=f(t,"Asset Manager")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f$(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.ASSET_MANAGER,$$slots:{default:[i$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function c$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"AssetManager* getAssetManager();"}}),r=new Se({props:{$$slots:{return:[f$],details:[l$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $$ extends ve{constructor(e){super(),Ee(this,e,null,c$,be,{})}}function u$(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p$(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m$(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:"#include <fillcan/window.hpp>"}}),s=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[u$]},$$scope:{ctx:c}}}),u=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[p$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Window"),n=i(" class is used by "),I(s.$$.fragment),a=i(" for presentation. The Window is instantiated automatically by "),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=f(_,`
The `),r=g(_,"CODE",{});var v=E(r);$=f(v,"Window"),v.forEach(l),n=f(_," class is used by "),S(s.$$.fragment,_),a=f(_," for presentation. The Window is instantiated automatically by "),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),h(_,r,v),o(r,$),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),s.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(e.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),_&&l(r),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class h$ extends ve{constructor(e){super(),Ee(this,e,null,m$,be,{})}}function d$(c){let e;return{c(){e=i("GLFW")},l(t){e=f(t,"GLFW")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g$(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://www.glfw.org/",target:"_blank",$$slots:{default:[d$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Window."),r=d("br"),$=i(`
        Creates a new `),I(n.$$.fragment),s=i(" Window."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Window."),r=g(p,"BR",{}),$=f(p,`
        Creates a new `),S(n.$$.fragment,p),s=f(p," Window."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function _$(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("width"),n=d("br"),s=i(`
            The initial width of the Window.`),a=j(),u=d("li"),p=d("code"),m=i("height"),_=d("br"),v=i(`
            The initial height of the Window.`),R=j(),P=d("li"),A=d("code"),T=i("name"),y=d("br"),B=i(`
            The name of the Window.`),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var x=E(t);r=g(x,"CODE",{});var F=E(r);$=f(F,"width"),F.forEach(l),n=g(x,"BR",{}),s=f(x,`
            The initial width of the Window.`),x.forEach(l),a=Y(O),u=g(O,"LI",{});var V=E(u);p=g(V,"CODE",{});var q=E(p);m=f(q,"height"),q.forEach(l),_=g(V,"BR",{}),v=f(V,`
            The initial height of the Window.`),V.forEach(l),R=Y(O),P=g(O,"LI",{});var k=E(P);A=g(k,"CODE",{});var N=E(A);T=f(N,"name"),N.forEach(l),y=g(k,"BR",{}),B=f(k,`
            The name of the Window.`),k.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B)},p:Oe,d(M){M&&l(e)}}}function v$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Window(unsigned int width, unsigned int height, std::string name);"}}),r=new Se({props:{$$slots:{params:[_$],details:[g$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class E$ extends ve{constructor(e){super(),Ee(this,e,null,v$,be,{})}}function b$(c){let e,t;return{c(){e=d("span"),t=i("Whether the Window should close, e.g. the user attempts to close it."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Whether the Window should close, e.g. the user attempts to close it."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function w$(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the Window should close. "),n=d("code"),s=i("false"),a=i(" if the Window shouldn't close."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the Window should close. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Window shouldn't close."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function I$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool shouldClose();"}}),r=new Se({props:{$$slots:{return:[w$],details:[b$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class D$ extends ve{constructor(e){super(),Ee(this,e,null,I$,be,{})}}function C$(c){let e,t;return{c(){e=d("span"),t=i("Whether the Window was resized."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Whether the Window was resized."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function S$(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the Window was resized. "),n=d("code"),s=i("false"),a=i(" if the Window wasn't resized."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the Window was resized. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Window wasn't resized."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function R$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool wasResized();"}}),r=new Se({props:{$$slots:{return:[S$],details:[C$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class A$ extends ve{constructor(e){super(),Ee(this,e,null,R$,be,{})}}function P$(c){let e,t;return{c(){e=d("span"),t=i(`Poll for events, e.g. close button pressed, window resized or other user
        interaction.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Poll for events, e.g. close button pressed, window resized or other user
        interaction.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function B$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void pollEvents();"}}),r=new Se({props:{$$slots:{details:[P$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class L$ extends ve{constructor(e){super(),Ee(this,e,null,B$,be,{})}}function k$(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T$(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[k$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Get a list of required extensions that should be enabled by Vulkan. The
        available extensions can be retrieved using `),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`Get a list of required extensions that should be enabled by Vulkan. The
        available extensions can be retrieved using `),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function O$(c){let e,t;return{c(){e=d("span"),t=i("A list of the required extensions."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required extensions."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function V$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<const char*> getRequiredExtensions();"}}),r=new Se({props:{$$slots:{return:[O$],details:[T$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class y$ extends ve{constructor(e){super(),Ee(this,e,null,V$,be,{})}}function M$(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F$(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x$(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[M$]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[F$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i(" using the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a "),S(r.$$.fragment,p),$=f(p," using the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function N$(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U$(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[N$]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pInstance"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to create a surface in."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pInstance"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to create a surface in."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function G$(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the surface failed to be created."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the surface failed to be created."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function H$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void createSurface(Instance* pInstance);"}}),r=new Se({props:{$$slots:{throws:[G$],params:[U$],details:[x$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class q$ extends ve{constructor(e){super(),Ee(this,e,null,H$,be,{})}}function W$(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q$(c){let e;return{c(){e=i("createSurface")},l(t){e=f(t,"createSurface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K$(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[W$]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW_createSurface,$$slots:{default:[Q$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" created with "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the "),S(r.$$.fragment,p),$=f(p," created with "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function z$(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j$(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[z$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A handle to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A handle to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Y$(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSurfaceKHR getSurface();"}}),r=new Se({props:{$$slots:{return:[j$],details:[K$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class X$ extends ve{constructor(e){super(),Ee(this,e,null,Y$,be,{})}}function Z$(c){let e;return{c(){e=i("Extent")},l(t){e=f(t,"Extent")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J$(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[Z$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" of the Window."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," of the Window."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function eu(c){let e;return{c(){e=i("Extent")},l(t){e=f(t,"Extent")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[eu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(" of the Window."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The "),S(r.$$.fragment,a),$=f(a," of the Window."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ru(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkExtent2D getExtent();"}}),r=new Se({props:{$$slots:{return:[tu],details:[J$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nu extends ve{constructor(e){super(),Ee(this,e,null,ru,be,{})}}function su(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function au(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ou(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return e=new $e({props:{language:pe,code:"#include <fillcan/instance/instance.hpp>"}}),A=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[su]},$$scope:{ctx:c}}}),y=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[au]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Instance"),n=i(` class is the connection between the application and
the Vulkan library and to create it some details of the application need to be
specified to the driver.`),s=d("br"),a=i(`
The instance contains information such as an application name, name and version of
the engine used to create the application, and enabled instance-level extensions
and layers.`),u=d("br"),p=i(`
Vulkan can be seen as a subsystem of the application. Once the application is linked
to the Vulkan libraries and initialized, a certain state is tracked. Vulkan does
not introduce a global state in the application, so all tracked state must be stored
in an object that the application provides, the `),m=d("code"),_=i("Instance"),v=i(" class."),R=d("br"),P=i(`
The Instance is instantiated automatically by `),I(A.$$.fragment),T=i(" and "),I(y.$$.fragment),B=i(".")},l(O){S(e.$$.fragment,O),t=f(O,`
The `),r=g(O,"CODE",{});var x=E(r);$=f(x,"Instance"),x.forEach(l),n=f(O,` class is the connection between the application and
the Vulkan library and to create it some details of the application need to be
specified to the driver.`),s=g(O,"BR",{}),a=f(O,`
The instance contains information such as an application name, name and version of
the engine used to create the application, and enabled instance-level extensions
and layers.`),u=g(O,"BR",{}),p=f(O,`
Vulkan can be seen as a subsystem of the application. Once the application is linked
to the Vulkan libraries and initialized, a certain state is tracked. Vulkan does
not introduce a global state in the application, so all tracked state must be stored
in an object that the application provides, the `),m=g(O,"CODE",{});var F=E(m);_=f(F,"Instance"),F.forEach(l),v=f(O," class."),R=g(O,"BR",{}),P=f(O,`
The Instance is instantiated automatically by `),S(A.$$.fragment,O),T=f(O," and "),S(y.$$.fragment,O),B=f(O,".")},m(O,x){D(e,O,x),h(O,t,x),h(O,r,x),o(r,$),h(O,n,x),h(O,s,x),h(O,a,x),h(O,u,x),h(O,p,x),h(O,m,x),o(m,_),h(O,v,x),h(O,R,x),h(O,P,x),D(A,O,x),h(O,T,x),D(y,O,x),h(O,B,x),M=!0},p(O,[x]){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),A.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),y.$set(V)},i(O){M||(b(e.$$.fragment,O),b(A.$$.fragment,O),b(y.$$.fragment,O),M=!0)},o(O){w(e.$$.fragment,O),w(A.$$.fragment,O),w(y.$$.fragment,O),M=!1},d(O){C(e,O),O&&l(t),O&&l(r),O&&l(n),O&&l(s),O&&l(a),O&&l(u),O&&l(p),O&&l(m),O&&l(v),O&&l(R),O&&l(P),C(A,O),O&&l(T),C(y,O),O&&l(B)}}}class lu extends ve{constructor(e){super(),Ee(this,e,null,ou,be,{})}}function iu(c){let e,t;return{c(){e=d("span"),t=i("Create a new Instance."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Instance."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function fu(c){let e;return{c(){e=i("vkEnumerateInstanceLayerProperties")},l(t){e=f(t,"vkEnumerateInstanceLayerProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cu(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $u(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uu(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pu(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mu(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hu(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be;return M=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html",target:"_blank",$$slots:{default:[fu]},$$scope:{ctx:c}}}),k=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[cu]},$$scope:{ctx:c}}}),Q=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[$u]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[uu]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[pu]},$$scope:{ctx:c}}}),se=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[mu]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=j(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),R=j(),P=d("li"),A=d("code"),T=i("requiredLayers"),y=d("br"),B=i(`
            The Instance layers that should be enabled. To get a list of supported
            layers the function `),I(M.$$.fragment),O=i(" can be called."),x=d("br"),F=i(`
            Layers are used to intercept the Vulkan API and provide logging, profiling,
            debugging, and other additional features.`),V=d("br"),q=j(),I(k.$$.fragment),N=i(" and "),I(Q.$$.fragment),X=i(" will enable the layer "),Z=d("code"),K=i("VK_LAYER_KHRONOS_validation"),W=i(` when
            the application is running in Debug mode.`),U=j(),G=d("li"),te=d("code"),ee=i("requiredExtensions"),ne=d("br"),le=i(`
            The Instance extensions that should be enabled. To get a list of supported
            extensions the function `),I(ae.$$.fragment),J=i(" can be called."),ue=d("br"),De=i(`
            Vulkan requires applications to sign up for extensions and enable them
            explicitly. This allows drivers to disable extensions that are not in
            use and makes it more difficult for applications to accidentally use
            functionality that is part of an extension that they had no intention
            of enabling.
            `),de=d("br"),me=j(),I(Ce.$$.fragment),_e=i(" and "),I(se.$$.fragment),ie=i(` will enable the extension
            `),ge=d("code"),we=i("VK_EXT_DEBUG_UTILS_EXTENSION_NAME"),Re=i(` when the application is
            running in Debug mode.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Ae=E(r);$=f(Ae,"pApplicationName"),Ae.forEach(l),n=g(he,"BR",{}),s=f(he,`
            The name of the application.`),he.forEach(l),a=Y(re),u=g(re,"LI",{});var Ve=E(u);p=g(Ve,"CODE",{});var oe=E(p);m=f(oe,"applicationVersion"),oe.forEach(l),_=g(Ve,"BR",{}),v=f(Ve,`
            The version of the application.`),Ve.forEach(l),R=Y(re),P=g(re,"LI",{});var ce=E(P);A=g(ce,"CODE",{});var Pe=E(A);T=f(Pe,"requiredLayers"),Pe.forEach(l),y=g(ce,"BR",{}),B=f(ce,`
            The Instance layers that should be enabled. To get a list of supported
            layers the function `),S(M.$$.fragment,ce),O=f(ce," can be called."),x=g(ce,"BR",{}),F=f(ce,`
            Layers are used to intercept the Vulkan API and provide logging, profiling,
            debugging, and other additional features.`),V=g(ce,"BR",{}),q=Y(ce),S(k.$$.fragment,ce),N=f(ce," and "),S(Q.$$.fragment,ce),X=f(ce," will enable the layer "),Z=g(ce,"CODE",{});var Fe=E(Z);K=f(Fe,"VK_LAYER_KHRONOS_validation"),Fe.forEach(l),W=f(ce,` when
            the application is running in Debug mode.`),ce.forEach(l),U=Y(re),G=g(re,"LI",{});var ke=E(G);te=g(ke,"CODE",{});var Te=E(te);ee=f(Te,"requiredExtensions"),Te.forEach(l),ne=g(ke,"BR",{}),le=f(ke,`
            The Instance extensions that should be enabled. To get a list of supported
            extensions the function `),S(ae.$$.fragment,ke),J=f(ke," can be called."),ue=g(ke,"BR",{}),De=f(ke,`
            Vulkan requires applications to sign up for extensions and enable them
            explicitly. This allows drivers to disable extensions that are not in
            use and makes it more difficult for applications to accidentally use
            functionality that is part of an extension that they had no intention
            of enabling.
            `),de=g(ke,"BR",{}),me=Y(ke),S(Ce.$$.fragment,ke),_e=f(ke," and "),S(se.$$.fragment,ke),ie=f(ke,` will enable the extension
            `),ge=g(ke,"CODE",{});var Me=E(ge);we=f(Me,"VK_EXT_DEBUG_UTILS_EXTENSION_NAME"),Me.forEach(l),Re=f(ke,` when the application is
            running in Debug mode.`),ke.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B),D(M,P,null),o(P,O),o(P,x),o(P,F),o(P,V),o(P,q),D(k,P,null),o(P,N),D(Q,P,null),o(P,X),o(P,Z),o(Z,K),o(P,W),o(e,U),o(e,G),o(G,te),o(te,ee),o(G,ne),o(G,le),D(ae,G,null),o(G,J),o(G,ue),o(G,De),o(G,de),o(G,me),D(Ce,G,null),o(G,_e),D(se,G,null),o(G,ie),o(G,ge),o(ge,we),o(G,Re),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),M.$set(he);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),k.$set(Ae);const Ve={};re&1&&(Ve.$$scope={dirty:re,ctx:Ie}),Q.$set(Ve);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),ae.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),Ce.$set(ce);const Pe={};re&1&&(Pe.$$scope={dirty:re,ctx:Ie}),se.$set(Pe)},i(Ie){Be||(b(M.$$.fragment,Ie),b(k.$$.fragment,Ie),b(Q.$$.fragment,Ie),b(ae.$$.fragment,Ie),b(Ce.$$.fragment,Ie),b(se.$$.fragment,Ie),Be=!0)},o(Ie){w(M.$$.fragment,Ie),w(k.$$.fragment,Ie),w(Q.$$.fragment,Ie),w(ae.$$.fragment,Ie),w(Ce.$$.fragment,Ie),w(se.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(M),C(k),C(Q),C(ae),C(Ce),C(se)}}}function du(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gu(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[du]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        throws `),p=d("code"),m=i("std::runtime_error"),_=i(` aswell when running in DEBUG mode
        and the debug messenger couldn't be created.`),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P," couldn't be created."),a=g(P,"BR",{}),u=f(P,`
        throws `),p=g(P,"CODE",{});var T=E(p);m=f(T,"std::runtime_error"),T.forEach(l),_=f(P,` aswell when running in DEBUG mode
        and the debug messenger couldn't be created.`),P.forEach(l),this.h()},h(){z(e,"slot","throws")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),o(p,m),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A)},i(R){v||(b(n.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),v=!1},d(R){R&&l(e),C(n)}}}function _u(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Instance(
        std::string pApplicationName, 
        unsigned int applicationVersion, 
        std::vector<const char*> requiredLayers,
        std::vector<const char*> requiredExtensions
);`}}),r=new Se({props:{$$slots:{throws:[gu],params:[hu],details:[iu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vu extends ve{constructor(e){super(),Ee(this,e,null,_u,be,{})}}function Eu(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[Eu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wu(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[wu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Du(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkInstance getInstanceHandle() const;"}}),r=new Se({props:{$$slots:{return:[Iu],details:[bu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cu extends ve{constructor(e){super(),Ee(this,e,null,Du,be,{})}}function Su(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ru(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Au(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pu(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bu(c){let e;return{c(){e=i("Logical Devices")},l(t){e=f(t,"Logical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lu(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ku(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tu(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return e=new $e({props:{language:pe,code:"#include <fillcan/instance/device_pool.hpp>"}}),s=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[Su]},$$scope:{ctx:c}}}),u=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Ru]},$$scope:{ctx:c}}}),m=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Au]},$$scope:{ctx:c}}}),P=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Pu]},$$scope:{ctx:c}}}),T=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Bu]},$$scope:{ctx:c}}}),O=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[Lu]},$$scope:{ctx:c}}}),F=new fe({props:{href:je().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[ku]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("DevicePool"),n=i(" class takes in information about the "),I(s.$$.fragment),a=i(", "),I(u.$$.fragment),p=i(`, required device extensions and required device features and uses that
information to prepare a list of `),I(m.$$.fragment),_=i(" that meet the stated requirements."),v=d("br"),R=i(`
These `),I(P.$$.fragment),A=i(" can be then be turned into "),I(T.$$.fragment),y=i(" at the request of the application."),B=d("br"),M=i(`
The Device Pool is instantiated automatically by `),I(O.$$.fragment),x=i(" and "),I(F.$$.fragment),V=i(".")},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"DevicePool"),N.forEach(l),n=f(k," class takes in information about the "),S(s.$$.fragment,k),a=f(k,", "),S(u.$$.fragment,k),p=f(k,`, required device extensions and required device features and uses that
information to prepare a list of `),S(m.$$.fragment,k),_=f(k," that meet the stated requirements."),v=g(k,"BR",{}),R=f(k,`
These `),S(P.$$.fragment,k),A=f(k," can be then be turned into "),S(T.$$.fragment,k),y=f(k," at the request of the application."),B=g(k,"BR",{}),M=f(k,`
The Device Pool is instantiated automatically by `),S(O.$$.fragment,k),x=f(k," and "),S(F.$$.fragment,k),V=f(k,".")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),D(m,k,N),h(k,_,N),h(k,v,N),h(k,R,N),D(P,k,N),h(k,A,N),D(T,k,N),h(k,y,N),h(k,B,N),h(k,M,N),D(O,k,N),h(k,x,N),D(F,k,N),h(k,V,N),q=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),m.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),P.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),T.$set(W);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),O.$set(U);const G={};N&1&&(G.$$scope={dirty:N,ctx:k}),F.$set(G)},i(k){q||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(m.$$.fragment,k),b(P.$$.fragment,k),b(T.$$.fragment,k),b(O.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(m.$$.fragment,k),w(P.$$.fragment,k),w(T.$$.fragment,k),w(O.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),C(m,k),k&&l(_),k&&l(v),k&&l(R),C(P,k),k&&l(A),C(T,k),k&&l(y),k&&l(B),k&&l(M),C(O,k),k&&l(x),C(F,k),k&&l(V)}}}class Ou extends ve{constructor(e){super(),Ee(this,e,null,Tu,be,{})}}function Vu(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yu(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Vu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Device Pool."),r=d("br"),$=i(`
        Initializes a list of `),I(n.$$.fragment),s=i(" that are supported for the purposes of the implementation."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Device Pool."),r=g(p,"BR",{}),$=f(p,`
        Initializes a list of `),S(n.$$.fragment,p),s=f(p," that are supported for the purposes of the implementation."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Mu(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fu(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xu(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nu(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uu(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gu(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hu(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qu(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wu(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qu(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie;return a=new fe({props:{href:je().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[Mu]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Fu]},$$scope:{ctx:c}}}),O=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[xu]},$$scope:{ctx:c}}}),F=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Nu]},$$scope:{ctx:c}}}),N=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Uu]},$$scope:{ctx:c}}}),te=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Gu]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[Hu]},$$scope:{ctx:c}}}),se=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[qu]},$$scope:{ctx:c}}}),Re=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[Wu]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pInstance"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" with which the "),I(p.$$.fragment),m=i(" should be enumerated."),_=j(),v=d("li"),R=d("code"),P=i("pWindow"),A=d("br"),T=i(`
            If not `),y=d("code"),B=i("nullptr"),M=i(", a pointer to the "),I(O.$$.fragment),x=i(` with which the support for presentation will be determined for the
            `),I(F.$$.fragment),V=i("."),q=d("br"),k=i(`
            Support for presentation- and graphics operations for the `),I(N.$$.fragment),Q=i(" will be ensured as well."),X=j(),Z=d("li"),K=d("code"),W=i("requiredDeviceFeatures"),U=d("br"),G=i(`
            The features a `),I(te.$$.fragment),ee=i(" should have for the purposes of the application."),ne=d("br"),le=i(`
            This should be a `),I(ae.$$.fragment),J=i("-structure where each required feature should be set to true."),ue=j(),De=d("li"),de=d("code"),me=i("requiredDeviceExtensions"),Ce=d("br"),_e=i(`
            The extensions a `),I(se.$$.fragment),ie=i(" should support for the purposes of the application."),ge=d("br"),we=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(Re.$$.fragment),Be=i("."),this.h()},l(re){e=g(re,"DIV",{slot:!0});var he=E(e);t=g(he,"LI",{});var Ae=E(t);r=g(Ae,"CODE",{});var Ve=E(r);$=f(Ve,"pInstance"),Ve.forEach(l),n=g(Ae,"BR",{}),s=f(Ae,`
            A pointer to the `),S(a.$$.fragment,Ae),u=f(Ae," with which the "),S(p.$$.fragment,Ae),m=f(Ae," should be enumerated."),Ae.forEach(l),_=Y(he),v=g(he,"LI",{});var oe=E(v);R=g(oe,"CODE",{});var ce=E(R);P=f(ce,"pWindow"),ce.forEach(l),A=g(oe,"BR",{}),T=f(oe,`
            If not `),y=g(oe,"CODE",{});var Pe=E(y);B=f(Pe,"nullptr"),Pe.forEach(l),M=f(oe,", a pointer to the "),S(O.$$.fragment,oe),x=f(oe,` with which the support for presentation will be determined for the
            `),S(F.$$.fragment,oe),V=f(oe,"."),q=g(oe,"BR",{}),k=f(oe,`
            Support for presentation- and graphics operations for the `),S(N.$$.fragment,oe),Q=f(oe," will be ensured as well."),oe.forEach(l),X=Y(he),Z=g(he,"LI",{});var Fe=E(Z);K=g(Fe,"CODE",{});var ke=E(K);W=f(ke,"requiredDeviceFeatures"),ke.forEach(l),U=g(Fe,"BR",{}),G=f(Fe,`
            The features a `),S(te.$$.fragment,Fe),ee=f(Fe," should have for the purposes of the application."),ne=g(Fe,"BR",{}),le=f(Fe,`
            This should be a `),S(ae.$$.fragment,Fe),J=f(Fe,"-structure where each required feature should be set to true."),Fe.forEach(l),ue=Y(he),De=g(he,"LI",{});var Te=E(De);de=g(Te,"CODE",{});var Me=E(de);me=f(Me,"requiredDeviceExtensions"),Me.forEach(l),Ce=g(Te,"BR",{}),_e=f(Te,`
            The extensions a `),S(se.$$.fragment,Te),ie=f(Te," should support for the purposes of the application."),ge=g(Te,"BR",{}),we=f(Te,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(Re.$$.fragment,Te),Be=f(Te,"."),Te.forEach(l),he.forEach(l),this.h()},h(){z(e,"slot","params")},m(re,he){h(re,e,he),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),o(v,y),o(y,B),o(v,M),D(O,v,null),o(v,x),D(F,v,null),o(v,V),o(v,q),o(v,k),D(N,v,null),o(v,Q),o(e,X),o(e,Z),o(Z,K),o(K,W),o(Z,U),o(Z,G),D(te,Z,null),o(Z,ee),o(Z,ne),o(Z,le),D(ae,Z,null),o(Z,J),o(e,ue),o(e,De),o(De,de),o(de,me),o(De,Ce),o(De,_e),D(se,De,null),o(De,ie),o(De,ge),o(De,we),D(Re,De,null),o(De,Be),Ie=!0},p(re,he){const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),a.$set(Ae);const Ve={};he&1&&(Ve.$$scope={dirty:he,ctx:re}),p.$set(Ve);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),O.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),F.$set(ce);const Pe={};he&1&&(Pe.$$scope={dirty:he,ctx:re}),N.$set(Pe);const Fe={};he&1&&(Fe.$$scope={dirty:he,ctx:re}),te.$set(Fe);const ke={};he&1&&(ke.$$scope={dirty:he,ctx:re}),ae.$set(ke);const Te={};he&1&&(Te.$$scope={dirty:he,ctx:re}),se.$set(Te);const Me={};he&1&&(Me.$$scope={dirty:he,ctx:re}),Re.$set(Me)},i(re){Ie||(b(a.$$.fragment,re),b(p.$$.fragment,re),b(O.$$.fragment,re),b(F.$$.fragment,re),b(N.$$.fragment,re),b(te.$$.fragment,re),b(ae.$$.fragment,re),b(se.$$.fragment,re),b(Re.$$.fragment,re),Ie=!0)},o(re){w(a.$$.fragment,re),w(p.$$.fragment,re),w(O.$$.fragment,re),w(F.$$.fragment,re),w(N.$$.fragment,re),w(te.$$.fragment,re),w(ae.$$.fragment,re),w(se.$$.fragment,re),w(Re.$$.fragment,re),Ie=!1},d(re){re&&l(e),C(a),C(p),C(O),C(F),C(N),C(te),C(ae),C(se),C(Re)}}}function Ku(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no devices with Vulkan support were found."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if no devices with Vulkan support were found."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function zu(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`DevicePool(
        Instance* pInstance, 
        Window* pWindow, 
        std::vector<const char*> requiredDeviceExtensions,
        VkPhysicalDeviceFeatures requiredDeviceFeatures
);`}}),r=new Se({props:{$$slots:{throws:[Ku],params:[Qu],details:[yu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ju extends ve{constructor(e){super(),Ee(this,e,null,zu,be,{})}}function Yu(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xu(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zu(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Yu]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.DEVICE_POOL_Constructor,$$slots:{default:[Xu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" that support the requirements given in the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the "),S(r.$$.fragment,p),$=f(p," that support the requirements given in the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ju(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ep(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Ju]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of all the "),I(r.$$.fragment),$=i(" that meet the requirements for the purposes of this implementation."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of all the "),S(r.$$.fragment,a),$=f(a," that meet the requirements for the purposes of this implementation."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<PhysicalDevice> getSupportedPhysicalDevices();"}}),r=new Se({props:{$$slots:{return:[ep],details:[Zu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rp extends ve{constructor(e){super(),Ee(this,e,null,tp,be,{})}}function np(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sp(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ap(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:je().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[np]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[sp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Select a "),I(r.$$.fragment),$=i(" by index to create a "),I(n.$$.fragment),s=i(` of.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Select a "),S(r.$$.fragment,p),$=f(p," by index to create a "),S(n.$$.fragment,p),s=f(p,` of.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function op(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lp(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[op]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i(`.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,`.
    `),a.forEach(l),this.h()},h(){z(e,"slot","returns")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ip(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fp(c){let e;return{c(){e=i("getCurrentDevice")},l(t){e=f(t,"getCurrentDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cp(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:"LogicalDevice* selectDevice(unsigned int deviceIndex = 0);"}}),r=new Se({props:{$$slots:{returns:[lp],details:[ap]},$$scope:{ctx:c}}}),s=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[ip]},$$scope:{ctx:c}}}),u=new fe({props:{href:je().URL.documentation+"#"+L.DEVICE_POOL_getCurrentDevice,$$slots:{default:[fp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
If a device is selected, a pointer to the `),I(s.$$.fragment),a=i(` can also be retrieved using
`),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=Y(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=f(_,`
If a device is selected, a pointer to the `),S(s.$$.fragment,_),a=f(_,` can also be retrieved using
`),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),s.$set(P);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),u.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class $p extends ve{constructor(e){super(),Ee(this,e,null,cp,be,{})}}function up(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pp(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mp(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[up]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.DEVICE_POOL_selectDevice,$$slots:{default:[pp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the currently selected "),I(r.$$.fragment),$=i(" (selected with "),I(n.$$.fragment),s=i(")"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the currently selected "),S(r.$$.fragment,p),$=f(p," (selected with "),S(n.$$.fragment,p),s=f(p,")"),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function hp(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dp(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[hp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the currently selected "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the currently selected "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"LogicalDevice* getCurrentDevice();"}}),r=new Se({props:{$$slots:{return:[dp],details:[mp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _p extends ve{constructor(e){super(),Ee(this,e,null,gp,be,{})}}function vp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ep(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ip(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return e=new $e({props:{language:pe,code:"#include <fillcan/instance/physical_device.hpp>"}}),s=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[vp]},$$scope:{ctx:c}}}),u=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Ep]},$$scope:{ctx:c}}}),B=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[bp]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[wp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Physical Device"),n=i(" class takes in a handle to a "),I(s.$$.fragment),a=i(", a pointer to the "),I(u.$$.fragment),p=i(" (or "),m=d("code"),_=i("nullptr"),v=i(`) and the required device features and extensions.
`),R=d("br"),P=i(`
With this information the `),A=d("code"),T=i("Physical Device"),y=i(` class acts as a wrapper
around the `),I(B.$$.fragment),M=i(" for requesting information about the Physical Device and it's capabilities."),O=d("br"),x=i(`
A `),I(F.$$.fragment),V=i(` usually represents a single piece of hardware or a collection of hardware that
is interconnected. There is a fixed, finite number of physical devices in any system,
unless that system supports reconfiguration, such as hot-plugging. Hot plugging is
the addition of a part to a running computer system without significant interruption
of system operation.`)},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Physical Device"),N.forEach(l),n=f(k," class takes in a handle to a "),S(s.$$.fragment,k),a=f(k,", a pointer to the "),S(u.$$.fragment,k),p=f(k," (or "),m=g(k,"CODE",{});var Q=E(m);_=f(Q,"nullptr"),Q.forEach(l),v=f(k,`) and the required device features and extensions.
`),R=g(k,"BR",{}),P=f(k,`
With this information the `),A=g(k,"CODE",{});var X=E(A);T=f(X,"Physical Device"),X.forEach(l),y=f(k,` class acts as a wrapper
around the `),S(B.$$.fragment,k),M=f(k," for requesting information about the Physical Device and it's capabilities."),O=g(k,"BR",{}),x=f(k,`
A `),S(F.$$.fragment,k),V=f(k,` usually represents a single piece of hardware or a collection of hardware that
is interconnected. There is a fixed, finite number of physical devices in any system,
unless that system supports reconfiguration, such as hot-plugging. Hot plugging is
the addition of a part to a running computer system without significant interruption
of system operation.`)},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),o(m,_),h(k,v,N),h(k,R,N),h(k,P,N),h(k,A,N),o(A,T),h(k,y,N),D(B,k,N),h(k,M,N),h(k,O,N),h(k,x,N),D(F,k,N),h(k,V,N),q=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),B.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),F.$set(K)},i(k){q||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(B.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(B.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(v),k&&l(R),k&&l(P),k&&l(A),k&&l(y),C(B,k),k&&l(M),k&&l(O),k&&l(x),C(F,k),k&&l(V)}}}class Dp extends ve{constructor(e){super(),Ee(this,e,null,Ip,be,{})}}function Cp(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sp(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Cp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Physical Device."),r=d("br"),$=i(`
        Finds the queue family indices of the applicable `),I(n.$$.fragment),s=i(" (graphics, presentation and computation)."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Physical Device."),r=g(p,"BR",{}),$=f(p,`
        Finds the queue family indices of the applicable `),S(n.$$.fragment,p),s=f(p," (graphics, presentation and computation)."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Rp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ap(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pp(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bp(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lp(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kp(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[Rp]},$$scope:{ctx:c}}}),B=new fe({props:{href:je().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Ap]},$$scope:{ctx:c}}}),F=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Pp]},$$scope:{ctx:c}}}),U=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[Bp]},$$scope:{ctx:c}}}),de=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[Lp]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("hPhysicalDevice"),n=d("br"),s=i(`
            A handle to the `),I(a.$$.fragment),u=i(" to wrap."),p=j(),m=d("li"),_=d("code"),v=i("pWindow"),R=d("br"),P=i(`
            If not `),A=d("code"),T=i("nullptr"),y=i(", a pointer to the "),I(B.$$.fragment),M=i(` with which the support for presentation can be determined and other
            surface related capabilities.`),O=d("br"),x=i(`
            The queue family index for the graphics- and presentation `),I(F.$$.fragment),V=i(" will be looked for aswell."),q=j(),k=d("li"),N=d("code"),Q=i("requiredDeviceFeatures"),X=d("br"),Z=i(`
            The features the Physical Device should have for the purposes of the
            application.`),K=d("br"),W=i(`
            This should be a `),I(U.$$.fragment),G=i("-structure where each required feature should be set to true."),te=j(),ee=d("li"),ne=d("code"),le=i("requiredDeviceExtensions"),ae=d("br"),J=i(`
            The extensions the Physical Device should support for the purposes of
            the application.`),ue=d("br"),De=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(de.$$.fragment),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var se=E(e);t=g(se,"LI",{});var ie=E(t);r=g(ie,"CODE",{});var ge=E(r);$=f(ge,"hPhysicalDevice"),ge.forEach(l),n=g(ie,"BR",{}),s=f(ie,`
            A handle to the `),S(a.$$.fragment,ie),u=f(ie," to wrap."),ie.forEach(l),p=Y(se),m=g(se,"LI",{});var we=E(m);_=g(we,"CODE",{});var Re=E(_);v=f(Re,"pWindow"),Re.forEach(l),R=g(we,"BR",{}),P=f(we,`
            If not `),A=g(we,"CODE",{});var Be=E(A);T=f(Be,"nullptr"),Be.forEach(l),y=f(we,", a pointer to the "),S(B.$$.fragment,we),M=f(we,` with which the support for presentation can be determined and other
            surface related capabilities.`),O=g(we,"BR",{}),x=f(we,`
            The queue family index for the graphics- and presentation `),S(F.$$.fragment,we),V=f(we," will be looked for aswell."),we.forEach(l),q=Y(se),k=g(se,"LI",{});var Ie=E(k);N=g(Ie,"CODE",{});var re=E(N);Q=f(re,"requiredDeviceFeatures"),re.forEach(l),X=g(Ie,"BR",{}),Z=f(Ie,`
            The features the Physical Device should have for the purposes of the
            application.`),K=g(Ie,"BR",{}),W=f(Ie,`
            This should be a `),S(U.$$.fragment,Ie),G=f(Ie,"-structure where each required feature should be set to true."),Ie.forEach(l),te=Y(se),ee=g(se,"LI",{});var he=E(ee);ne=g(he,"CODE",{});var Ae=E(ne);le=f(Ae,"requiredDeviceExtensions"),Ae.forEach(l),ae=g(he,"BR",{}),J=f(he,`
            The extensions the Physical Device should support for the purposes of
            the application.`),ue=g(he,"BR",{}),De=f(he,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(de.$$.fragment,he),me=f(he,"."),he.forEach(l),se.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,se){h(_e,e,se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(m,A),o(A,T),o(m,y),D(B,m,null),o(m,M),o(m,O),o(m,x),D(F,m,null),o(m,V),o(e,q),o(e,k),o(k,N),o(N,Q),o(k,X),o(k,Z),o(k,K),o(k,W),D(U,k,null),o(k,G),o(e,te),o(e,ee),o(ee,ne),o(ne,le),o(ee,ae),o(ee,J),o(ee,ue),o(ee,De),D(de,ee,null),o(ee,me),Ce=!0},p(_e,se){const ie={};se&1&&(ie.$$scope={dirty:se,ctx:_e}),a.$set(ie);const ge={};se&1&&(ge.$$scope={dirty:se,ctx:_e}),B.$set(ge);const we={};se&1&&(we.$$scope={dirty:se,ctx:_e}),F.$set(we);const Re={};se&1&&(Re.$$scope={dirty:se,ctx:_e}),U.$set(Re);const Be={};se&1&&(Be.$$scope={dirty:se,ctx:_e}),de.$set(Be)},i(_e){Ce||(b(a.$$.fragment,_e),b(B.$$.fragment,_e),b(F.$$.fragment,_e),b(U.$$.fragment,_e),b(de.$$.fragment,_e),Ce=!0)},o(_e){w(a.$$.fragment,_e),w(B.$$.fragment,_e),w(F.$$.fragment,_e),w(U.$$.fragment,_e),w(de.$$.fragment,_e),Ce=!1},d(_e){_e&&l(e),C(a),C(B),C(F),C(U),C(de)}}}function Tp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`PhysicalDevice(
        VkPhysicalDevice hPhysicalDevice, 
        Window* pWindow, 
        std::vector<const char*> requiredExtensions,
        VkPhysicalDeviceFeatures requiredFeatures = {}
);`}}),r=new Se({props:{$$slots:{params:[kp],details:[Sp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Op extends ve{constructor(e){super(),Ee(this,e,null,Tp,be,{})}}function Vp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yp(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[Vp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Mp(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fp(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[Mp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function xp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPhysicalDevice getPhysicalDeviceHandle() const;"}}),r=new Se({props:{$$slots:{return:[Fp],details:[yp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Np extends ve{constructor(e){super(),Ee(this,e,null,xp,be,{})}}function Up(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gp(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[Up]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the device extensions (given in the "),I(r.$$.fragment),$=i(") this Physical Device should support."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the device extensions (given in the "),S(r.$$.fragment,a),$=f(a,") this Physical Device should support."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Hp(c){let e,t;return{c(){e=d("span"),t=i("A list of the required device extensions."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required device extensions."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function qp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<const char*>& getRequiredExtensions() const;"}}),r=new Se({props:{$$slots:{return:[Hp],details:[Gp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Wp extends ve{constructor(e){super(),Ee(this,e,null,qp,be,{})}}function Qp(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kp(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[Qp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Whether the device extensions given in the "),I(r.$$.fragment),$=i(" are supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Whether the device extensions given in the "),S(r.$$.fragment,a),$=f(a," are supported."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zp(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the device extensions are supported.
        `),n=d("code"),s=i("false"),a=i(" if the device extensions aren't supported."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the device extensions are supported.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the device extensions aren't supported."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function jp(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool areExtensionsSupported();"}}),r=new Se({props:{$$slots:{return:[zp],details:[Kp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Yp extends ve{constructor(e){super(),Ee(this,e,null,jp,be,{})}}const{window:Xp}=lo;function Ya(c,e,t){const r=c.slice();return r[8]=e[t],r[9]=e,r[10]=t,r}function Xa(c){let e,t="<",r;return{c(){e=d("span"),r=i(t),this.h()},l($){e=g($,"SPAN",{class:!0});var n=E(e);r=f(n,t),n.forEach(l),this.h()},h(){z(e,"class","visible-reference-indicator svelte-1vakv9t")},m($,n){h($,e,n),o(e,r)},d($){$&&l(e)}}}function Za(c){let e,t,r=c[8].label+"",$,n,s,a=c[10],u,p,m,_,v=c[2]!==null&&c[8].id===c[2].id&&Xa();const R=()=>c[6](t,a),P=()=>c[6](null,a);return{c(){e=d("li"),t=d("a"),$=i(r),n=j(),v&&v.c(),u=j(),this.h()},l(A){e=g(A,"LI",{class:!0});var T=E(e);t=g(T,"A",{href:!0,class:!0});var y=E(t);$=f(y,r),n=Y(y),v&&v.l(y),y.forEach(l),u=Y(T),T.forEach(l),this.h()},h(){z(t,"href",s=Ts+"/documentation#"+c[8].id),z(t,"class","svelte-1vakv9t"),z(e,"class",p="reference-item h"+c[8].heading+" "+(c[2]!==null&&c[8].id===c[2].id?"active":"")+" svelte-1vakv9t")},m(A,T){h(A,e,T),o(e,t),o(t,$),o(t,n),v&&v.m(t,null),R(),o(e,u),m||(_=Vs(t,"click",c[4]),m=!0)},p(A,T){c=A,T&1&&r!==(r=c[8].label+"")&&$s($,r),c[2]!==null&&c[8].id===c[2].id?v||(v=Xa(),v.c(),v.m(t,null)):v&&(v.d(1),v=null),T&1&&s!==(s=Ts+"/documentation#"+c[8].id)&&z(t,"href",s),a!==c[10]&&(P(),a=c[10],R()),T&5&&p!==(p="reference-item h"+c[8].heading+" "+(c[2]!==null&&c[8].id===c[2].id?"active":"")+" svelte-1vakv9t")&&z(e,"class",p)},d(A){A&&l(e),v&&v.d(),P(),m=!1,_()}}}function Zp(c){let e,t,r,$=c[0],n=[];for(let s=0;s<$.length;s+=1)n[s]=Za(Ya(c,$,s));return{c(){e=d("ul");for(let s=0;s<n.length;s+=1)n[s].c();this.h()},l(s){e=g(s,"UL",{class:!0});var a=E(e);for(let u=0;u<n.length;u+=1)n[u].l(a);a.forEach(l),this.h()},h(){z(e,"class","references-list svelte-1vakv9t")},m(s,a){h(s,e,a);for(let u=0;u<n.length;u+=1)n[u].m(e,null);t||(r=Vs(Xp,"scroll",c[3]),t=!0)},p(s,[a]){if(a&23){$=s[0];let u;for(u=0;u<$.length;u+=1){const p=Ya(s,$,u);n[u]?n[u].p(p,a):(n[u]=Za(p),n[u].c(),n[u].m(e,null))}for(;u<n.length;u+=1)n[u].d(1);n.length=$.length}},i:Oe,o:Oe,d(s){s&&l(e),io(n,s),t=!1,r()}}}function Jp(c){c.getBoundingClientRect().bottom>window.innerHeight&&c.scrollIntoView(!1),c.getBoundingClientRect().top<100&&c.scrollIntoView()}function em(c,e,t){let{sections:r}=e,{onReferenceClick:$=()=>{}}=e,n=null,s=[],a=null;function u(){a!==null&&Jp(a)}function p(_){$()}function m(_,v){Us[_?"unshift":"push"](()=>{s[v]=_,t(1,s)})}return c.$$set=_=>{"sections"in _&&t(0,r=_.sections),"onReferenceClick"in _&&t(5,$=_.onReferenceClick)},c.$$.update=()=>{if(c.$$.dirty&3){for(let _=0;_<r.length;_++)if(r[_].visible){t(2,n=r[_]),a=s[_];break}}},[r,s,n,u,p,$,m]}class Eo extends ve{constructor(e){super(),Ee(this,e,em,Zp,be,{sections:0,onReferenceClick:5})}}function tm(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rm(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[tm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the device features (given in the "),I(r.$$.fragment),$=i(") this Physical Device should support."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the device features (given in the "),S(r.$$.fragment,a),$=f(a,") this Physical Device should support."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function nm(c){let e,t;return{c(){e=d("span"),t=i("A list of the required device features."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required device features."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function sm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPhysicalDeviceFeatures& getRequiredFeatures() const;"}}),r=new Se({props:{$$slots:{return:[nm],details:[rm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class am extends ve{constructor(e){super(),Ee(this,e,null,sm,be,{})}}function om(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lm(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[om]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Whether the device features given in the "),I(r.$$.fragment),$=i(" are supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Whether the device features given in the "),S(r.$$.fragment,a),$=f(a," are supported."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function im(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the device features are supported.
        `),n=d("code"),s=i("false"),a=i(" if the device features aren't supported."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the device features are supported.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the device features aren't supported."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function fm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool areFeaturesSupported();"}}),r=new Se({props:{$$slots:{return:[im],details:[lm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class cm extends ve{constructor(e){super(),Ee(this,e,null,fm,be,{})}}function $m(c){let e,t;return{c(){e=d("span"),t=i("Query all supported and unsupported features for this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query all supported and unsupported features for this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function um(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pm(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[um]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying which features are and aren't supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,"-structure specifying which features are and aren't supported."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPhysicalDeviceFeatures getFeatures() const;"}}),r=new Se({props:{$$slots:{return:[pm],details:[$m]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hm extends ve{constructor(e){super(),Ee(this,e,null,mm,be,{})}}function dm(c){let e,t;return{c(){e=d("span"),t=i("Query all properties of this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query all properties of this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function gm(c){let e;return{c(){e=i("VkPhysicalDeviceProperties")},l(t){e=f(t,"VkPhysicalDeviceProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _m(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html",target:"_blank",$$slots:{default:[gm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying the properties of this Physical Device."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,"-structure specifying the properties of this Physical Device."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPhysicalDeviceProperties getProperties() const;"}}),r=new Se({props:{$$slots:{return:[_m],details:[dm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Em extends ve{constructor(e){super(),Ee(this,e,null,vm,be,{})}}function bm(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wm(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Im(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.WINDOW,$$slots:{default:[bm]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[wm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the basic capabilities of the "),I(r.$$.fragment),$=i(" surface, needed in order to create a "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the basic capabilities of the "),S(r.$$.fragment,p),$=f(p," surface, needed in order to create a "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Dm(c){let e;return{c(){e=i("VkSurfaceCapabilitiesKHR")},l(t){e=f(t,"VkSurfaceCapabilitiesKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cm(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sm(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html",target:"_blank",$$slots:{default:[Dm]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Cm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying the basic capabilities of the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p,"-structure specifying the basic capabilities of the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Rm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkSurfaceCapabilitiesKHR getSurfaceCapabilitiesKHR() const;"}}),r=new Se({props:{$$slots:{return:[Sm],details:[Im]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Am extends ve{constructor(e){super(),Ee(this,e,null,Rm,be,{})}}function Pm(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bm(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lm(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Pm]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Bm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the supported "),I(r.$$.fragment),$=i(" format with colorspace pairs for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the supported "),S(r.$$.fragment,p),$=f(p," format with colorspace pairs for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function km(c){let e;return{c(){e=i("VkSurfaceFormatKHR")},l(t){e=f(t,"VkSurfaceFormatKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tm(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Om(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html",target:"_blank",$$slots:{default:[km]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Tm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i(`-structures specifying the supported format with colorspace pairs for
        the `),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,`-structures specifying the supported format with colorspace pairs for
        the `),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Vm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkSurfaceFormatKHR> getSurfaceFormatsKHR() const;"}}),r=new Se({props:{$$slots:{return:[Om],details:[Lm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ym extends ve{constructor(e){super(),Ee(this,e,null,Vm,be,{})}}function Mm(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fm(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xm(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Mm]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Fm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the supported "),I(r.$$.fragment),$=i(" presentation modes for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the supported "),S(r.$$.fragment,p),$=f(p," presentation modes for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Nm(c){let e;return{c(){e=i("VkPresentMode")},l(t){e=f(t,"VkPresentMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Um(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gm(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[Nm]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Um]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures specifying the supported presentation modes for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,"-structures specifying the supported presentation modes for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Hm(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkPresentModeKHR> getSurfacePresentModesKHR() const;"}}),r=new Se({props:{$$slots:{return:[Gm],details:[xm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qm extends ve{constructor(e){super(),Ee(this,e,null,Hm,be,{})}}function Wm(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qm(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Wm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the properties of the "),I(r.$$.fragment),$=i(" available on this Physical Device. >."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Query the properties of the "),S(r.$$.fragment,a),$=f(a," available on this Physical Device. >."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Km(c){let e;return{c(){e=i("VkQueueFamilyProperties")},l(t){e=f(t,"VkQueueFamilyProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zm(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jm(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html",target:"_blank",$$slots:{default:[Km]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.QUEUE,$$slots:{default:[zm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures specifying the properties of the "),I(n.$$.fragment),s=i(" available on this Physical Device."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,"-structures specifying the properties of the "),S(n.$$.fragment,p),s=f(p," available on this Physical Device."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ym(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkQueueFamilyProperties> getQueueFamilyProperties() const;"}}),r=new Se({props:{$$slots:{return:[jm],details:[Qm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Xm extends ve{constructor(e){super(),Ee(this,e,null,Ym,be,{})}}function Zm(c){let e,t;return{c(){e=d("span"),t=i("Query the properties of a given format for this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query the properties of a given format for this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Jm(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            The format of which to query it's properties for this Physical Device.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"format"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The format of which to query it's properties for this Physical Device.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function eh(c){let e;return{c(){e=i("VkFormatProperties")},l(t){e=f(t,"VkFormatProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function th(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html",target:"_blank",$$slots:{default:[eh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure specifying the properties of the given format for this
        Physical Device.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-structure specifying the properties of the given format for this
        Physical Device.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rh(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkFormatProperties getFormatProperties(VkFormat format) const;"}}),r=new Se({props:{$$slots:{return:[th],params:[Jm],details:[Zm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nh extends ve{constructor(e){super(),Ee(this,e,null,rh,be,{})}}function sh(c){let e,t;return{c(){e=d("span"),t=i(`Find a format from a list of given formats which supports the given
        tiling and features.
    `),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Find a format from a list of given formats which supports the given
        tiling and features.
    `),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function ah(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oh(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lh(c){let e;return{c(){e=i("VkFormatFeatureFlagBits")},l(t){e=f(t,"VkFormatFeatureFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ih(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fh(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X;return R=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ah]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[oh]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html",target:"_blank",$$slots:{default:[lh]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.BUFFER,$$slots:{default:[ih]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("formats"),n=d("br"),s=i(`
            The formats to query support for.`),a=j(),u=d("li"),p=d("code"),m=i("tiling"),_=d("br"),v=i(`
            The tiling arrangement of data in an `),I(R.$$.fragment),P=i(" which the format should support. This should be a member of the "),I(A.$$.fragment),T=i(" enumeration."),y=j(),B=d("li"),M=d("code"),O=i("features"),x=d("br"),F=i(`
            A bitmask of `),I(V.$$.fragment),q=i(" specifying the features supported by a "),I(k.$$.fragment),N=i(" this format should support."),Q=j(),this.h()},l(Z){e=g(Z,"DIV",{slot:!0});var K=E(e);t=g(K,"LI",{});var W=E(t);r=g(W,"CODE",{});var U=E(r);$=f(U,"formats"),U.forEach(l),n=g(W,"BR",{}),s=f(W,`
            The formats to query support for.`),W.forEach(l),a=Y(K),u=g(K,"LI",{});var G=E(u);p=g(G,"CODE",{});var te=E(p);m=f(te,"tiling"),te.forEach(l),_=g(G,"BR",{}),v=f(G,`
            The tiling arrangement of data in an `),S(R.$$.fragment,G),P=f(G," which the format should support. This should be a member of the "),S(A.$$.fragment,G),T=f(G," enumeration."),G.forEach(l),y=Y(K),B=g(K,"LI",{});var ee=E(B);M=g(ee,"CODE",{});var ne=E(M);O=f(ne,"features"),ne.forEach(l),x=g(ee,"BR",{}),F=f(ee,`
            A bitmask of `),S(V.$$.fragment,ee),q=f(ee," specifying the features supported by a "),S(k.$$.fragment,ee),N=f(ee," this format should support."),ee.forEach(l),Q=Y(K),K.forEach(l),this.h()},h(){z(e,"slot","params")},m(Z,K){h(Z,e,K),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),D(A,u,null),o(u,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),o(e,Q),X=!0},p(Z,K){const W={};K&1&&(W.$$scope={dirty:K,ctx:Z}),R.$set(W);const U={};K&1&&(U.$$scope={dirty:K,ctx:Z}),A.$set(U);const G={};K&1&&(G.$$scope={dirty:K,ctx:Z}),V.$set(G);const te={};K&1&&(te.$$scope={dirty:K,ctx:Z}),k.$set(te)},i(Z){X||(b(R.$$.fragment,Z),b(A.$$.fragment,Z),b(V.$$.fragment,Z),b(k.$$.fragment,Z),X=!0)},o(Z){w(R.$$.fragment,Z),w(A.$$.fragment,Z),w(V.$$.fragment,Z),w(k.$$.fragment,Z),X=!1},d(Z){Z&&l(e),C(R),C(A),C(V),C(k)}}}function ch(c){let e;return{c(){e=i("std::nullopt")},l(t){e=f(t,"std::nullopt")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $h(c){let e,t,r,$,n;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/optional/nullopt",target:"_blank",$$slots:{default:[ch]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`An optional value of the first format in the list of given formats that
        supports the given tiling and features or `),I(r.$$.fragment),$=i(` if none of the given formats supports the given tiling and features.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`An optional value of the first format in the list of given formats that
        supports the given tiling and features or `),S(r.$$.fragment,a),$=f(a,` if none of the given formats supports the given tiling and features.
    `),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function uh(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:`const std::optional<VkFormat> findSupportedFormat(
        std::vector<VkFormat> formats, 
        VkImageTiling tiling, 
        VkFormatFeatureFlags features
) const;`}}),r=new Se({props:{$$slots:{return:[$h],params:[fh],details:[sh]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`std::vector<VkFormat> formats = { VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT };
VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
VkFormatFeatureFlags features = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;

std::optional<VkFormat> optFormat = fillcan.getCurrentDevice()->getPhysicalDevice()->findSupportedFormat(
    formats, tiling, features
);

if (!optFormat.has_value()) {
    throw std::runtime_error("Failed to find a supported format");
}

VkFormat supportedFormat = optFormat.value();`}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class ph extends ve{constructor(e){super(),Ee(this,e,null,uh,be,{})}}function mh(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hh(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[mh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the graphics "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the graphics "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function dh(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the graphics Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the graphics Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function gh(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<unsigned int>& getGraphicsQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[dh],details:[hh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _h extends ve{constructor(e){super(),Ee(this,e,null,gh,be,{})}}function vh(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eh(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[vh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the present "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the present "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bh(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the present Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the present Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function wh(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<unsigned int>& getPresentQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[bh],details:[Eh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ih extends ve{constructor(e){super(),Ee(this,e,null,wh,be,{})}}function Dh(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ch(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Dh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the compute "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the compute "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Sh(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the compute Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the compute Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Rh(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<unsigned int>& getComputeQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[Sh],details:[Ch]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ah extends ve{constructor(e){super(),Ee(this,e,null,Rh,be,{})}}function Ph(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bh(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lh(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kh(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Th(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oh(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vh(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yh(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return e=new $e({props:{language:pe,code:"#include <fillcan/instance/logical_device.hpp>"}}),s=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Ph]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Bh]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Lh]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[kh]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Th]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Oh]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Vh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Logical Device"),n=i(" class takes in a pointer to the "),I(s.$$.fragment),a=i(" to construct around. It uses the "),I(u.$$.fragment),p=i(" to construct the graphics, presentation and computation "),I(m.$$.fragment),_=i(" if available."),v=d("br"),R=i(`
The Logical Device is the software construction around a `),I(P.$$.fragment),A=i(`. A Logical Device represents a reservation of resources associated with a
particular `),I(T.$$.fragment),y=i(". This includes a possible subset of the available "),I(B.$$.fragment),M=i(" on the "),I(O.$$.fragment),x=i(`, and it is the Logical Device that the application will communicate with most
of the time.`)},l(V){S(e.$$.fragment,V),t=f(V,`
The `),r=g(V,"CODE",{});var q=E(r);$=f(q,"Logical Device"),q.forEach(l),n=f(V," class takes in a pointer to the "),S(s.$$.fragment,V),a=f(V," to construct around. It uses the "),S(u.$$.fragment,V),p=f(V," to construct the graphics, presentation and computation "),S(m.$$.fragment,V),_=f(V," if available."),v=g(V,"BR",{}),R=f(V,`
The Logical Device is the software construction around a `),S(P.$$.fragment,V),A=f(V,`. A Logical Device represents a reservation of resources associated with a
particular `),S(T.$$.fragment,V),y=f(V,". This includes a possible subset of the available "),S(B.$$.fragment,V),M=f(V," on the "),S(O.$$.fragment,V),x=f(V,`, and it is the Logical Device that the application will communicate with most
of the time.`)},m(V,q){D(e,V,q),h(V,t,q),h(V,r,q),o(r,$),h(V,n,q),D(s,V,q),h(V,a,q),D(u,V,q),h(V,p,q),D(m,V,q),h(V,_,q),h(V,v,q),h(V,R,q),D(P,V,q),h(V,A,q),D(T,V,q),h(V,y,q),D(B,V,q),h(V,M,q),D(O,V,q),h(V,x,q),F=!0},p(V,[q]){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),s.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),u.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),m.$set(Q);const X={};q&1&&(X.$$scope={dirty:q,ctx:V}),P.$set(X);const Z={};q&1&&(Z.$$scope={dirty:q,ctx:V}),T.$set(Z);const K={};q&1&&(K.$$scope={dirty:q,ctx:V}),B.$set(K);const W={};q&1&&(W.$$scope={dirty:q,ctx:V}),O.$set(W)},i(V){F||(b(e.$$.fragment,V),b(s.$$.fragment,V),b(u.$$.fragment,V),b(m.$$.fragment,V),b(P.$$.fragment,V),b(T.$$.fragment,V),b(B.$$.fragment,V),b(O.$$.fragment,V),F=!0)},o(V){w(e.$$.fragment,V),w(s.$$.fragment,V),w(u.$$.fragment,V),w(m.$$.fragment,V),w(P.$$.fragment,V),w(T.$$.fragment,V),w(B.$$.fragment,V),w(O.$$.fragment,V),F=!1},d(V){C(e,V),V&&l(t),V&&l(r),V&&l(n),C(s,V),V&&l(a),C(u,V),V&&l(p),C(m,V),V&&l(_),V&&l(v),V&&l(R),C(P,V),V&&l(A),C(T,V),V&&l(y),C(B,V),V&&l(M),C(O,V),V&&l(x)}}}class Mh extends ve{constructor(e){super(),Ee(this,e,null,yh,be,{})}}function Fh(c){let e,t;return{c(){e=d("span"),t=i("Create a new Logical Device. "),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Logical Device. "),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function xh(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nh(c){let e,t,r,$,n,s,a,u,p,m;return a=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[xh]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pPhysicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to create a Logical Device from."),p=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"pPhysicalDevice"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," to create a Logical Device from."),R.forEach(l),p=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),a.$set(R)},i(_){m||(b(a.$$.fragment,_),m=!0)},o(_){w(a.$$.fragment,_),m=!1},d(_){_&&l(e),C(a)}}}function Uh(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gh(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hh(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[Uh]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Gh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        throws `),p=d("code"),m=i("std::runtime_error"),_=i(" aswell if no "),I(v.$$.fragment),R=i(` were found.
    `),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=g(T,"CODE",{});var y=E(t);r=f(y,"std::runtime_error"),y.forEach(l),$=f(T," if the "),S(n.$$.fragment,T),s=f(T," couldn't be created."),a=g(T,"BR",{}),u=f(T,`
        throws `),p=g(T,"CODE",{});var B=E(p);m=f(B,"std::runtime_error"),B.forEach(l),_=f(T," aswell if no "),S(v.$$.fragment,T),R=f(T,` were found.
    `),T.forEach(l),this.h()},h(){z(e,"slot","throws")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,R),P=!0},p(A,T){const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),n.$set(y);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),v.$set(B)},i(A){P||(b(n.$$.fragment,A),b(v.$$.fragment,A),P=!0)},o(A){w(n.$$.fragment,A),w(v.$$.fragment,A),P=!1},d(A){A&&l(e),C(n),C(v)}}}function qh(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wh(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qh(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kh(c){let e,t,r,$,n,s,a,u,p,m,_,v;return e=new $e({props:{language:pe,code:"LogicalDevice(PhysicalDevice* pPhysicalDevice);"}}),r=new Se({props:{$$slots:{throws:[Hh],params:[Nh],details:[Fh]},$$scope:{ctx:c}}}),s=new H({props:{sectionID:L.FILLCAN,$$slots:{default:[qh]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.FILLCAN_GRAPHICS,$$slots:{default:[Wh]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.FILLCAN_selectDevice,$$slots:{default:[Qh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
The Logical Device can be retrieved using the `),I(s.$$.fragment),a=i(" or "),I(u.$$.fragment),p=i(` API by calling
`),I(m.$$.fragment),_=i(` instead
of manually calling this Constructor.`)},l(R){S(e.$$.fragment,R),t=Y(R),S(r.$$.fragment,R),$=g(R,"BR",{}),n=f(R,`
The Logical Device can be retrieved using the `),S(s.$$.fragment,R),a=f(R," or "),S(u.$$.fragment,R),p=f(R,` API by calling
`),S(m.$$.fragment,R),_=f(R,` instead
of manually calling this Constructor.`)},m(R,P){D(e,R,P),h(R,t,P),D(r,R,P),h(R,$,P),h(R,n,P),D(s,R,P),h(R,a,P),D(u,R,P),h(R,p,P),D(m,R,P),h(R,_,P),v=!0},p(R,[P]){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),r.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),s.$set(T);const y={};P&1&&(y.$$scope={dirty:P,ctx:R}),u.$set(y);const B={};P&1&&(B.$$scope={dirty:P,ctx:R}),m.$set(B)},i(R){v||(b(e.$$.fragment,R),b(r.$$.fragment,R),b(s.$$.fragment,R),b(u.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(e.$$.fragment,R),w(r.$$.fragment,R),w(s.$$.fragment,R),w(u.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){C(e,R),R&&l(t),C(r,R),R&&l($),R&&l(n),C(s,R),R&&l(a),C(u,R),R&&l(p),C(m,R),R&&l(_)}}}class zh extends ve{constructor(e){super(),Ee(this,e,null,Kh,be,{})}}function jh(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yh(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[jh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Xh(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zh(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[Xh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Jh(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkDevice getLogicalDeviceHandle() const;"}}),r=new Se({props:{$$slots:{return:[Zh],details:[Yh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ed extends ve{constructor(e){super(),Ee(this,e,null,Jh,be,{})}}function td(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rd(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[td]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the "),I(r.$$.fragment),$=i(" this Logical Device is constructed around."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the "),S(r.$$.fragment,a),$=f(a," this Logical Device is constructed around."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function nd(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sd(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[nd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" this Logical Device is constructed around."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," this Logical Device is constructed around."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ad(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const PhysicalDevice* getPhysicalDevice() const;"}}),r=new Se({props:{$$slots:{return:[sd],details:[rd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class od extends ve{constructor(e){super(),Ee(this,e,null,ad,be,{})}}function ld(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function id(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fd(c){let e,t,r,$,n,s,a,u,p;return n=new H({props:{sectionID:L.QUEUE,$$slots:{default:[ld]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.QUEUE,$$slots:{default:[id]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the Logical Device to become idle."),r=d("br"),$=i(`
        Waits on the host for the completion of ongoing `),I(n.$$.fragment),s=i(` operations for all
        `),I(a.$$.fragment),u=i(` on this Logical
        Device.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Wait for the Logical Device to become idle."),r=g(_,"BR",{}),$=f(_,`
        Waits on the host for the completion of ongoing `),S(n.$$.fragment,_),s=f(_,` operations for all
        `),S(a.$$.fragment,_),u=f(_,` on this Logical
        Device.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function cd(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void waitIdle();"}}),r=new Se({props:{$$slots:{details:[fd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $d extends ve{constructor(e){super(),Ee(this,e,null,cd,be,{})}}function ud(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pd(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[ud]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the graphics "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the graphics "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function md(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dd(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[md]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.QUEUE,$$slots:{default:[hd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the graphics "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the graphics "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function gd(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Queue* getGraphicsQueue();"}}),r=new Se({props:{$$slots:{return:[dd],details:[pd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _d extends ve{constructor(e){super(),Ee(this,e,null,gd,be,{})}}function vd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ed(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[vd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the compute "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the compute "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Id(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[bd]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.QUEUE,$$slots:{default:[wd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the compute "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the compute "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function Dd(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Queue* getComputeQueue();"}}),r=new Se({props:{$$slots:{return:[Id],details:[Ed]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cd extends ve{constructor(e){super(),Ee(this,e,null,Dd,be,{})}}function Sd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rd(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Sd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the present "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the present "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ad(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bd(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Ad]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Pd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the present "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the present "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function Ld(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Queue* getPresentQueue();"}}),r=new Se({props:{$$slots:{return:[Bd],details:[Rd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kd extends ve{constructor(e){super(),Ee(this,e,null,Ld,be,{})}}function Td(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Od(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Md(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xd(c){let e;return{c(){e=i("endSingleTimeRecording")},l(t){e=f(t,"endSingleTimeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nd(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return r=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Td]},$$scope:{ctx:c}}}),n=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Od]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Vd]},$$scope:{ctx:c}}}),_=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[yd]},$$scope:{ctx:c}}}),R=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_BUFFER,$$slots:{default:[Md]},$$scope:{ctx:c}}}),A=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_BUFFER,$$slots:{default:[Fd]},$$scope:{ctx:c}}}),y=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE_endSingleTimeCommandRecording,$$slots:{default:[xd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Start a "),I(r.$$.fragment),$=i(" with a given "),I(n.$$.fragment),s=i("."),a=d("br"),u=i(`
        Creates a `),I(p.$$.fragment),m=i(" using the given Queue pointer. This "),I(_.$$.fragment),v=i(" will contain 1 (one) Primary "),I(R.$$.fragment),P=i(" and 0 (zero) Secondary "),I(A.$$.fragment),T=i(". To end the recording, call "),I(y.$$.fragment),B=i("."),this.h()},l(O){e=g(O,"SPAN",{slot:!0});var x=E(e);t=f(x,"Start a "),S(r.$$.fragment,x),$=f(x," with a given "),S(n.$$.fragment,x),s=f(x,"."),a=g(x,"BR",{}),u=f(x,`
        Creates a `),S(p.$$.fragment,x),m=f(x," using the given Queue pointer. This "),S(_.$$.fragment,x),v=f(x," will contain 1 (one) Primary "),S(R.$$.fragment,x),P=f(x," and 0 (zero) Secondary "),S(A.$$.fragment,x),T=f(x,". To end the recording, call "),S(y.$$.fragment,x),B=f(x,"."),x.forEach(l),this.h()},h(){z(e,"slot","details")},m(O,x){h(O,e,x),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),D(R,e,null),o(e,P),D(A,e,null),o(e,T),D(y,e,null),o(e,B),M=!0},p(O,x){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),r.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),n.$set(V);const q={};x&1&&(q.$$scope={dirty:x,ctx:O}),p.$set(q);const k={};x&1&&(k.$$scope={dirty:x,ctx:O}),_.$set(k);const N={};x&1&&(N.$$scope={dirty:x,ctx:O}),R.$set(N);const Q={};x&1&&(Q.$$scope={dirty:x,ctx:O}),A.$set(Q);const X={};x&1&&(X.$$scope={dirty:x,ctx:O}),y.$set(X)},i(O){M||(b(r.$$.fragment,O),b(n.$$.fragment,O),b(p.$$.fragment,O),b(_.$$.fragment,O),b(R.$$.fragment,O),b(A.$$.fragment,O),b(y.$$.fragment,O),M=!0)},o(O){w(r.$$.fragment,O),w(n.$$.fragment,O),w(p.$$.fragment,O),w(_.$$.fragment,O),w(R.$$.fragment,O),w(A.$$.fragment,O),w(y.$$.fragment,O),M=!1},d(O){O&&l(e),C(r),C(n),C(p),C(_),C(R),C(A),C(y)}}}function Ud(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hd(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Ud]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Gd]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pQueue"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" from which a "),I(p.$$.fragment),m=i(" will be created from."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pQueue"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," from which a "),S(p.$$.fragment,P),m=f(P," will be created from."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function qd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wd(c){let e,t,r,$,n;return r=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[qd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Qd(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"CommandRecording* Fillcan::beginSingleTimeCommandRecording(Queue* pQueue);"}}),r=new Se({props:{$$slots:{return:[Wd],params:[Hd],details:[Nd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Kd extends ve{constructor(e){super(),Ee(this,e,null,Qd,be,{})}}function zd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jd(c){let e;return{c(){e=i("beginSingleTimeRecording")},l(t){e=f(t,"beginSingleTimeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yd(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xd(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[zd]},$$scope:{ctx:c}}}),a=new fe({props:{href:je().URL.documentation+"#"+L.LOGICAL_DEVICE_beginSingleTimeCommandRecording,$$slots:{default:[jd]},$$scope:{ctx:c}}}),p=new fe({props:{href:je().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Yd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("End a Command Recording."),r=d("br"),$=i(`
        Ends a `),I(n.$$.fragment),s=i(" (preferably created using "),I(a.$$.fragment),u=i("), submits the recording and waits for the "),I(p.$$.fragment),m=i(" to idle before returning."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=f(R,"End a Command Recording."),r=g(R,"BR",{}),$=f(R,`
        Ends a `),S(n.$$.fragment,R),s=f(R," (preferably created using "),S(a.$$.fragment,R),u=f(R,"), submits the recording and waits for the "),S(p.$$.fragment,R),m=f(R," to idle before returning."),R.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,R){h(v,e,R),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),n.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),a.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:v}),p.$set(T)},i(v){_||(b(n.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(a),C(p)}}}function Zd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jd(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:je().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Zd]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecording"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to end."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pCommandRecording"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to end."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function eg(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void endSingleTimeCommandRecording(CommandRecording* pCommandRecording);"}}),r=new Se({props:{$$slots:{params:[Jd],details:[Xd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tg extends ve{constructor(e){super(),Ee(this,e,null,eg,be,{})}}function rg(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ng(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sg(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ag(c){let e;return{c(){e=i("getGraphicsQueue")},l(t){e=f(t,"getGraphicsQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function og(c){let e;return{c(){e=i("getPresentQueue")},l(t){e=f(t,"getPresentQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lg(c){let e;return{c(){e=i("getComputeQueue")},l(t){e=f(t,"getComputeQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ig(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return e=new $e({props:{language:pe,code:"#include <fillcan/commands/queue.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[rg]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[ng]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[sg]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.LOGICAL_DEVICE_getGraphicsQueue,$$slots:{default:[ag]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.LOGICAL_DEVICE_getPresentQueue,$$slots:{default:[og]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.LOGICAL_DEVICE_getComputeQueue,$$slots:{default:[lg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Queue"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with the queue family index and queue index and uses this information to
construct one `),I(u.$$.fragment),p=i("."),m=d("br"),_=i(`
Each device in Vulkan has one or more Queues. The Queue is the part of the device
that does the actual work. It can be thought of as a sub-device that exposes a subset
of the functionality of the device.`),v=d("br"),R=i(`
Queues are grouped into one or more queue families, each containing one or more Queues.
Queues within a single family are essentially identical. Their capabilities are the
same, their performance level and access to system resources is the same, and there
is no cost (other than synchronization) for transferring work between each other.`),P=d("br"),A=i(`
The `),I(T.$$.fragment),y=i(` will
automatically attempt to create one graphics, presentation and computation Queue
which can be retrieved with `),I(B.$$.fragment),M=i(", "),I(O.$$.fragment),x=i(" and "),I(F.$$.fragment),V=i(", respectively.")},l(k){S(e.$$.fragment,k),t=f(k,`

The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Queue"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k,` along with the queue family index and queue index and uses this information to
construct one `),S(u.$$.fragment,k),p=f(k,"."),m=g(k,"BR",{}),_=f(k,`
Each device in Vulkan has one or more Queues. The Queue is the part of the device
that does the actual work. It can be thought of as a sub-device that exposes a subset
of the functionality of the device.`),v=g(k,"BR",{}),R=f(k,`
Queues are grouped into one or more queue families, each containing one or more Queues.
Queues within a single family are essentially identical. Their capabilities are the
same, their performance level and access to system resources is the same, and there
is no cost (other than synchronization) for transferring work between each other.`),P=g(k,"BR",{}),A=f(k,`
The `),S(T.$$.fragment,k),y=f(k,` will
automatically attempt to create one graphics, presentation and computation Queue
which can be retrieved with `),S(B.$$.fragment,k),M=f(k,", "),S(O.$$.fragment,k),x=f(k," and "),S(F.$$.fragment,k),V=f(k,", respectively.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),h(k,_,N),h(k,v,N),h(k,R,N),h(k,P,N),h(k,A,N),D(T,k,N),h(k,y,N),D(B,k,N),h(k,M,N),D(O,k,N),h(k,x,N),D(F,k,N),h(k,V,N),q=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),T.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),B.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),O.$set(W);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),F.$set(U)},i(k){q||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(T.$$.fragment,k),b(B.$$.fragment,k),b(O.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(T.$$.fragment,k),w(B.$$.fragment,k),w(O.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(_),k&&l(v),k&&l(R),k&&l(P),k&&l(A),C(T,k),k&&l(y),C(B,k),k&&l(M),C(O,k),k&&l(x),C(F,k),k&&l(V)}}}class fg extends ve{constructor(e){super(),Ee(this,e,null,ig,be,{})}}function cg(c){let e,t;return{c(){e=d("span"),t=i("Create a new Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Queue."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function $g(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ug(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[$g]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Queue."),p=j(),m=d("li"),_=d("code"),v=i("queueFamilyIndex"),R=d("br"),P=i(`
            The index of the chosen queue family.`),A=j(),T=d("li"),y=d("code"),B=i("queueIndex"),M=d("br"),O=i(`
            The index of the chosen queue from the queue family.`),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"pLogicalDevice"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A pointer to the `),S(a.$$.fragment,q),u=f(q," that owns the Queue."),q.forEach(l),p=Y(V),m=g(V,"LI",{});var N=E(m);_=g(N,"CODE",{});var Q=E(_);v=f(Q,"queueFamilyIndex"),Q.forEach(l),R=g(N,"BR",{}),P=f(N,`
            The index of the chosen queue family.`),N.forEach(l),A=Y(V),T=g(V,"LI",{});var X=E(T);y=g(X,"CODE",{});var Z=E(y);B=f(Z,"queueIndex"),Z.forEach(l),M=g(X,"BR",{}),O=f(X,`
            The index of the chosen queue from the queue family.`),X.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q)},i(F){x||(b(a.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),x=!1},d(F){F&&l(e),C(a)}}}function pg(c){let e,t,r,$,n,s,a,u;return{c(){e=d("span"),t=i("When either "),r=d("code"),$=i("queueFamilyIndex"),n=i(" or "),s=d("code"),a=i("queueIndex"),u=i(` is out
        of range.`),this.h()},l(p){e=g(p,"SPAN",{slot:!0});var m=E(e);t=f(m,"When either "),r=g(m,"CODE",{});var _=E(r);$=f(_,"queueFamilyIndex"),_.forEach(l),n=f(m," or "),s=g(m,"CODE",{});var v=E(s);a=f(v,"queueIndex"),v.forEach(l),u=f(m,` is out
        of range.`),m.forEach(l),this.h()},h(){z(e,"slot","throws")},m(p,m){h(p,e,m),o(e,t),o(e,r),o(r,$),o(e,n),o(e,s),o(s,a),o(e,u)},p:Oe,d(p){p&&l(e)}}}function mg(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Queue(LogicalDevice* pLogicalDevice, unsigned int queueFamilyIndex, unsigned int queueIndex);"}}),r=new Se({props:{$$slots:{throws:[pg],params:[ug],details:[cg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hg extends ve{constructor(e){super(),Ee(this,e,null,mg,be,{})}}function dg(c){let e;return{c(){e=i("Vulkan Queue")},l(t){e=f(t,"Vulkan Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html",target:"_blank",$$slots:{default:[dg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _g(c){let e;return{c(){e=i("Vulkan Queue")},l(t){e=f(t,"Vulkan Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html",target:"_blank",$$slots:{default:[_g]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Eg(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkQueue getQueueHandle(); const"}}),r=new Se({props:{$$slots:{return:[vg],details:[gg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bg extends ve{constructor(e){super(),Ee(this,e,null,Eg,be,{})}}function wg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ig(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[wg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Dg(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sg(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ag(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pg(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bg(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Dg]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Cg]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Sg]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Rg]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Ag]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Pg]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("primaryCommandBufferCount"),n=d("br"),s=i(`
            The amount of Primary `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should allocate."),_=j(),v=d("li"),R=d("code"),P=i("secondaryCommandBufferCount"),A=d("br"),T=i(`
            The amount of Secondary `),I(y.$$.fragment),B=i(" the "),I(M.$$.fragment),O=i(" should allocate."),x=j(),F=d("li"),V=d("code"),q=i("commandPoolIndex"),k=d("br"),N=i(`
            The index of the `),I(Q.$$.fragment),X=i(" to allocate the "),I(Z.$$.fragment),K=i(" from."),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"primaryCommandBufferCount"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The amount of Primary `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te," should allocate."),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"secondaryCommandBufferCount"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The amount of Secondary `),S(y.$$.fragment,ne),B=f(ne," the "),S(M.$$.fragment,ne),O=f(ne," should allocate."),ne.forEach(l),x=Y(G),F=g(G,"LI",{});var ae=E(F);V=g(ae,"CODE",{});var J=E(V);q=f(J,"commandPoolIndex"),J.forEach(l),k=g(ae,"BR",{}),N=f(ae,`
            The index of the `),S(Q.$$.fragment,ae),X=f(ae," to allocate the "),S(Z.$$.fragment,ae),K=f(ae," from."),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),D(Z,F,null),o(F,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),M.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(M.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(M.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(M),C(Q),C(Z)}}}function Lg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kg(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Lg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Tg(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Og(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Tg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the given index exceeds the max
        possible index of a `),I(n.$$.fragment),s=i(" for this Queue."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if the given index exceeds the max
        possible index of a `),S(n.$$.fragment,p),s=f(p," for this Queue."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Vg(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`CommandRecording* createRecording(
        unsigned int primaryCommandBufferCount, 
        unsigned int secondaryCommandBufferCount,
        unsigned int commandPoolIndex = 0
);`}}),r=new Se({props:{$$slots:{throws:[Og],return:[kg],params:[Bg],details:[Ig]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yg extends ve{constructor(e){super(),Ee(this,e,null,Vg,be,{})}}function Mg(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fg(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Mg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Submit one or more "),I(r.$$.fragment),$=i(" to be executed by the Queue."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Submit one or more "),S(r.$$.fragment,a),$=f(a," to be executed by the Queue."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function xg(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ng(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ug(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gg(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return a=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[xg]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.FENCE,$$slots:{default:[Ng]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Ug]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecordings"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to submit."),p=j(),m=d("li"),_=d("code"),v=i("pFence"),R=d("br"),P=i(`
            A pointer to a `),I(A.$$.fragment),T=i(" to signal once all submitted "),I(y.$$.fragment),B=i(" have completed execution."),this.h()},l(O){e=g(O,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var F=E(t);r=g(F,"CODE",{});var V=E(r);$=f(V,"pCommandRecordings"),V.forEach(l),n=g(F,"BR",{}),s=f(F,`
            The `),S(a.$$.fragment,F),u=f(F," to submit."),F.forEach(l),p=Y(x),m=g(x,"LI",{});var q=E(m);_=g(q,"CODE",{});var k=E(_);v=f(k,"pFence"),k.forEach(l),R=g(q,"BR",{}),P=f(q,`
            A pointer to a `),S(A.$$.fragment,q),T=f(q," to signal once all submitted "),S(y.$$.fragment,q),B=f(q," have completed execution."),q.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,x){h(O,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),M=!0},p(O,x){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),a.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),A.$set(V);const q={};x&1&&(q.$$scope={dirty:x,ctx:O}),y.$set(q)},i(O){M||(b(a.$$.fragment,O),b(A.$$.fragment,O),b(y.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(A.$$.fragment,O),w(y.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(A),C(y)}}}function Hg(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all Command Recordings were succesfully submitted
        to the Queue. `),n=d("code"),s=i("false"),a=i(` if not all Command Recordings were succesfully
        submitted to the Queue.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all Command Recordings were succesfully submitted
        to the Queue. `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if not all Command Recordings were succesfully
        submitted to the Queue.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function qg(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool submitRecordings(std::vector<CommandRecording*> pCommandRecordings, Fence* pFence = nullptr);"}}),r=new Se({props:{$$slots:{return:[Hg],params:[Gg],details:[Fg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Wg extends ve{constructor(e){super(),Ee(this,e,null,qg,be,{})}}function Qg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kg(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zg(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jg(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yg(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return r=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Qg]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[Kg]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[zg]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[jg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Reset a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        This will call `),I(a.$$.fragment),u=i(" on every "),I(p.$$.fragment),m=i(" in the given "),I(_.$$.fragment),v=i("."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var A=E(e);t=f(A,"Reset a "),S(r.$$.fragment,A),$=f(A,"."),n=g(A,"BR",{}),s=f(A,`
        This will call `),S(a.$$.fragment,A),u=f(A," on every "),S(p.$$.fragment,A),m=f(A," in the given "),S(_.$$.fragment,A),v=f(A,"."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(P,A){h(P,e,A),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),r.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),a.$set(y);const B={};A&1&&(B.$$scope={dirty:A,ctx:P}),p.$set(B);const M={};A&1&&(M.$$scope={dirty:A,ctx:P}),_.$set(M)},i(P){R||(b(r.$$.fragment,P),b(a.$$.fragment,P),b(p.$$.fragment,P),b(_.$$.fragment,P),R=!0)},o(P){w(r.$$.fragment,P),w(a.$$.fragment,P),w(p.$$.fragment,P),w(_.$$.fragment,P),R=!1},d(P){P&&l(e),C(r),C(a),C(p),C(_)}}}function Xg(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zg(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jg(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return a=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Xg]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Zg]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[Jg]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecordings"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to reset."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            Additional actions to perform while resetting the `),I(A.$$.fragment),T=i(". This is a bitmask of "),I(y.$$.fragment),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var x=E(t);r=g(x,"CODE",{});var F=E(r);$=f(F,"pCommandRecordings"),F.forEach(l),n=g(x,"BR",{}),s=f(x,`
            The `),S(a.$$.fragment,x),u=f(x," to reset."),x.forEach(l),p=Y(O),m=g(O,"LI",{});var V=E(m);_=g(V,"CODE",{});var q=E(_);v=f(q,"flags"),q.forEach(l),R=g(V,"BR",{}),P=f(V,`
            Additional actions to perform while resetting the `),S(A.$$.fragment,V),T=f(V,". This is a bitmask of "),S(y.$$.fragment,V),V.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),B=!0},p(M,O){const x={};O&1&&(x.$$scope={dirty:O,ctx:M}),a.$set(x);const F={};O&1&&(F.$$scope={dirty:O,ctx:M}),A.$set(F);const V={};O&1&&(V.$$scope={dirty:O,ctx:M}),y.$set(V)},i(M){B||(b(a.$$.fragment,M),b(A.$$.fragment,M),b(y.$$.fragment,M),B=!0)},o(M){w(a.$$.fragment,M),w(A.$$.fragment,M),w(y.$$.fragment,M),B=!1},d(M){M&&l(e),C(a),C(A),C(y)}}}function t_(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r_(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n_(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[t_]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[r_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the "),I(n.$$.fragment),s=i(` was succesfully reset.
        `),a=d("code"),u=i("false"),p=i(" if the "),I(m.$$.fragment),_=i(" failed to reset."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P,` was succesfully reset.
        `),a=g(P,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(P," if the "),S(m.$$.fragment,P),_=f(P," failed to reset."),P.forEach(l),this.h()},h(){z(e,"slot","return")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),m.$set(T)},i(R){v||(b(n.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){R&&l(e),C(n),C(m)}}}function s_(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool resetRecording(CommandRecording* pCommandRecording, VkCommandBufferResetFlags flags);"}}),r=new Se({props:{$$slots:{return:[n_],params:[e_],details:[Yg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class a_ extends ve{constructor(e){super(),Ee(this,e,null,s_,be,{})}}function o_(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l_(c){let e;return{c(){e=i("freeCommandBuffers")},l(t){e=f(t,"freeCommandBuffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c_(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return r=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[o_]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.COMMAND_POOL_freeCommandBuffers,$$slots:{default:[l_]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[i_]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[f_]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[c_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        This will call `),I(a.$$.fragment),u=i(" on the "),I(p.$$.fragment),m=i(" for all the "),I(_.$$.fragment),v=i(" in the given "),I(R.$$.fragment),P=i("."),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var y=E(e);t=f(y,"Free a "),S(r.$$.fragment,y),$=f(y,"."),n=g(y,"BR",{}),s=f(y,`
        This will call `),S(a.$$.fragment,y),u=f(y," on the "),S(p.$$.fragment,y),m=f(y," for all the "),S(_.$$.fragment,y),v=f(y," in the given "),S(R.$$.fragment,y),P=f(y,"."),y.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,y){h(T,e,y),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),D(R,e,null),o(e,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),r.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),a.$set(M);const O={};y&1&&(O.$$scope={dirty:y,ctx:T}),p.$set(O);const x={};y&1&&(x.$$scope={dirty:y,ctx:T}),_.$set(x);const F={};y&1&&(F.$$scope={dirty:y,ctx:T}),R.$set(F)},i(T){A||(b(r.$$.fragment,T),b(a.$$.fragment,T),b(p.$$.fragment,T),b(_.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(a.$$.fragment,T),w(p.$$.fragment,T),w(_.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(a),C(p),C(_),C(R)}}}function u_(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p_(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[u_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecording"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to free."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pCommandRecording"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to free."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function m_(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void freeRecording(CommandRecording* pCommandRecording);"}}),r=new Se({props:{$$slots:{params:[p_],details:[$_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class h_ extends ve{constructor(e){super(),Ee(this,e,null,m_,be,{})}}function d_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return _=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[d_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the Queue to become idle."),r=d("br"),$=i(`
        When `),n=d("code"),s=i("waitIdle"),a=i(" returns "),u=d("code"),p=i("true"),m=i(", all "),I(_.$$.fragment),v=i(" sent to the Queue are guaranteed to be completed."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var A=E(e);t=f(A,"Wait for the Queue to become idle."),r=g(A,"BR",{}),$=f(A,`
        When `),n=g(A,"CODE",{});var T=E(n);s=f(T,"waitIdle"),T.forEach(l),a=f(A," returns "),u=g(A,"CODE",{});var y=E(u);p=f(y,"true"),y.forEach(l),m=f(A,", all "),S(_.$$.fragment,A),v=f(A," sent to the Queue are guaranteed to be completed."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(P,A){h(P,e,A),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(u,p),o(e,m),D(_,e,null),o(e,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),_.$set(T)},i(P){R||(b(_.$$.fragment,P),R=!0)},o(P){w(_.$$.fragment,P),R=!1},d(P){P&&l(e),C(_)}}}function __(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Queue was sucessfully waited on.
        `),n=d("code"),s=i("false"),a=i(` if something went wrong while waiting for the Queue to
        idle.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Queue was sucessfully waited on.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if something went wrong while waiting for the Queue to
        idle.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function v_(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool waitIdle();"}}),r=new Se({props:{$$slots:{return:[__],details:[g_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class E_ extends ve{constructor(e){super(),Ee(this,e,null,v_,be,{})}}function b_(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I_(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S_(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R_(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return e=new $e({props:{language:pe,code:"#include <fillcan/commands/command_pool.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[b_]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[w_]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.QUEUE,$$slots:{default:[I_]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[D_]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[C_]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.QUEUE,$$slots:{default:[S_]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[R_]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[A_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Command Pool"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with the queue family index uses this information to allocate, free and reset
`),I(u.$$.fragment),p=i("."),m=d("br"),_=i(`
The primary purpose of a `),I(v.$$.fragment),R=i(` is to process work on behalf of the application. Work is represented as a series
of commands that are committed to `),I(P.$$.fragment),A=i(". The application will create "),I(T.$$.fragment),y=i(" with the work to be done and send them to one of the "),I(B.$$.fragment),M=i(" for execution. Before commands can be recorded, a "),I(O.$$.fragment),x=i(" must be created. "),I(F.$$.fragment),V=i(" themselves are not created directly, but allocated from Command Pools.")},l(k){S(e.$$.fragment,k),t=f(k,`

The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Command Pool"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k,` along with the queue family index uses this information to allocate, free and reset
`),S(u.$$.fragment,k),p=f(k,"."),m=g(k,"BR",{}),_=f(k,`
The primary purpose of a `),S(v.$$.fragment,k),R=f(k,` is to process work on behalf of the application. Work is represented as a series
of commands that are committed to `),S(P.$$.fragment,k),A=f(k,". The application will create "),S(T.$$.fragment,k),y=f(k," with the work to be done and send them to one of the "),S(B.$$.fragment,k),M=f(k," for execution. Before commands can be recorded, a "),S(O.$$.fragment,k),x=f(k," must be created. "),S(F.$$.fragment,k),V=f(k," themselves are not created directly, but allocated from Command Pools.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),h(k,_,N),D(v,k,N),h(k,R,N),D(P,k,N),h(k,A,N),D(T,k,N),h(k,y,N),D(B,k,N),h(k,M,N),D(O,k,N),h(k,x,N),D(F,k,N),h(k,V,N),q=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),v.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),P.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),T.$set(W);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),B.$set(U);const G={};N&1&&(G.$$scope={dirty:N,ctx:k}),O.$set(G);const te={};N&1&&(te.$$scope={dirty:N,ctx:k}),F.$set(te)},i(k){q||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(v.$$.fragment,k),b(P.$$.fragment,k),b(T.$$.fragment,k),b(B.$$.fragment,k),b(O.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(v.$$.fragment,k),w(P.$$.fragment,k),w(T.$$.fragment,k),w(B.$$.fragment,k),w(O.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(_),C(v,k),k&&l(R),C(P,k),k&&l(A),C(T,k),k&&l(y),C(B,k),k&&l(M),C(O,k),k&&l(x),C(F,k),k&&l(V)}}}class B_ extends ve{constructor(e){super(),Ee(this,e,null,P_,be,{})}}function L_(c){let e,t;return{c(){e=d("span"),t=i("Create a new Command Pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Command Pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function k_(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T_(c){let e;return{c(){e=i("VkCommandPoolCreateFlagBits")},l(t){e=f(t,"VkCommandPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V_(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M_(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[k_]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[T_]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[O_]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[V_]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[y_]},$$scope:{ctx:c}}}),te=new H({props:{sectionID:L.QUEUE,$$slots:{default:[M_]},$$scope:{ctx:c}}}),ne=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[F_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Command Pool."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" that specifies usage behavior for the pool and the "),I(y.$$.fragment),B=i(`
            assigned to it.`),M=d("br"),O=i(`
            In order to be able to call `),I(x.$$.fragment),F=i(" on the "),I(V.$$.fragment),q=i(` allocated from this Command Pool the flag
            `),k=d("code"),N=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),Q=i(`
            should be set.`),X=j(),Z=d("li"),K=d("code"),W=i("queueFamilyIndex"),U=d("br"),G=i(`
            The family index of `),I(te.$$.fragment),ee=i(" where "),I(ne.$$.fragment),le=i(" allocated from this pool are sent."),this.h()},l(J){e=g(J,"DIV",{slot:!0});var ue=E(e);t=g(ue,"LI",{});var De=E(t);r=g(De,"CODE",{});var de=E(r);$=f(de,"pLogicalDevice"),de.forEach(l),n=g(De,"BR",{}),s=f(De,`
            A pointer to the `),S(a.$$.fragment,De),u=f(De," that owns the Command Pool."),De.forEach(l),p=Y(ue),m=g(ue,"LI",{});var me=E(m);_=g(me,"CODE",{});var Ce=E(_);v=f(Ce,"flags"),Ce.forEach(l),R=g(me,"BR",{}),P=f(me,`
            A bitmask of `),S(A.$$.fragment,me),T=f(me," that specifies usage behavior for the pool and the "),S(y.$$.fragment,me),B=f(me,`
            assigned to it.`),M=g(me,"BR",{}),O=f(me,`
            In order to be able to call `),S(x.$$.fragment,me),F=f(me," on the "),S(V.$$.fragment,me),q=f(me,` allocated from this Command Pool the flag
            `),k=g(me,"CODE",{});var _e=E(k);N=f(_e,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),_e.forEach(l),Q=f(me,`
            should be set.`),me.forEach(l),X=Y(ue),Z=g(ue,"LI",{});var se=E(Z);K=g(se,"CODE",{});var ie=E(K);W=f(ie,"queueFamilyIndex"),ie.forEach(l),U=g(se,"BR",{}),G=f(se,`
            The family index of `),S(te.$$.fragment,se),ee=f(se," where "),S(ne.$$.fragment,se),le=f(se," allocated from this pool are sent."),se.forEach(l),ue.forEach(l),this.h()},h(){z(e,"slot","params")},m(J,ue){h(J,e,ue),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),o(m,M),o(m,O),D(x,m,null),o(m,F),D(V,m,null),o(m,q),o(m,k),o(k,N),o(m,Q),o(e,X),o(e,Z),o(Z,K),o(K,W),o(Z,U),o(Z,G),D(te,Z,null),o(Z,ee),D(ne,Z,null),o(Z,le),ae=!0},p(J,ue){const De={};ue&1&&(De.$$scope={dirty:ue,ctx:J}),a.$set(De);const de={};ue&1&&(de.$$scope={dirty:ue,ctx:J}),A.$set(de);const me={};ue&1&&(me.$$scope={dirty:ue,ctx:J}),y.$set(me);const Ce={};ue&1&&(Ce.$$scope={dirty:ue,ctx:J}),x.$set(Ce);const _e={};ue&1&&(_e.$$scope={dirty:ue,ctx:J}),V.$set(_e);const se={};ue&1&&(se.$$scope={dirty:ue,ctx:J}),te.$set(se);const ie={};ue&1&&(ie.$$scope={dirty:ue,ctx:J}),ne.$set(ie)},i(J){ae||(b(a.$$.fragment,J),b(A.$$.fragment,J),b(y.$$.fragment,J),b(x.$$.fragment,J),b(V.$$.fragment,J),b(te.$$.fragment,J),b(ne.$$.fragment,J),ae=!0)},o(J){w(a.$$.fragment,J),w(A.$$.fragment,J),w(y.$$.fragment,J),w(x.$$.fragment,J),w(V.$$.fragment,J),w(te.$$.fragment,J),w(ne.$$.fragment,J),ae=!1},d(J){J&&l(e),C(a),C(A),C(y),C(x),C(V),C(te),C(ne)}}}function N_(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U_(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[N_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function G_(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"CommandPool(LogicalDevice* pLogicalDevice, VkCommandPoolCreateFlags flags, unsigned int queueFamilyIndex);"}}),r=new Se({props:{$$slots:{throws:[U_],params:[x_],details:[L_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class H_ extends ve{constructor(e){super(),Ee(this,e,null,G_,be,{})}}function q_(c){let e,t;return{c(){e=d("span"),t=i("Allocate Command Buffers from the pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Allocate Command Buffers from the pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function W_(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K_(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",$$slots:{default:[W_]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Q_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("level"),n=d("br"),s=i(`
            The level at which the allocated Command Buffers operate. This should
            be a member of the `),I(a.$$.fragment),u=i("-enumerant."),p=j(),m=d("li"),_=d("code"),v=i("commandBufferCount"),R=d("br"),P=i(`
            The amount of `),I(A.$$.fragment),T=i(" to allocate."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"level"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The level at which the allocated Command Buffers operate. This should
            be a member of the `),S(a.$$.fragment,O),u=f(O,"-enumerant."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"commandBufferCount"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            The amount of `),S(A.$$.fragment,F),T=f(F," to allocate."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function z_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j_(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[z_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Y_(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<CommandBuffer*> allocateCommandBuffers(VkCommandBufferLevel level, unsigned int commandBufferCount);"}}),r=new Se({props:{$$slots:{return:[j_],params:[K_],details:[q_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class X_ extends ve{constructor(e){super(),Ee(this,e,null,Y_,be,{})}}function Z_(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J_(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Z_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free the given Command Buffers."),r=d("br"),$=i(`
        Freeing a `),I(n.$$.fragment),s=i(` does not necessarily free all its resources, but returns them to the Command
        Pool from which they were allocated.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Free the given Command Buffers."),r=g(p,"BR",{}),$=f(p,`
        Freeing a `),S(n.$$.fragment,p),s=f(p,` does not necessarily free all its resources, but returns them to the Command
        Pool from which they were allocated.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ev(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tv(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[ev]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffers"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to free."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pCommandBuffers"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to free."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function rv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void freeCommandBuffers(std::vector<CommandBuffer*> pCommandBuffers);"}}),r=new Se({props:{$$slots:{params:[tv],details:[J_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nv extends ve{constructor(e){super(),Ee(this,e,null,rv,be,{})}}function sv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function av(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[sv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Reset the Command Pool."),r=d("br"),$=i(`
        Resets all the `),I(n.$$.fragment),s=i(" allocated from this Command Pool."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Reset the Command Pool."),r=g(p,"BR",{}),$=f(p,`
        Resets all the `),S(n.$$.fragment,p),s=f(p," allocated from this Command Pool."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ov(c){let e;return{c(){e=i("VkCommandPoolResetFlagBits")},l(t){e=f(t,"VkCommandPoolResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lv(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html",target:"_blank",$$slots:{default:[ov]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the command pool. This
            is a bitmask of `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"flags"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            Additional actions to perform while resetting the command pool. This
            is a bitmask of `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function iv(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Pool was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Command Pool failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Pool was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Pool failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function fv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool reset(VkCommandPoolResetFlags flags);"}}),r=new Se({props:{$$slots:{return:[iv],params:[lv],details:[av]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class cv extends ve{constructor(e){super(),Ee(this,e,null,fv,be,{})}}function $v(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uv(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[$v]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function pv(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mv(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[pv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkCommandPool getCommandPoolHandle() const;"}}),r=new Se({props:{$$slots:{return:[mv],details:[uv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dv extends ve{constructor(e){super(),Ee(this,e,null,hv,be,{})}}function gv(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _v(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[gv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vv(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ev(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[vv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkCommandBuffer getCommandBufferHandle() const;"}}),r=new Se({props:{$$slots:{return:[Ev],details:[_v]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wv extends ve{constructor(e){super(),Ee(this,e,null,bv,be,{})}}function Iv(c){let e,t;return{c(){e=d("span"),t=i("Get the level at which the Command Buffer operates."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the level at which the Command Buffer operates."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Dv(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cv(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",target:"_blank",$$slots:{default:[Dv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`The level at which the Command Buffer operates. This is a member of the
        `),I(r.$$.fragment),$=i("-enumerant."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`The level at which the Command Buffer operates. This is a member of the
        `),S(r.$$.fragment,a),$=f(a,"-enumerant."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Sv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkCommandBufferLevel getLevel() const;"}}),r=new Se({props:{$$slots:{return:[Cv],details:[Iv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Rv extends ve{constructor(e){super(),Ee(this,e,null,Sv,be,{})}}function Av(c){let e,t;return{c(){e=d("span"),t=i("Start the Command Buffer, which resets it to an initial state."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Start the Command Buffer, which resets it to an initial state."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Pv(c){let e;return{c(){e=i("VkCommandBufferUsageFlagBits")},l(t){e=f(t,"VkCommandBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bv(c){let e;return{c(){e=i("VkCommandBufferInheritanceInfo")},l(t){e=f(t,"VkCommandBufferInheritanceInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lv(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[Pv]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html",target:"_blank",$$slots:{default:[Bv]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" telling Vulkan how the Command Buffer will be used."),p=j(),m=d("li"),_=d("code"),v=i("pSecondaryCommandBufferInheritanceInfo"),R=d("br"),P=i(`
            A `),I(A.$$.fragment),T=i(`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"flags"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            A bitmask of `),S(a.$$.fragment,O),u=f(O," telling Vulkan how the Command Buffer will be used."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"pSecondaryCommandBufferInheritanceInfo"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            A `),S(A.$$.fragment,F),T=f(F,`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function kv(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully started.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to start."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully started.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to start."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function Tv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`bool begin(
        VkCommandBufferUsageFlags flags = 0, 
        VkCommandBufferInheritanceInfo* pSecondaryCommandBufferInheritanceInfo = nullptr
);`}}),r=new Se({props:{$$slots:{return:[kv],params:[Lv],details:[Av]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ov extends ve{constructor(e){super(),Ee(this,e,null,Tv,be,{})}}function Vv(c){let e,t,r,$;return{c(){e=d("span"),t=i("End the Command Buffer."),r=d("br"),$=i(`
        Before the Command Buffer is ready to be sent to the device for execution,
        we need to tell Vulkan that we're done recording commands in it.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"End the Command Buffer."),r=g(s,"BR",{}),$=f(s,`
        Before the Command Buffer is ready to be sent to the device for execution,
        we need to tell Vulkan that we're done recording commands in it.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function yv(c){let e;return{c(){e=i("VkCommandBufferUsageFlagBits")},l(t){e=f(t,"VkCommandBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mv(c){let e;return{c(){e=i("VkCommandBufferInheritanceInfo")},l(t){e=f(t,"VkCommandBufferInheritanceInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fv(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[yv]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html",target:"_blank",$$slots:{default:[Mv]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" telling Vulkan how the Command Buffer will be used."),p=j(),m=d("li"),_=d("code"),v=i("pSecondaryCommandBufferInheritanceInfo"),R=d("br"),P=i(`
            A `),I(A.$$.fragment),T=i(`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"flags"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            A bitmask of `),S(a.$$.fragment,O),u=f(O," telling Vulkan how the Command Buffer will be used."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"pSecondaryCommandBufferInheritanceInfo"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            A `),S(A.$$.fragment,F),T=f(F,`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function xv(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully ended.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to end."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully ended.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to end."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function Nv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool end();"}}),r=new Se({props:{$$slots:{return:[xv],params:[Fv],details:[Vv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Uv extends ve{constructor(e){super(),Ee(this,e,null,Nv,be,{})}}function Gv(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hv(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qv(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return p=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Gv]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Hv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Start the Command Buffer, which resets it to an initial state."),r=d("br"),$=i(`

        Many applications use a similar set of commands to render all or part of
        each frame. Therefore, it is likely that similar Command Buffers are
        included in the application over and over again.`),n=d("br"),s=i(`
        Allocating and freeing Command Buffers every frame is a relatively heavy
        operation. If the application reuses a Command Buffer many times in a row
        for similar work, it may be more efficient to reset the Command Buffer.`),a=d("br"),u=i(`
        This effectively restores the Command Buffer to its original state, but does
        not necessarily interact with the `),I(p.$$.fragment),m=i(` to do so. Therefore, if the Command Buffer dynamically allocates resources
        from the `),I(_.$$.fragment),v=i(` as the Command Buffer grows, the Command Buffer can hold onto those resources
        and avoid the cost of reallocation the next time it is rebuilt.`),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var A=E(e);t=f(A,"Start the Command Buffer, which resets it to an initial state."),r=g(A,"BR",{}),$=f(A,`

        Many applications use a similar set of commands to render all or part of
        each frame. Therefore, it is likely that similar Command Buffers are
        included in the application over and over again.`),n=g(A,"BR",{}),s=f(A,`
        Allocating and freeing Command Buffers every frame is a relatively heavy
        operation. If the application reuses a Command Buffer many times in a row
        for similar work, it may be more efficient to reset the Command Buffer.`),a=g(A,"BR",{}),u=f(A,`
        This effectively restores the Command Buffer to its original state, but does
        not necessarily interact with the `),S(p.$$.fragment,A),m=f(A,` to do so. Therefore, if the Command Buffer dynamically allocates resources
        from the `),S(_.$$.fragment,A),v=f(A,` as the Command Buffer grows, the Command Buffer can hold onto those resources
        and avoid the cost of reallocation the next time it is rebuilt.`),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(P,A){h(P,e,A),o(e,t),o(e,r),o(e,$),o(e,n),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),p.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),_.$set(y)},i(P){R||(b(p.$$.fragment,P),b(_.$$.fragment,P),R=!0)},o(P){w(p.$$.fragment,P),w(_.$$.fragment,P),R=!1},d(P){P&&l(e),C(p),C(_)}}}function Wv(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qv(c){let e,t,r,$,n,s,a,u,p,m,_;return p=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[Wv]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the command buffer.`),a=d("br"),u=i(`
            This is a bitmask of `),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"flags"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            Additional actions to perform while resetting the command buffer.`),a=g(P,"BR",{}),u=f(P,`
            This is a bitmask of `),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),p.$set(P)},i(v){_||(b(p.$$.fragment,v),_=!0)},o(v){w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(p)}}}function Kv(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function zv(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool reset(VkCommandBufferResetFlags flags = 0);"}}),r=new Se({props:{$$slots:{return:[Kv],params:[Qv],details:[qv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jv extends ve{constructor(e){super(),Ee(this,e,null,zv,be,{})}}function Yv(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xv(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zv(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jv(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K;return e=new $e({props:{language:pe,code:"#include <fillcan/commands/command_buffer.hpp>"}}),s=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[Yv]},$$scope:{ctx:c}}}),R=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[Xv]},$$scope:{ctx:c}}}),X=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Zv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Command Buffer"),n=i(" class takes in a handle to a "),I(s.$$.fragment),a=i(" and the level of the Command Buffer."),u=d("br"),p=i(`
With this information the `),m=d("code"),_=i("Command Buffer"),v=i(` class acts as a wrapper
around the `),I(R.$$.fragment),P=i(" for beginning, ending and resetting the Command Buffer."),A=d("br"),T=i(`
All commands for the GPU are stored in a Command Buffer. All functions that perform
GPU work do nothing until the Command Buffer is sent to the GPU.`),y=d("br"),B=i(`
Access to the Command Buffer must be synchronized externally, which means that it
is the responsibility of the application to ensure that no two threads simultaneously
try to insert commands into the same Command Buffer at the same time.`),M=d("br"),O=i(`
However, the following is perfectly acceptable:
`),x=d("ul"),F=d("li"),V=i(`One thread can record commands in multiple Command Buffers by simply
        calling Command Buffer functions sequentially on different Command
        Buffers.`),q=j(),k=d("li"),N=i(`Two or more threads can participate in building a single Command Buffer,
        as long as the application can guarantee that no two of the threads ever
        run a Command Buffer build function simultaneously.`),Q=i(`
One of Vulkan's key design principles is to enable efficient multithreading. To achieve
this, it is important that the application threads do not block each other's execution.
For this reason, it is good practice to have one or more Command Buffers for each
thread rather than sharing one. Furthermore, since Command Buffers are allocated
from pools, one can go further by creating a `),I(X.$$.fragment),Z=i(` for each thread, so that Command Buffers can be allocated by the worker threads
from their respective pools without these worker threads interacting with each other.`)},l(W){S(e.$$.fragment,W),t=f(W,`

The `),r=g(W,"CODE",{});var U=E(r);$=f(U,"Command Buffer"),U.forEach(l),n=f(W," class takes in a handle to a "),S(s.$$.fragment,W),a=f(W," and the level of the Command Buffer."),u=g(W,"BR",{}),p=f(W,`
With this information the `),m=g(W,"CODE",{});var G=E(m);_=f(G,"Command Buffer"),G.forEach(l),v=f(W,` class acts as a wrapper
around the `),S(R.$$.fragment,W),P=f(W," for beginning, ending and resetting the Command Buffer."),A=g(W,"BR",{}),T=f(W,`
All commands for the GPU are stored in a Command Buffer. All functions that perform
GPU work do nothing until the Command Buffer is sent to the GPU.`),y=g(W,"BR",{}),B=f(W,`
Access to the Command Buffer must be synchronized externally, which means that it
is the responsibility of the application to ensure that no two threads simultaneously
try to insert commands into the same Command Buffer at the same time.`),M=g(W,"BR",{}),O=f(W,`
However, the following is perfectly acceptable:
`),x=g(W,"UL",{});var te=E(x);F=g(te,"LI",{});var ee=E(F);V=f(ee,`One thread can record commands in multiple Command Buffers by simply
        calling Command Buffer functions sequentially on different Command
        Buffers.`),ee.forEach(l),q=Y(te),k=g(te,"LI",{});var ne=E(k);N=f(ne,`Two or more threads can participate in building a single Command Buffer,
        as long as the application can guarantee that no two of the threads ever
        run a Command Buffer build function simultaneously.`),ne.forEach(l),te.forEach(l),Q=f(W,`
One of Vulkan's key design principles is to enable efficient multithreading. To achieve
this, it is important that the application threads do not block each other's execution.
For this reason, it is good practice to have one or more Command Buffers for each
thread rather than sharing one. Furthermore, since Command Buffers are allocated
from pools, one can go further by creating a `),S(X.$$.fragment,W),Z=f(W,` for each thread, so that Command Buffers can be allocated by the worker threads
from their respective pools without these worker threads interacting with each other.`)},m(W,U){D(e,W,U),h(W,t,U),h(W,r,U),o(r,$),h(W,n,U),D(s,W,U),h(W,a,U),h(W,u,U),h(W,p,U),h(W,m,U),o(m,_),h(W,v,U),D(R,W,U),h(W,P,U),h(W,A,U),h(W,T,U),h(W,y,U),h(W,B,U),h(W,M,U),h(W,O,U),h(W,x,U),o(x,F),o(F,V),o(x,q),o(x,k),o(k,N),h(W,Q,U),D(X,W,U),h(W,Z,U),K=!0},p(W,[U]){const G={};U&1&&(G.$$scope={dirty:U,ctx:W}),s.$set(G);const te={};U&1&&(te.$$scope={dirty:U,ctx:W}),R.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:W}),X.$set(ee)},i(W){K||(b(e.$$.fragment,W),b(s.$$.fragment,W),b(R.$$.fragment,W),b(X.$$.fragment,W),K=!0)},o(W){w(e.$$.fragment,W),w(s.$$.fragment,W),w(R.$$.fragment,W),w(X.$$.fragment,W),K=!1},d(W){C(e,W),W&&l(t),W&&l(r),W&&l(n),C(s,W),W&&l(a),W&&l(u),W&&l(p),W&&l(m),W&&l(v),C(R,W),W&&l(P),W&&l(A),W&&l(T),W&&l(y),W&&l(B),W&&l(M),W&&l(O),W&&l(x),W&&l(Q),C(X,W),W&&l(Z)}}}class eE extends ve{constructor(e){super(),Ee(this,e,null,Jv,be,{})}}function tE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sE(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[tE]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[rE]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[nE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        The Queue automatically creates one `),I(a.$$.fragment),u=i(" on construction, this "),I(p.$$.fragment),m=i(" has both the "),_=d("code"),v=i("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),R=i(`-flag
        and `),P=d("code"),A=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),T=i(`-flag
        set.`),this.h()},l(B){e=g(B,"SPAN",{slot:!0});var M=E(e);t=f(M,"Create a "),S(r.$$.fragment,M),$=f(M,"."),n=g(M,"BR",{}),s=f(M,`
        The Queue automatically creates one `),S(a.$$.fragment,M),u=f(M," on construction, this "),S(p.$$.fragment,M),m=f(M," has both the "),_=g(M,"CODE",{});var O=E(_);v=f(O,"VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),O.forEach(l),R=f(M,`-flag
        and `),P=g(M,"CODE",{});var x=E(P);A=f(x,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),x.forEach(l),T=f(M,`-flag
        set.`),M.forEach(l),this.h()},h(){z(e,"slot","details")},m(B,M){h(B,e,M),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),o(e,_),o(_,v),o(e,R),o(e,P),o(P,A),o(e,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),r.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),a.$set(x);const F={};M&1&&(F.$$scope={dirty:M,ctx:B}),p.$set(F)},i(B){y||(b(r.$$.fragment,B),b(a.$$.fragment,B),b(p.$$.fragment,B),y=!0)},o(B){w(r.$$.fragment,B),w(a.$$.fragment,B),w(p.$$.fragment,B),y=!1},d(B){B&&l(e),C(r),C(a),C(p)}}}function aE(c){let e;return{c(){e=i("VkCommandPoolCreateFlagBits")},l(t){e=f(t,"VkCommandPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lE(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fE(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[aE]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[oE]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[lE]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[iE]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that specifies usage behavior for the pool and the "),I(p.$$.fragment),m=i(`
            assigned to it.`),_=d("br"),v=i(`
            In order to be able to call `),I(R.$$.fragment),P=i(" on the "),I(A.$$.fragment),T=i(` allocated from this Command Pool the flag
            `),y=d("code"),B=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),M=i(`
            should be set.`),this.h()},l(x){e=g(x,"DIV",{slot:!0});var F=E(e);t=g(F,"LI",{});var V=E(t);r=g(V,"CODE",{});var q=E(r);$=f(q,"flags"),q.forEach(l),n=g(V,"BR",{}),s=f(V,`
            A bitmask of `),S(a.$$.fragment,V),u=f(V," that specifies usage behavior for the pool and the "),S(p.$$.fragment,V),m=f(V,`
            assigned to it.`),_=g(V,"BR",{}),v=f(V,`
            In order to be able to call `),S(R.$$.fragment,V),P=f(V," on the "),S(A.$$.fragment,V),T=f(V,` allocated from this Command Pool the flag
            `),y=g(V,"CODE",{});var k=E(y);B=f(k,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),k.forEach(l),M=f(V,`
            should be set.`),V.forEach(l),F.forEach(l),this.h()},h(){z(e,"slot","params")},m(x,F){h(x,e,F),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(t,v),D(R,t,null),o(t,P),D(A,t,null),o(t,T),o(t,y),o(y,B),o(t,M),O=!0},p(x,F){const V={};F&1&&(V.$$scope={dirty:F,ctx:x}),a.$set(V);const q={};F&1&&(q.$$scope={dirty:F,ctx:x}),p.$set(q);const k={};F&1&&(k.$$scope={dirty:F,ctx:x}),R.$set(k);const N={};F&1&&(N.$$scope={dirty:F,ctx:x}),A.$set(N)},i(x){O||(b(a.$$.fragment,x),b(p.$$.fragment,x),b(R.$$.fragment,x),b(A.$$.fragment,x),O=!0)},o(x){w(a.$$.fragment,x),w(p.$$.fragment,x),w(R.$$.fragment,x),w(A.$$.fragment,x),O=!1},d(x){x&&l(e),C(a),C(p),C(R),C(A)}}}function cE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $E(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uE(c){let e;return{c(){e=i("getCommandPool")},l(t){e=f(t,"getCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pE(c){let e,t,r,$,n,s,a,u,p;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[cE]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[$E]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.QUEUE_getCommandPool,$$slots:{default:[uE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to request the "),I(n.$$.fragment),s=i(" with "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to request the "),S(n.$$.fragment,_),s=f(_," with "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),n.$set(R);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function mE(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int createCommandPool(VkCommandPoolCreateFlags flags);"}}),r=new Se({props:{$$slots:{return:[pE],params:[fE],details:[sE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hE extends ve{constructor(e){super(),Ee(this,e,null,mE,be,{})}}function dE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gE(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[dE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _E(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vE(c){let e;return{c(){e=i("createCommandPool")},l(t){e=f(t,"createCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EE(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[_E]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.QUEUE_createCommandPool,$$slots:{default:[vE]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" to get. This index was returned by "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The index of the `),S(a.$$.fragment,P),u=f(P," to get. This index was returned by "),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function bE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wE(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[bE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function IE(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"CommandPool* getCommandPool(unsigned int index = 0);"}}),r=new Se({props:{$$slots:{return:[wE],params:[EE],details:[gE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DE extends ve{constructor(e){super(),Ee(this,e,null,IE,be,{})}}function CE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SE(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[CE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function RE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AE(c){let e;return{c(){e=i("createCommandPool")},l(t){e=f(t,"createCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PE(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[RE]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.QUEUE_createCommandPool,$$slots:{default:[AE]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" to destroy. This index was returned by "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The index of the `),S(a.$$.fragment,P),u=f(P," to destroy. This index was returned by "),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function BE(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroyCommandPool(unsigned int index);"}}),r=new Se({props:{$$slots:{params:[PE],details:[SE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LE extends ve{constructor(e){super(),Ee(this,e,null,BE,be,{})}}function kE(c){let e,t;return{c(){e=d("span"),t=i("Create a new Command Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Command Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function TE(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OE(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VE(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[TE]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",target:"_blank",$$slots:{default:[OE]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("hCommandBuffer"),n=d("br"),s=i(`
            A handle to the `),I(a.$$.fragment),u=i(" to wrap."),p=j(),m=d("li"),_=d("code"),v=i("level"),R=d("br"),P=i(`
            The level at which the Command Buffer operates. This should be a member
            of the `),I(A.$$.fragment),T=i("-enumerant."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"hCommandBuffer"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            A handle to the `),S(a.$$.fragment,O),u=f(O," to wrap."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"level"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            The level at which the Command Buffer operates. This should be a member
            of the `),S(A.$$.fragment,F),T=f(F,"-enumerant."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function yE(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"CommandBuffer(VkCommandBuffer hCommandBuffer, VkCommandBufferLevel level);"}}),r=new Se({props:{$$slots:{params:[VE],details:[kE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ME extends ve{constructor(e){super(),Ee(this,e,null,yE,be,{})}}function FE(c){let e;return{c(){e=i("Command Pools")},l(t){e=f(t,"Command Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xE(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[FE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function NE(c){let e;return{c(){e=i("Command Pools")},l(t){e=f(t,"Command Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UE(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[NE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function GE(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<CommandPool*> getCommandPools();"}}),r=new Se({props:{$$slots:{return:[UE],details:[xE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class HE extends ve{constructor(e){super(),Ee(this,e,null,GE,be,{})}}function qE(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WE(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QE(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KE(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zE(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZE(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JE(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eb(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tb(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nb(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sb(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ab(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ob(c){let e;return{c(){e=i("createFence")},l(t){e=f(t,"createFence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lb(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St,tt,ot,At;return a=new H({props:{sectionID:L.QUEUE,$$slots:{default:[KE]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[zE]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[jE]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[YE]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[XE]},$$scope:{ctx:c}}}),De=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[ZE]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[JE]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[eb]},$$scope:{ctx:c}}}),Ne=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[tb]},$$scope:{ctx:c}}}),$t=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[rb]},$$scope:{ctx:c}}}),Ke=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[nb]},$$scope:{ctx:c}}}),st=new H({props:{sectionID:L.FENCE,$$slots:{default:[sb]},$$scope:{ctx:c}}}),at=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[ab]},$$scope:{ctx:c}}}),tt=new H({props:{sectionID:L.COMMAND_RECORDING_createFence,$$slots:{default:[ob]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("pQueue"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(` that owns
            this recording.`),p=j(),m=d("li"),_=d("code"),v=i("pCommandPool"),R=d("br"),P=i(`
            The `),I(A.$$.fragment),T=i(" the "),I(y.$$.fragment),B=i(" were allocated from."),M=j(),O=d("li"),x=d("code"),F=i("pPrimaryCommandBuffers"),V=d("br"),q=i(`
            The allocated primary `),I(k.$$.fragment),N=i(" that can be recorded to."),Q=j(),X=d("li"),Z=d("code"),K=i("pSecondaryCommandBuffers"),W=d("br"),U=i(`
            The allocated secondary `),I(G.$$.fragment),te=i(" that can be recorded to."),ee=j(),ne=d("li"),le=d("code"),ae=i("pWaitSemaphores"),J=d("br"),ue=i(`
            A list of pointers to `),I(De.$$.fragment),de=i(" to wait for before executing the "),I(me.$$.fragment),Ce=i("."),_e=j(),se=d("li"),ie=d("code"),ge=i("waitDstStageMask"),we=d("br"),Re=i(`
            An array of pipeline stages, which is a bitmask of `),I(Be.$$.fragment),Ie=i(", at which each corresponding semaphore wait will occur."),re=d("br"),he=i(`
            So the semaphore at index `),Ae=d("code"),Ve=i("0"),oe=i(` will wait at the pipeline
            stage at index
            `),ce=d("code"),Pe=i("0"),Fe=i(", the semaphore at index "),ke=d("code"),Te=i("1"),Me=i(` will wait at
            the pipeline stage at index
            `),Ue=d("code"),qe=i("1"),xe=i(", etc."),Ge=j(),ye=d("li"),We=d("code"),ze=i("pSignalSemaphores"),Ye=d("br"),rt=i(`
            A list of pointers to `),I(Ne.$$.fragment),He=i(" that are signaled when the "),I($t.$$.fragment),ut=i(" have finished execution."),ht=j(),Je=d("li"),dt=d("code"),et=i("upFenceWorkCompleted"),Ze=d("br"),nt=i(`
            A `),I(Ke.$$.fragment),ct=i(" to a "),I(st.$$.fragment),Qe=i(` that
            will be signaled once the `),I(at.$$.fragment),bt=i(" have finished execution."),wt=d("br"),St=i(`
            To initialize this Fence, call `),I(tt.$$.fragment),ot=i("."),this.h()},l(it){e=g(it,"SPAN",{slot:!0});var Xe=E(e);t=g(Xe,"LI",{});var Dt=E(t);r=g(Dt,"CODE",{});var Ct=E(r);$=f(Ct,"pQueue"),Ct.forEach(l),n=g(Dt,"BR",{}),s=f(Dt,`
            The `),S(a.$$.fragment,Dt),u=f(Dt,` that owns
            this recording.`),Dt.forEach(l),p=Y(Xe),m=g(Xe,"LI",{});var pt=E(m);_=g(pt,"CODE",{});var yt=E(_);v=f(yt,"pCommandPool"),yt.forEach(l),R=g(pt,"BR",{}),P=f(pt,`
            The `),S(A.$$.fragment,pt),T=f(pt," the "),S(y.$$.fragment,pt),B=f(pt," were allocated from."),pt.forEach(l),M=Y(Xe),O=g(Xe,"LI",{});var mt=E(O);x=g(mt,"CODE",{});var Ot=E(x);F=f(Ot,"pPrimaryCommandBuffers"),Ot.forEach(l),V=g(mt,"BR",{}),q=f(mt,`
            The allocated primary `),S(k.$$.fragment,mt),N=f(mt," that can be recorded to."),mt.forEach(l),Q=Y(Xe),X=g(Xe,"LI",{});var Pt=E(X);Z=g(Pt,"CODE",{});var Tt=E(Z);K=f(Tt,"pSecondaryCommandBuffers"),Tt.forEach(l),W=g(Pt,"BR",{}),U=f(Pt,`
            The allocated secondary `),S(G.$$.fragment,Pt),te=f(Pt," that can be recorded to."),Pt.forEach(l),ee=Y(Xe),ne=g(Xe,"LI",{});var vt=E(ne);le=g(vt,"CODE",{});var gt=E(le);ae=f(gt,"pWaitSemaphores"),gt.forEach(l),J=g(vt,"BR",{}),ue=f(vt,`
            A list of pointers to `),S(De.$$.fragment,vt),de=f(vt," to wait for before executing the "),S(me.$$.fragment,vt),Ce=f(vt,"."),vt.forEach(l),_e=Y(Xe),se=g(Xe,"LI",{});var kt=E(se);ie=g(kt,"CODE",{});var Ft=E(ie);ge=f(Ft,"waitDstStageMask"),Ft.forEach(l),we=g(kt,"BR",{}),Re=f(kt,`
            An array of pipeline stages, which is a bitmask of `),S(Be.$$.fragment,kt),Ie=f(kt,", at which each corresponding semaphore wait will occur."),re=g(kt,"BR",{}),he=f(kt,`
            So the semaphore at index `),Ae=g(kt,"CODE",{});var Mt=E(Ae);Ve=f(Mt,"0"),Mt.forEach(l),oe=f(kt,` will wait at the pipeline
            stage at index
            `),ce=g(kt,"CODE",{});var Ht=E(ce);Pe=f(Ht,"0"),Ht.forEach(l),Fe=f(kt,", the semaphore at index "),ke=g(kt,"CODE",{});var $r=E(ke);Te=f($r,"1"),$r.forEach(l),Me=f(kt,` will wait at
            the pipeline stage at index
            `),Ue=g(kt,"CODE",{});var Ut=E(Ue);qe=f(Ut,"1"),Ut.forEach(l),xe=f(kt,", etc."),kt.forEach(l),Ge=Y(Xe),ye=g(Xe,"LI",{});var or=E(ye);We=g(or,"CODE",{});var Xt=E(We);ze=f(Xt,"pSignalSemaphores"),Xt.forEach(l),Ye=g(or,"BR",{}),rt=f(or,`
            A list of pointers to `),S(Ne.$$.fragment,or),He=f(or," that are signaled when the "),S($t.$$.fragment,or),ut=f(or," have finished execution."),or.forEach(l),ht=Y(Xe),Je=g(Xe,"LI",{});var Vt=E(Je);dt=g(Vt,"CODE",{});var Zt=E(dt);et=f(Zt,"upFenceWorkCompleted"),Zt.forEach(l),Ze=g(Vt,"BR",{}),nt=f(Vt,`
            A `),S(Ke.$$.fragment,Vt),ct=f(Vt," to a "),S(st.$$.fragment,Vt),Qe=f(Vt,` that
            will be signaled once the `),S(at.$$.fragment,Vt),bt=f(Vt," have finished execution."),wt=g(Vt,"BR",{}),St=f(Vt,`
            To initialize this Fence, call `),S(tt.$$.fragment,Vt),ot=f(Vt,"."),Vt.forEach(l),Xe.forEach(l),this.h()},h(){z(e,"slot","params")},m(it,Xe){h(it,e,Xe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),D(G,X,null),o(X,te),o(e,ee),o(e,ne),o(ne,le),o(le,ae),o(ne,J),o(ne,ue),D(De,ne,null),o(ne,de),D(me,ne,null),o(ne,Ce),o(e,_e),o(e,se),o(se,ie),o(ie,ge),o(se,we),o(se,Re),D(Be,se,null),o(se,Ie),o(se,re),o(se,he),o(se,Ae),o(Ae,Ve),o(se,oe),o(se,ce),o(ce,Pe),o(se,Fe),o(se,ke),o(ke,Te),o(se,Me),o(se,Ue),o(Ue,qe),o(se,xe),o(e,Ge),o(e,ye),o(ye,We),o(We,ze),o(ye,Ye),o(ye,rt),D(Ne,ye,null),o(ye,He),D($t,ye,null),o(ye,ut),o(e,ht),o(e,Je),o(Je,dt),o(dt,et),o(Je,Ze),o(Je,nt),D(Ke,Je,null),o(Je,ct),D(st,Je,null),o(Je,Qe),D(at,Je,null),o(Je,bt),o(Je,wt),o(Je,St),D(tt,Je,null),o(Je,ot),At=!0},p(it,Xe){const Dt={};Xe&1&&(Dt.$$scope={dirty:Xe,ctx:it}),a.$set(Dt);const Ct={};Xe&1&&(Ct.$$scope={dirty:Xe,ctx:it}),A.$set(Ct);const pt={};Xe&1&&(pt.$$scope={dirty:Xe,ctx:it}),y.$set(pt);const yt={};Xe&1&&(yt.$$scope={dirty:Xe,ctx:it}),k.$set(yt);const mt={};Xe&1&&(mt.$$scope={dirty:Xe,ctx:it}),G.$set(mt);const Ot={};Xe&1&&(Ot.$$scope={dirty:Xe,ctx:it}),De.$set(Ot);const Pt={};Xe&1&&(Pt.$$scope={dirty:Xe,ctx:it}),me.$set(Pt);const Tt={};Xe&1&&(Tt.$$scope={dirty:Xe,ctx:it}),Be.$set(Tt);const vt={};Xe&1&&(vt.$$scope={dirty:Xe,ctx:it}),Ne.$set(vt);const gt={};Xe&1&&(gt.$$scope={dirty:Xe,ctx:it}),$t.$set(gt);const kt={};Xe&1&&(kt.$$scope={dirty:Xe,ctx:it}),Ke.$set(kt);const Ft={};Xe&1&&(Ft.$$scope={dirty:Xe,ctx:it}),st.$set(Ft);const Mt={};Xe&1&&(Mt.$$scope={dirty:Xe,ctx:it}),at.$set(Mt);const Ht={};Xe&1&&(Ht.$$scope={dirty:Xe,ctx:it}),tt.$set(Ht)},i(it){At||(b(a.$$.fragment,it),b(A.$$.fragment,it),b(y.$$.fragment,it),b(k.$$.fragment,it),b(G.$$.fragment,it),b(De.$$.fragment,it),b(me.$$.fragment,it),b(Be.$$.fragment,it),b(Ne.$$.fragment,it),b($t.$$.fragment,it),b(Ke.$$.fragment,it),b(st.$$.fragment,it),b(at.$$.fragment,it),b(tt.$$.fragment,it),At=!0)},o(it){w(a.$$.fragment,it),w(A.$$.fragment,it),w(y.$$.fragment,it),w(k.$$.fragment,it),w(G.$$.fragment,it),w(De.$$.fragment,it),w(me.$$.fragment,it),w(Be.$$.fragment,it),w(Ne.$$.fragment,it),w($t.$$.fragment,it),w(Ke.$$.fragment,it),w(st.$$.fragment,it),w(at.$$.fragment,it),w(tt.$$.fragment,it),At=!1},d(it){it&&l(e),C(a),C(A),C(y),C(k),C(G),C(De),C(me),C(Be),C(Ne),C($t),C(Ke),C(st),C(at),C(tt)}}}function ib(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return e=new $e({props:{language:pe,code:"#include <fillcan/commands/command_recording.hpp>"}}),r=new $e({props:{language:pe,code:`struct CommandRecording {
    Queue* pQueue;
    CommandPool* pCommandPool;
    std::vector<CommandBuffer*> pPrimaryCommandBuffers = {};
    std::vector<CommandBuffer*> pSecondaryCommandBuffers = {};
    std::vector<Semaphore*> pWaitSemaphores = {};
    VkPipelineStageFlags waitDstStageMask = 0;
    std::vector<Semaphore*> pSignalSemaphores = {};
    std::unique_ptr<Fence> upFenceWorkCompleted = nullptr;
};`}}),u=new H({props:{sectionID:L.QUEUE,$$slots:{default:[qE]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[WE]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.FENCE,$$slots:{default:[QE]},$$scope:{ctx:c}}}),T=new Se({props:{$$slots:{params:[lb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=i(`

The `),n=d("code"),s=i("Command Recording"),a=i(" structure is used by the "),I(u.$$.fragment),p=i(` to keep track of the information needed for recording commands and can be supplemented
with `),I(m.$$.fragment),_=i(" and a "),I(v.$$.fragment),R=i(" for synchronization purposes."),P=d("br"),A=j(),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=Y(B),S(r.$$.fragment,B),$=f(B,`

The `),n=g(B,"CODE",{});var M=E(n);s=f(M,"Command Recording"),M.forEach(l),a=f(B," structure is used by the "),S(u.$$.fragment,B),p=f(B,` to keep track of the information needed for recording commands and can be supplemented
with `),S(m.$$.fragment,B),_=f(B," and a "),S(v.$$.fragment,B),R=f(B," for synchronization purposes."),P=g(B,"BR",{}),A=Y(B),S(T.$$.fragment,B)},m(B,M){D(e,B,M),h(B,t,M),D(r,B,M),h(B,$,M),h(B,n,M),o(n,s),h(B,a,M),D(u,B,M),h(B,p,M),D(m,B,M),h(B,_,M),D(v,B,M),h(B,R,M),h(B,P,M),h(B,A,M),D(T,B,M),y=!0},p(B,[M]){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),u.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),m.$set(x);const F={};M&1&&(F.$$scope={dirty:M,ctx:B}),v.$set(F);const V={};M&1&&(V.$$scope={dirty:M,ctx:B}),T.$set(V)},i(B){y||(b(e.$$.fragment,B),b(r.$$.fragment,B),b(u.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),y=!0)},o(B){w(e.$$.fragment,B),w(r.$$.fragment,B),w(u.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),y=!1},d(B){C(e,B),B&&l(t),C(r,B),B&&l($),B&&l(n),B&&l(a),C(u,B),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(R),B&&l(P),B&&l(A),C(T,B)}}}class fb extends ve{constructor(e){super(),Ee(this,e,null,ib,be,{})}}function cb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $b(c){let e;return{c(){e=i("end")},l(t){e=f(t,"end")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ub(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pb(c){let e,t,r,$,n,s,a,u,p,m,_;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[cb]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.COMMAND_BUFFER_end,$$slots:{default:[$b]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[ub]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Ends all "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Calls `),I(a.$$.fragment),u=i(" on all "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=f(R,"Ends all "),S(r.$$.fragment,R),$=f(R,"."),n=g(R,"BR",{}),s=f(R,`
        Calls `),S(a.$$.fragment,R),u=f(R," on all "),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,R){h(v,e,R),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),r.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),a.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:v}),p.$set(T)},i(v){_||(b(r.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(r.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(r),C(a),C(p)}}}function mb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function db(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[mb]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[hb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if all "),I(n.$$.fragment),s=i(` were succesfully ended.
        `),a=d("code"),u=i("false"),p=i(" if not all "),I(m.$$.fragment),_=i(" could be ended."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(P," if all "),S(n.$$.fragment,P),s=f(P,` were succesfully ended.
        `),a=g(P,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(P," if not all "),S(m.$$.fragment,P),_=f(P," could be ended."),P.forEach(l),this.h()},h(){z(e,"slot","return")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),m.$set(T)},i(R){v||(b(n.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){R&&l(e),C(n),C(m)}}}function gb(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool endAll();"}}),r=new Se({props:{$$slots:{return:[db],details:[pb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _b extends ve{constructor(e){super(),Ee(this,e,null,gb,be,{})}}function vb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eb(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bb(c){let e;return{c(){e=i("submitRecordings")},l(t){e=f(t,"submitRecordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wb(c){let e,t,r,$,n,s,a,u,p,m,_;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[vb]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Eb]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.QUEUE_submitRecordings,$$slots:{default:[bb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Submit "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i("."),a=d("br"),u=i(`
        alls `),I(p.$$.fragment),m=i(" for this recording."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=f(R,"Submit "),S(r.$$.fragment,R),$=f(R," to the "),S(n.$$.fragment,R),s=f(R,"."),a=g(R,"BR",{}),u=f(R,`
        alls `),S(p.$$.fragment,R),m=f(R," for this recording."),R.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,R){h(v,e,R),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),r.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:v}),p.$set(T)},i(v){_||(b(r.$$.fragment,v),b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(r.$$.fragment,v),w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(r),C(n),C(p)}}}function Ib(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Db(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cb(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Ib]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Db]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the recording was succesfully submitted to the "),I(n.$$.fragment),s=i(`.
        `),a=d("code"),u=i("false"),p=i(" if the recording failed to submit to the "),I(m.$$.fragment),_=i("."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(P," if the recording was succesfully submitted to the "),S(n.$$.fragment,P),s=f(P,`.
        `),a=g(P,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(P," if the recording failed to submit to the "),S(m.$$.fragment,P),_=f(P,"."),P.forEach(l),this.h()},h(){z(e,"slot","return")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),m.$set(T)},i(R){v||(b(n.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){R&&l(e),C(n),C(m)}}}function Sb(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool submit();"}}),r=new Se({props:{$$slots:{return:[Cb],details:[wb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Rb extends ve{constructor(e){super(),Ee(this,e,null,Sb,be,{})}}function Ab(c){let e;return{c(){e=i("resetRecording")},l(t){e=f(t,"resetRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pb(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.QUEUE_resetRecording,$$slots:{default:[Ab]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Resets the recording and resets all structure variables to their default
        values.`),r=d("br"),$=i(`
        Calls `),I(n.$$.fragment),s=i(` for this recording before resetting all structure variables to their default
        values.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,`Resets the recording and resets all structure variables to their default
        values.`),r=g(p,"BR",{}),$=f(p,`
        Calls `),S(n.$$.fragment,p),s=f(p,` for this recording before resetting all structure variables to their default
        values.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Bb(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lb(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kb(c){let e,t,r,$,n,s,a,u,p,m;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Bb]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[Lb]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the `),I(a.$$.fragment),u=i(". This is a bitmask of "),I(p.$$.fragment),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"flags"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            Additional actions to perform while resetting the `),S(a.$$.fragment,R),u=f(R,". This is a bitmask of "),S(p.$$.fragment,R),R.forEach(l),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),a.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),p.$set(P)},i(_){m||(b(a.$$.fragment,_),b(p.$$.fragment,_),m=!0)},o(_){w(a.$$.fragment,_),w(p.$$.fragment,_),m=!1},d(_){_&&l(e),C(a),C(p)}}}function Tb(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the recording was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the recording failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the recording was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the recording failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function Ob(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool reset(VkCommandBufferResetFlags flags = 0);"}}),r=new Se({props:{$$slots:{return:[Tb],params:[kb],details:[Pb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Vb extends ve{constructor(e){super(),Ee(this,e,null,Ob,be,{})}}function yb(c){let e;return{c(){e=i("freeRecording")},l(t){e=f(t,"freeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mb(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.QUEUE_freeRecording,$$slots:{default:[yb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free this recording."),r=d("br"),$=i(`
        Calls `),I(n.$$.fragment),s=i(" for this recording."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Free this recording."),r=g(p,"BR",{}),$=f(p,`
        Calls `),S(n.$$.fragment,p),s=f(p," for this recording."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Fb(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void free();"}}),r=new Se({props:{$$slots:{details:[Mb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class xb extends ve{constructor(e){super(),Ee(this,e,null,Fb,be,{})}}function Nb(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ub(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gb(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.FENCE,$$slots:{default:[Nb]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Ub]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i(` which will
        be signaled once this recording has been submitted to the `),I(n.$$.fragment),s=i(" and all work has finished execution."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a "),S(r.$$.fragment,p),$=f(p,` which will
        be signaled once this recording has been submitted to the `),S(n.$$.fragment,p),s=f(p," and all work has finished execution."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Hb(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qb(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wb(c){let e;return{c(){e=i("VkFenceCreateFlagBits")},l(t){e=f(t,"VkFenceCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qb(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kb(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Hb]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.FENCE,$$slots:{default:[qb]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html",target:"_blank",$$slots:{default:[Wb]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.FENCE,$$slots:{default:[Qb]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" that should own the "),I(p.$$.fragment),m=i("."),_=j(),v=d("li"),R=d("code"),P=i("flags"),A=d("br"),T=i(`
            A bitmask of `),I(y.$$.fragment),B=i(" specifying the initial state and behavior of the "),I(M.$$.fragment),O=i("."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"pLogicalDevice"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            The `),S(a.$$.fragment,q),u=f(q," that should own the "),S(p.$$.fragment,q),m=f(q,"."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"flags"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            A bitmask of `),S(y.$$.fragment,N),B=f(N," specifying the initial state and behavior of the "),S(M.$$.fragment,N),O=f(N,"."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function zb(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void createFence(LogicalDevice* pLogicalDevice, VkFenceCreateFlags flags = 0);"}}),r=new Se({props:{$$slots:{params:[Kb],details:[Gb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jb extends ve{constructor(e){super(),Ee(this,e,null,zb,be,{})}}function Yb(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xb(c){let e;return{c(){e=i("createFence")},l(t){e=f(t,"createFence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zb(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.FENCE,$$slots:{default:[Yb]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMMAND_RECORDING_createFence,$$slots:{default:[Xb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the "),I(r.$$.fragment),$=i(` defined
        with `),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Wait for the "),S(r.$$.fragment,p),$=f(p,` defined
        with `),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Jb(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("timeout"),n=d("br"),s=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"timeout"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The timeout period in units of nanoseconds to wait before returning.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function e1(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t1(c){let e,t,r,$,n,s,a,u,p,m;return n=new H({props:{sectionID:L.FENCE,$$slots:{default:[e1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the "),I(n.$$.fragment),s=i(" was succesfully waited for. "),a=d("code"),u=i("false"),p=i(" if the timeout expired."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=g(v,"CODE",{});var R=E(t);r=f(R,"true"),R.forEach(l),$=f(v," if the "),S(n.$$.fragment,v),s=f(v," was succesfully waited for. "),a=g(v,"CODE",{});var P=E(a);u=f(P,"false"),P.forEach(l),p=f(v," if the timeout expired."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),n.$set(R)},i(_){m||(b(n.$$.fragment,_),m=!0)},o(_){w(n.$$.fragment,_),m=!1},d(_){_&&l(e),C(n)}}}function r1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool waitForFence(uint64_t timeout = UINT64_MAX);"}}),r=new Se({props:{$$slots:{return:[t1],params:[Jb],details:[Zb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class n1 extends ve{constructor(e){super(),Ee(this,e,null,r1,be,{})}}function s1(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a1(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o1(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l1(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u1(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p1(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/swapchain.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[s1]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.WINDOW,$$slots:{default:[a1]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.QUEUE,$$slots:{default:[o1]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.WINDOW,$$slots:{default:[l1]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.IMAGE,$$slots:{default:[i1]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.IMAGE,$$slots:{default:[f1]},$$scope:{ctx:c}}}),q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[c1]},$$scope:{ctx:c}}}),N=new H({props:{sectionID:L.IMAGE,$$slots:{default:[$1]},$$scope:{ctx:c}}}),K=new H({props:{sectionID:L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[u1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Swapchain"),n=i(" class takes in a pointer to the "),I(s.$$.fragment),a=i(", the "),I(u.$$.fragment),p=i(` and the present
`),I(m.$$.fragment),_=i(`. It uses this
information to prepare special image objects we can use to present to the `),I(v.$$.fragment),R=i(" surface."),P=d("br"),A=d("br"),T=i(`
Swapchain objects are used to ask the window system to create one or more images
that can be used to present on a Vulkan surface (this is visible with the
`),y=d("code"),B=i("VK_KHR_surface"),M=i(`
extension). Each Swapchain object manages a series of `),I(O.$$.fragment),x=i(`, usually in some form of a ring buffer. The application can ask the Swapchain
for the next available `),I(F.$$.fragment),V=i(`,
render to it, and then return the `),I(q.$$.fragment),k=i(` to the swapchain ready for display. By managing presentable images in a ring or
queue, one `),I(N.$$.fragment),Q=i(` can be displayed
on the screen while another is drawn to by the application, overlapping the operation
of the window system and the application.`),X=d("br"),Z=i(`
It is recommended to create Swapchains using `),I(K.$$.fragment),W=i(".")},l(G){S(e.$$.fragment,G),t=f(G,`
The `),r=g(G,"CODE",{});var te=E(r);$=f(te,"Swapchain"),te.forEach(l),n=f(G," class takes in a pointer to the "),S(s.$$.fragment,G),a=f(G,", the "),S(u.$$.fragment,G),p=f(G,` and the present
`),S(m.$$.fragment,G),_=f(G,`. It uses this
information to prepare special image objects we can use to present to the `),S(v.$$.fragment,G),R=f(G," surface."),P=g(G,"BR",{}),A=g(G,"BR",{}),T=f(G,`
Swapchain objects are used to ask the window system to create one or more images
that can be used to present on a Vulkan surface (this is visible with the
`),y=g(G,"CODE",{});var ee=E(y);B=f(ee,"VK_KHR_surface"),ee.forEach(l),M=f(G,`
extension). Each Swapchain object manages a series of `),S(O.$$.fragment,G),x=f(G,`, usually in some form of a ring buffer. The application can ask the Swapchain
for the next available `),S(F.$$.fragment,G),V=f(G,`,
render to it, and then return the `),S(q.$$.fragment,G),k=f(G,` to the swapchain ready for display. By managing presentable images in a ring or
queue, one `),S(N.$$.fragment,G),Q=f(G,` can be displayed
on the screen while another is drawn to by the application, overlapping the operation
of the window system and the application.`),X=g(G,"BR",{}),Z=f(G,`
It is recommended to create Swapchains using `),S(K.$$.fragment,G),W=f(G,".")},m(G,te){D(e,G,te),h(G,t,te),h(G,r,te),o(r,$),h(G,n,te),D(s,G,te),h(G,a,te),D(u,G,te),h(G,p,te),D(m,G,te),h(G,_,te),D(v,G,te),h(G,R,te),h(G,P,te),h(G,A,te),h(G,T,te),h(G,y,te),o(y,B),h(G,M,te),D(O,G,te),h(G,x,te),D(F,G,te),h(G,V,te),D(q,G,te),h(G,k,te),D(N,G,te),h(G,Q,te),h(G,X,te),h(G,Z,te),D(K,G,te),h(G,W,te),U=!0},p(G,[te]){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:G}),s.$set(ee);const ne={};te&1&&(ne.$$scope={dirty:te,ctx:G}),u.$set(ne);const le={};te&1&&(le.$$scope={dirty:te,ctx:G}),m.$set(le);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:G}),v.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:G}),O.$set(J);const ue={};te&1&&(ue.$$scope={dirty:te,ctx:G}),F.$set(ue);const De={};te&1&&(De.$$scope={dirty:te,ctx:G}),q.$set(De);const de={};te&1&&(de.$$scope={dirty:te,ctx:G}),N.$set(de);const me={};te&1&&(me.$$scope={dirty:te,ctx:G}),K.$set(me)},i(G){U||(b(e.$$.fragment,G),b(s.$$.fragment,G),b(u.$$.fragment,G),b(m.$$.fragment,G),b(v.$$.fragment,G),b(O.$$.fragment,G),b(F.$$.fragment,G),b(q.$$.fragment,G),b(N.$$.fragment,G),b(K.$$.fragment,G),U=!0)},o(G){w(e.$$.fragment,G),w(s.$$.fragment,G),w(u.$$.fragment,G),w(m.$$.fragment,G),w(v.$$.fragment,G),w(O.$$.fragment,G),w(F.$$.fragment,G),w(q.$$.fragment,G),w(N.$$.fragment,G),w(K.$$.fragment,G),U=!1},d(G){C(e,G),G&&l(t),G&&l(r),G&&l(n),C(s,G),G&&l(a),C(u,G),G&&l(p),C(m,G),G&&l(_),C(v,G),G&&l(R),G&&l(P),G&&l(A),G&&l(T),G&&l(y),G&&l(M),C(O,G),G&&l(x),C(F,G),G&&l(V),C(q,G),G&&l(k),C(N,G),G&&l(Q),G&&l(X),G&&l(Z),C(K,G),G&&l(W)}}}class m1 extends ve{constructor(e){super(),Ee(this,e,null,p1,be,{})}}function h1(c){let e,t;return{c(){e=d("span"),t=i("Create a new Swapchain."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Swapchain."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function d1(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g1(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v1(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b1(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w1(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[d1]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.WINDOW,$$slots:{default:[g1]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[_1]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.QUEUE,$$slots:{default:[v1]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.IMAGE,$$slots:{default:[E1]},$$scope:{ctx:c}}}),oe=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[b1]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to associate the Swapchain with."),p=j(),m=d("li"),_=d("code"),v=i("pWindow"),R=d("br"),P=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" whose surface the Swapchain should make presentable "),I(y.$$.fragment),B=i(" for."),M=j(),O=d("li"),x=d("code"),F=i("pPresentQueue"),V=d("br"),q=i(`
            The `),I(k.$$.fragment),N=i(` which the
            Swapchain should use for presentation.`),Q=j(),X=d("li"),Z=d("code"),K=i("imageCount"),W=d("br"),U=i(`
            The amount of `),I(G.$$.fragment),te=i(" the Swapchain should prepare."),ee=d("br"),ne=i(`
            Setting `),le=d("code"),ae=i("imageCount"),J=i(` to 2 enables double buffering.
            Setting `),ue=d("code"),De=i("imageCount"),de=i(`
            to 3 enables triple buffering. Setting `),me=d("code"),Ce=i("imageCount"),_e=i(` to 1
            represents a request to render directly to the frontbuffer or to the
            screen.`),se=d("br"),ie=i(`
            Setting `),ge=d("code"),we=i("imageCount"),Re=i(` to 2 means that one frontbuffer and one
            backbuffer will be created. After the presentation of a completed backbuffer
            is activated, rendering to the frontbuffer cannot begin until the presentation
            of the frontbuffer has completed.`),Be=j(),Ie=d("li"),re=d("code"),he=i("presentMode"),Ae=d("br"),Ve=i(`
            The presentation mode for the surface. This should be a member of the
            `),I(oe.$$.fragment),ce=i("-enumerant."),Pe=j(),Fe=d("li"),ke=d("code"),Te=i("pOldSwapchain"),Me=d("br"),Ue=i(`
            A pointer to the old Swapchain which can be used to return an existing
            Swapchain associated with the surface to Vulkan for recycling. This will
            be used when one Swapchain is replaced by another, such as when a Window
            is resized and the Swapchain needs to be remapped with larger images.`),this.h()},l(xe){e=g(xe,"DIV",{slot:!0});var Ge=E(e);t=g(Ge,"LI",{});var ye=E(t);r=g(ye,"CODE",{});var We=E(r);$=f(We,"pLogicalDevice"),We.forEach(l),n=g(ye,"BR",{}),s=f(ye,`
            A pointer to the `),S(a.$$.fragment,ye),u=f(ye," to associate the Swapchain with."),ye.forEach(l),p=Y(Ge),m=g(Ge,"LI",{});var ze=E(m);_=g(ze,"CODE",{});var Ye=E(_);v=f(Ye,"pWindow"),Ye.forEach(l),R=g(ze,"BR",{}),P=f(ze,`
            A pointer to the `),S(A.$$.fragment,ze),T=f(ze," whose surface the Swapchain should make presentable "),S(y.$$.fragment,ze),B=f(ze," for."),ze.forEach(l),M=Y(Ge),O=g(Ge,"LI",{});var rt=E(O);x=g(rt,"CODE",{});var Ne=E(x);F=f(Ne,"pPresentQueue"),Ne.forEach(l),V=g(rt,"BR",{}),q=f(rt,`
            The `),S(k.$$.fragment,rt),N=f(rt,` which the
            Swapchain should use for presentation.`),rt.forEach(l),Q=Y(Ge),X=g(Ge,"LI",{});var He=E(X);Z=g(He,"CODE",{});var $t=E(Z);K=f($t,"imageCount"),$t.forEach(l),W=g(He,"BR",{}),U=f(He,`
            The amount of `),S(G.$$.fragment,He),te=f(He," the Swapchain should prepare."),ee=g(He,"BR",{}),ne=f(He,`
            Setting `),le=g(He,"CODE",{});var ut=E(le);ae=f(ut,"imageCount"),ut.forEach(l),J=f(He,` to 2 enables double buffering.
            Setting `),ue=g(He,"CODE",{});var ht=E(ue);De=f(ht,"imageCount"),ht.forEach(l),de=f(He,`
            to 3 enables triple buffering. Setting `),me=g(He,"CODE",{});var Je=E(me);Ce=f(Je,"imageCount"),Je.forEach(l),_e=f(He,` to 1
            represents a request to render directly to the frontbuffer or to the
            screen.`),se=g(He,"BR",{}),ie=f(He,`
            Setting `),ge=g(He,"CODE",{});var dt=E(ge);we=f(dt,"imageCount"),dt.forEach(l),Re=f(He,` to 2 means that one frontbuffer and one
            backbuffer will be created. After the presentation of a completed backbuffer
            is activated, rendering to the frontbuffer cannot begin until the presentation
            of the frontbuffer has completed.`),He.forEach(l),Be=Y(Ge),Ie=g(Ge,"LI",{});var et=E(Ie);re=g(et,"CODE",{});var Ze=E(re);he=f(Ze,"presentMode"),Ze.forEach(l),Ae=g(et,"BR",{}),Ve=f(et,`
            The presentation mode for the surface. This should be a member of the
            `),S(oe.$$.fragment,et),ce=f(et,"-enumerant."),et.forEach(l),Pe=Y(Ge),Fe=g(Ge,"LI",{});var nt=E(Fe);ke=g(nt,"CODE",{});var Ke=E(ke);Te=f(Ke,"pOldSwapchain"),Ke.forEach(l),Me=g(nt,"BR",{}),Ue=f(nt,`
            A pointer to the old Swapchain which can be used to return an existing
            Swapchain associated with the surface to Vulkan for recycling. This will
            be used when one Swapchain is replaced by another, such as when a Window
            is resized and the Swapchain needs to be remapped with larger images.`),nt.forEach(l),Ge.forEach(l),this.h()},h(){z(e,"slot","params")},m(xe,Ge){h(xe,e,Ge),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),D(G,X,null),o(X,te),o(X,ee),o(X,ne),o(X,le),o(le,ae),o(X,J),o(X,ue),o(ue,De),o(X,de),o(X,me),o(me,Ce),o(X,_e),o(X,se),o(X,ie),o(X,ge),o(ge,we),o(X,Re),o(e,Be),o(e,Ie),o(Ie,re),o(re,he),o(Ie,Ae),o(Ie,Ve),D(oe,Ie,null),o(Ie,ce),o(e,Pe),o(e,Fe),o(Fe,ke),o(ke,Te),o(Fe,Me),o(Fe,Ue),qe=!0},p(xe,Ge){const ye={};Ge&1&&(ye.$$scope={dirty:Ge,ctx:xe}),a.$set(ye);const We={};Ge&1&&(We.$$scope={dirty:Ge,ctx:xe}),A.$set(We);const ze={};Ge&1&&(ze.$$scope={dirty:Ge,ctx:xe}),y.$set(ze);const Ye={};Ge&1&&(Ye.$$scope={dirty:Ge,ctx:xe}),k.$set(Ye);const rt={};Ge&1&&(rt.$$scope={dirty:Ge,ctx:xe}),G.$set(rt);const Ne={};Ge&1&&(Ne.$$scope={dirty:Ge,ctx:xe}),oe.$set(Ne)},i(xe){qe||(b(a.$$.fragment,xe),b(A.$$.fragment,xe),b(y.$$.fragment,xe),b(k.$$.fragment,xe),b(G.$$.fragment,xe),b(oe.$$.fragment,xe),qe=!0)},o(xe){w(a.$$.fragment,xe),w(A.$$.fragment,xe),w(y.$$.fragment,xe),w(k.$$.fragment,xe),w(G.$$.fragment,xe),w(oe.$$.fragment,xe),qe=!1},d(xe){xe&&l(e),C(a),C(A),C(y),C(k),C(G),C(oe)}}}function I1(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C1(c){let e,t,r,$,n,s,a,u,p;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[I1]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[D1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created or the Swapchain "),I(a.$$.fragment),u=i(" failed to query."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_," if the "),S(n.$$.fragment,_),s=f(_," couldn't be created or the Swapchain "),S(a.$$.fragment,_),u=f(_," failed to query."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function S1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Swapchain(
        LogicalDevice* pLogicalDevice, 
        Window* pWindow, 
        Queue* pPresentQueue, 
        uint32_t imageCount = 3,
        VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR, 
        Swapchain* pOldSwapchain = nullptr
);`}}),r=new Se({props:{$$slots:{throws:[C1],params:[w1],details:[h1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class R1 extends ve{constructor(e){super(),Ee(this,e,null,S1,be,{})}}function A1(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P1(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[A1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function B1(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L1(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[B1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function k1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkSwapchainKHR getSwapchainHandle() const;"}}),r=new Se({props:{$$slots:{return:[L1],details:[P1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class T1 extends ve{constructor(e){super(),Ee(this,e,null,k1,be,{})}}function O1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V1(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[O1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the next available Swapchain "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        The images of the Swapchain are not immediately usable. Before data can be
        written into it, the next available image must be obtained.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the next available Swapchain "),S(r.$$.fragment,p),$=f(p,"."),n=g(p,"BR",{}),s=f(p,`
        The images of the Swapchain are not immediately usable. Before data can be
        written into it, the next available image must be obtained.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(r.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),a=!1},d(u){u&&l(e),C(r)}}}function y1(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F1(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.FENCE,$$slots:{default:[y1]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[M1]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pFence"),n=d("br"),s=i(`
            A pointer to a `),I(a.$$.fragment),u=i(" which will be signaled once it's safe to render to the acquired "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pFence"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to a `),S(a.$$.fragment,P),u=f(P," which will be signaled once it's safe to render to the acquired "),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function x1(c){let e;return{c(){e=i("SwapchainImage")},l(t){e=f(t,"SwapchainImage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N1(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.SWAPCHAIN_Swapchain_Image,$$slots:{default:[x1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-struct containing the necessary information for
        rendering to the Swapchain Image.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-struct containing the necessary information for
        rendering to the Swapchain Image.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function U1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"SwapchainImage getNextImage(Fence* pFence = nullptr);"}}),r=new Se({props:{$$slots:{return:[N1],params:[F1],details:[V1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class G1 extends ve{constructor(e){super(),Ee(this,e,null,U1,be,{})}}function H1(c){let e,t;return{c(){e=d("span"),t=i("Get the intended Swapchain format and colorspace pair."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended Swapchain format and colorspace pair."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function q1(c){let e;return{c(){e=i("VkSurfaceFormatKHR")},l(t){e=f(t,"VkSurfaceFormatKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W1(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html",target:"_blank",$$slots:{default:[q1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure describing the intended Swapchain format and colorspace
        pair.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-structure describing the intended Swapchain format and colorspace
        pair.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Q1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSurfaceFormatKHR getSurfaceFormat();"}}),r=new Se({props:{$$slots:{return:[W1],details:[H1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class K1 extends ve{constructor(e){super(),Ee(this,e,null,Q1,be,{})}}function z1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j1(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[z1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the amount of Swapchain "),I(r.$$.fragment),$=i(" supported by this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the amount of Swapchain "),S(r.$$.fragment,a),$=f(a," supported by this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Y1(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X1(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Y1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The amount of Swapchain "),I(r.$$.fragment),$=i(" supported by this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The amount of Swapchain "),S(r.$$.fragment,a),$=f(a," supported by this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Z1(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"uint32_t getImageCount();"}}),r=new Se({props:{$$slots:{return:[X1],details:[j1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class J1 extends ve{constructor(e){super(),Ee(this,e,null,Z1,be,{})}}function ew(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tw(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ew]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the amount of array layers a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain supports."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the amount of array layers a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain supports."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nw(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[rw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The amount of array layers a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain supports."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The amount of array layers a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain supports."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function sw(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getImageArrayLayers();"}}),r=new Se({props:{$$slots:{return:[nw],details:[tw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aw extends ve{constructor(e){super(),Ee(this,e,null,sw,be,{})}}function ow(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lw(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ow]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the supported usage for a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the supported usage for a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function iw(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cw(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[iw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[fw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A bitmap of "),I(r.$$.fragment),$=i(" describing the supported usage for a Swapchain "),I(n.$$.fragment),s=i(" of this Swapchain."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A bitmap of "),S(r.$$.fragment,p),$=f(p," describing the supported usage for a Swapchain "),S(n.$$.fragment,p),s=f(p," of this Swapchain."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function $w(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageUsageFlags getImageUsage();"}}),r=new Se({props:{$$slots:{return:[cw],details:[lw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uw extends ve{constructor(e){super(),Ee(this,e,null,$w,be,{})}}function pw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hw(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dw(c){let e,t,r,$,n,s,a,u,p;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[pw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[mw]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.QUEUE,$$slots:{default:[hw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(` sharing
        mode describing how the Swapchain `),I(n.$$.fragment),s=i(" of this Swapchain can be accessed from "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Get the "),S(r.$$.fragment,_),$=f(_,` sharing
        mode describing how the Swapchain `),S(n.$$.fragment,_),s=f(_," of this Swapchain can be accessed from "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),n.$set(R);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function gw(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _w(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vw(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ew(c){let e,t,r,$,n,s,a,u,p;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[gw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[_w]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[vw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A member of the "),I(r.$$.fragment),$=i("-enumerant describing the "),I(n.$$.fragment),s=i(" sharing mode for the Swapchain "),I(a.$$.fragment),u=i(" of this Swapchain."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"A member of the "),S(r.$$.fragment,_),$=f(_,"-enumerant describing the "),S(n.$$.fragment,_),s=f(_," sharing mode for the Swapchain "),S(a.$$.fragment,_),u=f(_," of this Swapchain."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),n.$set(R);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function bw(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSharingMode getImageSharingMode();"}}),r=new Se({props:{$$slots:{return:[Ew],details:[dw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ww extends ve{constructor(e){super(),Ee(this,e,null,bw,be,{})}}function Iw(c){let e,t;return{c(){e=d("span"),t=i("Get the current presentation mode for the surface of this Swapchain."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the current presentation mode for the surface of this Swapchain."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Dw(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cw(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[Dw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A member of the "),I(r.$$.fragment),$=i("-enumerant describing the current presentation mode of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A member of the "),S(r.$$.fragment,a),$=f(a,"-enumerant describing the current presentation mode of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Sw(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkPresentModeKHR getPresentMode();"}}),r=new Se({props:{$$slots:{return:[Cw],details:[Iw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Rw extends ve{constructor(e){super(),Ee(this,e,null,Sw,be,{})}}function Aw(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pw(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Aw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the extent (the width and height) of the Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the extent (the width and height) of the Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Bw(c){let e;return{c(){e=i("VkExtent2D")},l(t){e=f(t,"VkExtent2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lw(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kw(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[Bw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Lw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure describing the width and height of the Swapchain
        `),I(n.$$.fragment),s=i(" of this Swapchain."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p,`-structure describing the width and height of the Swapchain
        `),S(n.$$.fragment,p),s=f(p," of this Swapchain."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Tw(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkExtent2D getImageExtent();"}}),r=new Se({props:{$$slots:{return:[kw],details:[Pw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ow extends ve{constructor(e){super(),Ee(this,e,null,Tw,be,{})}}function Vw(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mw(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fw(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xw(c){let e,t,r,$,n,s,a,u,p=je().Fillcan.version+"",m,_,v,R,P,A,T;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Vw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[yw]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Mw]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Fw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(` families between
        which an `),I(n.$$.fragment),s=i(" is shared."),a=d("br"),u=i(`
        For Fillcan version `),m=i(p),_=i(` this list will always be
        empty, as shared `),I(v.$$.fragment),R=i(" are not yet supported for Swapchain "),I(P.$$.fragment),A=i("."),this.h()},l(y){e=g(y,"SPAN",{slot:!0});var B=E(e);t=f(B,"The "),S(r.$$.fragment,B),$=f(B,` families between
        which an `),S(n.$$.fragment,B),s=f(B," is shared."),a=g(B,"BR",{}),u=f(B,`
        For Fillcan version `),m=f(B,p),_=f(B,` this list will always be
        empty, as shared `),S(v.$$.fragment,B),R=f(B," are not yet supported for Swapchain "),S(P.$$.fragment,B),A=f(B,"."),B.forEach(l),this.h()},h(){z(e,"slot","details")},m(y,B){h(y,e,B),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,m),o(e,_),D(v,e,null),o(e,R),D(P,e,null),o(e,A),T=!0},p(y,B){const M={};B&1&&(M.$$scope={dirty:B,ctx:y}),r.$set(M);const O={};B&1&&(O.$$scope={dirty:B,ctx:y}),n.$set(O);const x={};B&1&&(x.$$scope={dirty:B,ctx:y}),v.$set(x);const F={};B&1&&(F.$$scope={dirty:B,ctx:y}),P.$set(F)},i(y){T||(b(r.$$.fragment,y),b(n.$$.fragment,y),b(v.$$.fragment,y),b(P.$$.fragment,y),T=!0)},o(y){w(r.$$.fragment,y),w(n.$$.fragment,y),w(v.$$.fragment,y),w(P.$$.fragment,y),T=!1},d(y){y&&l(e),C(r),C(n),C(v),C(P)}}}function Nw(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gw(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Nw]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Uw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i(` family
        indices between which an `),I(n.$$.fragment),s=i(" is shared."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,` family
        indices between which an `),S(n.$$.fragment,p),s=f(p," is shared."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Hw(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[Gw],details:[xw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qw extends ve{constructor(e){super(),Ee(this,e,null,Hw,be,{})}}function Ww(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qw(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kw(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Ww]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.WINDOW,$$slots:{default:[Qw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Present a Swapchain "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Present a Swapchain "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function zw(c){let e;return{c(){e=i("SwapchainImage")},l(t){e=f(t,"SwapchainImage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yw(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xw(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zw(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.SWAPCHAIN_Swapchain_Image,$$slots:{default:[zw]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[jw]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[Yw]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Xw]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pSwapchainImage"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i("-structure containing the "),I(p.$$.fragment),m=i(" that should be presented."),_=j(),v=d("li"),R=d("code"),P=i("waitSemaphores"),A=d("br"),T=i(`
            The `),I(y.$$.fragment),B=i(" to wait for before presenting the "),I(M.$$.fragment),O=i("."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"pSwapchainImage"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A pointer to the `),S(a.$$.fragment,q),u=f(q,"-structure containing the "),S(p.$$.fragment,q),m=f(q," that should be presented."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"waitSemaphores"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The `),S(y.$$.fragment,N),B=f(N," to wait for before presenting the "),S(M.$$.fragment,N),O=f(N,"."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function Jw(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the presentation was succesful. "),n=d("code"),s=i("false"),a=i(` if
        the presentation failed.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the presentation was succesful. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if
        the presentation failed.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function eI(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool present(SwapchainImage* pSwapchainImage, std::vector<VkSemaphore> waitSemaphores);"}}),r=new Se({props:{$$slots:{return:[Jw],params:[Zw],details:[Kw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tI extends ve{constructor(e){super(),Ee(this,e,null,eI,be,{})}}function rI(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nI(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aI(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lI(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fI(c){let e;return{c(){e=i("Semaphore")},l(t){e=f(t,"Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $I(c){let e;return{c(){e=i("Semaphore")},l(t){e=f(t,"Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pI(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe;return a=new H({props:{sectionID:L.WINDOW,$$slots:{default:[nI]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[sI]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[aI]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.IMAGE,$$slots:{default:[oI]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[lI]},$$scope:{ctx:c}}}),ee=new H({props:{sectionID:L.IMAGE,$$slots:{default:[iI]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[fI]},$$scope:{ctx:c}}}),_e=new H({props:{sectionID:L.IMAGE,$$slots:{default:[cI]},$$scope:{ctx:c}}}),re=new H({props:{sectionID:L.SEMAPHORE,$$slots:{default:[$I]},$$scope:{ctx:c}}}),Ae=new H({props:{sectionID:L.IMAGE,$$slots:{default:[uI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("outOfDate"),n=d("br"),s=i(`
            Whether the Swapchain has become incompatible with the surface and can
            no longer be used for rendering. Usually happens after a `),I(a.$$.fragment),u=i(" resize."),p=j(),m=d("li"),_=d("code"),v=i("index"),R=d("br"),P=i(`
            The index of the Swapchain `),I(A.$$.fragment),T=i("."),y=j(),B=d("li"),M=d("code"),O=i("pSwapchainImageView"),x=d("br"),F=i(`
            A pointer to the `),I(V.$$.fragment),q=i(" of the Swapchain "),I(k.$$.fragment),N=i("."),Q=j(),X=d("li"),Z=d("code"),K=i("pDepthImageView"),W=d("br"),U=i(`
            A pointer to the Depth `),I(G.$$.fragment),te=i(" for the Swapchain "),I(ee.$$.fragment),ne=i("."),le=j(),ae=d("li"),J=d("code"),ue=i("pSemaphoreImageReady"),De=d("br"),de=i(`
            A pointer to a `),I(me.$$.fragment),Ce=i(" which will be signaled once the "),I(_e.$$.fragment),se=i(" can be rendered to."),ie=j(),ge=d("li"),we=d("code"),Re=i("pSemaphorePresentReady"),Be=d("br"),Ie=i(`
            A pointer to a `),I(re.$$.fragment),he=i(" which will be signaled once the "),I(Ae.$$.fragment),Ve=i(" can be presented."),this.h()},l(ce){e=g(ce,"SPAN",{slot:!0});var Pe=E(e);t=g(Pe,"LI",{});var Fe=E(t);r=g(Fe,"CODE",{});var ke=E(r);$=f(ke,"outOfDate"),ke.forEach(l),n=g(Fe,"BR",{}),s=f(Fe,`
            Whether the Swapchain has become incompatible with the surface and can
            no longer be used for rendering. Usually happens after a `),S(a.$$.fragment,Fe),u=f(Fe," resize."),Fe.forEach(l),p=Y(Pe),m=g(Pe,"LI",{});var Te=E(m);_=g(Te,"CODE",{});var Me=E(_);v=f(Me,"index"),Me.forEach(l),R=g(Te,"BR",{}),P=f(Te,`
            The index of the Swapchain `),S(A.$$.fragment,Te),T=f(Te,"."),Te.forEach(l),y=Y(Pe),B=g(Pe,"LI",{});var Ue=E(B);M=g(Ue,"CODE",{});var qe=E(M);O=f(qe,"pSwapchainImageView"),qe.forEach(l),x=g(Ue,"BR",{}),F=f(Ue,`
            A pointer to the `),S(V.$$.fragment,Ue),q=f(Ue," of the Swapchain "),S(k.$$.fragment,Ue),N=f(Ue,"."),Ue.forEach(l),Q=Y(Pe),X=g(Pe,"LI",{});var xe=E(X);Z=g(xe,"CODE",{});var Ge=E(Z);K=f(Ge,"pDepthImageView"),Ge.forEach(l),W=g(xe,"BR",{}),U=f(xe,`
            A pointer to the Depth `),S(G.$$.fragment,xe),te=f(xe," for the Swapchain "),S(ee.$$.fragment,xe),ne=f(xe,"."),xe.forEach(l),le=Y(Pe),ae=g(Pe,"LI",{});var ye=E(ae);J=g(ye,"CODE",{});var We=E(J);ue=f(We,"pSemaphoreImageReady"),We.forEach(l),De=g(ye,"BR",{}),de=f(ye,`
            A pointer to a `),S(me.$$.fragment,ye),Ce=f(ye," which will be signaled once the "),S(_e.$$.fragment,ye),se=f(ye," can be rendered to."),ye.forEach(l),ie=Y(Pe),ge=g(Pe,"LI",{});var ze=E(ge);we=g(ze,"CODE",{});var Ye=E(we);Re=f(Ye,"pSemaphorePresentReady"),Ye.forEach(l),Be=g(ze,"BR",{}),Ie=f(ze,`
            A pointer to a `),S(re.$$.fragment,ze),he=f(ze," which will be signaled once the "),S(Ae.$$.fragment,ze),Ve=f(ze," can be presented."),ze.forEach(l),Pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Pe){h(ce,e,Pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),D(G,X,null),o(X,te),D(ee,X,null),o(X,ne),o(e,le),o(e,ae),o(ae,J),o(J,ue),o(ae,De),o(ae,de),D(me,ae,null),o(ae,Ce),D(_e,ae,null),o(ae,se),o(e,ie),o(e,ge),o(ge,we),o(we,Re),o(ge,Be),o(ge,Ie),D(re,ge,null),o(ge,he),D(Ae,ge,null),o(ge,Ve),oe=!0},p(ce,Pe){const Fe={};Pe&1&&(Fe.$$scope={dirty:Pe,ctx:ce}),a.$set(Fe);const ke={};Pe&1&&(ke.$$scope={dirty:Pe,ctx:ce}),A.$set(ke);const Te={};Pe&1&&(Te.$$scope={dirty:Pe,ctx:ce}),V.$set(Te);const Me={};Pe&1&&(Me.$$scope={dirty:Pe,ctx:ce}),k.$set(Me);const Ue={};Pe&1&&(Ue.$$scope={dirty:Pe,ctx:ce}),G.$set(Ue);const qe={};Pe&1&&(qe.$$scope={dirty:Pe,ctx:ce}),ee.$set(qe);const xe={};Pe&1&&(xe.$$scope={dirty:Pe,ctx:ce}),me.$set(xe);const Ge={};Pe&1&&(Ge.$$scope={dirty:Pe,ctx:ce}),_e.$set(Ge);const ye={};Pe&1&&(ye.$$scope={dirty:Pe,ctx:ce}),re.$set(ye);const We={};Pe&1&&(We.$$scope={dirty:Pe,ctx:ce}),Ae.$set(We)},i(ce){oe||(b(a.$$.fragment,ce),b(A.$$.fragment,ce),b(V.$$.fragment,ce),b(k.$$.fragment,ce),b(G.$$.fragment,ce),b(ee.$$.fragment,ce),b(me.$$.fragment,ce),b(_e.$$.fragment,ce),b(re.$$.fragment,ce),b(Ae.$$.fragment,ce),oe=!0)},o(ce){w(a.$$.fragment,ce),w(A.$$.fragment,ce),w(V.$$.fragment,ce),w(k.$$.fragment,ce),w(G.$$.fragment,ce),w(ee.$$.fragment,ce),w(me.$$.fragment,ce),w(_e.$$.fragment,ce),w(re.$$.fragment,ce),w(Ae.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(a),C(A),C(V),C(k),C(G),C(ee),C(me),C(_e),C(re),C(Ae)}}}function mI(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:`struct SwapchainImage {
    bool outOfDate;
    unsigned int index;
    ImageView* pSwapchainImageView;
    ImageView* pDepthImageView;
    Semaphore* pSemaphoreImageReady = nullptr;
    Semaphore* pSemaphorePresentReady = nullptr;
};`}}),s=new H({props:{sectionID:L.IMAGE,$$slots:{default:[rI]},$$scope:{ctx:c}}}),u=new Se({props:{$$slots:{params:[pI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Swapchain Image"),n=i(` structure is used by the Swapchain to keep
track of the information needed for rendering to and presenting of Swapchain
`),I(s.$$.fragment),a=i(`.
`),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=f(m,`

The `),r=g(m,"CODE",{});var _=E(r);$=f(_,"Swapchain Image"),_.forEach(l),n=f(m,` structure is used by the Swapchain to keep
track of the information needed for rendering to and presenting of Swapchain
`),S(s.$$.fragment,m),a=f(m,`.
`),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),h(m,r,_),o(r,$),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),s.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),m&&l(r),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class hI extends ve{constructor(e){super(),Ee(this,e,null,mI,be,{})}}function dI(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gI(c){let e;return{c(){e=i("Vulkan Buffer Object")},l(t){e=f(t,"Vulkan Buffer Object")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _I(c){let e;return{c(){e=i("Vulkan Buffers")},l(t){e=f(t,"Vulkan Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vI(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EI(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bI(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wI(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/buffer.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[dI]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[gI]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[_I]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[vI]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[EI]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[bI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a size and usage and uses this information to create a "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=d("br"),_=j(),I(v.$$.fragment),R=i(` represent linear arrays of data that are used for different purposes by binding
them to a `),I(P.$$.fragment),A=i(" or "),I(T.$$.fragment),y=i(" via "),I(B.$$.fragment),M=i(` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},l(x){S(e.$$.fragment,x),t=f(x,`
The `),r=g(x,"CODE",{});var F=E(r);$=f(F,"Buffer"),F.forEach(l),n=f(x," class takes a pointer to a "),S(s.$$.fragment,x),a=f(x," along with a size and usage and uses this information to create a "),S(u.$$.fragment,x),p=f(x,` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=g(x,"BR",{}),_=Y(x),S(v.$$.fragment,x),R=f(x,` represent linear arrays of data that are used for different purposes by binding
them to a `),S(P.$$.fragment,x),A=f(x," or "),S(T.$$.fragment,x),y=f(x," via "),S(B.$$.fragment,x),M=f(x,` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},m(x,F){D(e,x,F),h(x,t,F),h(x,r,F),o(r,$),h(x,n,F),D(s,x,F),h(x,a,F),D(u,x,F),h(x,p,F),h(x,m,F),h(x,_,F),D(v,x,F),h(x,R,F),D(P,x,F),h(x,A,F),D(T,x,F),h(x,y,F),D(B,x,F),h(x,M,F),O=!0},p(x,[F]){const V={};F&1&&(V.$$scope={dirty:F,ctx:x}),s.$set(V);const q={};F&1&&(q.$$scope={dirty:F,ctx:x}),u.$set(q);const k={};F&1&&(k.$$scope={dirty:F,ctx:x}),v.$set(k);const N={};F&1&&(N.$$scope={dirty:F,ctx:x}),P.$set(N);const Q={};F&1&&(Q.$$scope={dirty:F,ctx:x}),T.$set(Q);const X={};F&1&&(X.$$scope={dirty:F,ctx:x}),B.$set(X)},i(x){O||(b(e.$$.fragment,x),b(s.$$.fragment,x),b(u.$$.fragment,x),b(v.$$.fragment,x),b(P.$$.fragment,x),b(T.$$.fragment,x),b(B.$$.fragment,x),O=!0)},o(x){w(e.$$.fragment,x),w(s.$$.fragment,x),w(u.$$.fragment,x),w(v.$$.fragment,x),w(P.$$.fragment,x),w(T.$$.fragment,x),w(B.$$.fragment,x),O=!1},d(x){C(e,x),x&&l(t),x&&l(r),x&&l(n),C(s,x),x&&l(a),C(u,x),x&&l(p),x&&l(m),x&&l(_),C(v,x),x&&l(R),C(P,x),x&&l(A),C(T,x),x&&l(y),C(B,x),x&&l(M)}}}class II extends ve{constructor(e){super(),Ee(this,e,null,wI,be,{})}}function DI(c){let e;const t=c[2].default,r=gn(t,c,c[3],null);return{c(){r&&r.c()},l($){r&&r.l($)},m($,n){r&&r.m($,n),e=!0},p($,n){r&&r.p&&(!e||n&8)&&_n(r,t,$,$[3],e?En(t,$[3],n,null):vn($[3]),null)},i($){e||(b(r,$),e=!0)},o($){w(r,$),e=!1},d($){r&&r.d($)}}}function CI(c){let e,t;return e=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/"+c[1]+"-extensions/man/html/"+c[0]+".html",target:"_blank",$$slots:{default:[DI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment)},l(r){S(e.$$.fragment,r)},m(r,$){D(e,r,$),t=!0},p(r,[$]){const n={};$&3&&(n.href="https://registry.khronos.org/vulkan/specs/"+r[1]+"-extensions/man/html/"+r[0]+".html"),$&8&&(n.$$scope={dirty:$,ctx:r}),e.$set(n)},i(r){t||(b(e.$$.fragment,r),t=!0)},o(r){w(e.$$.fragment,r),t=!1},d(r){C(e,r)}}}function SI(c,e,t){let{$$slots:r={},$$scope:$}=e,{reference:n}=e,{version:s}=e;return c.$$set=a=>{"reference"in a&&t(0,n=a.reference),"version"in a&&t(1,s=a.version),"$$scope"in a&&t(3,$=a.$$scope)},[n,s,r,$]}class Bt extends ve{constructor(e){super(),Ee(this,e,SI,CI,be,{reference:0,version:1})}}function RI(c){let e;return{c(){e=i("Buffer Director")},l(t){e=f(t,"Buffer Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AI(c){let e;return{c(){e=i("Buffer Builder")},l(t){e=f(t,"Buffer Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PI(c){let e,t,r,$,n,s,a,u,p;return n=new H({props:{sectionID:L.BUFFER_DIRECTOR,$$slots:{default:[RI]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[AI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Buffer."),r=d("br"),$=i(`
        It is recommended to not create a Buffer by it's Constructor, but to use
        a `),I(n.$$.fragment),s=i(" or "),I(a.$$.fragment),u=i(" instead."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Create a new Buffer."),r=g(_,"BR",{}),$=f(_,`
        It is recommended to not create a Buffer by it's Constructor, but to use
        a `),S(n.$$.fragment,_),s=f(_," or "),S(a.$$.fragment,_),u=f(_," instead."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function BI(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LI(c){let e;return{c(){e=i("VkBufferCreateFlagBits")},l(t){e=f(t,"VkBufferCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kI(c){let e;return{c(){e=i("VkBufferUsageFlagBits")},l(t){e=f(t,"VkBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TI(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OI(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VI(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yI(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MI(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FI(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M=je().Fillcan.version+"",O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[BI]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html",target:"_blank",$$slots:{default:[LI]},$$scope:{ctx:c}}}),ue=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[kI]},$$scope:{ctx:c}}}),ge=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[TI]},$$scope:{ctx:c}}}),Re=new H({props:{sectionID:L.QUEUE,$$slots:{default:[OI]},$$scope:{ctx:c}}}),ce=new H({props:{sectionID:L.QUEUE,$$slots:{default:[VI]},$$scope:{ctx:c}}}),xe=new H({props:{sectionID:L.QUEUE,$$slots:{default:[yI]},$$scope:{ctx:c}}}),Ke=new H({props:{sectionID:L.QUEUE,$$slots:{default:[MI]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Buffer should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" which are all related to sparse buffers."),y=d("br"),B=i(`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),O=i(M),x=i("."),F=j(),V=d("li"),q=d("code"),k=i("size"),N=d("br"),Q=i(`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),X=d("code"),Z=i("1024"),K=i(`
            * `),W=d("code"),U=i("1024"),G=i(")."),te=j(),ee=d("li"),ne=d("code"),le=i("usage"),ae=d("br"),J=i(`
            A bitmask of members of the `),I(ue.$$.fragment),De=i("-enumerant telling Vulkan how the Buffer will be used."),de=j(),me=d("li"),Ce=d("code"),_e=i("sharingMode"),se=d("br"),ie=i(`
            A member of the `),I(ge.$$.fragment),we=i(`-enumerant indicating how the Buffer will be used in the multiple
            device `),I(Re.$$.fragment),Be=i(` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Buffer will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Ie=d("code"),re=i("sharingMode"),he=i(`
            to `),Ae=d("code"),Ve=i("VK_SHARING_MODE_EXCLUSIVE"),oe=i(` tells Vulkan that the
            Buffer will only be used for a single `),I(ce.$$.fragment),Pe=i(`, while setting
            `),Fe=d("code"),ke=i("sharingMode"),Te=i(`
            to
            `),Me=d("code"),Ue=i("VK_SHARING_MODE_CONCURRENT"),qe=i(` specifies that the
            application will use the Buffer on multiple `),I(xe.$$.fragment),Ge=i(` at once. Using
            `),ye=d("code"),We=i("VK_SHARING_MODE_CONCURRENT"),ze=i(` may result in lower
            performance on some systems, so unless necessary,
            `),Ye=d("code"),rt=i("sharingMode"),Ne=i(`
            should be set to `),He=d("code"),$t=i("VK_SHARING_MODE_EXCLUSIVE"),ut=i("."),ht=j(),Je=d("li"),dt=d("code"),et=i("queueFamilyIndices"),Ze=d("br"),nt=i(`
            An array of `),I(Ke.$$.fragment),ct=i(`
            family indices on which the buffer will be used.`),this.h()},l(Qe){e=g(Qe,"DIV",{slot:!0});var at=E(e);t=g(at,"LI",{});var bt=E(t);r=g(bt,"CODE",{});var wt=E(r);$=f(wt,"pLogicalDevice"),wt.forEach(l),n=g(bt,"BR",{}),s=f(bt,`
            A pointer to the `),S(a.$$.fragment,bt),u=f(bt," the Buffer should be associated with."),bt.forEach(l),p=Y(at),m=g(at,"LI",{});var St=E(m);_=g(St,"CODE",{});var tt=E(_);v=f(tt,"flags"),tt.forEach(l),R=g(St,"BR",{}),P=f(St,`
            A bitmask of `),S(A.$$.fragment,St),T=f(St," which are all related to sparse buffers."),y=g(St,"BR",{}),B=f(St,`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),O=f(St,M),x=f(St,"."),St.forEach(l),F=Y(at),V=g(at,"LI",{});var ot=E(V);q=g(ot,"CODE",{});var At=E(q);k=f(At,"size"),At.forEach(l),N=g(ot,"BR",{}),Q=f(ot,`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),X=g(ot,"CODE",{});var it=E(X);Z=f(it,"1024"),it.forEach(l),K=f(ot,`
            * `),W=g(ot,"CODE",{});var Xe=E(W);U=f(Xe,"1024"),Xe.forEach(l),G=f(ot,")."),ot.forEach(l),te=Y(at),ee=g(at,"LI",{});var Dt=E(ee);ne=g(Dt,"CODE",{});var Ct=E(ne);le=f(Ct,"usage"),Ct.forEach(l),ae=g(Dt,"BR",{}),J=f(Dt,`
            A bitmask of members of the `),S(ue.$$.fragment,Dt),De=f(Dt,"-enumerant telling Vulkan how the Buffer will be used."),Dt.forEach(l),de=Y(at),me=g(at,"LI",{});var pt=E(me);Ce=g(pt,"CODE",{});var yt=E(Ce);_e=f(yt,"sharingMode"),yt.forEach(l),se=g(pt,"BR",{}),ie=f(pt,`
            A member of the `),S(ge.$$.fragment,pt),we=f(pt,`-enumerant indicating how the Buffer will be used in the multiple
            device `),S(Re.$$.fragment,pt),Be=f(pt,` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Buffer will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Ie=g(pt,"CODE",{});var mt=E(Ie);re=f(mt,"sharingMode"),mt.forEach(l),he=f(pt,`
            to `),Ae=g(pt,"CODE",{});var Ot=E(Ae);Ve=f(Ot,"VK_SHARING_MODE_EXCLUSIVE"),Ot.forEach(l),oe=f(pt,` tells Vulkan that the
            Buffer will only be used for a single `),S(ce.$$.fragment,pt),Pe=f(pt,`, while setting
            `),Fe=g(pt,"CODE",{});var Pt=E(Fe);ke=f(Pt,"sharingMode"),Pt.forEach(l),Te=f(pt,`
            to
            `),Me=g(pt,"CODE",{});var Tt=E(Me);Ue=f(Tt,"VK_SHARING_MODE_CONCURRENT"),Tt.forEach(l),qe=f(pt,` specifies that the
            application will use the Buffer on multiple `),S(xe.$$.fragment,pt),Ge=f(pt,` at once. Using
            `),ye=g(pt,"CODE",{});var vt=E(ye);We=f(vt,"VK_SHARING_MODE_CONCURRENT"),vt.forEach(l),ze=f(pt,` may result in lower
            performance on some systems, so unless necessary,
            `),Ye=g(pt,"CODE",{});var gt=E(Ye);rt=f(gt,"sharingMode"),gt.forEach(l),Ne=f(pt,`
            should be set to `),He=g(pt,"CODE",{});var kt=E(He);$t=f(kt,"VK_SHARING_MODE_EXCLUSIVE"),kt.forEach(l),ut=f(pt,"."),pt.forEach(l),ht=Y(at),Je=g(at,"LI",{});var Ft=E(Je);dt=g(Ft,"CODE",{});var Mt=E(dt);et=f(Mt,"queueFamilyIndices"),Mt.forEach(l),Ze=g(Ft,"BR",{}),nt=f(Ft,`
            An array of `),S(Ke.$$.fragment,Ft),ct=f(Ft,`
            family indices on which the buffer will be used.`),Ft.forEach(l),at.forEach(l),this.h()},h(){z(e,"slot","params")},m(Qe,at){h(Qe,e,at),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(m,y),o(m,B),o(m,O),o(m,x),o(e,F),o(e,V),o(V,q),o(q,k),o(V,N),o(V,Q),o(V,X),o(X,Z),o(V,K),o(V,W),o(W,U),o(V,G),o(e,te),o(e,ee),o(ee,ne),o(ne,le),o(ee,ae),o(ee,J),D(ue,ee,null),o(ee,De),o(e,de),o(e,me),o(me,Ce),o(Ce,_e),o(me,se),o(me,ie),D(ge,me,null),o(me,we),D(Re,me,null),o(me,Be),o(me,Ie),o(Ie,re),o(me,he),o(me,Ae),o(Ae,Ve),o(me,oe),D(ce,me,null),o(me,Pe),o(me,Fe),o(Fe,ke),o(me,Te),o(me,Me),o(Me,Ue),o(me,qe),D(xe,me,null),o(me,Ge),o(me,ye),o(ye,We),o(me,ze),o(me,Ye),o(Ye,rt),o(me,Ne),o(me,He),o(He,$t),o(me,ut),o(e,ht),o(e,Je),o(Je,dt),o(dt,et),o(Je,Ze),o(Je,nt),D(Ke,Je,null),o(Je,ct),st=!0},p(Qe,at){const bt={};at&1&&(bt.$$scope={dirty:at,ctx:Qe}),a.$set(bt);const wt={};at&1&&(wt.$$scope={dirty:at,ctx:Qe}),A.$set(wt);const St={};at&1&&(St.$$scope={dirty:at,ctx:Qe}),ue.$set(St);const tt={};at&1&&(tt.$$scope={dirty:at,ctx:Qe}),ge.$set(tt);const ot={};at&1&&(ot.$$scope={dirty:at,ctx:Qe}),Re.$set(ot);const At={};at&1&&(At.$$scope={dirty:at,ctx:Qe}),ce.$set(At);const it={};at&1&&(it.$$scope={dirty:at,ctx:Qe}),xe.$set(it);const Xe={};at&1&&(Xe.$$scope={dirty:at,ctx:Qe}),Ke.$set(Xe)},i(Qe){st||(b(a.$$.fragment,Qe),b(A.$$.fragment,Qe),b(ue.$$.fragment,Qe),b(ge.$$.fragment,Qe),b(Re.$$.fragment,Qe),b(ce.$$.fragment,Qe),b(xe.$$.fragment,Qe),b(Ke.$$.fragment,Qe),st=!0)},o(Qe){w(a.$$.fragment,Qe),w(A.$$.fragment,Qe),w(ue.$$.fragment,Qe),w(ge.$$.fragment,Qe),w(Re.$$.fragment,Qe),w(ce.$$.fragment,Qe),w(xe.$$.fragment,Qe),w(Ke.$$.fragment,Qe),st=!1},d(Qe){Qe&&l(e),C(a),C(A),C(ue),C(ge),C(Re),C(ce),C(xe),C(Ke)}}}function xI(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NI(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkBuffer",version:1.3,$$slots:{default:[xI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function UI(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Buffer(
    LogicalDevice* pLogicalDevice, 
    VkBufferCreateFlags& flags, 
    VkDeviceSize& size, 
    VkBufferUsageFlags& usage, 
    VkSharingMode& sharingMode,
    std::vector<uint32_t> queueFamilyIndices = {}
);`}}),r=new Se({props:{$$slots:{throws:[NI],params:[FI],details:[PI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GI extends ve{constructor(e){super(),Ee(this,e,null,UI,be,{})}}function HI(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qI(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[HI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function WI(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QI(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[WI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function KI(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkBuffer getBufferHandle() const;"}}),r=new Se({props:{$$slots:{return:[QI],details:[qI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zI extends ve{constructor(e){super(),Ee(this,e,null,KI,be,{})}}function jI(c){let e,t;return{c(){e=d("span"),t=i("Get the flags used for creating the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the flags used for creating the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function YI(c){let e,t;return{c(){e=d("span"),t=i("The flags set when creating of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The flags set when creating of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function XI(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkBufferCreateFlags getFlags();"}}),r=new Se({props:{$$slots:{return:[YI],details:[jI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ZI extends ve{constructor(e){super(),Ee(this,e,null,XI,be,{})}}function JI(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_Constructor,$$slots:{default:[JI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the size given in the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the size given in the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tD(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_Constructor,$$slots:{default:[tD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The size given in the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The size given in the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function nD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkDeviceSize getSize();"}}),r=new Se({props:{$$slots:{return:[rD],details:[eD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sD extends ve{constructor(e){super(),Ee(this,e,null,nD,be,{})}}function aD(c){let e,t;return{c(){e=d("span"),t=i("Get the intended usage of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended usage of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function oD(c){let e,t;return{c(){e=d("span"),t=i("The intended usage of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The intended usage of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function lD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkBufferUsageFlags getUsage();"}}),r=new Se({props:{$$slots:{return:[oD],details:[aD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iD extends ve{constructor(e){super(),Ee(this,e,null,lD,be,{})}}function fD(c){let e,t;return{c(){e=d("span"),t=i("Get the sharing mode of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sharing mode of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function cD(c){let e,t;return{c(){e=d("span"),t=i("The sharing mode of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sharing mode of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function $D(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSharingMode getSharingMode();"}}),r=new Se({props:{$$slots:{return:[cD],details:[fD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uD extends ve{constructor(e){super(),Ee(this,e,null,$D,be,{})}}function pD(c){let e,t;return{c(){e=d("span"),t=i("Get the queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function mD(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function hD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[mD],details:[pD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dD extends ve{constructor(e){super(),Ee(this,e,null,hD,be,{})}}function gD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _D(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.MEMORY,$$slots:{default:[gD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind "),I(r.$$.fragment),$=i(" to the Buffer."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind "),S(r.$$.fragment,a),$=f(a," to the Buffer."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ED(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wD(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return a=new H({props:{sectionID:L.MEMORY,$$slots:{default:[vD]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.MEMORY,$$slots:{default:[ED]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.MEMORY,$$slots:{default:[bD]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pMemory"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to the Buffer."),p=j(),m=d("li"),_=d("code"),v=i("memoryOffset"),R=d("br"),P=i(`
            Specifies the offset in the `),I(A.$$.fragment),T=i(` object the Buffer will live. If only one resource will be bound to
            the `),I(y.$$.fragment),B=i(` object,
            this can be set to
            `),M=d("code"),O=i("0"),x=i("."),this.h()},l(V){e=g(V,"DIV",{slot:!0});var q=E(e);t=g(q,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"pMemory"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            A pointer to the `),S(a.$$.fragment,k),u=f(k," to bind to the Buffer."),k.forEach(l),p=Y(q),m=g(q,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"memoryOffset"),X.forEach(l),R=g(Q,"BR",{}),P=f(Q,`
            Specifies the offset in the `),S(A.$$.fragment,Q),T=f(Q,` object the Buffer will live. If only one resource will be bound to
            the `),S(y.$$.fragment,Q),B=f(Q,` object,
            this can be set to
            `),M=g(Q,"CODE",{});var Z=E(M);O=f(Z,"0"),Z.forEach(l),x=f(Q,"."),Q.forEach(l),q.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,q){h(V,e,q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),o(m,M),o(M,O),o(m,x),F=!0},p(V,q){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),a.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),A.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),y.$set(Q)},i(V){F||(b(a.$$.fragment,V),b(A.$$.fragment,V),b(y.$$.fragment,V),F=!0)},o(V){w(a.$$.fragment,V),w(A.$$.fragment,V),w(y.$$.fragment,V),F=!1},d(V){V&&l(e),C(a),C(A),C(y)}}}function ID(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void bindMemory(Memory* pMemory, VkDeviceSize memoryOffset = 0);"}}),r=new Se({props:{$$slots:{params:[wD],details:[_D]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DD extends ve{constructor(e){super(),Ee(this,e,null,ID,be,{})}}function CD(c){let e;return{c(){e=i("bindMemory")},l(t){e=f(t,"bindMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_bindMemory,$$slots:{default:[CD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the Memory bound with "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the Memory bound with "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function RD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PD(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.MEMORY,$$slots:{default:[RD]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.MEMORY,$$slots:{default:[AD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function BD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Memory* getMemory() const;"}}),r=new Se({props:{$$slots:{return:[PD],details:[SD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LD extends ve{constructor(e){super(),Ee(this,e,null,BD,be,{})}}function kD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[kD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function OD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xD(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae;return R=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[OD]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[VD]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[yD]},$$scope:{ctx:c}}}),X=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[MD]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[FD]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            The format in which to interpret the Buffer.`),a=j(),u=d("li"),p=d("code"),m=i("offset"),_=d("br"),v=i(`
            The `),I(R.$$.fragment),P=i(' will be a "window" into the parent buffer. The '),A=d("code"),T=i("offset"),y=i(`
            is the number of bytes within the Buffer where the `),I(B.$$.fragment),M=i(" should start. To create a "),I(O.$$.fragment),x=i(" of the entire Buffer, this must be 0."),F=j(),V=d("li"),q=d("code"),k=i("range"),N=d("br"),Q=i(`
            The number of bytes the `),I(X.$$.fragment),Z=i(" will contain from "),K=d("code"),W=i("offset"),U=i(". To create a "),I(G.$$.fragment),te=i(` of the entire Buffer, this must be
            `),ee=d("code"),ne=i("VK_WHOLE_SIZE"),le=i("."),this.h()},l(J){e=g(J,"DIV",{slot:!0});var ue=E(e);t=g(ue,"LI",{});var De=E(t);r=g(De,"CODE",{});var de=E(r);$=f(de,"format"),de.forEach(l),n=g(De,"BR",{}),s=f(De,`
            The format in which to interpret the Buffer.`),De.forEach(l),a=Y(ue),u=g(ue,"LI",{});var me=E(u);p=g(me,"CODE",{});var Ce=E(p);m=f(Ce,"offset"),Ce.forEach(l),_=g(me,"BR",{}),v=f(me,`
            The `),S(R.$$.fragment,me),P=f(me,' will be a "window" into the parent buffer. The '),A=g(me,"CODE",{});var _e=E(A);T=f(_e,"offset"),_e.forEach(l),y=f(me,`
            is the number of bytes within the Buffer where the `),S(B.$$.fragment,me),M=f(me," should start. To create a "),S(O.$$.fragment,me),x=f(me," of the entire Buffer, this must be 0."),me.forEach(l),F=Y(ue),V=g(ue,"LI",{});var se=E(V);q=g(se,"CODE",{});var ie=E(q);k=f(ie,"range"),ie.forEach(l),N=g(se,"BR",{}),Q=f(se,`
            The number of bytes the `),S(X.$$.fragment,se),Z=f(se," will contain from "),K=g(se,"CODE",{});var ge=E(K);W=f(ge,"offset"),ge.forEach(l),U=f(se,". To create a "),S(G.$$.fragment,se),te=f(se,` of the entire Buffer, this must be
            `),ee=g(se,"CODE",{});var we=E(ee);ne=f(we,"VK_WHOLE_SIZE"),we.forEach(l),le=f(se,"."),se.forEach(l),ue.forEach(l),this.h()},h(){z(e,"slot","params")},m(J,ue){h(J,e,ue),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(u,A),o(A,T),o(u,y),D(B,u,null),o(u,M),D(O,u,null),o(u,x),o(e,F),o(e,V),o(V,q),o(q,k),o(V,N),o(V,Q),D(X,V,null),o(V,Z),o(V,K),o(K,W),o(V,U),D(G,V,null),o(V,te),o(V,ee),o(ee,ne),o(V,le),ae=!0},p(J,ue){const De={};ue&1&&(De.$$scope={dirty:ue,ctx:J}),R.$set(De);const de={};ue&1&&(de.$$scope={dirty:ue,ctx:J}),B.$set(de);const me={};ue&1&&(me.$$scope={dirty:ue,ctx:J}),O.$set(me);const Ce={};ue&1&&(Ce.$$scope={dirty:ue,ctx:J}),X.$set(Ce);const _e={};ue&1&&(_e.$$scope={dirty:ue,ctx:J}),G.$set(_e)},i(J){ae||(b(R.$$.fragment,J),b(B.$$.fragment,J),b(O.$$.fragment,J),b(X.$$.fragment,J),b(G.$$.fragment,J),ae=!0)},o(J){w(R.$$.fragment,J),w(B.$$.fragment,J),w(O.$$.fragment,J),w(X.$$.fragment,J),w(G.$$.fragment,J),ae=!1},d(J){J&&l(e),C(R),C(B),C(O),C(X),C(G)}}}function ND(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GD(c){let e;return{c(){e=i("getBufferView")},l(t){e=f(t,"getBufferView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HD(c){let e,t,r,$,n,s,a,u,p;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[ND]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[UD]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.BUFFER_getBufferView,$$slots:{default:[GD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to get the created "),I(n.$$.fragment),s=i(" using "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to get the created "),S(n.$$.fragment,_),s=f(_," using "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),n.$set(R);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function qD(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WD(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[qD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function QD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int createBufferView(VkFormat format, VkDeviceSize offset = 0, VkDeviceSize range = VK_WHOLE_SIZE);"}}),r=new Se({props:{$$slots:{throws:[WD],return:[HD],params:[xD],details:[TD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class KD extends ve{constructor(e){super(),Ee(this,e,null,QD,be,{})}}function zD(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[zD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function YD(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XD(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[YD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ZD(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<BufferView*> getBufferViews();"}}),r=new Se({props:{$$slots:{return:[XD],details:[jD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class JD extends ve{constructor(e){super(),Ee(this,e,null,ZD,be,{})}}function eC(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tC(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[eC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rC(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nC(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[rC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function sC(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<BufferView*> getBufferViews();"}}),r=new Se({props:{$$slots:{return:[nC],details:[tC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aC extends ve{constructor(e){super(),Ee(this,e,null,sC,be,{})}}function oC(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lC(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[oC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function iC(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fC(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[iC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to destroy."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"index"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to destroy."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function cC(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroyBufferView(unsigned int index);"}}),r=new Se({props:{$$slots:{params:[fC],details:[lC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $C extends ve{constructor(e){super(),Ee(this,e,null,cC,be,{})}}function uC(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pC(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[uC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy all created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy all created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mC(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroyBufferViews();"}}),r=new Se({props:{$$slots:{details:[pC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hC extends ve{constructor(e){super(),Ee(this,e,null,mC,be,{})}}function dC(c){let e,t;return{c(){e=d("span"),t=i("Copy this Buffer's data to a given Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Buffer's data to a given Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function gC(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _C(c){let e;return{c(){e=i("VkBufferCopy")},l(t){e=f(t,"VkBufferCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vC(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[gC]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html",target:"_blank",$$slots:{default:[_C]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=j(),m=d("li"),_=d("code"),v=i("pBuffer"),R=d("br"),P=i(`
            A pointer to the Buffer to copy this Buffer's data to.`),A=j(),T=d("li"),y=d("code"),B=i("regions"),M=d("br"),O=i(`
            An array of `),I(x.$$.fragment),F=i("-structures, each of which describes a region of data to copy."),V=j(),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"pCommandBuffer"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The `),S(a.$$.fragment,Q),u=f(Q," to use to execute the copy."),Q.forEach(l),p=Y(N),m=g(N,"LI",{});var Z=E(m);_=g(Z,"CODE",{});var K=E(_);v=f(K,"pBuffer"),K.forEach(l),R=g(Z,"BR",{}),P=f(Z,`
            A pointer to the Buffer to copy this Buffer's data to.`),Z.forEach(l),A=Y(N),T=g(N,"LI",{});var W=E(T);y=g(W,"CODE",{});var U=E(y);B=f(U,"regions"),U.forEach(l),M=g(W,"BR",{}),O=f(W,`
            An array of `),S(x.$$.fragment,W),F=f(W,"-structures, each of which describes a region of data to copy."),W.forEach(l),V=Y(N),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),o(e,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),a.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),x.$set(X)},i(k){q||(b(a.$$.fragment,k),b(x.$$.fragment,k),q=!0)},o(k){w(a.$$.fragment,k),w(x.$$.fragment,k),q=!1},d(k){k&&l(e),C(a),C(x)}}}function EC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bC(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[EC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Copy this Buffer's data to a given "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Copy this Buffer's data to a given "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wC(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CC(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SC(c){let e;return{c(){e=i("VkBufferCopy")},l(t){e=f(t,"VkBufferCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RC(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[wC]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[IC]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.IMAGE,$$slots:{default:[DC]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[CC]},$$scope:{ctx:c}}}),Re=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html",target:"_blank",$$slots:{default:[SC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=j(),m=d("li"),_=d("code"),v=i("pImage"),R=d("br"),P=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to copy this Buffer's data to."),y=j(),B=d("li"),M=d("code"),O=i("dstLayout"),x=d("br"),F=i(`
            The layout of the destination `),I(V.$$.fragment),q=i(" subresources for the copy. This should be a member of the "),I(k.$$.fragment),N=i("-enumerant."),Q=d("br"),X=i(`
            This is most likely either
            `),Z=d("code"),K=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),W=i(`,
            `),U=d("code"),G=i("VK_IMAGE_LAYOUT_GENERAL"),te=i(`
            or `),ee=d("code"),ne=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),le=i("."),ae=j(),J=d("li"),ue=d("code"),De=i("pBuffer"),de=d("br"),me=i(`
            A pointer to the Buffer to copy this Buffer's data to.`),Ce=j(),_e=d("li"),se=d("code"),ie=i("regions"),ge=d("br"),we=i(`
            An array of `),I(Re.$$.fragment),Be=i("-structures, each of which describes a region of data to copy."),this.h()},l(re){e=g(re,"DIV",{slot:!0});var he=E(e);t=g(he,"LI",{});var Ae=E(t);r=g(Ae,"CODE",{});var Ve=E(r);$=f(Ve,"pCommandBuffer"),Ve.forEach(l),n=g(Ae,"BR",{}),s=f(Ae,`
            The `),S(a.$$.fragment,Ae),u=f(Ae," to use to execute the copy."),Ae.forEach(l),p=Y(he),m=g(he,"LI",{});var oe=E(m);_=g(oe,"CODE",{});var ce=E(_);v=f(ce,"pImage"),ce.forEach(l),R=g(oe,"BR",{}),P=f(oe,`
            A pointer to the `),S(A.$$.fragment,oe),T=f(oe," to copy this Buffer's data to."),oe.forEach(l),y=Y(he),B=g(he,"LI",{});var Pe=E(B);M=g(Pe,"CODE",{});var Fe=E(M);O=f(Fe,"dstLayout"),Fe.forEach(l),x=g(Pe,"BR",{}),F=f(Pe,`
            The layout of the destination `),S(V.$$.fragment,Pe),q=f(Pe," subresources for the copy. This should be a member of the "),S(k.$$.fragment,Pe),N=f(Pe,"-enumerant."),Q=g(Pe,"BR",{}),X=f(Pe,`
            This is most likely either
            `),Z=g(Pe,"CODE",{});var ke=E(Z);K=f(ke,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),ke.forEach(l),W=f(Pe,`,
            `),U=g(Pe,"CODE",{});var Te=E(U);G=f(Te,"VK_IMAGE_LAYOUT_GENERAL"),Te.forEach(l),te=f(Pe,`
            or `),ee=g(Pe,"CODE",{});var Me=E(ee);ne=f(Me,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),Me.forEach(l),le=f(Pe,"."),Pe.forEach(l),ae=Y(he),J=g(he,"LI",{});var Ue=E(J);ue=g(Ue,"CODE",{});var qe=E(ue);De=f(qe,"pBuffer"),qe.forEach(l),de=g(Ue,"BR",{}),me=f(Ue,`
            A pointer to the Buffer to copy this Buffer's data to.`),Ue.forEach(l),Ce=Y(he),_e=g(he,"LI",{});var xe=E(_e);se=g(xe,"CODE",{});var Ge=E(se);ie=f(Ge,"regions"),Ge.forEach(l),ge=g(xe,"BR",{}),we=f(xe,`
            An array of `),S(Re.$$.fragment,xe),Be=f(xe,"-structures, each of which describes a region of data to copy."),xe.forEach(l),he.forEach(l),this.h()},h(){z(e,"slot","params")},m(re,he){h(re,e,he),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),o(B,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,U),o(U,G),o(B,te),o(B,ee),o(ee,ne),o(B,le),o(e,ae),o(e,J),o(J,ue),o(ue,De),o(J,de),o(J,me),o(e,Ce),o(e,_e),o(_e,se),o(se,ie),o(_e,ge),o(_e,we),D(Re,_e,null),o(_e,Be),Ie=!0},p(re,he){const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),a.$set(Ae);const Ve={};he&1&&(Ve.$$scope={dirty:he,ctx:re}),A.$set(Ve);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),V.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),k.$set(ce);const Pe={};he&1&&(Pe.$$scope={dirty:he,ctx:re}),Re.$set(Pe)},i(re){Ie||(b(a.$$.fragment,re),b(A.$$.fragment,re),b(V.$$.fragment,re),b(k.$$.fragment,re),b(Re.$$.fragment,re),Ie=!0)},o(re){w(a.$$.fragment,re),w(A.$$.fragment,re),w(V.$$.fragment,re),w(k.$$.fragment,re),w(Re.$$.fragment,re),Ie=!1},d(re){re&&l(e),C(a),C(A),C(V),C(k),C(Re)}}}function AC(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void copyTo(CommandBuffer* pCommandBuffer, Buffer* pBuffer, std::vector<VkBufferCopy>& regions);"}}),r=new Se({props:{$$slots:{params:[vC],details:[dC]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:"void copyTo(CommandBuffer* pCommandBuffer, Image* pImage, VkImageLayout dstLayout, std::vector<VkBufferImageCopy>& regions);"}}),u=new Se({props:{$$slots:{params:[RC],details:[bC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class PC extends ve{constructor(e){super(),Ee(this,e,null,AC,be,{})}}function BC(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LC(c){let e;return{c(){e=i("Vulkan Image Object")},l(t){e=f(t,"Vulkan Image Object")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kC(c){let e;return{c(){e=i("Vulkan Images")},l(t){e=f(t,"Vulkan Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TC(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OC(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VC(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yC(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/image.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[BC]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[LC]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[kC]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[TC]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[OC]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[VC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a size and usage and uses this information to create a "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=d("br"),_=j(),I(v.$$.fragment),R=i(` represent linear arrays of data that are used for different purposes by binding
them to a `),I(P.$$.fragment),A=i(" or "),I(T.$$.fragment),y=i(" via "),I(B.$$.fragment),M=i(` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},l(x){S(e.$$.fragment,x),t=f(x,`
The `),r=g(x,"CODE",{});var F=E(r);$=f(F,"Image"),F.forEach(l),n=f(x," class takes a pointer to a "),S(s.$$.fragment,x),a=f(x," along with a size and usage and uses this information to create a "),S(u.$$.fragment,x),p=f(x,` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=g(x,"BR",{}),_=Y(x),S(v.$$.fragment,x),R=f(x,` represent linear arrays of data that are used for different purposes by binding
them to a `),S(P.$$.fragment,x),A=f(x," or "),S(T.$$.fragment,x),y=f(x," via "),S(B.$$.fragment,x),M=f(x,` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},m(x,F){D(e,x,F),h(x,t,F),h(x,r,F),o(r,$),h(x,n,F),D(s,x,F),h(x,a,F),D(u,x,F),h(x,p,F),h(x,m,F),h(x,_,F),D(v,x,F),h(x,R,F),D(P,x,F),h(x,A,F),D(T,x,F),h(x,y,F),D(B,x,F),h(x,M,F),O=!0},p(x,[F]){const V={};F&1&&(V.$$scope={dirty:F,ctx:x}),s.$set(V);const q={};F&1&&(q.$$scope={dirty:F,ctx:x}),u.$set(q);const k={};F&1&&(k.$$scope={dirty:F,ctx:x}),v.$set(k);const N={};F&1&&(N.$$scope={dirty:F,ctx:x}),P.$set(N);const Q={};F&1&&(Q.$$scope={dirty:F,ctx:x}),T.$set(Q);const X={};F&1&&(X.$$scope={dirty:F,ctx:x}),B.$set(X)},i(x){O||(b(e.$$.fragment,x),b(s.$$.fragment,x),b(u.$$.fragment,x),b(v.$$.fragment,x),b(P.$$.fragment,x),b(T.$$.fragment,x),b(B.$$.fragment,x),O=!0)},o(x){w(e.$$.fragment,x),w(s.$$.fragment,x),w(u.$$.fragment,x),w(v.$$.fragment,x),w(P.$$.fragment,x),w(T.$$.fragment,x),w(B.$$.fragment,x),O=!1},d(x){C(e,x),x&&l(t),x&&l(r),x&&l(n),C(s,x),x&&l(a),C(u,x),x&&l(p),x&&l(m),x&&l(_),C(v,x),x&&l(R),C(P,x),x&&l(A),C(T,x),x&&l(y),C(B,x),x&&l(M)}}}class MC extends ve{constructor(e){super(),Ee(this,e,null,yC,be,{})}}function FC(c){let e;return{c(){e=i("Image Director")},l(t){e=f(t,"Image Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xC(c){let e;return{c(){e=i("Image Builder")},l(t){e=f(t,"Image Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NC(c){let e,t,r,$,n,s,a,u,p;return n=new H({props:{sectionID:L.IMAGE_DIRECTOR,$$slots:{default:[FC]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[xC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Image."),r=d("br"),$=i(`
        It is recommended to not create a Image by it's Constructor, but to use a
        `),I(n.$$.fragment),s=i(" or "),I(a.$$.fragment),u=i(" instead."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Create a new Image."),r=g(_,"BR",{}),$=f(_,`
        It is recommended to not create a Image by it's Constructor, but to use a
        `),S(n.$$.fragment,_),s=f(_," or "),S(a.$$.fragment,_),u=f(_," instead."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function UC(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GC(c){let e;return{c(){e=i("VkImageCreateFlagBits")},l(t){e=f(t,"VkImageCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HC(c){let e;return{c(){e=i("VkExtent3D")},l(t){e=f(t,"VkExtent3D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qC(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WC(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QC(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KC(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zC(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jC(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YC(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XC(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZC(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JC(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,yt,mt,Ot,Pt,Tt,vt,gt,kt,Ft,Mt,Ht,$r,Ut,or,Xt,Vt,Zt,Ar,br,ur,Qt,Vr,rr,Kr,lr,gr,yr,Kt,ir,Mr,Le,lt,Jt,_r,jt,nr,vr,Tr,fr,cr,sr,er,zr,_t,ft,qt,Fr,wr,Nt,Wt,xr,pr,Or,Yt,Pr,Ir,Nr,mr,Dr,hr,Br,Cr,en,Ur,tr,Gr,tn,Yr,ln,Er,fn,Lr,cn,jr;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[UC]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html",target:"_blank",$$slots:{default:[GC]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html",target:"_blank",$$slots:{default:[HC]},$$scope:{ctx:c}}}),dt=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html",target:"_blank",$$slots:{default:[qC]},$$scope:{ctx:c}}}),at=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[WC]},$$scope:{ctx:c}}}),Ot=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[QC]},$$scope:{ctx:c}}}),Ht=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[KC]},$$scope:{ctx:c}}}),Ut=new H({props:{sectionID:L.QUEUE,$$slots:{default:[zC]},$$scope:{ctx:c}}}),Qt=new H({props:{sectionID:L.QUEUE,$$slots:{default:[jC]},$$scope:{ctx:c}}}),ir=new H({props:{sectionID:L.QUEUE,$$slots:{default:[YC]},$$scope:{ctx:c}}}),qt=new H({props:{sectionID:L.QUEUE,$$slots:{default:[XC]},$$scope:{ctx:c}}}),Yt=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[ZC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Image should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" that describe some properties of the image."),y=j(),B=d("li"),M=d("code"),O=i("type"),x=d("br"),F=i(`
            The type of image being created. The image type is essentially the dimensionality
            of the image and can be `),V=d("code"),q=i("VK_IMAGE_TYPE_1D"),k=i(`,
            `),N=d("code"),Q=i("VK_IMAGE_TYPE_2D"),X=i(`
            or `),Z=d("code"),K=i("VK_IMAGE_TYPE_3D"),W=i(`
            for a 1D, 2D or 3D image respectively.`),U=j(),G=d("li"),te=d("code"),ee=i("format"),ne=d("br"),le=i(`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),ae=j(),J=d("li"),ue=d("code"),De=i("extent"),de=d("br"),me=i(`
            The size of the image in texels. This should be an instance of the `),I(Ce.$$.fragment),_e=i(`
            structure , which has three members: `),se=d("code"),ie=i("width"),ge=i(`,
            `),we=d("code"),Re=i("height"),Be=i(", and "),Ie=d("code"),re=i("depth"),he=i(`. These should be set
            respectively to the width, height and depth of the desired image.
            For 1D images, the height should be set to `),Ae=d("code"),Ve=i("1"),oe=i(`, and for
            1D and 2D images, the depth should be set to `),ce=d("code"),Pe=i("1"),Fe=i("."),ke=j(),Te=d("li"),Me=d("code"),Ue=i("mipLevels"),qe=d("br"),xe=i(`
            The number of mipmap levels to create in the image.`),Ge=j(),ye=d("li"),We=d("code"),ze=i("arrayLayers"),Ye=d("br"),rt=i(`
            The amount of images each mipmap level of the image has.`),Ne=j(),He=d("li"),$t=d("code"),ut=i("samples"),ht=d("br"),Je=i(`
            The number of samples in the image. It must be a member of the `),I(dt.$$.fragment),et=i("-enumerant."),Ze=j(),nt=d("li"),Ke=d("code"),ct=i("tiling"),st=d("br"),Qe=i(`
            A member of the `),I(at.$$.fragment),bt=i("-enumerant, which contains only "),wt=d("code"),St=i("VK_IMAGE_TILING_LINEAR"),tt=i(`
            or
            `),ot=d("code"),At=i("VK_IMAGE_TILING_OPTIMAL"),it=i(`. Linear tiling means that image
            data is laid out from left to right, top to bottom, so that if the
            underlying memory is mapped and it is written with the CPU, it would
            form a linear image. Meanwhile, optimal tiling is an opaque display
            used by Vulkan to store data in memory to improve the efficiency of
            the memory subsystem on the device. This is generally what should be
            chosen unless the image needs to be CPU mapped and manipulated.
            Optimal tiling is likely to outperform linear tiling in most
            operations, and linear tiling may not be supported at all for some
            operations or formats, depending on the Vulkan implementation.`),Xe=j(),Dt=d("li"),Ct=d("code"),pt=i("usage"),yt=d("br"),mt=i(`
            A bitmask of members of the `),I(Ot.$$.fragment),Pt=i("-enumerant telling Vulkan how the Image will be used."),Tt=j(),vt=d("li"),gt=d("code"),kt=i("sharingMode"),Ft=d("br"),Mt=i(`
            A member of the `),I(Ht.$$.fragment),$r=i(`-enumerant indicating how the Image will be used in the multiple
            device `),I(Ut.$$.fragment),or=i(` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Image will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Xt=d("code"),Vt=i("sharingMode"),Zt=i(`
            to `),Ar=d("code"),br=i("VK_SHARING_MODE_EXCLUSIVE"),ur=i(` tells Vulkan that the
            Image will only be used for a single `),I(Qt.$$.fragment),Vr=i(`, while setting
            `),rr=d("code"),Kr=i("sharingMode"),lr=i(`
            to
            `),gr=d("code"),yr=i("VK_SHARING_MODE_CONCURRENT"),Kt=i(` specifies that the
            application will use the Image on multiple `),I(ir.$$.fragment),Mr=i(` at once. Using
            `),Le=d("code"),lt=i("VK_SHARING_MODE_CONCURRENT"),Jt=i(` may result in lower
            performance on some systems, so unless necessary,
            `),_r=d("code"),jt=i("sharingMode"),nr=i(`
            should be set to `),vr=d("code"),Tr=i("VK_SHARING_MODE_EXCLUSIVE"),fr=i("."),cr=j(),sr=d("li"),er=d("code"),zr=i("queueFamilyIndices"),_t=d("br"),ft=i(`
            A pointer to an array of `),I(qt.$$.fragment),Fr=i(" family indices on which the image will be used."),wr=j(),Nt=d("li"),Wt=d("code"),xr=i("initialLayout"),pr=d("br"),Or=i(`
            Images have a layout, which partially indicates how they will be used
            at a given time. This field determines the layout in which the image
            is created. The available layouts are the members of the `),I(Yt.$$.fragment),Pr=i("-enumerant."),Ir=d("br"),Nr=i(`
            Images should initially be created in the format
            `),mr=d("code"),Dr=i("VK_IMAGE_LAYOUT_UNDEFINED"),hr=i(`
            or `),Br=d("code"),Cr=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),en=i(`.
            `),Ur=d("code"),tr=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),Gr=i(`
            should only be used if there is data in memory that is bound immediately
            to the image source.
            `),tn=d("code"),Yr=i("VK_IMAGE_LAYOUT_UNDEFINED"),ln=i(`
            should be used when moving the resource to another layout before use.
            Images can be moved out of the
            `),Er=d("code"),fn=i("VK_IMAGE_LAYOUT_UNDEFINED"),Lr=i(` layout at any time with little
            or no time cost.`),cn=j(),this.h()},l(Lt){e=g(Lt,"DIV",{slot:!0});var It=E(e);t=g(It,"LI",{});var Hr=E(t);r=g(Hr,"CODE",{});var kr=E(r);$=f(kr,"pLogicalDevice"),kr.forEach(l),n=g(Hr,"BR",{}),s=f(Hr,`
            A pointer to the `),S(a.$$.fragment,Hr),u=f(Hr," the Image should be associated with."),Hr.forEach(l),p=Y(It),m=g(It,"LI",{});var qr=E(m);_=g(qr,"CODE",{});var bn=E(_);v=f(bn,"flags"),bn.forEach(l),R=g(qr,"BR",{}),P=f(qr,`
            A bitmask of `),S(A.$$.fragment,qr),T=f(qr," that describe some properties of the image."),qr.forEach(l),y=Y(It),B=g(It,"LI",{});var Sr=E(B);M=g(Sr,"CODE",{});var wn=E(M);O=f(wn,"type"),wn.forEach(l),x=g(Sr,"BR",{}),F=f(Sr,`
            The type of image being created. The image type is essentially the dimensionality
            of the image and can be `),V=g(Sr,"CODE",{});var In=E(V);q=f(In,"VK_IMAGE_TYPE_1D"),In.forEach(l),k=f(Sr,`,
            `),N=g(Sr,"CODE",{});var Xr=E(N);Q=f(Xr,"VK_IMAGE_TYPE_2D"),Xr.forEach(l),X=f(Sr,`
            or `),Z=g(Sr,"CODE",{});var Dn=E(Z);K=f(Dn,"VK_IMAGE_TYPE_3D"),Dn.forEach(l),W=f(Sr,`
            for a 1D, 2D or 3D image respectively.`),Sr.forEach(l),U=Y(It),G=g(It,"LI",{});var nn=E(G);te=g(nn,"CODE",{});var xt=E(te);ee=f(xt,"format"),xt.forEach(l),ne=g(nn,"BR",{}),le=f(nn,`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),nn.forEach(l),ae=Y(It),J=g(It,"LI",{});var ar=E(J);ue=g(ar,"CODE",{});var Hn=E(ue);De=f(Hn,"extent"),Hn.forEach(l),de=g(ar,"BR",{}),me=f(ar,`
            The size of the image in texels. This should be an instance of the `),S(Ce.$$.fragment,ar),_e=f(ar,`
            structure , which has three members: `),se=g(ar,"CODE",{});var qn=E(se);ie=f(qn,"width"),qn.forEach(l),ge=f(ar,`,
            `),we=g(ar,"CODE",{});var Wn=E(we);Re=f(Wn,"height"),Wn.forEach(l),Be=f(ar,", and "),Ie=g(ar,"CODE",{});var Bn=E(Ie);re=f(Bn,"depth"),Bn.forEach(l),he=f(ar,`. These should be set
            respectively to the width, height and depth of the desired image.
            For 1D images, the height should be set to `),Ae=g(ar,"CODE",{});var Qn=E(Ae);Ve=f(Qn,"1"),Qn.forEach(l),oe=f(ar,`, and for
            1D and 2D images, the depth should be set to `),ce=g(ar,"CODE",{});var Kn=E(ce);Pe=f(Kn,"1"),Kn.forEach(l),Fe=f(ar,"."),ar.forEach(l),ke=Y(It),Te=g(It,"LI",{});var $n=E(Te);Me=g($n,"CODE",{});var zn=E(Me);Ue=f(zn,"mipLevels"),zn.forEach(l),qe=g($n,"BR",{}),xe=f($n,`
            The number of mipmap levels to create in the image.`),$n.forEach(l),Ge=Y(It),ye=g(It,"LI",{});var Ln=E(ye);We=g(Ln,"CODE",{});var kn=E(We);ze=f(kn,"arrayLayers"),kn.forEach(l),Ye=g(Ln,"BR",{}),rt=f(Ln,`
            The amount of images each mipmap level of the image has.`),Ln.forEach(l),Ne=Y(It),He=g(It,"LI",{});var un=E(He);$t=g(un,"CODE",{});var jn=E($t);ut=f(jn,"samples"),jn.forEach(l),ht=g(un,"BR",{}),Je=f(un,`
            The number of samples in the image. It must be a member of the `),S(dt.$$.fragment,un),et=f(un,"-enumerant."),un.forEach(l),Ze=Y(It),nt=g(It,"LI",{});var Wr=E(nt);Ke=g(Wr,"CODE",{});var Yn=E(Ke);ct=f(Yn,"tiling"),Yn.forEach(l),st=g(Wr,"BR",{}),Qe=f(Wr,`
            A member of the `),S(at.$$.fragment,Wr),bt=f(Wr,"-enumerant, which contains only "),wt=g(Wr,"CODE",{});var Xn=E(wt);St=f(Xn,"VK_IMAGE_TILING_LINEAR"),Xn.forEach(l),tt=f(Wr,`
            or
            `),ot=g(Wr,"CODE",{});var Tn=E(ot);At=f(Tn,"VK_IMAGE_TILING_OPTIMAL"),Tn.forEach(l),it=f(Wr,`. Linear tiling means that image
            data is laid out from left to right, top to bottom, so that if the
            underlying memory is mapped and it is written with the CPU, it would
            form a linear image. Meanwhile, optimal tiling is an opaque display
            used by Vulkan to store data in memory to improve the efficiency of
            the memory subsystem on the device. This is generally what should be
            chosen unless the image needs to be CPU mapped and manipulated.
            Optimal tiling is likely to outperform linear tiling in most
            operations, and linear tiling may not be supported at all for some
            operations or formats, depending on the Vulkan implementation.`),Wr.forEach(l),Xe=Y(It),Dt=g(It,"LI",{});var pn=E(Dt);Ct=g(pn,"CODE",{});var Zn=E(Ct);pt=f(Zn,"usage"),Zn.forEach(l),yt=g(pn,"BR",{}),mt=f(pn,`
            A bitmask of members of the `),S(Ot.$$.fragment,pn),Pt=f(pn,"-enumerant telling Vulkan how the Image will be used."),pn.forEach(l),Tt=Y(It),vt=g(It,"LI",{});var Gt=E(vt);gt=g(Gt,"CODE",{});var Jn=E(gt);kt=f(Jn,"sharingMode"),Jn.forEach(l),Ft=g(Gt,"BR",{}),Mt=f(Gt,`
            A member of the `),S(Ht.$$.fragment,Gt),$r=f(Gt,`-enumerant indicating how the Image will be used in the multiple
            device `),S(Ut.$$.fragment,Gt),or=f(Gt,` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Image will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Xt=g(Gt,"CODE",{});var es=E(Xt);Vt=f(es,"sharingMode"),es.forEach(l),Zt=f(Gt,`
            to `),Ar=g(Gt,"CODE",{});var On=E(Ar);br=f(On,"VK_SHARING_MODE_EXCLUSIVE"),On.forEach(l),ur=f(Gt,` tells Vulkan that the
            Image will only be used for a single `),S(Qt.$$.fragment,Gt),Vr=f(Gt,`, while setting
            `),rr=g(Gt,"CODE",{});var ts=E(rr);Kr=f(ts,"sharingMode"),ts.forEach(l),lr=f(Gt,`
            to
            `),gr=g(Gt,"CODE",{});var rs=E(gr);yr=f(rs,"VK_SHARING_MODE_CONCURRENT"),rs.forEach(l),Kt=f(Gt,` specifies that the
            application will use the Image on multiple `),S(ir.$$.fragment,Gt),Mr=f(Gt,` at once. Using
            `),Le=g(Gt,"CODE",{});var Vn=E(Le);lt=f(Vn,"VK_SHARING_MODE_CONCURRENT"),Vn.forEach(l),Jt=f(Gt,` may result in lower
            performance on some systems, so unless necessary,
            `),_r=g(Gt,"CODE",{});var ns=E(_r);jt=f(ns,"sharingMode"),ns.forEach(l),nr=f(Gt,`
            should be set to `),vr=g(Gt,"CODE",{});var ss=E(vr);Tr=f(ss,"VK_SHARING_MODE_EXCLUSIVE"),ss.forEach(l),fr=f(Gt,"."),Gt.forEach(l),cr=Y(It),sr=g(It,"LI",{});var rn=E(sr);er=g(rn,"CODE",{});var as=E(er);zr=f(as,"queueFamilyIndices"),as.forEach(l),_t=g(rn,"BR",{}),ft=f(rn,`
            A pointer to an array of `),S(qt.$$.fragment,rn),Fr=f(rn," family indices on which the image will be used."),rn.forEach(l),wr=Y(It),Nt=g(It,"LI",{});var dr=E(Nt);Wt=g(dr,"CODE",{});var yn=E(Wt);xr=f(yn,"initialLayout"),yn.forEach(l),pr=g(dr,"BR",{}),Or=f(dr,`
            Images have a layout, which partially indicates how they will be used
            at a given time. This field determines the layout in which the image
            is created. The available layouts are the members of the `),S(Yt.$$.fragment,dr),Pr=f(dr,"-enumerant."),Ir=g(dr,"BR",{}),Nr=f(dr,`
            Images should initially be created in the format
            `),mr=g(dr,"CODE",{});var os=E(mr);Dr=f(os,"VK_IMAGE_LAYOUT_UNDEFINED"),os.forEach(l),hr=f(dr,`
            or `),Br=g(dr,"CODE",{});var ls=E(Br);Cr=f(ls,"VK_IMAGE_LAYOUT_PREINITIALIZED"),ls.forEach(l),en=f(dr,`.
            `),Ur=g(dr,"CODE",{});var Mn=E(Ur);tr=f(Mn,"VK_IMAGE_LAYOUT_PREINITIALIZED"),Mn.forEach(l),Gr=f(dr,`
            should only be used if there is data in memory that is bound immediately
            to the image source.
            `),tn=g(dr,"CODE",{});var is=E(tn);Yr=f(is,"VK_IMAGE_LAYOUT_UNDEFINED"),is.forEach(l),ln=f(dr,`
            should be used when moving the resource to another layout before use.
            Images can be moved out of the
            `),Er=g(dr,"CODE",{});var fs=E(Er);fn=f(fs,"VK_IMAGE_LAYOUT_UNDEFINED"),fs.forEach(l),Lr=f(dr,` layout at any time with little
            or no time cost.`),dr.forEach(l),cn=Y(It),It.forEach(l),this.h()},h(){z(e,"slot","params")},m(Lt,It){h(Lt,e,It),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),o(B,V),o(V,q),o(B,k),o(B,N),o(N,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(e,U),o(e,G),o(G,te),o(te,ee),o(G,ne),o(G,le),o(e,ae),o(e,J),o(J,ue),o(ue,De),o(J,de),o(J,me),D(Ce,J,null),o(J,_e),o(J,se),o(se,ie),o(J,ge),o(J,we),o(we,Re),o(J,Be),o(J,Ie),o(Ie,re),o(J,he),o(J,Ae),o(Ae,Ve),o(J,oe),o(J,ce),o(ce,Pe),o(J,Fe),o(e,ke),o(e,Te),o(Te,Me),o(Me,Ue),o(Te,qe),o(Te,xe),o(e,Ge),o(e,ye),o(ye,We),o(We,ze),o(ye,Ye),o(ye,rt),o(e,Ne),o(e,He),o(He,$t),o($t,ut),o(He,ht),o(He,Je),D(dt,He,null),o(He,et),o(e,Ze),o(e,nt),o(nt,Ke),o(Ke,ct),o(nt,st),o(nt,Qe),D(at,nt,null),o(nt,bt),o(nt,wt),o(wt,St),o(nt,tt),o(nt,ot),o(ot,At),o(nt,it),o(e,Xe),o(e,Dt),o(Dt,Ct),o(Ct,pt),o(Dt,yt),o(Dt,mt),D(Ot,Dt,null),o(Dt,Pt),o(e,Tt),o(e,vt),o(vt,gt),o(gt,kt),o(vt,Ft),o(vt,Mt),D(Ht,vt,null),o(vt,$r),D(Ut,vt,null),o(vt,or),o(vt,Xt),o(Xt,Vt),o(vt,Zt),o(vt,Ar),o(Ar,br),o(vt,ur),D(Qt,vt,null),o(vt,Vr),o(vt,rr),o(rr,Kr),o(vt,lr),o(vt,gr),o(gr,yr),o(vt,Kt),D(ir,vt,null),o(vt,Mr),o(vt,Le),o(Le,lt),o(vt,Jt),o(vt,_r),o(_r,jt),o(vt,nr),o(vt,vr),o(vr,Tr),o(vt,fr),o(e,cr),o(e,sr),o(sr,er),o(er,zr),o(sr,_t),o(sr,ft),D(qt,sr,null),o(sr,Fr),o(e,wr),o(e,Nt),o(Nt,Wt),o(Wt,xr),o(Nt,pr),o(Nt,Or),D(Yt,Nt,null),o(Nt,Pr),o(Nt,Ir),o(Nt,Nr),o(Nt,mr),o(mr,Dr),o(Nt,hr),o(Nt,Br),o(Br,Cr),o(Nt,en),o(Nt,Ur),o(Ur,tr),o(Nt,Gr),o(Nt,tn),o(tn,Yr),o(Nt,ln),o(Nt,Er),o(Er,fn),o(Nt,Lr),o(e,cn),jr=!0},p(Lt,It){const Hr={};It&1&&(Hr.$$scope={dirty:It,ctx:Lt}),a.$set(Hr);const kr={};It&1&&(kr.$$scope={dirty:It,ctx:Lt}),A.$set(kr);const qr={};It&1&&(qr.$$scope={dirty:It,ctx:Lt}),Ce.$set(qr);const bn={};It&1&&(bn.$$scope={dirty:It,ctx:Lt}),dt.$set(bn);const Sr={};It&1&&(Sr.$$scope={dirty:It,ctx:Lt}),at.$set(Sr);const wn={};It&1&&(wn.$$scope={dirty:It,ctx:Lt}),Ot.$set(wn);const In={};It&1&&(In.$$scope={dirty:It,ctx:Lt}),Ht.$set(In);const Xr={};It&1&&(Xr.$$scope={dirty:It,ctx:Lt}),Ut.$set(Xr);const Dn={};It&1&&(Dn.$$scope={dirty:It,ctx:Lt}),Qt.$set(Dn);const nn={};It&1&&(nn.$$scope={dirty:It,ctx:Lt}),ir.$set(nn);const xt={};It&1&&(xt.$$scope={dirty:It,ctx:Lt}),qt.$set(xt);const ar={};It&1&&(ar.$$scope={dirty:It,ctx:Lt}),Yt.$set(ar)},i(Lt){jr||(b(a.$$.fragment,Lt),b(A.$$.fragment,Lt),b(Ce.$$.fragment,Lt),b(dt.$$.fragment,Lt),b(at.$$.fragment,Lt),b(Ot.$$.fragment,Lt),b(Ht.$$.fragment,Lt),b(Ut.$$.fragment,Lt),b(Qt.$$.fragment,Lt),b(ir.$$.fragment,Lt),b(qt.$$.fragment,Lt),b(Yt.$$.fragment,Lt),jr=!0)},o(Lt){w(a.$$.fragment,Lt),w(A.$$.fragment,Lt),w(Ce.$$.fragment,Lt),w(dt.$$.fragment,Lt),w(at.$$.fragment,Lt),w(Ot.$$.fragment,Lt),w(Ht.$$.fragment,Lt),w(Ut.$$.fragment,Lt),w(Qt.$$.fragment,Lt),w(ir.$$.fragment,Lt),w(qt.$$.fragment,Lt),w(Yt.$$.fragment,Lt),jr=!1},d(Lt){Lt&&l(e),C(a),C(A),C(Ce),C(dt),C(at),C(Ot),C(Ht),C(Ut),C(Qt),C(ir),C(qt),C(Yt)}}}function eS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tS(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkImage",version:1.3,$$slots:{default:[eS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function rS(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nS(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[rS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wrap around a "),I(r.$$.fragment),$=i(" Image."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Wrap around a "),S(r.$$.fragment,a),$=f(a," Image."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function sS(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aS(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oS(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fS(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[sS]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[aS]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[oS]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[lS]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[iS]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" Image is associated with."),_=j(),v=d("li"),R=d("code"),P=i("pSwapchain"),A=d("br"),T=i(`
            A pointer to the `),I(y.$$.fragment),B=i(" which owns the "),I(M.$$.fragment),O=i("."),x=j(),F=d("li"),V=d("code"),q=i("hImage"),k=d("br"),N=i(`
            The handle to the `),I(Q.$$.fragment),X=i(" to wrap around."),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var U=E(t);r=g(U,"CODE",{});var G=E(r);$=f(G,"pLogicalDevice"),G.forEach(l),n=g(U,"BR",{}),s=f(U,`
            A pointer to the `),S(a.$$.fragment,U),u=f(U," the "),S(p.$$.fragment,U),m=f(U," Image is associated with."),U.forEach(l),_=Y(W),v=g(W,"LI",{});var te=E(v);R=g(te,"CODE",{});var ee=E(R);P=f(ee,"pSwapchain"),ee.forEach(l),A=g(te,"BR",{}),T=f(te,`
            A pointer to the `),S(y.$$.fragment,te),B=f(te," which owns the "),S(M.$$.fragment,te),O=f(te,"."),te.forEach(l),x=Y(W),F=g(W,"LI",{});var ne=E(F);V=g(ne,"CODE",{});var le=E(V);q=f(le,"hImage"),le.forEach(l),k=g(ne,"BR",{}),N=f(ne,`
            The handle to the `),S(Q.$$.fragment,ne),X=f(ne," to wrap around."),ne.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),Z=!0},p(K,W){const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),a.$set(U);const G={};W&1&&(G.$$scope={dirty:W,ctx:K}),p.$set(G);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),y.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),M.$set(ee);const ne={};W&1&&(ne.$$scope={dirty:W,ctx:K}),Q.$set(ne)},i(K){Z||(b(a.$$.fragment,K),b(p.$$.fragment,K),b(y.$$.fragment,K),b(M.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(a.$$.fragment,K),w(p.$$.fragment,K),w(y.$$.fragment,K),w(M.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){K&&l(e),C(a),C(p),C(y),C(M),C(Q)}}}function cS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $S(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[cS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function uS(c){let e,t,r,$;return{c(){e=d("span"),t=i(`This Constructor is primarily used by the Swapchain to create Image
        Views for it's images.`),r=d("br"),$=i(`
        By using this Constructor most class members will have their default values.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,`This Constructor is primarily used by the Swapchain to create Image
        Views for it's images.`),r=g(s,"BR",{}),$=f(s,`
        By using this Constructor most class members will have their default values.`),s.forEach(l),this.h()},h(){z(e,"slot","note")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function pS(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:`Image(
    LogicalDevice* pLogicalDevice, 
    VkImageCreateFlags flags, 
    VkImageType type, 
    VkFormat format, 
    VkExtent3D extent, 
    unsigned int mipLevels,
    unsigned int arrayLayers, 
    VkSampleCountFlagBits samples, 
    VkImageTiling tiling, 
    VkImageUsageFlags usage, 
    VkSharingMode sharingMode,
    std::vector<uint32_t>& queueFamilyIndices, 
    VkImageLayout initialLayout
);`}}),r=new Se({props:{$$slots:{throws:[tS],params:[JC],details:[NC]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`Image(
    LogicalDevice* pLogicalDevice, 
    Swapchain* pSwapchain, 
    VkImage hImage
);`}}),u=new Se({props:{$$slots:{note:[uS],throws:[$S],params:[fS],details:[nS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class mS extends ve{constructor(e){super(),Ee(this,e,null,pS,be,{})}}function hS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dS(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[hS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gS(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _S(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[gS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkImage getImageHandle() const;"}}),r=new Se({props:{$$slots:{return:[_S],details:[dS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ES extends ve{constructor(e){super(),Ee(this,e,null,vS,be,{})}}function bS(c){let e,t;return{c(){e=d("span"),t=i("Get the flags used for creating the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the flags used for creating the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function wS(c){let e,t;return{c(){e=d("span"),t=i("The flags set when creating of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The flags set when creating of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function IS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageCreateFlags getFlags();"}}),r=new Se({props:{$$slots:{return:[wS],details:[bS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DS extends ve{constructor(e){super(),Ee(this,e,null,IS,be,{})}}function CS(c){let e,t;return{c(){e=d("span"),t=i("Get the intended usage of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended usage of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function SS(c){let e,t;return{c(){e=d("span"),t=i("The intended usage of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The intended usage of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function RS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageUsageFlags getUsage();"}}),r=new Se({props:{$$slots:{return:[SS],details:[CS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class AS extends ve{constructor(e){super(),Ee(this,e,null,RS,be,{})}}function PS(c){let e,t;return{c(){e=d("span"),t=i("Get the sharing mode of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sharing mode of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function BS(c){let e,t;return{c(){e=d("span"),t=i("The sharing mode of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sharing mode of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function LS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSharingMode getSharingMode();"}}),r=new Se({props:{$$slots:{return:[BS],details:[PS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kS extends ve{constructor(e){super(),Ee(this,e,null,LS,be,{})}}function TS(c){let e,t;return{c(){e=d("span"),t=i("Get the queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function OS(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function VS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Se({props:{$$slots:{return:[OS],details:[TS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yS extends ve{constructor(e){super(),Ee(this,e,null,VS,be,{})}}function MS(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FS(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.MEMORY,$$slots:{default:[MS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind "),I(r.$$.fragment),$=i(" to the Image."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind "),S(r.$$.fragment,a),$=f(a," to the Image."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function xS(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NS(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function US(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GS(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return a=new H({props:{sectionID:L.MEMORY,$$slots:{default:[xS]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.MEMORY,$$slots:{default:[NS]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.MEMORY,$$slots:{default:[US]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pMemory"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to the Image."),p=j(),m=d("li"),_=d("code"),v=i("memoryOffset"),R=d("br"),P=i(`
            Specifies the offset in the `),I(A.$$.fragment),T=i(` object the Image will live. If only one resource will be bound to
            the `),I(y.$$.fragment),B=i(` object,
            this can be set to
            `),M=d("code"),O=i("0"),x=i("."),this.h()},l(V){e=g(V,"DIV",{slot:!0});var q=E(e);t=g(q,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"pMemory"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            A pointer to the `),S(a.$$.fragment,k),u=f(k," to bind to the Image."),k.forEach(l),p=Y(q),m=g(q,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"memoryOffset"),X.forEach(l),R=g(Q,"BR",{}),P=f(Q,`
            Specifies the offset in the `),S(A.$$.fragment,Q),T=f(Q,` object the Image will live. If only one resource will be bound to
            the `),S(y.$$.fragment,Q),B=f(Q,` object,
            this can be set to
            `),M=g(Q,"CODE",{});var Z=E(M);O=f(Z,"0"),Z.forEach(l),x=f(Q,"."),Q.forEach(l),q.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,q){h(V,e,q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),o(m,M),o(M,O),o(m,x),F=!0},p(V,q){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),a.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),A.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),y.$set(Q)},i(V){F||(b(a.$$.fragment,V),b(A.$$.fragment,V),b(y.$$.fragment,V),F=!0)},o(V){w(a.$$.fragment,V),w(A.$$.fragment,V),w(y.$$.fragment,V),F=!1},d(V){V&&l(e),C(a),C(A),C(y)}}}function HS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void bindMemory(Memory* pMemory, VkDeviceSize memoryOffset = 0);"}}),r=new Se({props:{$$slots:{params:[GS],details:[FS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qS extends ve{constructor(e){super(),Ee(this,e,null,HS,be,{})}}function WS(c){let e;return{c(){e=i("bindMemory")},l(t){e=f(t,"bindMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QS(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_bindMemory,$$slots:{default:[WS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the Memory bound with "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the Memory bound with "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function KS(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zS(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jS(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.MEMORY,$$slots:{default:[KS]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.MEMORY,$$slots:{default:[zS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function YS(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Memory* getMemory() const;"}}),r=new Se({props:{$$slots:{return:[jS],details:[QS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class XS extends ve{constructor(e){super(),Ee(this,e,null,YS,be,{})}}function ZS(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JS(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[ZS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create an "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create an "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function eR(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tR(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sR(c){let e;return{c(){e=i("VkImageSubresourceRange")},l(t){e=f(t,"VkImageSubresourceRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oR(c){let e;return{c(){e=i("VkComponentMapping")},l(t){e=f(t,"VkComponentMapping")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lR(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[eR]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[tR]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[rR]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[nR]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html",target:"_blank",$$slots:{default:[sR]},$$scope:{ctx:c}}}),ee=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[aR]},$$scope:{ctx:c}}}),le=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html",target:"_blank",$$slots:{default:[oR]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewType"),n=d("br"),s=i(`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),I(a.$$.fragment),u=i("-enumeration, which is larger than the "),I(p.$$.fragment),m=i("-enumeration used when creating the parent Image."),_=j(),v=d("li"),R=d("code"),P=i("format"),A=d("br"),T=i(`
            The format of the new `),I(y.$$.fragment),B=i(`. This must be a format compatible with the parent image. If two
            formats have the same number of bits per pixel, they are generally
            considered compatible.`),M=j(),O=d("li"),x=d("code"),F=i("subresourceRange"),V=d("br"),q=i(`
            The `),I(k.$$.fragment),N=i(` can be a subset of the parent Image. This subset is specified using
            the embedded `),I(Q.$$.fragment),X=i("-structure."),Z=j(),K=d("li"),W=d("code"),U=i("components"),G=d("br"),te=i(`
            The order of the components in the `),I(ee.$$.fragment),ne=i(` may differ from that in the parent Image. This makes it possible, for
            example, to create an RGBA representation of an Image in BGRA format.
            This remapping is specified using an instance of the `),I(le.$$.fragment),ae=i("-structure."),this.h()},l(ue){e=g(ue,"DIV",{slot:!0});var De=E(e);t=g(De,"LI",{});var de=E(t);r=g(de,"CODE",{});var me=E(r);$=f(me,"viewType"),me.forEach(l),n=g(de,"BR",{}),s=f(de,`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),S(a.$$.fragment,de),u=f(de,"-enumeration, which is larger than the "),S(p.$$.fragment,de),m=f(de,"-enumeration used when creating the parent Image."),de.forEach(l),_=Y(De),v=g(De,"LI",{});var Ce=E(v);R=g(Ce,"CODE",{});var _e=E(R);P=f(_e,"format"),_e.forEach(l),A=g(Ce,"BR",{}),T=f(Ce,`
            The format of the new `),S(y.$$.fragment,Ce),B=f(Ce,`. This must be a format compatible with the parent image. If two
            formats have the same number of bits per pixel, they are generally
            considered compatible.`),Ce.forEach(l),M=Y(De),O=g(De,"LI",{});var se=E(O);x=g(se,"CODE",{});var ie=E(x);F=f(ie,"subresourceRange"),ie.forEach(l),V=g(se,"BR",{}),q=f(se,`
            The `),S(k.$$.fragment,se),N=f(se,` can be a subset of the parent Image. This subset is specified using
            the embedded `),S(Q.$$.fragment,se),X=f(se,"-structure."),se.forEach(l),Z=Y(De),K=g(De,"LI",{});var ge=E(K);W=g(ge,"CODE",{});var we=E(W);U=f(we,"components"),we.forEach(l),G=g(ge,"BR",{}),te=f(ge,`
            The order of the components in the `),S(ee.$$.fragment,ge),ne=f(ge,` may differ from that in the parent Image. This makes it possible, for
            example, to create an RGBA representation of an Image in BGRA format.
            This remapping is specified using an instance of the `),S(le.$$.fragment,ge),ae=f(ge,"-structure."),ge.forEach(l),De.forEach(l),this.h()},h(){z(e,"slot","params")},m(ue,De){h(ue,e,De),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),D(ee,K,null),o(K,ne),D(le,K,null),o(K,ae),J=!0},p(ue,De){const de={};De&1&&(de.$$scope={dirty:De,ctx:ue}),a.$set(de);const me={};De&1&&(me.$$scope={dirty:De,ctx:ue}),p.$set(me);const Ce={};De&1&&(Ce.$$scope={dirty:De,ctx:ue}),y.$set(Ce);const _e={};De&1&&(_e.$$scope={dirty:De,ctx:ue}),k.$set(_e);const se={};De&1&&(se.$$scope={dirty:De,ctx:ue}),Q.$set(se);const ie={};De&1&&(ie.$$scope={dirty:De,ctx:ue}),ee.$set(ie);const ge={};De&1&&(ge.$$scope={dirty:De,ctx:ue}),le.$set(ge)},i(ue){J||(b(a.$$.fragment,ue),b(p.$$.fragment,ue),b(y.$$.fragment,ue),b(k.$$.fragment,ue),b(Q.$$.fragment,ue),b(ee.$$.fragment,ue),b(le.$$.fragment,ue),J=!0)},o(ue){w(a.$$.fragment,ue),w(p.$$.fragment,ue),w(y.$$.fragment,ue),w(k.$$.fragment,ue),w(Q.$$.fragment,ue),w(ee.$$.fragment,ue),w(le.$$.fragment,ue),J=!1},d(ue){ue&&l(e),C(a),C(p),C(y),C(k),C(Q),C(ee),C(le)}}}function iR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cR(c){let e;return{c(){e=i("getImageView")},l(t){e=f(t,"getImageView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $R(c){let e,t,r,$,n,s,a,u,p;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[iR]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[fR]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.IMAGE_getImageView,$$slots:{default:[cR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to get the created "),I(n.$$.fragment),s=i(" using "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to get the created "),S(n.$$.fragment,_),s=f(_," using "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),n.$set(R);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function uR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pR(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[uR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function mR(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`unsigned int createImageView(
    VkImageViewType viewType, 
    VkFormat format,
    VkImageSubresourceRange subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1},
    VkComponentMapping components = {VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY,
                                    VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY}
);`}}),r=new Se({props:{$$slots:{throws:[pR],return:[$R],params:[lR],details:[JS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hR extends ve{constructor(e){super(),Ee(this,e,null,mR,be,{})}}function dR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gR(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[dR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to an "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to an "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _R(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vR(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[_R]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to get."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"index"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to get."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function ER(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bR(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[ER]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wR(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"ImageView* getImageView(unsigned int index);"}}),r=new Se({props:{$$slots:{return:[bR],params:[vR],details:[gR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class IR extends ve{constructor(e){super(),Ee(this,e,null,wR,be,{})}}function DR(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CR(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[DR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy all created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy all created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function SR(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroyImageViews();"}}),r=new Se({props:{$$slots:{details:[CR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RR extends ve{constructor(e){super(),Ee(this,e,null,SR,be,{})}}function AR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PR(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[AR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy an "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy an "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function BR(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LR(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[BR]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to destroy."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"index"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to destroy."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function kR(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void destroyImageView(unsigned int index);"}}),r=new Se({props:{$$slots:{params:[LR],details:[PR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TR extends ve{constructor(e){super(),Ee(this,e,null,kR,be,{})}}function OR(c){let e,t;return{c(){e=d("span"),t=i("Copy this Image's data to a given Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Image's data to a given Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function VR(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yR(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MR(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FR(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xR(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NR(c){let e;return{c(){e=i("VkImageCopy")},l(t){e=f(t,"VkImageCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UR(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[VR]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.IMAGE,$$slots:{default:[yR]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[MR]},$$scope:{ctx:c}}}),de=new H({props:{sectionID:L.IMAGE,$$slots:{default:[FR]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[xR]},$$scope:{ctx:c}}}),Me=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html",target:"_blank",$$slots:{default:[NR]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=j(),m=d("li"),_=d("code"),v=i("pImage"),R=d("br"),P=i(`
            A pointer to the Image to copy this Image's data to.`),A=j(),T=d("li"),y=d("code"),B=i("srcLayout"),M=d("br"),O=i(`
            The layout of the sourece `),I(x.$$.fragment),F=i(` (this Image) subresources for the copy. This should be a member of
            the `),I(V.$$.fragment),q=i("-enumerant."),k=d("br"),N=i(`
            This is most likely either
            `),Q=d("code"),X=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Z=i(`,
            `),K=d("code"),W=i("VK_IMAGE_LAYOUT_GENERAL"),U=i(`
            or `),G=d("code"),te=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ee=i("."),ne=j(),le=d("li"),ae=d("code"),J=i("dstLayout"),ue=d("br"),De=i(`
            The layout of the destination `),I(de.$$.fragment),me=i(" subresources for the copy. This should be a member of the "),I(Ce.$$.fragment),_e=i("-enumerant."),se=d("br"),ie=i(`
            This is most likely either
            `),ge=d("code"),we=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Re=i(`,
            `),Be=d("code"),Ie=i("VK_IMAGE_LAYOUT_GENERAL"),re=i(`
            or `),he=d("code"),Ae=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),Ve=i("."),oe=j(),ce=d("li"),Pe=d("code"),Fe=i("regions"),ke=d("br"),Te=i(`
            An array of `),I(Me.$$.fragment),Ue=i("-structures, each of which describes a region of data to copy."),qe=j(),this.h()},l(Ge){e=g(Ge,"DIV",{slot:!0});var ye=E(e);t=g(ye,"LI",{});var We=E(t);r=g(We,"CODE",{});var ze=E(r);$=f(ze,"pCommandBuffer"),ze.forEach(l),n=g(We,"BR",{}),s=f(We,`
            The `),S(a.$$.fragment,We),u=f(We," to use to execute the copy."),We.forEach(l),p=Y(ye),m=g(ye,"LI",{});var Ye=E(m);_=g(Ye,"CODE",{});var rt=E(_);v=f(rt,"pImage"),rt.forEach(l),R=g(Ye,"BR",{}),P=f(Ye,`
            A pointer to the Image to copy this Image's data to.`),Ye.forEach(l),A=Y(ye),T=g(ye,"LI",{});var Ne=E(T);y=g(Ne,"CODE",{});var He=E(y);B=f(He,"srcLayout"),He.forEach(l),M=g(Ne,"BR",{}),O=f(Ne,`
            The layout of the sourece `),S(x.$$.fragment,Ne),F=f(Ne,` (this Image) subresources for the copy. This should be a member of
            the `),S(V.$$.fragment,Ne),q=f(Ne,"-enumerant."),k=g(Ne,"BR",{}),N=f(Ne,`
            This is most likely either
            `),Q=g(Ne,"CODE",{});var $t=E(Q);X=f($t,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),$t.forEach(l),Z=f(Ne,`,
            `),K=g(Ne,"CODE",{});var ut=E(K);W=f(ut,"VK_IMAGE_LAYOUT_GENERAL"),ut.forEach(l),U=f(Ne,`
            or `),G=g(Ne,"CODE",{});var ht=E(G);te=f(ht,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ht.forEach(l),ee=f(Ne,"."),Ne.forEach(l),ne=Y(ye),le=g(ye,"LI",{});var Je=E(le);ae=g(Je,"CODE",{});var dt=E(ae);J=f(dt,"dstLayout"),dt.forEach(l),ue=g(Je,"BR",{}),De=f(Je,`
            The layout of the destination `),S(de.$$.fragment,Je),me=f(Je," subresources for the copy. This should be a member of the "),S(Ce.$$.fragment,Je),_e=f(Je,"-enumerant."),se=g(Je,"BR",{}),ie=f(Je,`
            This is most likely either
            `),ge=g(Je,"CODE",{});var et=E(ge);we=f(et,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),et.forEach(l),Re=f(Je,`,
            `),Be=g(Je,"CODE",{});var Ze=E(Be);Ie=f(Ze,"VK_IMAGE_LAYOUT_GENERAL"),Ze.forEach(l),re=f(Je,`
            or `),he=g(Je,"CODE",{});var nt=E(he);Ae=f(nt,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),nt.forEach(l),Ve=f(Je,"."),Je.forEach(l),oe=Y(ye),ce=g(ye,"LI",{});var Ke=E(ce);Pe=g(Ke,"CODE",{});var ct=E(Pe);Fe=f(ct,"regions"),ct.forEach(l),ke=g(Ke,"BR",{}),Te=f(Ke,`
            An array of `),S(Me.$$.fragment,Ke),Ue=f(Ke,"-structures, each of which describes a region of data to copy."),Ke.forEach(l),qe=Y(ye),ye.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ge,ye){h(Ge,e,ye),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),D(V,T,null),o(T,q),o(T,k),o(T,N),o(T,Q),o(Q,X),o(T,Z),o(T,K),o(K,W),o(T,U),o(T,G),o(G,te),o(T,ee),o(e,ne),o(e,le),o(le,ae),o(ae,J),o(le,ue),o(le,De),D(de,le,null),o(le,me),D(Ce,le,null),o(le,_e),o(le,se),o(le,ie),o(le,ge),o(ge,we),o(le,Re),o(le,Be),o(Be,Ie),o(le,re),o(le,he),o(he,Ae),o(le,Ve),o(e,oe),o(e,ce),o(ce,Pe),o(Pe,Fe),o(ce,ke),o(ce,Te),D(Me,ce,null),o(ce,Ue),o(e,qe),xe=!0},p(Ge,ye){const We={};ye&1&&(We.$$scope={dirty:ye,ctx:Ge}),a.$set(We);const ze={};ye&1&&(ze.$$scope={dirty:ye,ctx:Ge}),x.$set(ze);const Ye={};ye&1&&(Ye.$$scope={dirty:ye,ctx:Ge}),V.$set(Ye);const rt={};ye&1&&(rt.$$scope={dirty:ye,ctx:Ge}),de.$set(rt);const Ne={};ye&1&&(Ne.$$scope={dirty:ye,ctx:Ge}),Ce.$set(Ne);const He={};ye&1&&(He.$$scope={dirty:ye,ctx:Ge}),Me.$set(He)},i(Ge){xe||(b(a.$$.fragment,Ge),b(x.$$.fragment,Ge),b(V.$$.fragment,Ge),b(de.$$.fragment,Ge),b(Ce.$$.fragment,Ge),b(Me.$$.fragment,Ge),xe=!0)},o(Ge){w(a.$$.fragment,Ge),w(x.$$.fragment,Ge),w(V.$$.fragment,Ge),w(de.$$.fragment,Ge),w(Ce.$$.fragment,Ge),w(Me.$$.fragment,Ge),xe=!1},d(Ge){Ge&&l(e),C(a),C(x),C(V),C(de),C(Ce),C(Me)}}}function GR(c){let e,t;return{c(){e=d("span"),t=i("Copy this Image's data to a given Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Image's data to a given Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function HR(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WR(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QR(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KR(c){let e;return{c(){e=i("VkBufferImageCopy")},l(t){e=f(t,"VkBufferImageCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zR(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[HR]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.BUFFER,$$slots:{default:[qR]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.IMAGE,$$slots:{default:[WR]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[QR]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html",target:"_blank",$$slots:{default:[KR]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=j(),m=d("li"),_=d("code"),v=i("pBuffer"),R=d("br"),P=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to copy this Image's data to."),y=j(),B=d("li"),M=d("code"),O=i("srcLayout"),x=d("br"),F=i(`
            The layout of the sourece `),I(V.$$.fragment),q=i(` (this Image) subresources for the copy. This should be a member of
            the `),I(k.$$.fragment),N=i("-enumerant."),Q=d("br"),X=i(`
            This is most likely either
            `),Z=d("code"),K=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),W=i(`,
            `),U=d("code"),G=i("VK_IMAGE_LAYOUT_GENERAL"),te=i(`
            or `),ee=d("code"),ne=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),le=i("."),ae=j(),J=d("li"),ue=d("code"),De=i("regions"),de=d("br"),me=i(`
            An array of `),I(Ce.$$.fragment),_e=i("-structures, each of which describes a region of data to copy."),se=j(),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Re=E(t);r=g(Re,"CODE",{});var Be=E(r);$=f(Be,"pCommandBuffer"),Be.forEach(l),n=g(Re,"BR",{}),s=f(Re,`
            The `),S(a.$$.fragment,Re),u=f(Re," to use to execute the copy."),Re.forEach(l),p=Y(we),m=g(we,"LI",{});var Ie=E(m);_=g(Ie,"CODE",{});var re=E(_);v=f(re,"pBuffer"),re.forEach(l),R=g(Ie,"BR",{}),P=f(Ie,`
            A pointer to the `),S(A.$$.fragment,Ie),T=f(Ie," to copy this Image's data to."),Ie.forEach(l),y=Y(we),B=g(we,"LI",{});var he=E(B);M=g(he,"CODE",{});var Ae=E(M);O=f(Ae,"srcLayout"),Ae.forEach(l),x=g(he,"BR",{}),F=f(he,`
            The layout of the sourece `),S(V.$$.fragment,he),q=f(he,` (this Image) subresources for the copy. This should be a member of
            the `),S(k.$$.fragment,he),N=f(he,"-enumerant."),Q=g(he,"BR",{}),X=f(he,`
            This is most likely either
            `),Z=g(he,"CODE",{});var Ve=E(Z);K=f(Ve,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Ve.forEach(l),W=f(he,`,
            `),U=g(he,"CODE",{});var oe=E(U);G=f(oe,"VK_IMAGE_LAYOUT_GENERAL"),oe.forEach(l),te=f(he,`
            or `),ee=g(he,"CODE",{});var ce=E(ee);ne=f(ce,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ce.forEach(l),le=f(he,"."),he.forEach(l),ae=Y(we),J=g(we,"LI",{});var Pe=E(J);ue=g(Pe,"CODE",{});var Fe=E(ue);De=f(Fe,"regions"),Fe.forEach(l),de=g(Pe,"BR",{}),me=f(Pe,`
            An array of `),S(Ce.$$.fragment,Pe),_e=f(Pe,"-structures, each of which describes a region of data to copy."),Pe.forEach(l),se=Y(we),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),o(B,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,U),o(U,G),o(B,te),o(B,ee),o(ee,ne),o(B,le),o(e,ae),o(e,J),o(J,ue),o(ue,De),o(J,de),o(J,me),D(Ce,J,null),o(J,_e),o(e,se),ie=!0},p(ge,we){const Re={};we&1&&(Re.$$scope={dirty:we,ctx:ge}),a.$set(Re);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),A.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),V.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),Ce.$set(he)},i(ge){ie||(b(a.$$.fragment,ge),b(A.$$.fragment,ge),b(V.$$.fragment,ge),b(k.$$.fragment,ge),b(Ce.$$.fragment,ge),ie=!0)},o(ge){w(a.$$.fragment,ge),w(A.$$.fragment,ge),w(V.$$.fragment,ge),w(k.$$.fragment,ge),w(Ce.$$.fragment,ge),ie=!1},d(ge){ge&&l(e),C(a),C(A),C(V),C(k),C(Ce)}}}function jR(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:`void copyTo(
    CommandBuffer* pCommandBuffer, 
    Image* pImage, 
    VkImageLayout srcLayout, 
    VkImageLayout dstLayout,
    std::vector<VkImageCopy>& regions
);`}}),r=new Se({props:{$$slots:{params:[UR],details:[OR]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`void copyTo(
    CommandBuffer* pCommandBuffer, 
    Buffer* pImage, 
    VkImageLayout srcLayout, 
    std::vector<VkBufferImageCopy>& regions
);`}}),u=new Se({props:{$$slots:{params:[zR],details:[GR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment),p=d("br")},l(_){S(e.$$.fragment,_),t=Y(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=Y(_),S(s.$$.fragment,_),a=Y(_),S(u.$$.fragment,_),p=g(_,"BR",{})},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class YR extends ve{constructor(e){super(),Ee(this,e,null,jR,be,{})}}function XR(c){let e,t;return{c(){e=d("span"),t=i("Get the type of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the type of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function ZR(c){let e,t;return{c(){e=d("span"),t=i("The type of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The type of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function JR(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageType getType();"}}),r=new Se({props:{$$slots:{return:[ZR],details:[XR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eA extends ve{constructor(e){super(),Ee(this,e,null,JR,be,{})}}function tA(c){let e,t;return{c(){e=d("span"),t=i("Get the format of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the format of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function rA(c){let e,t;return{c(){e=d("span"),t=i("The format of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The format of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function nA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkFormat getFormat();"}}),r=new Se({props:{$$slots:{return:[rA],details:[tA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sA extends ve{constructor(e){super(),Ee(this,e,null,nA,be,{})}}function aA(c){let e,t;return{c(){e=d("span"),t=i("Get the extent of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the extent of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function oA(c){let e,t;return{c(){e=d("span"),t=i("The extent of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The extent of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function lA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkExtent3D getExtent();"}}),r=new Se({props:{$$slots:{return:[oA],details:[aA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iA extends ve{constructor(e){super(),Ee(this,e,null,lA,be,{})}}function fA(c){let e,t;return{c(){e=d("span"),t=i("Get the amount of mipmap levels of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the amount of mipmap levels of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function cA(c){let e,t;return{c(){e=d("span"),t=i("The amount of mipmap levels of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The amount of mipmap levels of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function $A(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getMipLevels();"}}),r=new Se({props:{$$slots:{return:[cA],details:[fA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uA extends ve{constructor(e){super(),Ee(this,e,null,$A,be,{})}}function pA(c){let e,t;return{c(){e=d("span"),t=i("Get the amount of array layers of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the amount of array layers of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function mA(c){let e,t;return{c(){e=d("span"),t=i("The amount of array layers of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The amount of array layers of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function hA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getArrayLayers();"}}),r=new Se({props:{$$slots:{return:[mA],details:[pA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dA extends ve{constructor(e){super(),Ee(this,e,null,hA,be,{})}}function gA(c){let e,t;return{c(){e=d("span"),t=i("Get the sample count of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sample count of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function _A(c){let e,t;return{c(){e=d("span"),t=i("The sample count of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sample count of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function vA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkSampleCountFlagBits getSamples();"}}),r=new Se({props:{$$slots:{return:[_A],details:[gA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class EA extends ve{constructor(e){super(),Ee(this,e,null,vA,be,{})}}function bA(c){let e,t;return{c(){e=d("span"),t=i("Get the tiling of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the tiling of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function wA(c){let e,t;return{c(){e=d("span"),t=i("The tiling of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The tiling of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function IA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageTiling getTiling();"}}),r=new Se({props:{$$slots:{return:[wA],details:[bA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DA extends ve{constructor(e){super(),Ee(this,e,null,IA,be,{})}}function CA(c){let e,t;return{c(){e=d("span"),t=i("Get the initial layout of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the initial layout of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function SA(c){let e,t;return{c(){e=d("span"),t=i("The initial layout of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The initial layout of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function RA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkImageLayout getInitialLayout();"}}),r=new Se({props:{$$slots:{return:[SA],details:[CA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class AA extends ve{constructor(e){super(),Ee(this,e,null,RA,be,{})}}function PA(c){let e;return{c(){e=i("Vulkan Image Memory Barrier")},l(t){e=f(t,"Vulkan Image Memory Barrier")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BA(c){let e;return{c(){e=i("image memory barriers")},l(t){e=f(t,"image memory barriers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LA(c){let e;return{c(){e=i("Image memory barriers")},l(t){e=f(t,"Image memory barriers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kA(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TA(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[PA]},$$scope:{ctx:c}}}),a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[BA]},$$scope:{ctx:c}}}),_=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[LA]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.QUEUE,$$slots:{default:[kA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Transition an Image from one layout to another using an "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Images are transferred from layout to layout using `),I(a.$$.fragment),u=i("."),p=d("br"),m=j(),I(_.$$.fragment),v=i(` are used to control access to an Image. They make our operations on the
        GPU happen in a certain order, which ensures that we get the expected result.
        A barrier separates two operations in a `),I(R.$$.fragment),P=i(`: before the barrier and after the barrier. Work done before the
        barrier is completed is always done before it can be used again.`),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var y=E(e);t=f(y,"Transition an Image from one layout to another using an "),S(r.$$.fragment,y),$=f(y,"."),n=g(y,"BR",{}),s=f(y,`
        Images are transferred from layout to layout using `),S(a.$$.fragment,y),u=f(y,"."),p=g(y,"BR",{}),m=Y(y),S(_.$$.fragment,y),v=f(y,` are used to control access to an Image. They make our operations on the
        GPU happen in a certain order, which ensures that we get the expected result.
        A barrier separates two operations in a `),S(R.$$.fragment,y),P=f(y,`: before the barrier and after the barrier. Work done before the
        barrier is completed is always done before it can be used again.`),y.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,y){h(T,e,y),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),o(e,p),o(e,m),D(_,e,null),o(e,v),D(R,e,null),o(e,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),r.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),a.$set(M);const O={};y&1&&(O.$$scope={dirty:y,ctx:T}),_.$set(O);const x={};y&1&&(x.$$scope={dirty:y,ctx:T}),R.$set(x)},i(T){A||(b(r.$$.fragment,T),b(a.$$.fragment,T),b(_.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(a.$$.fragment,T),w(_.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(a),C(_),C(R)}}}function OA(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VA(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yA(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MA(c){let e;return{c(){e=i("VkAccessFlagBits")},l(t){e=f(t,"VkAccessFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FA(c){let e;return{c(){e=i("VkAccessFlagBits")},l(t){e=f(t,"VkAccessFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xA(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NA(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UA(c){let e;return{c(){e=i("VkDependencyFlagBits")},l(t){e=f(t,"VkDependencyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GA(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[OA]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[VA]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[yA]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html",target:"_blank",$$slots:{default:[MA]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html",target:"_blank",$$slots:{default:[FA]},$$scope:{ctx:c}}}),ie=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[xA]},$$scope:{ctx:c}}}),Te=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[NA]},$$scope:{ctx:c}}}),ht=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html",target:"_blank",$$slots:{default:[UA]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to transfer the Image layout."),p=j(),m=d("li"),_=d("code"),v=i("oldLayout"),R=d("br"),P=i(`
            The layout to be used before the barrier for the image. This is a member
            of the `),I(A.$$.fragment),T=i("-enumeration."),y=j(),B=d("li"),M=d("code"),O=i("newLayout"),x=d("br"),F=i(`
            The layout to use after the barrier for the image. This is a member of
            the `),I(V.$$.fragment),q=i("-enumeration."),k=j(),N=d("li"),Q=d("code"),X=i("srcAccessMask"),Z=d("br"),K=i(`
            The access type of the source. This is a member of the `),I(W.$$.fragment),U=i("-enumeration."),G=j(),te=d("li"),ee=d("code"),ne=i("dstAccessMask"),le=d("br"),ae=i(`
            The access type of the destination. This is a member of the `),I(J.$$.fragment),ue=i("-enumeration."),De=j(),de=d("li"),me=d("code"),Ce=i("srcStageMask"),_e=d("br"),se=i(`
            The access type of the resource. This is a member of the `),I(ie.$$.fragment),ge=i("-enumeration."),we=d("br"),Re=i(`
            The `),Be=d("code"),Ie=i("srcStageMask"),re=i(` indicates when the source stage has
            finished reading or writing a source. As a result, moving that
            stage's effective position later in the pipeline doesn't change the
            fact that those accesses have been completed; it can only mean that
            the implementation is waiting longer than is really necessary to
            complete.`),he=d("br"),Ae=i(`
            So it also waits for all phases of the pipeline before the specified
            phase.`),Ve=j(),oe=d("li"),ce=d("code"),Pe=i("dstStageMask"),Fe=d("br"),ke=i(`
            Which pipeline stages will read from the source. This is what happens
            after the barrier. Built from a number of members of the `),I(Te.$$.fragment),Me=i("-enumeration."),Ue=d("br"),qe=i(`
            The `),xe=d("code"),Ge=i("dstStageMask"),ye=i(` specifies the point at which the
            pipeline will wait before continuing. If an implementation moves
            that holdpoint before, it will still work. The event it's waiting
            for will still complete when the later parts of the pipeline run.
            That implementation simply misses the opportunity to perform work
            while it waited.`),We=d("br"),ze=i(`
            Later phases in the pipeline after the specified phase are therefore
            also blocked.`),Ye=j(),rt=d("li"),Ne=d("code"),He=i("dependencyFlags"),$t=d("br"),ut=i(`
            Specifies a set of `),I(ht.$$.fragment),Je=i(`-flags describing how the dependency represented by the barrier
            affects the resources referenced by the barrier.`),this.h()},l(et){e=g(et,"DIV",{slot:!0});var Ze=E(e);t=g(Ze,"LI",{});var nt=E(t);r=g(nt,"CODE",{});var Ke=E(r);$=f(Ke,"pCommandBuffer"),Ke.forEach(l),n=g(nt,"BR",{}),s=f(nt,`
            The `),S(a.$$.fragment,nt),u=f(nt," to use to transfer the Image layout."),nt.forEach(l),p=Y(Ze),m=g(Ze,"LI",{});var ct=E(m);_=g(ct,"CODE",{});var st=E(_);v=f(st,"oldLayout"),st.forEach(l),R=g(ct,"BR",{}),P=f(ct,`
            The layout to be used before the barrier for the image. This is a member
            of the `),S(A.$$.fragment,ct),T=f(ct,"-enumeration."),ct.forEach(l),y=Y(Ze),B=g(Ze,"LI",{});var Qe=E(B);M=g(Qe,"CODE",{});var at=E(M);O=f(at,"newLayout"),at.forEach(l),x=g(Qe,"BR",{}),F=f(Qe,`
            The layout to use after the barrier for the image. This is a member of
            the `),S(V.$$.fragment,Qe),q=f(Qe,"-enumeration."),Qe.forEach(l),k=Y(Ze),N=g(Ze,"LI",{});var bt=E(N);Q=g(bt,"CODE",{});var wt=E(Q);X=f(wt,"srcAccessMask"),wt.forEach(l),Z=g(bt,"BR",{}),K=f(bt,`
            The access type of the source. This is a member of the `),S(W.$$.fragment,bt),U=f(bt,"-enumeration."),bt.forEach(l),G=Y(Ze),te=g(Ze,"LI",{});var St=E(te);ee=g(St,"CODE",{});var tt=E(ee);ne=f(tt,"dstAccessMask"),tt.forEach(l),le=g(St,"BR",{}),ae=f(St,`
            The access type of the destination. This is a member of the `),S(J.$$.fragment,St),ue=f(St,"-enumeration."),St.forEach(l),De=Y(Ze),de=g(Ze,"LI",{});var ot=E(de);me=g(ot,"CODE",{});var At=E(me);Ce=f(At,"srcStageMask"),At.forEach(l),_e=g(ot,"BR",{}),se=f(ot,`
            The access type of the resource. This is a member of the `),S(ie.$$.fragment,ot),ge=f(ot,"-enumeration."),we=g(ot,"BR",{}),Re=f(ot,`
            The `),Be=g(ot,"CODE",{});var it=E(Be);Ie=f(it,"srcStageMask"),it.forEach(l),re=f(ot,` indicates when the source stage has
            finished reading or writing a source. As a result, moving that
            stage's effective position later in the pipeline doesn't change the
            fact that those accesses have been completed; it can only mean that
            the implementation is waiting longer than is really necessary to
            complete.`),he=g(ot,"BR",{}),Ae=f(ot,`
            So it also waits for all phases of the pipeline before the specified
            phase.`),ot.forEach(l),Ve=Y(Ze),oe=g(Ze,"LI",{});var Xe=E(oe);ce=g(Xe,"CODE",{});var Dt=E(ce);Pe=f(Dt,"dstStageMask"),Dt.forEach(l),Fe=g(Xe,"BR",{}),ke=f(Xe,`
            Which pipeline stages will read from the source. This is what happens
            after the barrier. Built from a number of members of the `),S(Te.$$.fragment,Xe),Me=f(Xe,"-enumeration."),Ue=g(Xe,"BR",{}),qe=f(Xe,`
            The `),xe=g(Xe,"CODE",{});var Ct=E(xe);Ge=f(Ct,"dstStageMask"),Ct.forEach(l),ye=f(Xe,` specifies the point at which the
            pipeline will wait before continuing. If an implementation moves
            that holdpoint before, it will still work. The event it's waiting
            for will still complete when the later parts of the pipeline run.
            That implementation simply misses the opportunity to perform work
            while it waited.`),We=g(Xe,"BR",{}),ze=f(Xe,`
            Later phases in the pipeline after the specified phase are therefore
            also blocked.`),Xe.forEach(l),Ye=Y(Ze),rt=g(Ze,"LI",{});var pt=E(rt);Ne=g(pt,"CODE",{});var yt=E(Ne);He=f(yt,"dependencyFlags"),yt.forEach(l),$t=g(pt,"BR",{}),ut=f(pt,`
            Specifies a set of `),S(ht.$$.fragment,pt),Je=f(pt,`-flags describing how the dependency represented by the barrier
            affects the resources referenced by the barrier.`),pt.forEach(l),Ze.forEach(l),this.h()},h(){z(e,"slot","params")},m(et,Ze){h(et,e,Ze),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),D(J,te,null),o(te,ue),o(e,De),o(e,de),o(de,me),o(me,Ce),o(de,_e),o(de,se),D(ie,de,null),o(de,ge),o(de,we),o(de,Re),o(de,Be),o(Be,Ie),o(de,re),o(de,he),o(de,Ae),o(e,Ve),o(e,oe),o(oe,ce),o(ce,Pe),o(oe,Fe),o(oe,ke),D(Te,oe,null),o(oe,Me),o(oe,Ue),o(oe,qe),o(oe,xe),o(xe,Ge),o(oe,ye),o(oe,We),o(oe,ze),o(e,Ye),o(e,rt),o(rt,Ne),o(Ne,He),o(rt,$t),o(rt,ut),D(ht,rt,null),o(rt,Je),dt=!0},p(et,Ze){const nt={};Ze&1&&(nt.$$scope={dirty:Ze,ctx:et}),a.$set(nt);const Ke={};Ze&1&&(Ke.$$scope={dirty:Ze,ctx:et}),A.$set(Ke);const ct={};Ze&1&&(ct.$$scope={dirty:Ze,ctx:et}),V.$set(ct);const st={};Ze&1&&(st.$$scope={dirty:Ze,ctx:et}),W.$set(st);const Qe={};Ze&1&&(Qe.$$scope={dirty:Ze,ctx:et}),J.$set(Qe);const at={};Ze&1&&(at.$$scope={dirty:Ze,ctx:et}),ie.$set(at);const bt={};Ze&1&&(bt.$$scope={dirty:Ze,ctx:et}),Te.$set(bt);const wt={};Ze&1&&(wt.$$scope={dirty:Ze,ctx:et}),ht.$set(wt)},i(et){dt||(b(a.$$.fragment,et),b(A.$$.fragment,et),b(V.$$.fragment,et),b(W.$$.fragment,et),b(J.$$.fragment,et),b(ie.$$.fragment,et),b(Te.$$.fragment,et),b(ht.$$.fragment,et),dt=!0)},o(et){w(a.$$.fragment,et),w(A.$$.fragment,et),w(V.$$.fragment,et),w(W.$$.fragment,et),w(J.$$.fragment,et),w(ie.$$.fragment,et),w(Te.$$.fragment,et),w(ht.$$.fragment,et),dt=!1},d(et){et&&l(e),C(a),C(A),C(V),C(W),C(J),C(ie),C(Te),C(ht)}}}function HA(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qA(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[HA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function WA(c){let e;return{c(){e=i("Render Passes")},l(t){e=f(t,"Render Passes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QA(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[WA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("It is usually better to use "),I(r.$$.fragment),$=i(" whenever possible for transferring Images from layout to layout."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"It is usually better to use "),S(r.$$.fragment,a),$=f(a," whenever possible for transferring Images from layout to layout."),a.forEach(l),this.h()},h(){z(e,"slot","note")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function KA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void transitionImageLayout(
    CommandBuffer* pCommandBuffer, 
    VkImageLayout oldLayout, 
    VkImageLayout newLayout, 
    VkAccessFlags srcAccessMask,
    VkAccessFlags dstAccessMask, 
    VkPipelineStageFlags srcStageMask, 
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags = 0
);`}}),r=new Se({props:{$$slots:{note:[QA],return:[qA],params:[GA],details:[TA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zA extends ve{constructor(e){super(),Ee(this,e,null,KA,be,{})}}function jA(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YA(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[jA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function XA(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZA(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[XA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function JA(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<ImageView*> getImageViews();"}}),r=new Se({props:{$$slots:{return:[ZA],details:[YA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eP extends ve{constructor(e){super(),Ee(this,e,null,JA,be,{})}}function tP(c){let e,t;return{c(){e=d("span"),t=i("Get the index of the queue family of this Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the index of the queue family of this Queue."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function rP(c){let e,t;return{c(){e=d("span"),t=i("The index of the queue family of this Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of the queue family of this Queue."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function nP(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getQueueFamilyIndex();"}}),r=new Se({props:{$$slots:{return:[rP],details:[tP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sP extends ve{constructor(e){super(),Ee(this,e,null,nP,be,{})}}function aP(c){let e,t;return{c(){e=d("span"),t=i("Get the index of this Queue within the queue family."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the index of this Queue within the queue family."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function oP(c){let e,t;return{c(){e=d("span"),t=i("The index of this Queue within the queue family."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of this Queue within the queue family."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function lP(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getQueuendex();"}}),r=new Se({props:{$$slots:{return:[oP],details:[aP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iP extends ve{constructor(e){super(),Ee(this,e,null,lP,be,{})}}function fP(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cP(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[fP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function $P(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uP(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[$P]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function pP(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkBufferView getBufferViewHandle() const;"}}),r=new Se({props:{$$slots:{return:[uP],details:[cP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class mP extends ve{constructor(e){super(),Ee(this,e,null,pP,be,{})}}function hP(c){let e;return{c(){e=i("createBufferView")},l(t){e=f(t,"createBufferView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dP(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER_createBufferView,$$slots:{default:[hP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Buffer View."),r=d("br"),$=i(`
        It is recommended to not create a Buffer View by it's Constructor, but to
        use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Buffer View."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Buffer View by it's Constructor, but to
        use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function gP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _P(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vP(c){let e;return{c(){e=i("getFormatProperties")},l(t){e=f(t,"getFormatProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CP(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SP(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RP(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PP(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[gP]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.BUFFER,$$slots:{default:[_P]},$$scope:{ctx:c}}}),te=new H({props:{sectionID:L.PHYSICAL_DEVICE_getFormatProperties,$$slots:{default:[vP]},$$scope:{ctx:c}}}),de=new H({props:{sectionID:L.BUFFER,$$slots:{default:[EP]},$$scope:{ctx:c}}}),se=new H({props:{sectionID:L.BUFFER,$$slots:{default:[bP]},$$scope:{ctx:c}}}),ge=new H({props:{sectionID:L.BUFFER,$$slots:{default:[wP]},$$scope:{ctx:c}}}),Pe=new H({props:{sectionID:L.BUFFER,$$slots:{default:[IP]},$$scope:{ctx:c}}}),xe=new H({props:{sectionID:L.BUFFER,$$slots:{default:[DP]},$$scope:{ctx:c}}}),ut=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[CP]},$$scope:{ctx:c}}}),Je=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html",target:"_blank",$$slots:{default:[SP]},$$scope:{ctx:c}}}),et=new H({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[RP]},$$scope:{ctx:c}}}),nt=new H({props:{sectionID:L.BUFFER,$$slots:{default:[AP]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Buffer View should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("pBuffer"),R=d("br"),P=i(`
            A pointer to the parent `),I(A.$$.fragment),T=i(" to create a Buffer View of."),y=j(),B=d("li"),M=d("code"),O=i("format"),x=d("br"),F=i(`
            When bound as a texel buffer, the data in the Buffer is interpreted as
            a string of texels with the format specified in this field.`),V=d("br"),q=i(`
            The specified format must support
            `),k=d("code"),N=i("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),Q=i(`,
            `),X=d("code"),Z=i("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),K=i(` or
            `),W=d("code"),U=i("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),G=i(`, as
            reported by `),I(te.$$.fragment),ee=i("."),ne=j(),le=d("li"),ae=d("code"),J=i("offset"),ue=d("br"),De=i(`
            The new view will be a "window" in the parent `),I(de.$$.fragment),me=i(", starting from offset bytes."),Ce=d("br"),_e=i(`
            The number of bytes of the `),I(se.$$.fragment),ie=i(` where the Buffer View should start. To create a Buffer View of the
            entire `),I(ge.$$.fragment),we=i(`,
            this must be `),Re=d("code"),Be=i("0"),Ie=i("."),re=j(),he=d("li"),Ae=d("code"),Ve=i("range"),oe=d("br"),ce=i(`
            The new view will be a "window" in the parent `),I(Pe.$$.fragment),Fe=i(", expanding to range bytes."),ke=d("br"),Te=i(`
            The number of bytes the Buffer View will contain from
            `),Me=d("code"),Ue=i("offset"),qe=i(`
            To create a Buffer View of the entire `),I(xe.$$.fragment),Ge=i(", it must be "),ye=d("code"),We=i("VK_WHOLE_SIZE"),ze=i("."),Ye=d("br"),rt=i(`
            The maximum number of texels that can be stored in a texel buffer is
            determined by inspecting the `),Ne=d("code"),He=i("maxTexelBufferElements"),$t=i(`
            field of the `),I(ut.$$.fragment),ht=i("'s "),I(Je.$$.fragment),dt=i(`-structure, which can be retrieved by calling
            `),I(et.$$.fragment),Ze=i(` If the
            `),I(nt.$$.fragment),Ke=i(` is used as
            a texel buffer, the range divided by the size of a texel in format field
            must be less than or equal to this limit.
            `),ct=d("code"),st=i("maxTexelBufferElements"),Qe=i(`
            is guaranteed to be a minimum of `),at=d("code"),bt=i("65.536"),wt=i(`, so if the view
            being created contains fewer texels, this limit does not need to be
            requested.`),this.h()},l(tt){e=g(tt,"DIV",{slot:!0});var ot=E(e);t=g(ot,"LI",{});var At=E(t);r=g(At,"CODE",{});var it=E(r);$=f(it,"pLogicalDevice"),it.forEach(l),n=g(At,"BR",{}),s=f(At,`
            A pointer to the `),S(a.$$.fragment,At),u=f(At," the Buffer View should be associated with."),At.forEach(l),p=Y(ot),m=g(ot,"LI",{});var Xe=E(m);_=g(Xe,"CODE",{});var Dt=E(_);v=f(Dt,"pBuffer"),Dt.forEach(l),R=g(Xe,"BR",{}),P=f(Xe,`
            A pointer to the parent `),S(A.$$.fragment,Xe),T=f(Xe," to create a Buffer View of."),Xe.forEach(l),y=Y(ot),B=g(ot,"LI",{});var Ct=E(B);M=g(Ct,"CODE",{});var pt=E(M);O=f(pt,"format"),pt.forEach(l),x=g(Ct,"BR",{}),F=f(Ct,`
            When bound as a texel buffer, the data in the Buffer is interpreted as
            a string of texels with the format specified in this field.`),V=g(Ct,"BR",{}),q=f(Ct,`
            The specified format must support
            `),k=g(Ct,"CODE",{});var yt=E(k);N=f(yt,"VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),yt.forEach(l),Q=f(Ct,`,
            `),X=g(Ct,"CODE",{});var mt=E(X);Z=f(mt,"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),mt.forEach(l),K=f(Ct,` or
            `),W=g(Ct,"CODE",{});var Ot=E(W);U=f(Ot,"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),Ot.forEach(l),G=f(Ct,`, as
            reported by `),S(te.$$.fragment,Ct),ee=f(Ct,"."),Ct.forEach(l),ne=Y(ot),le=g(ot,"LI",{});var Pt=E(le);ae=g(Pt,"CODE",{});var Tt=E(ae);J=f(Tt,"offset"),Tt.forEach(l),ue=g(Pt,"BR",{}),De=f(Pt,`
            The new view will be a "window" in the parent `),S(de.$$.fragment,Pt),me=f(Pt,", starting from offset bytes."),Ce=g(Pt,"BR",{}),_e=f(Pt,`
            The number of bytes of the `),S(se.$$.fragment,Pt),ie=f(Pt,` where the Buffer View should start. To create a Buffer View of the
            entire `),S(ge.$$.fragment,Pt),we=f(Pt,`,
            this must be `),Re=g(Pt,"CODE",{});var vt=E(Re);Be=f(vt,"0"),vt.forEach(l),Ie=f(Pt,"."),Pt.forEach(l),re=Y(ot),he=g(ot,"LI",{});var gt=E(he);Ae=g(gt,"CODE",{});var kt=E(Ae);Ve=f(kt,"range"),kt.forEach(l),oe=g(gt,"BR",{}),ce=f(gt,`
            The new view will be a "window" in the parent `),S(Pe.$$.fragment,gt),Fe=f(gt,", expanding to range bytes."),ke=g(gt,"BR",{}),Te=f(gt,`
            The number of bytes the Buffer View will contain from
            `),Me=g(gt,"CODE",{});var Ft=E(Me);Ue=f(Ft,"offset"),Ft.forEach(l),qe=f(gt,`
            To create a Buffer View of the entire `),S(xe.$$.fragment,gt),Ge=f(gt,", it must be "),ye=g(gt,"CODE",{});var Mt=E(ye);We=f(Mt,"VK_WHOLE_SIZE"),Mt.forEach(l),ze=f(gt,"."),Ye=g(gt,"BR",{}),rt=f(gt,`
            The maximum number of texels that can be stored in a texel buffer is
            determined by inspecting the `),Ne=g(gt,"CODE",{});var Ht=E(Ne);He=f(Ht,"maxTexelBufferElements"),Ht.forEach(l),$t=f(gt,`
            field of the `),S(ut.$$.fragment,gt),ht=f(gt,"'s "),S(Je.$$.fragment,gt),dt=f(gt,`-structure, which can be retrieved by calling
            `),S(et.$$.fragment,gt),Ze=f(gt,` If the
            `),S(nt.$$.fragment,gt),Ke=f(gt,` is used as
            a texel buffer, the range divided by the size of a texel in format field
            must be less than or equal to this limit.
            `),ct=g(gt,"CODE",{});var $r=E(ct);st=f($r,"maxTexelBufferElements"),$r.forEach(l),Qe=f(gt,`
            is guaranteed to be a minimum of `),at=g(gt,"CODE",{});var Ut=E(at);bt=f(Ut,"65.536"),Ut.forEach(l),wt=f(gt,`, so if the view
            being created contains fewer texels, this limit does not need to be
            requested.`),gt.forEach(l),ot.forEach(l),this.h()},h(){z(e,"slot","params")},m(tt,ot){h(tt,e,ot),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),o(B,V),o(B,q),o(B,k),o(k,N),o(B,Q),o(B,X),o(X,Z),o(B,K),o(B,W),o(W,U),o(B,G),D(te,B,null),o(B,ee),o(e,ne),o(e,le),o(le,ae),o(ae,J),o(le,ue),o(le,De),D(de,le,null),o(le,me),o(le,Ce),o(le,_e),D(se,le,null),o(le,ie),D(ge,le,null),o(le,we),o(le,Re),o(Re,Be),o(le,Ie),o(e,re),o(e,he),o(he,Ae),o(Ae,Ve),o(he,oe),o(he,ce),D(Pe,he,null),o(he,Fe),o(he,ke),o(he,Te),o(he,Me),o(Me,Ue),o(he,qe),D(xe,he,null),o(he,Ge),o(he,ye),o(ye,We),o(he,ze),o(he,Ye),o(he,rt),o(he,Ne),o(Ne,He),o(he,$t),D(ut,he,null),o(he,ht),D(Je,he,null),o(he,dt),D(et,he,null),o(he,Ze),D(nt,he,null),o(he,Ke),o(he,ct),o(ct,st),o(he,Qe),o(he,at),o(at,bt),o(he,wt),St=!0},p(tt,ot){const At={};ot&1&&(At.$$scope={dirty:ot,ctx:tt}),a.$set(At);const it={};ot&1&&(it.$$scope={dirty:ot,ctx:tt}),A.$set(it);const Xe={};ot&1&&(Xe.$$scope={dirty:ot,ctx:tt}),te.$set(Xe);const Dt={};ot&1&&(Dt.$$scope={dirty:ot,ctx:tt}),de.$set(Dt);const Ct={};ot&1&&(Ct.$$scope={dirty:ot,ctx:tt}),se.$set(Ct);const pt={};ot&1&&(pt.$$scope={dirty:ot,ctx:tt}),ge.$set(pt);const yt={};ot&1&&(yt.$$scope={dirty:ot,ctx:tt}),Pe.$set(yt);const mt={};ot&1&&(mt.$$scope={dirty:ot,ctx:tt}),xe.$set(mt);const Ot={};ot&1&&(Ot.$$scope={dirty:ot,ctx:tt}),ut.$set(Ot);const Pt={};ot&1&&(Pt.$$scope={dirty:ot,ctx:tt}),Je.$set(Pt);const Tt={};ot&1&&(Tt.$$scope={dirty:ot,ctx:tt}),et.$set(Tt);const vt={};ot&1&&(vt.$$scope={dirty:ot,ctx:tt}),nt.$set(vt)},i(tt){St||(b(a.$$.fragment,tt),b(A.$$.fragment,tt),b(te.$$.fragment,tt),b(de.$$.fragment,tt),b(se.$$.fragment,tt),b(ge.$$.fragment,tt),b(Pe.$$.fragment,tt),b(xe.$$.fragment,tt),b(ut.$$.fragment,tt),b(Je.$$.fragment,tt),b(et.$$.fragment,tt),b(nt.$$.fragment,tt),St=!0)},o(tt){w(a.$$.fragment,tt),w(A.$$.fragment,tt),w(te.$$.fragment,tt),w(de.$$.fragment,tt),w(se.$$.fragment,tt),w(ge.$$.fragment,tt),w(Pe.$$.fragment,tt),w(xe.$$.fragment,tt),w(ut.$$.fragment,tt),w(Je.$$.fragment,tt),w(et.$$.fragment,tt),w(nt.$$.fragment,tt),St=!1},d(tt){tt&&l(e),C(a),C(A),C(te),C(de),C(se),C(ge),C(Pe),C(xe),C(ut),C(Je),C(et),C(nt)}}}function BP(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LP(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[BP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function kP(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`BufferView(
    LogicalDevic pLogicalDevice, 
    Buffe pBuffer, 
    VkFormat format, 
    VkDeviceSize offset = 0, 
    VkDeviceSize range = VK_WHOLE_SIZE
);`}}),r=new Se({props:{$$slots:{throws:[LP],params:[PP],details:[dP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TP extends ve{constructor(e){super(),Ee(this,e,null,kP,be,{})}}function OP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xP(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/buffer_view.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[OP]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.BUFFER,$$slots:{default:[VP]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.BUFFER,$$slots:{default:[yP]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.BUFFER,$$slots:{default:[MP]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.BUFFER,$$slots:{default:[FP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer View"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to the parent "),I(u.$$.fragment),p=i(` which it will create a Buffer View of, along with information regarding the format
and size of the Buffer View.`),m=d("br"),_=i(`
A Buffer View is used to interpret the data in a `),I(v.$$.fragment),R=i(` with a specific format. Buffer Views represent a sub-scope of a buffer object.
Since the raw data in the `),I(P.$$.fragment),A=i(`
is then treated as a sequence of texels, this is also known as a texel buffer view.
A texel buffer view is directly accessible in shaders and Vulkan will automatically
convert the texels in the `),I(T.$$.fragment),y=i(" to the format expected by the shader.")},l(M){S(e.$$.fragment,M),t=f(M,`
The `),r=g(M,"CODE",{});var O=E(r);$=f(O,"Buffer View"),O.forEach(l),n=f(M," class takes a pointer to a "),S(s.$$.fragment,M),a=f(M,", a pointer to the parent "),S(u.$$.fragment,M),p=f(M,` which it will create a Buffer View of, along with information regarding the format
and size of the Buffer View.`),m=g(M,"BR",{}),_=f(M,`
A Buffer View is used to interpret the data in a `),S(v.$$.fragment,M),R=f(M,` with a specific format. Buffer Views represent a sub-scope of a buffer object.
Since the raw data in the `),S(P.$$.fragment,M),A=f(M,`
is then treated as a sequence of texels, this is also known as a texel buffer view.
A texel buffer view is directly accessible in shaders and Vulkan will automatically
convert the texels in the `),S(T.$$.fragment,M),y=f(M," to the format expected by the shader.")},m(M,O){D(e,M,O),h(M,t,O),h(M,r,O),o(r,$),h(M,n,O),D(s,M,O),h(M,a,O),D(u,M,O),h(M,p,O),h(M,m,O),h(M,_,O),D(v,M,O),h(M,R,O),D(P,M,O),h(M,A,O),D(T,M,O),h(M,y,O),B=!0},p(M,[O]){const x={};O&1&&(x.$$scope={dirty:O,ctx:M}),s.$set(x);const F={};O&1&&(F.$$scope={dirty:O,ctx:M}),u.$set(F);const V={};O&1&&(V.$$scope={dirty:O,ctx:M}),v.$set(V);const q={};O&1&&(q.$$scope={dirty:O,ctx:M}),P.$set(q);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),T.$set(k)},i(M){B||(b(e.$$.fragment,M),b(s.$$.fragment,M),b(u.$$.fragment,M),b(v.$$.fragment,M),b(P.$$.fragment,M),b(T.$$.fragment,M),B=!0)},o(M){w(e.$$.fragment,M),w(s.$$.fragment,M),w(u.$$.fragment,M),w(v.$$.fragment,M),w(P.$$.fragment,M),w(T.$$.fragment,M),B=!1},d(M){C(e,M),M&&l(t),M&&l(r),M&&l(n),C(s,M),M&&l(a),C(u,M),M&&l(p),M&&l(m),M&&l(_),C(v,M),M&&l(R),C(P,M),M&&l(A),C(T,M),M&&l(y)}}}class NP extends ve{constructor(e){super(),Ee(this,e,null,xP,be,{})}}function UP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WP(c){let e;return{c(){e=i("Framebuffer")},l(t){e=f(t,"Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QP(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zP(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/image_view.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[UP]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.IMAGE,$$slots:{default:[GP]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.IMAGE,$$slots:{default:[HP]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.IMAGE,$$slots:{default:[qP]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[WP]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[QP]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.IMAGE,$$slots:{default:[KP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image View"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to the parent "),I(u.$$.fragment),p=i(` which it will create an Image View of, along with information regarding the view
type and format.`),m=d("br"),_=i(`
In many cases, the `),I(v.$$.fragment),R=i(` resource
cannot be used directly because it requires more information than is contained in
the resource itself. For example, an `),I(P.$$.fragment),A=i(" resource cannot be used directly as an attachment to a "),I(T.$$.fragment),y=i(" or bound in a "),I(B.$$.fragment),M=i(` to be sampled in a shader. To meet these additional requirements, an image view
must be created, which is essentially a collection of properties and a reference
to a parent `),I(O.$$.fragment),x=i(" resource.")},l(V){S(e.$$.fragment,V),t=f(V,`
The `),r=g(V,"CODE",{});var q=E(r);$=f(q,"Image View"),q.forEach(l),n=f(V," class takes a pointer to a "),S(s.$$.fragment,V),a=f(V,", a pointer to the parent "),S(u.$$.fragment,V),p=f(V,` which it will create an Image View of, along with information regarding the view
type and format.`),m=g(V,"BR",{}),_=f(V,`
In many cases, the `),S(v.$$.fragment,V),R=f(V,` resource
cannot be used directly because it requires more information than is contained in
the resource itself. For example, an `),S(P.$$.fragment,V),A=f(V," resource cannot be used directly as an attachment to a "),S(T.$$.fragment,V),y=f(V," or bound in a "),S(B.$$.fragment,V),M=f(V,` to be sampled in a shader. To meet these additional requirements, an image view
must be created, which is essentially a collection of properties and a reference
to a parent `),S(O.$$.fragment,V),x=f(V," resource.")},m(V,q){D(e,V,q),h(V,t,q),h(V,r,q),o(r,$),h(V,n,q),D(s,V,q),h(V,a,q),D(u,V,q),h(V,p,q),h(V,m,q),h(V,_,q),D(v,V,q),h(V,R,q),D(P,V,q),h(V,A,q),D(T,V,q),h(V,y,q),D(B,V,q),h(V,M,q),D(O,V,q),h(V,x,q),F=!0},p(V,[q]){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),s.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),u.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),v.$set(Q);const X={};q&1&&(X.$$scope={dirty:q,ctx:V}),P.$set(X);const Z={};q&1&&(Z.$$scope={dirty:q,ctx:V}),T.$set(Z);const K={};q&1&&(K.$$scope={dirty:q,ctx:V}),B.$set(K);const W={};q&1&&(W.$$scope={dirty:q,ctx:V}),O.$set(W)},i(V){F||(b(e.$$.fragment,V),b(s.$$.fragment,V),b(u.$$.fragment,V),b(v.$$.fragment,V),b(P.$$.fragment,V),b(T.$$.fragment,V),b(B.$$.fragment,V),b(O.$$.fragment,V),F=!0)},o(V){w(e.$$.fragment,V),w(s.$$.fragment,V),w(u.$$.fragment,V),w(v.$$.fragment,V),w(P.$$.fragment,V),w(T.$$.fragment,V),w(B.$$.fragment,V),w(O.$$.fragment,V),F=!1},d(V){C(e,V),V&&l(t),V&&l(r),V&&l(n),C(s,V),V&&l(a),C(u,V),V&&l(p),V&&l(m),V&&l(_),C(v,V),V&&l(R),C(P,V),V&&l(A),C(T,V),V&&l(y),C(B,V),V&&l(M),C(O,V),V&&l(x)}}}class jP extends ve{constructor(e){super(),Ee(this,e,null,zP,be,{})}}function YP(c){let e;return{c(){e=i("createImageView")},l(t){e=f(t,"createImageView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XP(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.IMAGE_createImageView,$$slots:{default:[YP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Image View."),r=d("br"),$=i(`
        It is recommended to not create an Image View by it's Constructor, but to
        use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Image View."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create an Image View by it's Constructor, but to
        use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ZP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eB(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tB(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aB(c){let e;return{c(){e=i("VkImageSubresourceRange")},l(t){e=f(t,"VkImageSubresourceRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lB(c){let e;return{c(){e=i("VkComponentMapping")},l(t){e=f(t,"VkComponentMapping")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iB(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[ZP]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[JP]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[eB]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[tB]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[rB]},$$scope:{ctx:c}}}),ee=new H({props:{sectionID:L.IMAGE,$$slots:{default:[nB]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.IMAGE,$$slots:{default:[sB]},$$scope:{ctx:c}}}),_e=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html",target:"_blank",$$slots:{default:[aB]},$$scope:{ctx:c}}}),re=new H({props:{sectionID:L.IMAGE,$$slots:{default:[oB]},$$scope:{ctx:c}}}),Ae=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html",target:"_blank",$$slots:{default:[lB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Image View should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("pBuffer"),R=d("br"),P=i(`
            A pointer to the parent `),I(A.$$.fragment),T=i(" to create a Image View of."),y=j(),B=d("li"),M=d("code"),O=i("viewType"),x=d("br"),F=i(`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),I(V.$$.fragment),q=i("-enumeration, which is larger than the "),I(k.$$.fragment),N=i("-enumeration used when creating the parent "),I(Q.$$.fragment),X=i("."),Z=j(),K=d("li"),W=d("code"),U=i("format"),G=d("br"),te=i(`
            The format of the new Image View. This must be a format compatible with
            the parent `),I(ee.$$.fragment),ne=i(`.
            If two formats have the same number of bits per pixel, they are
            generally considered compatible.`),le=j(),ae=d("li"),J=d("code"),ue=i("subresourceRange"),De=d("br"),de=i(`
            The Image View can be a subset of the parent `),I(me.$$.fragment),Ce=i(". This subset is specified using the embedded "),I(_e.$$.fragment),se=i("-structure."),ie=j(),ge=d("li"),we=d("code"),Re=i("components"),Be=d("br"),Ie=i(`
            The order of the components in the Image View may differ from that in
            the parent `),I(re.$$.fragment),he=i(`.
            This makes it possible, for example, to create an RGBA
            representation of an Image in BGRA format. This remapping is
            specified using an instance of the `),I(Ae.$$.fragment),Ve=i("-structure."),this.h()},l(ce){e=g(ce,"DIV",{slot:!0});var Pe=E(e);t=g(Pe,"LI",{});var Fe=E(t);r=g(Fe,"CODE",{});var ke=E(r);$=f(ke,"pLogicalDevice"),ke.forEach(l),n=g(Fe,"BR",{}),s=f(Fe,`
            A pointer to the `),S(a.$$.fragment,Fe),u=f(Fe," the Image View should be associated with."),Fe.forEach(l),p=Y(Pe),m=g(Pe,"LI",{});var Te=E(m);_=g(Te,"CODE",{});var Me=E(_);v=f(Me,"pBuffer"),Me.forEach(l),R=g(Te,"BR",{}),P=f(Te,`
            A pointer to the parent `),S(A.$$.fragment,Te),T=f(Te," to create a Image View of."),Te.forEach(l),y=Y(Pe),B=g(Pe,"LI",{});var Ue=E(B);M=g(Ue,"CODE",{});var qe=E(M);O=f(qe,"viewType"),qe.forEach(l),x=g(Ue,"BR",{}),F=f(Ue,`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),S(V.$$.fragment,Ue),q=f(Ue,"-enumeration, which is larger than the "),S(k.$$.fragment,Ue),N=f(Ue,"-enumeration used when creating the parent "),S(Q.$$.fragment,Ue),X=f(Ue,"."),Ue.forEach(l),Z=Y(Pe),K=g(Pe,"LI",{});var xe=E(K);W=g(xe,"CODE",{});var Ge=E(W);U=f(Ge,"format"),Ge.forEach(l),G=g(xe,"BR",{}),te=f(xe,`
            The format of the new Image View. This must be a format compatible with
            the parent `),S(ee.$$.fragment,xe),ne=f(xe,`.
            If two formats have the same number of bits per pixel, they are
            generally considered compatible.`),xe.forEach(l),le=Y(Pe),ae=g(Pe,"LI",{});var ye=E(ae);J=g(ye,"CODE",{});var We=E(J);ue=f(We,"subresourceRange"),We.forEach(l),De=g(ye,"BR",{}),de=f(ye,`
            The Image View can be a subset of the parent `),S(me.$$.fragment,ye),Ce=f(ye,". This subset is specified using the embedded "),S(_e.$$.fragment,ye),se=f(ye,"-structure."),ye.forEach(l),ie=Y(Pe),ge=g(Pe,"LI",{});var ze=E(ge);we=g(ze,"CODE",{});var Ye=E(we);Re=f(Ye,"components"),Ye.forEach(l),Be=g(ze,"BR",{}),Ie=f(ze,`
            The order of the components in the Image View may differ from that in
            the parent `),S(re.$$.fragment,ze),he=f(ze,`.
            This makes it possible, for example, to create an RGBA
            representation of an Image in BGRA format. This remapping is
            specified using an instance of the `),S(Ae.$$.fragment,ze),Ve=f(ze,"-structure."),ze.forEach(l),Pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Pe){h(ce,e,Pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),D(Q,B,null),o(B,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),D(ee,K,null),o(K,ne),o(e,le),o(e,ae),o(ae,J),o(J,ue),o(ae,De),o(ae,de),D(me,ae,null),o(ae,Ce),D(_e,ae,null),o(ae,se),o(e,ie),o(e,ge),o(ge,we),o(we,Re),o(ge,Be),o(ge,Ie),D(re,ge,null),o(ge,he),D(Ae,ge,null),o(ge,Ve),oe=!0},p(ce,Pe){const Fe={};Pe&1&&(Fe.$$scope={dirty:Pe,ctx:ce}),a.$set(Fe);const ke={};Pe&1&&(ke.$$scope={dirty:Pe,ctx:ce}),A.$set(ke);const Te={};Pe&1&&(Te.$$scope={dirty:Pe,ctx:ce}),V.$set(Te);const Me={};Pe&1&&(Me.$$scope={dirty:Pe,ctx:ce}),k.$set(Me);const Ue={};Pe&1&&(Ue.$$scope={dirty:Pe,ctx:ce}),Q.$set(Ue);const qe={};Pe&1&&(qe.$$scope={dirty:Pe,ctx:ce}),ee.$set(qe);const xe={};Pe&1&&(xe.$$scope={dirty:Pe,ctx:ce}),me.$set(xe);const Ge={};Pe&1&&(Ge.$$scope={dirty:Pe,ctx:ce}),_e.$set(Ge);const ye={};Pe&1&&(ye.$$scope={dirty:Pe,ctx:ce}),re.$set(ye);const We={};Pe&1&&(We.$$scope={dirty:Pe,ctx:ce}),Ae.$set(We)},i(ce){oe||(b(a.$$.fragment,ce),b(A.$$.fragment,ce),b(V.$$.fragment,ce),b(k.$$.fragment,ce),b(Q.$$.fragment,ce),b(ee.$$.fragment,ce),b(me.$$.fragment,ce),b(_e.$$.fragment,ce),b(re.$$.fragment,ce),b(Ae.$$.fragment,ce),oe=!0)},o(ce){w(a.$$.fragment,ce),w(A.$$.fragment,ce),w(V.$$.fragment,ce),w(k.$$.fragment,ce),w(Q.$$.fragment,ce),w(ee.$$.fragment,ce),w(me.$$.fragment,ce),w(_e.$$.fragment,ce),w(re.$$.fragment,ce),w(Ae.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(a),C(A),C(V),C(k),C(Q),C(ee),C(me),C(_e),C(re),C(Ae)}}}function fB(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cB(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[fB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function $B(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`ImageView(
    LogicalDevice* pLogicalDevice, 
    Image* pImage, 
    VkImageViewType viewType, 
    VkFormat format, 
    VkImageSubresourceRange subresourceRange,
    VkComponentMapping components
);`}}),r=new Se({props:{$$slots:{throws:[cB],params:[iB],details:[XP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uB extends ve{constructor(e){super(),Ee(this,e,null,$B,be,{})}}function pB(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mB(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[pB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hB(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dB(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[hB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gB(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkImageView getImageViewHandle() const;"}}),r=new Se({props:{$$slots:{return:[dB],details:[mB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _B extends ve{constructor(e){super(),Ee(this,e,null,gB,be,{})}}function vB(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SB(c){let e;return{c(){e=i("VkDeviceMemory")},l(t){e=f(t,"VkDeviceMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RB(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/memory.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[vB]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.BUFFER,$$slots:{default:[EB]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.IMAGE,$$slots:{default:[bB]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.BUFFER,$$slots:{default:[wB]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.IMAGE,$$slots:{default:[IB]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.BUFFER,$$slots:{default:[DB]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.IMAGE,$$slots:{default:[CB]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[SB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Memory"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a pointer to a "),I(u.$$.fragment),p=i(" or "),I(m.$$.fragment),_=i(` and required memory
properties and uses this information to allocate Memory for a given `),I(v.$$.fragment),R=i(" or "),I(P.$$.fragment),A=i("."),T=d("br"),y=i(`

Before a resource, such as a `),I(B.$$.fragment),M=i(" or "),I(O.$$.fragment),x=i(`, can be used by
Vulkan to store data, it must be associated with memory. A device memory
allocation is represented as a `),I(F.$$.fragment),V=i("-object.")},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Memory"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k," along with a pointer to a "),S(u.$$.fragment,k),p=f(k," or "),S(m.$$.fragment,k),_=f(k,` and required memory
properties and uses this information to allocate Memory for a given `),S(v.$$.fragment,k),R=f(k," or "),S(P.$$.fragment,k),A=f(k,"."),T=g(k,"BR",{}),y=f(k,`

Before a resource, such as a `),S(B.$$.fragment,k),M=f(k," or "),S(O.$$.fragment,k),x=f(k,`, can be used by
Vulkan to store data, it must be associated with memory. A device memory
allocation is represented as a `),S(F.$$.fragment,k),V=f(k,"-object.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),D(m,k,N),h(k,_,N),D(v,k,N),h(k,R,N),D(P,k,N),h(k,A,N),h(k,T,N),h(k,y,N),D(B,k,N),h(k,M,N),D(O,k,N),h(k,x,N),D(F,k,N),h(k,V,N),q=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),m.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),v.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),P.$set(W);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),B.$set(U);const G={};N&1&&(G.$$scope={dirty:N,ctx:k}),O.$set(G);const te={};N&1&&(te.$$scope={dirty:N,ctx:k}),F.$set(te)},i(k){q||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(m.$$.fragment,k),b(v.$$.fragment,k),b(P.$$.fragment,k),b(B.$$.fragment,k),b(O.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(m.$$.fragment,k),w(v.$$.fragment,k),w(P.$$.fragment,k),w(B.$$.fragment,k),w(O.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),C(m,k),k&&l(_),C(v,k),k&&l(R),C(P,k),k&&l(A),k&&l(T),k&&l(y),C(B,k),k&&l(M),C(O,k),k&&l(x),C(F,k),k&&l(V)}}}class AB extends ve{constructor(e){super(),Ee(this,e,null,RB,be,{})}}function PB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BB(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[PB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Memory allocation for a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a new Memory allocation for a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function LB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kB(c){let e;return{c(){e=i("VkMemoryPropertyFlagBits")},l(t){e=f(t,"VkMemoryPropertyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TB(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return R=new H({props:{sectionID:L.BUFFER,$$slots:{default:[LB]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html",target:"_blank",$$slots:{default:[kB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),a=j(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the `),I(R.$$.fragment),P=i(" to create a Memory allocation for."),A=j(),T=d("li"),y=d("code"),B=i("flags"),M=d("br"),O=i(`
            A bitmask of `),I(x.$$.fragment),F=i(" specifying the required properties for the Memory."),V=j(),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"pLogicalDevice"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),Q.forEach(l),a=Y(N),u=g(N,"LI",{});var Z=E(u);p=g(Z,"CODE",{});var K=E(p);m=f(K,"pBuffer"),K.forEach(l),_=g(Z,"BR",{}),v=f(Z,`
            A pointer to the `),S(R.$$.fragment,Z),P=f(Z," to create a Memory allocation for."),Z.forEach(l),A=Y(N),T=g(N,"LI",{});var W=E(T);y=g(W,"CODE",{});var U=E(y);B=f(U,"flags"),U.forEach(l),M=g(W,"BR",{}),O=f(W,`
            A bitmask of `),S(x.$$.fragment,W),F=f(W," specifying the required properties for the Memory."),W.forEach(l),V=Y(N),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),o(e,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),R.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),x.$set(X)},i(k){q||(b(R.$$.fragment,k),b(x.$$.fragment,k),q=!0)},o(k){w(R.$$.fragment,k),w(x.$$.fragment,k),q=!1},d(k){k&&l(e),C(R),C(x)}}}function OB(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VB(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yB(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[OB]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[VB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created, the given "),a=d("code"),u=i("flags"),p=i(` are not supported or
        the memory requirements are not supported by the `),I(m.$$.fragment),_=i(`.
    `),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P," couldn't be created, the given "),a=g(P,"CODE",{});var T=E(a);u=f(T,"flags"),T.forEach(l),p=f(P,` are not supported or
        the memory requirements are not supported by the `),S(m.$$.fragment,P),_=f(P,`.
    `),P.forEach(l),this.h()},h(){z(e,"slot","throws")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),m.$set(T)},i(R){v||(b(n.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){R&&l(e),C(n),C(m)}}}function MB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FB(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[MB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Memory allocation for an "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a new Memory allocation for an "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function xB(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NB(c){let e;return{c(){e=i("VkMemoryPropertyFlagBits")},l(t){e=f(t,"VkMemoryPropertyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UB(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V;return R=new H({props:{sectionID:L.IMAGE,$$slots:{default:[xB]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html",target:"_blank",$$slots:{default:[NB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),a=j(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the `),I(R.$$.fragment),P=i(" to create a Memory allocation for."),A=j(),T=d("li"),y=d("code"),B=i("flags"),M=d("br"),O=i(`
            A bitmask of `),I(x.$$.fragment),F=i(" specifying the required properties for the Memory."),this.h()},l(q){e=g(q,"DIV",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"pLogicalDevice"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),N.forEach(l),a=Y(k),u=g(k,"LI",{});var X=E(u);p=g(X,"CODE",{});var Z=E(p);m=f(Z,"pBuffer"),Z.forEach(l),_=g(X,"BR",{}),v=f(X,`
            A pointer to the `),S(R.$$.fragment,X),P=f(X," to create a Memory allocation for."),X.forEach(l),A=Y(k),T=g(k,"LI",{});var K=E(T);y=g(K,"CODE",{});var W=E(y);B=f(W,"flags"),W.forEach(l),M=g(K,"BR",{}),O=f(K,`
            A bitmask of `),S(x.$$.fragment,K),F=f(K," specifying the required properties for the Memory."),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,k){h(q,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),V=!0},p(q,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:q}),R.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:q}),x.$set(Q)},i(q){V||(b(R.$$.fragment,q),b(x.$$.fragment,q),V=!0)},o(q){w(R.$$.fragment,q),w(x.$$.fragment,q),V=!1},d(q){q&&l(e),C(R),C(x)}}}function GB(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HB(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qB(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[GB]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[HB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created, the given "),a=d("code"),u=i("flags"),p=i(` are not supported or
        the memory requirements are not supported by the `),I(m.$$.fragment),_=i("."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P," couldn't be created, the given "),a=g(P,"CODE",{});var T=E(a);u=f(T,"flags"),T.forEach(l),p=f(P,` are not supported or
        the memory requirements are not supported by the `),S(m.$$.fragment,P),_=f(P,"."),P.forEach(l),this.h()},h(){z(e,"slot","throws")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(R,P){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),m.$set(T)},i(R){v||(b(n.$$.fragment,R),b(m.$$.fragment,R),v=!0)},o(R){w(n.$$.fragment,R),w(m.$$.fragment,R),v=!1},d(R){R&&l(e),C(n),C(m)}}}function WB(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:`Memory(
    LogicalDevice* pLogicalDevice, 
    Buffer* pBuffer, 
    VkMemoryPropertyFlags flags
);`}}),r=new Se({props:{$$slots:{throws:[yB],params:[TB],details:[BB]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`Memory(
    LogicalDevice* pLogicalDevice, 
    Image* pImage, 
    VkMemoryPropertyFlags flags
);`}}),u=new Se({props:{$$slots:{throws:[qB],params:[UB],details:[FB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class QB extends ve{constructor(e){super(),Ee(this,e,null,WB,be,{})}}function KB(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zB(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[KB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function jB(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YB(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[jB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function XB(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkDeviceMemory getMemoryHandle() const;"}}),r=new Se({props:{$$slots:{return:[YB],details:[zB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ZB extends ve{constructor(e){super(),Ee(this,e,null,XB,be,{})}}function JB(c){let e,t;return{c(){e=d("span"),t=i("Allocate memory to get a host usable pointer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Allocate memory to get a host usable pointer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function eL(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            Access to the memory object must be synchronized externally. To assign
            a range of a memory object, the initial offset in bytes must be specified
            in offset.`),a=d("br"),u=i(`
            To map the entire memory object, this must be `),p=d("code"),m=i("0"),_=i("."),v=j(),R=d("li"),P=d("code"),A=i("size"),T=d("br"),y=i(`
            Access to the memory object must be synchronized externally. To allocate
            a range of a memory object, the size in bytes must be specified.`),B=d("br"),M=i(`
            To map the entire memory object, it must be
            `),O=d("code"),x=i("VK_WHOLE_SIZE"),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"offset"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            Access to the memory object must be synchronized externally. To assign
            a range of a memory object, the initial offset in bytes must be specified
            in offset.`),a=g(q,"BR",{}),u=f(q,`
            To map the entire memory object, this must be `),p=g(q,"CODE",{});var N=E(p);m=f(N,"0"),N.forEach(l),_=f(q,"."),q.forEach(l),v=Y(V),R=g(V,"LI",{});var Q=E(R);P=g(Q,"CODE",{});var X=E(P);A=f(X,"size"),X.forEach(l),T=g(Q,"BR",{}),y=f(Q,`
            Access to the memory object must be synchronized externally. To allocate
            a range of a memory object, the size in bytes must be specified.`),B=g(Q,"BR",{}),M=f(Q,`
            To map the entire memory object, it must be
            `),O=g(Q,"CODE",{});var Z=E(O);x=f(Z,"VK_WHOLE_SIZE"),Z.forEach(l),Q.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(t,u),o(t,p),o(p,m),o(t,_),o(e,v),o(e,R),o(R,P),o(P,A),o(R,T),o(R,y),o(R,B),o(R,M),o(R,O),o(O,x)},p:Oe,d(F){F&&l(e)}}}function tL(c){let e,t;return{c(){e=d("span"),t=i(`If successful, it returns a pointer to the mapped area. This pointer can
        then be cast to the appropriate type in the application and dereferenced
        to read and write the device memory directly.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`If successful, it returns a pointer to the mapped area. This pointer can
        then be cast to the appropriate type in the application and dereferenced
        to read and write the device memory directly.`),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function rL(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the Memory failed to map."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the Memory failed to map."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function nL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void** map(VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE);"}}),r=new Se({props:{$$slots:{throws:[rL],return:[tL],params:[eL],details:[JB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sL extends ve{constructor(e){super(),Ee(this,e,null,nL,be,{})}}function aL(c){let e,t;return{c(){e=d("span"),t=i("Unmap any mapped memory."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Unmap any mapped memory."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function oL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void unmap();"}}),r=new Se({props:{$$slots:{details:[aL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class lL extends ve{constructor(e){super(),Ee(this,e,null,oL,be,{})}}function iL(c){let e,t;return{c(){e=d("span"),t=i("Return a pointer to the mapped memory area."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Return a pointer to the mapped memory area."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function fL(c){let e;return{c(){e=i("map")},l(t){e=f(t,"map")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cL(c){let e,t,r,$,n,s,a,u;return r=new H({props:{sectionID:L.MEMORY_map,$$slots:{default:[fL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The mapped memory mapped with "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no memory is mapped."),this.h()},l(p){e=g(p,"SPAN",{slot:!0});var m=E(e);t=f(m,"The mapped memory mapped with "),S(r.$$.fragment,m),$=f(m," or "),n=g(m,"CODE",{});var _=E(n);s=f(_,"nullptr"),_.forEach(l),a=f(m," if no memory is mapped."),m.forEach(l),this.h()},h(){z(e,"slot","return")},m(p,m){h(p,e,m),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),u=!0},p(p,m){const _={};m&1&&(_.$$scope={dirty:m,ctx:p}),r.$set(_)},i(p){u||(b(r.$$.fragment,p),u=!0)},o(p){w(r.$$.fragment,p),u=!1},d(p){p&&l(e),C(r)}}}function $L(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void unmap();"}}),r=new Se({props:{$$slots:{return:[cL],details:[iL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uL extends ve{constructor(e){super(),Ee(this,e,null,$L,be,{})}}function pL(c){let e,t,r,$,n,s,a,u,p;return{c(){e=d("span"),t=i("Flush a mapped memory range."),r=d("br"),$=i(`
        If `),n=d("code"),s=i("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),a=i(` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly flush or invalidate any caches that may be
        affected by the application.`),u=d("br"),p=i(`
        A flush is needed if the host has written to an allocated memory region and
        wants the device to see the effect of those writes.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Flush a mapped memory range."),r=g(_,"BR",{}),$=f(_,`
        If `),n=g(_,"CODE",{});var v=E(n);s=f(v,"VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),v.forEach(l),a=f(_,` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly flush or invalidate any caches that may be
        affected by the application.`),u=g(_,"BR",{}),p=f(_,`
        A flush is needed if the host has written to an allocated memory region and
        wants the device to see the effect of those writes.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(e,p)},p:Oe,d(m){m&&l(e)}}}function mL(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            The offset of the range of mapped memory to be flushed. To flush the
            entire memory area, this must be `),a=d("code"),u=i("0"),p=j(),m=d("li"),_=d("code"),v=i("size"),R=d("br"),P=i(`
            The size of the mapped memory range to be flushed. To flush the entire
            memory area, it must be `),A=d("code"),T=i("VK_WHOLE_SIZE"),y=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"offset"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The offset of the range of mapped memory to be flushed. To flush the
            entire memory area, this must be `),a=g(O,"CODE",{});var F=E(a);u=f(F,"0"),F.forEach(l),O.forEach(l),p=Y(M),m=g(M,"LI",{});var V=E(m);_=g(V,"CODE",{});var q=E(_);v=f(q,"size"),q.forEach(l),R=g(V,"BR",{}),P=f(V,`
            The size of the mapped memory range to be flushed. To flush the entire
            memory area, it must be `),A=g(V,"CODE",{});var k=E(A);T=f(k,"VK_WHOLE_SIZE"),k.forEach(l),y=f(V,"."),V.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(m,A),o(A,T),o(m,y)},p:Oe,d(B){B&&l(e)}}}function hL(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the mapped memory range failed to flush."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the mapped memory range failed to flush."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function dL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void unmap();"}}),r=new Se({props:{$$slots:{throws:[hL],params:[mL],details:[pL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gL extends ve{constructor(e){super(),Ee(this,e,null,dL,be,{})}}function _L(c){let e,t,r,$,n,s,a,u,p;return{c(){e=d("span"),t=i("Invalidate a mapped memory range."),r=d("br"),$=i(`
        If `),n=d("code"),s=i("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),a=i(` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly clear or invalidate any caches that may be
        affected by the application.`),u=d("br"),p=i(`
        An invalidation is needed if the device is writing to a mapped memory region
        and the host needs to see the effect of the device's writes.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Invalidate a mapped memory range."),r=g(_,"BR",{}),$=f(_,`
        If `),n=g(_,"CODE",{});var v=E(n);s=f(v,"VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),v.forEach(l),a=f(_,` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly clear or invalidate any caches that may be
        affected by the application.`),u=g(_,"BR",{}),p=f(_,`
        An invalidation is needed if the device is writing to a mapped memory region
        and the host needs to see the effect of the device's writes.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(e,p)},p:Oe,d(m){m&&l(e)}}}function vL(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            The offset of the range of mapped memory to be invalidated. To invalidate
            the entire memory area, this must be `),a=d("code"),u=i("0"),p=j(),m=d("li"),_=d("code"),v=i("size"),R=d("br"),P=i(`
            The size of the mapped memory range to be invalidated. To invalidate
            the entire memory area, it must be `),A=d("code"),T=i("VK_WHOLE_SIZE"),y=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"offset"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The offset of the range of mapped memory to be invalidated. To invalidate
            the entire memory area, this must be `),a=g(O,"CODE",{});var F=E(a);u=f(F,"0"),F.forEach(l),O.forEach(l),p=Y(M),m=g(M,"LI",{});var V=E(m);_=g(V,"CODE",{});var q=E(_);v=f(q,"size"),q.forEach(l),R=g(V,"BR",{}),P=f(V,`
            The size of the mapped memory range to be invalidated. To invalidate
            the entire memory area, it must be `),A=g(V,"CODE",{});var k=E(A);T=f(k,"VK_WHOLE_SIZE"),k.forEach(l),y=f(V,"."),V.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(m,A),o(A,T),o(m,y)},p:Oe,d(B){B&&l(e)}}}function EL(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the mapped memory range failed to invalidate."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the mapped memory range failed to invalidate."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function bL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void invalidate();"}}),r=new Se({props:{$$slots:{throws:[EL],params:[vL],details:[_L]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wL extends ve{constructor(e){super(),Ee(this,e,null,bL,be,{})}}function IL(c){let e;return{c(){e=i("builder")},l(t){e=f(t,"builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AL(c){let e;return{c(){e=i("Buffer Builder")},l(t){e=f(t,"Buffer Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BL(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LL(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/buffer_director.hpp>"}}),u=new H({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[IL]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.BUFFER,$$slots:{default:[DL]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[CL]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.BUFFER,$$slots:{default:[SL]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.BUFFER,$$slots:{default:[RL]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[AL]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.BUFFER,$$slots:{default:[PL]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[BL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer Director"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The director defines the order in which to execute building steps, while the
`),I(u.$$.fragment),p=i(` provides the
implementation for those steps.`),m=d("br"),_=i(`
The Buffer Director defines methods for constructing frequently used `),I(v.$$.fragment),R=i(" configurations. For it's methods it takes in the "),I(P.$$.fragment),A=i(" with which the "),I(T.$$.fragment),y=i(` should
be associated with, the size of the `),I(B.$$.fragment),M=i(` and it's sharing mode, which will default to
`),O=d("code"),x=i("VK_SHARING_MODE_EXCLUSIVE"),F=i(` most of the time. With this information
it will use the `),I(V.$$.fragment),q=i(" to construct the requested "),I(k.$$.fragment),N=i(" which it will then return as a "),I(Q.$$.fragment),X=i(" which ownership will be moved to the application.")},l(K){S(e.$$.fragment,K),t=f(K,`
The `),r=g(K,"CODE",{});var W=E(r);$=f(W,"Buffer Director"),W.forEach(l),n=f(K,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(K,"BR",{}),a=f(K,`
The director defines the order in which to execute building steps, while the
`),S(u.$$.fragment,K),p=f(K,` provides the
implementation for those steps.`),m=g(K,"BR",{}),_=f(K,`
The Buffer Director defines methods for constructing frequently used `),S(v.$$.fragment,K),R=f(K," configurations. For it's methods it takes in the "),S(P.$$.fragment,K),A=f(K," with which the "),S(T.$$.fragment,K),y=f(K,` should
be associated with, the size of the `),S(B.$$.fragment,K),M=f(K,` and it's sharing mode, which will default to
`),O=g(K,"CODE",{});var U=E(O);x=f(U,"VK_SHARING_MODE_EXCLUSIVE"),U.forEach(l),F=f(K,` most of the time. With this information
it will use the `),S(V.$$.fragment,K),q=f(K," to construct the requested "),S(k.$$.fragment,K),N=f(K," which it will then return as a "),S(Q.$$.fragment,K),X=f(K," which ownership will be moved to the application.")},m(K,W){D(e,K,W),h(K,t,W),h(K,r,W),o(r,$),h(K,n,W),h(K,s,W),h(K,a,W),D(u,K,W),h(K,p,W),h(K,m,W),h(K,_,W),D(v,K,W),h(K,R,W),D(P,K,W),h(K,A,W),D(T,K,W),h(K,y,W),D(B,K,W),h(K,M,W),h(K,O,W),o(O,x),h(K,F,W),D(V,K,W),h(K,q,W),D(k,K,W),h(K,N,W),D(Q,K,W),h(K,X,W),Z=!0},p(K,[W]){const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),u.$set(U);const G={};W&1&&(G.$$scope={dirty:W,ctx:K}),v.$set(G);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),P.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),T.$set(ee);const ne={};W&1&&(ne.$$scope={dirty:W,ctx:K}),B.$set(ne);const le={};W&1&&(le.$$scope={dirty:W,ctx:K}),V.$set(le);const ae={};W&1&&(ae.$$scope={dirty:W,ctx:K}),k.$set(ae);const J={};W&1&&(J.$$scope={dirty:W,ctx:K}),Q.$set(J)},i(K){Z||(b(e.$$.fragment,K),b(u.$$.fragment,K),b(v.$$.fragment,K),b(P.$$.fragment,K),b(T.$$.fragment,K),b(B.$$.fragment,K),b(V.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(e.$$.fragment,K),w(u.$$.fragment,K),w(v.$$.fragment,K),w(P.$$.fragment,K),w(T.$$.fragment,K),w(B.$$.fragment,K),w(V.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){C(e,K),K&&l(t),K&&l(r),K&&l(n),K&&l(s),K&&l(a),C(u,K),K&&l(p),K&&l(m),K&&l(_),C(v,K),K&&l(R),C(P,K),K&&l(A),C(T,K),K&&l(y),C(B,K),K&&l(M),K&&l(O),K&&l(F),C(V,K),K&&l(q),C(k,K),K&&l(N),C(Q,K),K&&l(X)}}}class kL extends ve{constructor(e){super(),Ee(this,e,null,LL,be,{})}}function TL(c){let e,t;return{c(){e=d("span"),t=i("Create a new Buffer Director."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Buffer Director."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function OL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"BufferDirector();"}}),r=new Se({props:{$$slots:{details:[TL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class VL extends ve{constructor(e){super(),Ee(this,e,null,OL,be,{})}}function yL(c){let e,t;return{c(){e=d("span"),t=i("Create a new Vertex Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Vertex Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function ML(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NL(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GL(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HL(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[ML]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[FL]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[xL]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[NL]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[UL]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[GL]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function qL(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QL(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[qL]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[WL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function KL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zL(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[KL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function jL(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeVertexBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[zL],return:[QL],params:[HL],details:[yL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class YL extends ve{constructor(e){super(),Ee(this,e,null,jL,be,{})}}function XL(c){let e,t;return{c(){e=d("span"),t=i(`Create a new Vertex Buffer which will be used as a destination for a
        transfer operation.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Create a new Vertex Buffer which will be used as a destination for a
        transfer operation.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function ZL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ek(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tk(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nk(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sk(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[ZL]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[JL]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[ek]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[tk]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[rk]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[nk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(" will be used in the multiple device "),I(Z.$$.fragment),K=i(" supported by the Device."),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae," will be used in the multiple device "),S(Z.$$.fragment,ae),K=f(ae," supported by the Device."),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function ak(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ok(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[ak]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[ok]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function ik(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fk(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[ik]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ck(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeVertexTransferDestinationBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[fk],return:[lk],params:[sk],details:[XL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $k extends ve{constructor(e){super(),Ee(this,e,null,ck,be,{})}}function uk(c){let e,t;return{c(){e=d("span"),t=i("Create a new Uniform Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Uniform Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function pk(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dk(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _k(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vk(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[pk]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[mk]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[hk]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[dk]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[gk]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[_k]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function Ek(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[Ek]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[bk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ik(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dk(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Ik]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Ck(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeUniformBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[Dk],return:[wk],params:[vk],details:[uk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Sk extends ve{constructor(e){super(),Ee(this,e,null,Ck,be,{})}}function Rk(c){let e,t;return{c(){e=d("span"),t=i("Create a new Storage Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Storage Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Ak(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lk(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tk(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ok(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Ak]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Pk]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Bk]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[Lk]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[kk]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[Tk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function Vk(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[Vk]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[yk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Fk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xk(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Fk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Nk(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeStorageBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[xk],return:[Mk],params:[Ok],details:[Rk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Uk extends ve{constructor(e){super(),Ee(this,e,null,Nk,be,{})}}function Gk(c){let e,t;return{c(){e=d("span"),t=i("Create a new Uniform Texel Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Uniform Texel Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Hk(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qk(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zk(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jk(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Hk]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[qk]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Wk]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[Qk]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Kk]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[zk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function Yk(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[Yk]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Xk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Jk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eT(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Jk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function tT(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeUniformTexelBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[eT],return:[Zk],params:[jk],details:[Gk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rT extends ve{constructor(e){super(),Ee(this,e,null,tT,be,{})}}function nT(c){let e,t;return{c(){e=d("span"),t=i("Create a new Storage Texel Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Storage Texel Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function sT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fT(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cT(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[sT]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[aT]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[oT]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[lT]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[iT]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[fT]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function $T(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pT(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[$T]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[uT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function mT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hT(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[mT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function dT(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeStorageTexelBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[hT],return:[pT],params:[cT],details:[nT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gT extends ve{constructor(e){super(),Ee(this,e,null,dT,be,{})}}function _T(c){let e,t;return{c(){e=d("span"),t=i("Create a new Index Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Index Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function vT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ET(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DT(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CT(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[vT]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[ET]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[bT]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[wT]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[IT]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[DT]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(" will be used in the multiple device "),I(Z.$$.fragment),K=i(" supported by the Device."),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae," will be used in the multiple device "),S(Z.$$.fragment,ae),K=f(ae," supported by the Device."),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function ST(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AT(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[ST]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[RT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function PT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BT(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[PT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function LT(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeIndexBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[BT],return:[AT],params:[CT],details:[_T]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kT extends ve{constructor(e){super(),Ee(this,e,null,LT,be,{})}}function TT(c){let e,t;return{c(){e=d("span"),t=i(`Create a new Index Buffer which will be used as a destination for a
        transfer operation.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Create a new Index Buffer which will be used as a destination for a
        transfer operation.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function OT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xT(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NT(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[OT]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[VT]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[yT]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[MT]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[FT]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[xT]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function UT(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HT(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[UT]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[GT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function qT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WT(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[qT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function QT(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeIndexTransferDestinationBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[WT],return:[HT],params:[NT],details:[TT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class KT extends ve{constructor(e){super(),Ee(this,e,null,QT,be,{})}}function zT(c){let e,t;return{c(){e=d("span"),t=i("Create a new Indirect Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Indirect Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function jT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e0(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t0(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[jT]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[YT]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[XT]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[ZT]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[JT]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[e0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function r0(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s0(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[r0]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[n0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function a0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o0(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[a0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function l0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeIndirectBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[o0],return:[s0],params:[t0],details:[zT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class i0 extends ve{constructor(e){super(),Ee(this,e,null,l0,be,{})}}function f0(c){let e,t;return{c(){e=d("span"),t=i("Create a new Staging Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Staging Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function c0(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p0(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h0(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d0(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[c0]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[$0]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[u0]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[p0]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.BUFFER,$$slots:{default:[m0]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.QUEUE,$$slots:{default:[h0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("size"),A=d("br"),T=i(`
            The size the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("sharingMode"),V=d("br"),q=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=Y(G),v=g(G,"LI",{});var ne=E(v);R=g(ne,"CODE",{});var le=E(R);P=f(le,"size"),le.forEach(l),A=g(ne,"BR",{}),T=f(ne,`
            The size the `),S(y.$$.fragment,ne),B=f(ne," should have."),ne.forEach(l),M=Y(G),O=g(G,"LI",{});var ae=E(O);x=g(ae,"CODE",{});var J=E(x);F=f(J,"sharingMode"),J.forEach(l),V=g(ae,"BR",{}),q=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),D(Q,O,null),o(O,X),D(Z,O,null),o(O,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),p.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),y.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),k.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),Q.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),Z.$set(J)},i(U){W||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(y.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(y.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(p),C(y),C(k),C(Q),C(Z)}}}function g0(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v0(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[g0]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[_0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function E0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b0(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[E0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function w0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Buffer> makeStagingBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[b0],return:[v0],params:[d0],details:[f0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class I0 extends ve{constructor(e){super(),Ee(this,e,null,w0,be,{})}}function D0(c){let e;return{c(){e=i("Buffer Director")},l(t){e=f(t,"Buffer Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C0(c){let e;return{c(){e=i("Buffers")},l(t){e=f(t,"Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S0(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/buffer_builder.hpp>"}}),m=new H({props:{sectionID:L.BUFFER_DIRECTOR,$$slots:{default:[D0]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.BUFFER,$$slots:{default:[C0]},$$scope:{ctx:c}}}),T=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
VkBufferCreateFlags flags = 0;
VkDeviceSize size = 0;
VkBufferUsageFlags usage = 0;
VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE;
std::vector<uint32_t> queueFamilyIndices = {};`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
It is recommended to use the `),I(m.$$.fragment),_=i(" for creating "),I(v.$$.fragment),R=i(` unless
the director doesn't offer the required configuration.`),P=d("br"),A=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var M=E(r);$=f(M,"Buffer Builder"),M.forEach(l),n=f(B,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(B,"BR",{}),a=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(B,"BR",{}),p=f(B,`
It is recommended to use the `),S(m.$$.fragment,B),_=f(B," for creating "),S(v.$$.fragment,B),R=f(B,` unless
the director doesn't offer the required configuration.`),P=g(B,"BR",{}),A=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(T.$$.fragment,B)},m(B,M){D(e,B,M),h(B,t,M),h(B,r,M),o(r,$),h(B,n,M),h(B,s,M),h(B,a,M),h(B,u,M),h(B,p,M),D(m,B,M),h(B,_,M),D(v,B,M),h(B,R,M),h(B,P,M),h(B,A,M),D(T,B,M),y=!0},p(B,[M]){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),m.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),v.$set(x)},i(B){y||(b(e.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),y=!0)},o(B){w(e.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),y=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(a),B&&l(u),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(R),B&&l(P),B&&l(A),C(T,B)}}}class R0 extends ve{constructor(e){super(),Ee(this,e,null,S0,be,{})}}function A0(c){let e,t;return{c(){e=d("span"),t=i("Create a new Buffer Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Buffer Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function P0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"BufferBuilder();"}}),r=new Se({props:{$$slots:{details:[A0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class B0 extends ve{constructor(e){super(),Ee(this,e,null,P0,be,{})}}function L0(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T0(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[L0]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[k0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function O0(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y0(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[O0]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[V0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P,` should
            be associated with.`),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function M0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[y0],details:[T0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class F0 extends ve{constructor(e){super(),Ee(this,e,null,M0,be,{})}}function x0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N0(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[x0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function U0(c){let e;return{c(){e=i("VkBufferCreateFlagBits")},l(t){e=f(t,"VkBufferCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G0(c){let e,t,r,$,n,s,a,u,p,m,_=je().Fillcan.version+"",v,R,P;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html",target:"_blank",$$slots:{default:[U0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" which are all related to sparse buffers."),p=d("br"),m=i(`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),v=i(_),R=i("."),this.h()},l(A){e=g(A,"DIV",{slot:!0});var T=E(e);t=g(T,"LI",{});var y=E(t);r=g(y,"CODE",{});var B=E(r);$=f(B,"flags"),B.forEach(l),n=g(y,"BR",{}),s=f(y,`
            A bitmask of `),S(a.$$.fragment,y),u=f(y," which are all related to sparse buffers."),p=g(y,"BR",{}),m=f(y,`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),v=f(y,_),R=f(y,"."),y.forEach(l),T.forEach(l),this.h()},h(){z(e,"slot","params")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),o(t,v),o(t,R),P=!0},p(A,T){const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),a.$set(y)},i(A){P||(b(a.$$.fragment,A),P=!0)},o(A){w(a.$$.fragment,A),P=!1},d(A){A&&l(e),C(a)}}}function H0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFlags(VkBufferCreateFlags flags);"}}),r=new Se({props:{$$slots:{params:[G0],details:[N0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class q0 extends ve{constructor(e){super(),Ee(this,e,null,H0,be,{})}}function W0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q0(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[W0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the size for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the size for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function K0(c){let e,t,r,$,n,s,a,u,p,m,_,v;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("size"),n=d("br"),s=i(`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),a=d("code"),u=i("1024"),p=i(`
            * `),m=d("code"),_=i("1024"),v=i(")."),this.h()},l(R){e=g(R,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var A=E(t);r=g(A,"CODE",{});var T=E(r);$=f(T,"size"),T.forEach(l),n=g(A,"BR",{}),s=f(A,`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),a=g(A,"CODE",{});var y=E(a);u=f(y,"1024"),y.forEach(l),p=f(A,`
            * `),m=g(A,"CODE",{});var B=E(m);_=f(B,"1024"),B.forEach(l),v=f(A,")."),A.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(t,m),o(m,_),o(t,v)},p:Oe,d(R){R&&l(e)}}}function z0(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setSize(VkDeviceSize size);"}}),r=new Se({props:{$$slots:{params:[K0],details:[Q0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class j0 extends ve{constructor(e){super(),Ee(this,e,null,z0,be,{})}}function Y0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X0(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[Y0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the usage for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the usage for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Z0(c){let e;return{c(){e=i("VkBufferUsageFlagBits")},l(t){e=f(t,"VkBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J0(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eO(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[Z0]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[J0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("usage"),n=d("br"),s=i(`
            A bitmask of members of the `),I(a.$$.fragment),u=i("-enumerant telling Vulkan how the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"usage"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A bitmask of members of the `),S(a.$$.fragment,P),u=f(P,"-enumerant telling Vulkan how the "),S(p.$$.fragment,P),m=f(P," will be used."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function tO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setUsage(VkBufferUsageFlags usage);"}}),r=new Se({props:{$$slots:{params:[eO],details:[X0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rO extends ve{constructor(e){super(),Ee(this,e,null,tO,be,{})}}function nO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sO(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[nO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sharing mode for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sharing mode for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aO(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lO(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cO(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $O(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uO(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pO(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[aO]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.BUFFER,$$slots:{default:[oO]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.QUEUE,$$slots:{default:[lO]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.BUFFER,$$slots:{default:[iO]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.BUFFER,$$slots:{default:[fO]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.QUEUE,$$slots:{default:[cO]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.BUFFER,$$slots:{default:[$O]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.QUEUE,$$slots:{default:[uO]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("sharingMode"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant indicating how the "),I(p.$$.fragment),m=i(" will be used in the multiple device "),I(_.$$.fragment),v=i(` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),I(R.$$.fragment),P=i(` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=d("code"),T=i("sharingMode"),y=i(`
            to `),B=d("code"),M=i("VK_SHARING_MODE_EXCLUSIVE"),O=i(` tells Vulkan that the
            `),I(x.$$.fragment),F=i(` will only
            be used for a single `),I(V.$$.fragment),q=i(`, while setting
            `),k=d("code"),N=i("sharingMode"),Q=i(`
            to
            `),X=d("code"),Z=i("VK_SHARING_MODE_CONCURRENT"),K=i(` specifies that the
            application will use the `),I(W.$$.fragment),U=i(" on multiple "),I(G.$$.fragment),te=i(` at once. Using
            `),ee=d("code"),ne=i("VK_SHARING_MODE_CONCURRENT"),le=i(` may result in lower
            performance on some systems, so unless necessary,
            `),ae=d("code"),J=i("sharingMode"),ue=i(`
            should be set to `),De=d("code"),de=i("VK_SHARING_MODE_EXCLUSIVE"),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var se=E(e);t=g(se,"LI",{});var ie=E(t);r=g(ie,"CODE",{});var ge=E(r);$=f(ge,"sharingMode"),ge.forEach(l),n=g(ie,"BR",{}),s=f(ie,`
            A member of the `),S(a.$$.fragment,ie),u=f(ie,"-enumerant indicating how the "),S(p.$$.fragment,ie),m=f(ie," will be used in the multiple device "),S(_.$$.fragment,ie),v=f(ie,` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),S(R.$$.fragment,ie),P=f(ie,` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=g(ie,"CODE",{});var we=E(A);T=f(we,"sharingMode"),we.forEach(l),y=f(ie,`
            to `),B=g(ie,"CODE",{});var Re=E(B);M=f(Re,"VK_SHARING_MODE_EXCLUSIVE"),Re.forEach(l),O=f(ie,` tells Vulkan that the
            `),S(x.$$.fragment,ie),F=f(ie,` will only
            be used for a single `),S(V.$$.fragment,ie),q=f(ie,`, while setting
            `),k=g(ie,"CODE",{});var Be=E(k);N=f(Be,"sharingMode"),Be.forEach(l),Q=f(ie,`
            to
            `),X=g(ie,"CODE",{});var Ie=E(X);Z=f(Ie,"VK_SHARING_MODE_CONCURRENT"),Ie.forEach(l),K=f(ie,` specifies that the
            application will use the `),S(W.$$.fragment,ie),U=f(ie," on multiple "),S(G.$$.fragment,ie),te=f(ie,` at once. Using
            `),ee=g(ie,"CODE",{});var re=E(ee);ne=f(re,"VK_SHARING_MODE_CONCURRENT"),re.forEach(l),le=f(ie,` may result in lower
            performance on some systems, so unless necessary,
            `),ae=g(ie,"CODE",{});var he=E(ae);J=f(he,"sharingMode"),he.forEach(l),ue=f(ie,`
            should be set to `),De=g(ie,"CODE",{});var Ae=E(De);de=f(Ae,"VK_SHARING_MODE_EXCLUSIVE"),Ae.forEach(l),me=f(ie,"."),ie.forEach(l),se.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,se){h(_e,e,se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),D(R,t,null),o(t,P),o(t,A),o(A,T),o(t,y),o(t,B),o(B,M),o(t,O),D(x,t,null),o(t,F),D(V,t,null),o(t,q),o(t,k),o(k,N),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,U),D(G,t,null),o(t,te),o(t,ee),o(ee,ne),o(t,le),o(t,ae),o(ae,J),o(t,ue),o(t,De),o(De,de),o(t,me),Ce=!0},p(_e,se){const ie={};se&1&&(ie.$$scope={dirty:se,ctx:_e}),a.$set(ie);const ge={};se&1&&(ge.$$scope={dirty:se,ctx:_e}),p.$set(ge);const we={};se&1&&(we.$$scope={dirty:se,ctx:_e}),_.$set(we);const Re={};se&1&&(Re.$$scope={dirty:se,ctx:_e}),R.$set(Re);const Be={};se&1&&(Be.$$scope={dirty:se,ctx:_e}),x.$set(Be);const Ie={};se&1&&(Ie.$$scope={dirty:se,ctx:_e}),V.$set(Ie);const re={};se&1&&(re.$$scope={dirty:se,ctx:_e}),W.$set(re);const he={};se&1&&(he.$$scope={dirty:se,ctx:_e}),G.$set(he)},i(_e){Ce||(b(a.$$.fragment,_e),b(p.$$.fragment,_e),b(_.$$.fragment,_e),b(R.$$.fragment,_e),b(x.$$.fragment,_e),b(V.$$.fragment,_e),b(W.$$.fragment,_e),b(G.$$.fragment,_e),Ce=!0)},o(_e){w(a.$$.fragment,_e),w(p.$$.fragment,_e),w(_.$$.fragment,_e),w(R.$$.fragment,_e),w(x.$$.fragment,_e),w(V.$$.fragment,_e),w(W.$$.fragment,_e),w(G.$$.fragment,_e),Ce=!1},d(_e){_e&&l(e),C(a),C(p),C(_),C(R),C(x),C(V),C(W),C(G)}}}function mO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setSharingMode(VkSharingMode sharingMode);"}}),r=new Se({props:{$$slots:{params:[pO],details:[sO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hO extends ve{constructor(e){super(),Ee(this,e,null,mO,be,{})}}function dO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gO(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[dO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _O(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vO(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.QUEUE,$$slots:{default:[_O]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("queueFamilyIndices"),n=d("br"),s=i(`
            An array of `),I(a.$$.fragment),u=i(`
            family indices on which the buffer will be used.`),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"queueFamilyIndices"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            An array of `),S(a.$$.fragment,v),u=f(v,`
            family indices on which the buffer will be used.`),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function EO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setQueueFamilyIndices(std::vector<uint32_t>& queueFamilyIndices);"}}),r=new Se({props:{$$slots:{params:[vO],details:[gO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bO extends ve{constructor(e){super(),Ee(this,e,null,EO,be,{})}}function wO(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IO(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function DO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[IO],default:[wO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class CO extends ve{constructor(e){super(),Ee(this,e,null,DO,be,{})}}function SO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RO(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[SO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function AO(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BO(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[AO]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[PO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function LO(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kO(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.BUFFER,$$slots:{default:[LO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function TO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<Buffer> getResult();"}}),r=new Se({props:{$$slots:{throws:[kO],return:[BO],details:[RO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class OO extends ve{constructor(e){super(),Ee(this,e,null,TO,be,{})}}function VO(c){let e,t;return{c(){e=d("span"),t=i("Create a new Image Director."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Image Director."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function yO(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"ImageDirector();"}}),r=new Se({props:{$$slots:{details:[VO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class MO extends ve{constructor(e){super(),Ee(this,e,null,yO,be,{})}}function FO(c){let e;return{c(){e=i("builder")},l(t){e=f(t,"builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NO(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qO(c){let e;return{c(){e=i("Image Builder")},l(t){e=f(t,"Image Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QO(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KO(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/image_director.hpp>"}}),u=new H({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[FO]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.IMAGE,$$slots:{default:[xO]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[NO]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.IMAGE,$$slots:{default:[UO]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.IMAGE,$$slots:{default:[GO]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.IMAGE,$$slots:{default:[HO]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[qO]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[WO]},$$scope:{ctx:c}}}),Z=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[QO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image Director"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The director defines the order in which to execute building steps, while the
`),I(u.$$.fragment),p=i(` provides the implementation
for those steps.`),m=d("br"),_=i(`
The Image Director defines methods for constructing frequently used `),I(v.$$.fragment),R=i(" configurations. For it's methods it takes in the "),I(P.$$.fragment),A=i(" with which the "),I(T.$$.fragment),y=i(` should
be associated with, the width and height the `),I(B.$$.fragment),M=i(", the sample count of the "),I(O.$$.fragment),x=i(` and it's sharing mode, which will default to
`),F=d("code"),V=i("VK_SHARING_MODE_EXCLUSIVE"),q=i(` most of the time. With this information
it will use the `),I(k.$$.fragment),N=i(" to construct the requested "),I(Q.$$.fragment),X=i(" which it will then return as a "),I(Z.$$.fragment),K=i(" which ownership will be moved to the application.")},l(U){S(e.$$.fragment,U),t=f(U,`
The `),r=g(U,"CODE",{});var G=E(r);$=f(G,"Image Director"),G.forEach(l),n=f(U,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(U,"BR",{}),a=f(U,`
The director defines the order in which to execute building steps, while the
`),S(u.$$.fragment,U),p=f(U,` provides the implementation
for those steps.`),m=g(U,"BR",{}),_=f(U,`
The Image Director defines methods for constructing frequently used `),S(v.$$.fragment,U),R=f(U," configurations. For it's methods it takes in the "),S(P.$$.fragment,U),A=f(U," with which the "),S(T.$$.fragment,U),y=f(U,` should
be associated with, the width and height the `),S(B.$$.fragment,U),M=f(U,", the sample count of the "),S(O.$$.fragment,U),x=f(U,` and it's sharing mode, which will default to
`),F=g(U,"CODE",{});var te=E(F);V=f(te,"VK_SHARING_MODE_EXCLUSIVE"),te.forEach(l),q=f(U,` most of the time. With this information
it will use the `),S(k.$$.fragment,U),N=f(U," to construct the requested "),S(Q.$$.fragment,U),X=f(U," which it will then return as a "),S(Z.$$.fragment,U),K=f(U," which ownership will be moved to the application.")},m(U,G){D(e,U,G),h(U,t,G),h(U,r,G),o(r,$),h(U,n,G),h(U,s,G),h(U,a,G),D(u,U,G),h(U,p,G),h(U,m,G),h(U,_,G),D(v,U,G),h(U,R,G),D(P,U,G),h(U,A,G),D(T,U,G),h(U,y,G),D(B,U,G),h(U,M,G),D(O,U,G),h(U,x,G),h(U,F,G),o(F,V),h(U,q,G),D(k,U,G),h(U,N,G),D(Q,U,G),h(U,X,G),D(Z,U,G),h(U,K,G),W=!0},p(U,[G]){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),u.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),v.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),P.$set(ne);const le={};G&1&&(le.$$scope={dirty:G,ctx:U}),T.$set(le);const ae={};G&1&&(ae.$$scope={dirty:G,ctx:U}),B.$set(ae);const J={};G&1&&(J.$$scope={dirty:G,ctx:U}),O.$set(J);const ue={};G&1&&(ue.$$scope={dirty:G,ctx:U}),k.$set(ue);const De={};G&1&&(De.$$scope={dirty:G,ctx:U}),Q.$set(De);const de={};G&1&&(de.$$scope={dirty:G,ctx:U}),Z.$set(de)},i(U){W||(b(e.$$.fragment,U),b(u.$$.fragment,U),b(v.$$.fragment,U),b(P.$$.fragment,U),b(T.$$.fragment,U),b(B.$$.fragment,U),b(O.$$.fragment,U),b(k.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),W=!0)},o(U){w(e.$$.fragment,U),w(u.$$.fragment,U),w(v.$$.fragment,U),w(P.$$.fragment,U),w(T.$$.fragment,U),w(B.$$.fragment,U),w(O.$$.fragment,U),w(k.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),W=!1},d(U){C(e,U),U&&l(t),U&&l(r),U&&l(n),U&&l(s),U&&l(a),C(u,U),U&&l(p),U&&l(m),U&&l(_),C(v,U),U&&l(R),C(P,U),U&&l(A),C(T,U),U&&l(y),C(B,U),U&&l(M),C(O,U),U&&l(x),U&&l(F),U&&l(q),C(k,U),U&&l(N),C(Q,U),U&&l(X),C(Z,U),U&&l(K)}}}class zO extends ve{constructor(e){super(),Ee(this,e,null,KO,be,{})}}function jO(c){let e,t;return{c(){e=d("span"),t=i("Create a new 2D texture."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new 2D texture."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function YO(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tV(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nV(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sV(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YO]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[XO]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ZO]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.IMAGE,$$slots:{default:[JO]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.IMAGE,$$slots:{default:[eV]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[tV]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.IMAGE,$$slots:{default:[rV]},$$scope:{ctx:c}}}),_e=new H({props:{sectionID:L.QUEUE,$$slots:{default:[nV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("width"),A=d("br"),T=i(`
            The width the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("height"),V=d("br"),q=i(`
            The height the `),I(k.$$.fragment),N=i(" should have."),Q=j(),X=d("li"),Z=d("code"),K=i("samples"),W=d("br"),U=i(`
            The sample count the `),I(G.$$.fragment),te=i(" should have."),ee=j(),ne=d("li"),le=d("code"),ae=i("sharingMode"),J=d("br"),ue=i(`
            A member of the `),I(De.$$.fragment),de=i("-enumerant indicating how the "),I(me.$$.fragment),Ce=i(" will be used in the multiple device "),I(_e.$$.fragment),se=i(" supported by the Device."),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Re=E(t);r=g(Re,"CODE",{});var Be=E(r);$=f(Be,"pLogicalDevice"),Be.forEach(l),n=g(Re,"BR",{}),s=f(Re,`
            The `),S(a.$$.fragment,Re),u=f(Re," the "),S(p.$$.fragment,Re),m=f(Re,` should
            be associated with.`),Re.forEach(l),_=Y(we),v=g(we,"LI",{});var Ie=E(v);R=g(Ie,"CODE",{});var re=E(R);P=f(re,"width"),re.forEach(l),A=g(Ie,"BR",{}),T=f(Ie,`
            The width the `),S(y.$$.fragment,Ie),B=f(Ie," should have."),Ie.forEach(l),M=Y(we),O=g(we,"LI",{});var he=E(O);x=g(he,"CODE",{});var Ae=E(x);F=f(Ae,"height"),Ae.forEach(l),V=g(he,"BR",{}),q=f(he,`
            The height the `),S(k.$$.fragment,he),N=f(he," should have."),he.forEach(l),Q=Y(we),X=g(we,"LI",{});var Ve=E(X);Z=g(Ve,"CODE",{});var oe=E(Z);K=f(oe,"samples"),oe.forEach(l),W=g(Ve,"BR",{}),U=f(Ve,`
            The sample count the `),S(G.$$.fragment,Ve),te=f(Ve," should have."),Ve.forEach(l),ee=Y(we),ne=g(we,"LI",{});var ce=E(ne);le=g(ce,"CODE",{});var Pe=E(le);ae=f(Pe,"sharingMode"),Pe.forEach(l),J=g(ce,"BR",{}),ue=f(ce,`
            A member of the `),S(De.$$.fragment,ce),de=f(ce,"-enumerant indicating how the "),S(me.$$.fragment,ce),Ce=f(ce," will be used in the multiple device "),S(_e.$$.fragment,ce),se=f(ce," supported by the Device."),ce.forEach(l),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),D(G,X,null),o(X,te),o(e,ee),o(e,ne),o(ne,le),o(le,ae),o(ne,J),o(ne,ue),D(De,ne,null),o(ne,de),D(me,ne,null),o(ne,Ce),D(_e,ne,null),o(ne,se),ie=!0},p(ge,we){const Re={};we&1&&(Re.$$scope={dirty:we,ctx:ge}),a.$set(Re);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),p.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),y.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),G.$set(he);const Ae={};we&1&&(Ae.$$scope={dirty:we,ctx:ge}),De.$set(Ae);const Ve={};we&1&&(Ve.$$scope={dirty:we,ctx:ge}),me.$set(Ve);const oe={};we&1&&(oe.$$scope={dirty:we,ctx:ge}),_e.$set(oe)},i(ge){ie||(b(a.$$.fragment,ge),b(p.$$.fragment,ge),b(y.$$.fragment,ge),b(k.$$.fragment,ge),b(G.$$.fragment,ge),b(De.$$.fragment,ge),b(me.$$.fragment,ge),b(_e.$$.fragment,ge),ie=!0)},o(ge){w(a.$$.fragment,ge),w(p.$$.fragment,ge),w(y.$$.fragment,ge),w(k.$$.fragment,ge),w(G.$$.fragment,ge),w(De.$$.fragment,ge),w(me.$$.fragment,ge),w(_e.$$.fragment,ge),ie=!1},d(ge){ge&&l(e),C(a),C(p),C(y),C(k),C(G),C(De),C(me),C(_e)}}}function aV(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lV(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[aV]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[oV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function iV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fV(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[iV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if a supported format could not be found.
        Also throws if the `),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if a supported format could not be found.
        Also throws if the `),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function cV(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Image> make2DTexture(
    LogicalDevice* pLogicalDevice, 
    unsigned int width, 
    unsigned int height, 
    VkSampleCountFlagBits samples,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[fV],return:[lV],params:[sV],details:[jO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $V extends ve{constructor(e){super(),Ee(this,e,null,cV,be,{})}}function uV(c){let e,t;return{c(){e=d("span"),t=i("Create a new Depth Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Depth Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function pV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _V(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EV(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bV(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[pV]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[mV]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[hV]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.IMAGE,$$slots:{default:[dV]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.IMAGE,$$slots:{default:[gV]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[_V]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.IMAGE,$$slots:{default:[vV]},$$scope:{ctx:c}}}),_e=new H({props:{sectionID:L.QUEUE,$$slots:{default:[EV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=j(),v=d("li"),R=d("code"),P=i("width"),A=d("br"),T=i(`
            The width the `),I(y.$$.fragment),B=i(" should have."),M=j(),O=d("li"),x=d("code"),F=i("height"),V=d("br"),q=i(`
            The height the `),I(k.$$.fragment),N=i(" should have."),Q=j(),X=d("li"),Z=d("code"),K=i("samples"),W=d("br"),U=i(`
            The sample count the `),I(G.$$.fragment),te=i(" should have."),ee=j(),ne=d("li"),le=d("code"),ae=i("sharingMode"),J=d("br"),ue=i(`
            A member of the `),I(De.$$.fragment),de=i("-enumerant indicating how the "),I(me.$$.fragment),Ce=i(" will be used in the multiple device "),I(_e.$$.fragment),se=i(" supported by the Device."),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Re=E(t);r=g(Re,"CODE",{});var Be=E(r);$=f(Be,"pLogicalDevice"),Be.forEach(l),n=g(Re,"BR",{}),s=f(Re,`
            The `),S(a.$$.fragment,Re),u=f(Re," the "),S(p.$$.fragment,Re),m=f(Re,` should
            be associated with.`),Re.forEach(l),_=Y(we),v=g(we,"LI",{});var Ie=E(v);R=g(Ie,"CODE",{});var re=E(R);P=f(re,"width"),re.forEach(l),A=g(Ie,"BR",{}),T=f(Ie,`
            The width the `),S(y.$$.fragment,Ie),B=f(Ie," should have."),Ie.forEach(l),M=Y(we),O=g(we,"LI",{});var he=E(O);x=g(he,"CODE",{});var Ae=E(x);F=f(Ae,"height"),Ae.forEach(l),V=g(he,"BR",{}),q=f(he,`
            The height the `),S(k.$$.fragment,he),N=f(he," should have."),he.forEach(l),Q=Y(we),X=g(we,"LI",{});var Ve=E(X);Z=g(Ve,"CODE",{});var oe=E(Z);K=f(oe,"samples"),oe.forEach(l),W=g(Ve,"BR",{}),U=f(Ve,`
            The sample count the `),S(G.$$.fragment,Ve),te=f(Ve," should have."),Ve.forEach(l),ee=Y(we),ne=g(we,"LI",{});var ce=E(ne);le=g(ce,"CODE",{});var Pe=E(le);ae=f(Pe,"sharingMode"),Pe.forEach(l),J=g(ce,"BR",{}),ue=f(ce,`
            A member of the `),S(De.$$.fragment,ce),de=f(ce,"-enumerant indicating how the "),S(me.$$.fragment,ce),Ce=f(ce," will be used in the multiple device "),S(_e.$$.fragment,ce),se=f(ce," supported by the Device."),ce.forEach(l),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),D(G,X,null),o(X,te),o(e,ee),o(e,ne),o(ne,le),o(le,ae),o(ne,J),o(ne,ue),D(De,ne,null),o(ne,de),D(me,ne,null),o(ne,Ce),D(_e,ne,null),o(ne,se),ie=!0},p(ge,we){const Re={};we&1&&(Re.$$scope={dirty:we,ctx:ge}),a.$set(Re);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),p.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),y.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),G.$set(he);const Ae={};we&1&&(Ae.$$scope={dirty:we,ctx:ge}),De.$set(Ae);const Ve={};we&1&&(Ve.$$scope={dirty:we,ctx:ge}),me.$set(Ve);const oe={};we&1&&(oe.$$scope={dirty:we,ctx:ge}),_e.$set(oe)},i(ge){ie||(b(a.$$.fragment,ge),b(p.$$.fragment,ge),b(y.$$.fragment,ge),b(k.$$.fragment,ge),b(G.$$.fragment,ge),b(De.$$.fragment,ge),b(me.$$.fragment,ge),b(_e.$$.fragment,ge),ie=!0)},o(ge){w(a.$$.fragment,ge),w(p.$$.fragment,ge),w(y.$$.fragment,ge),w(k.$$.fragment,ge),w(G.$$.fragment,ge),w(De.$$.fragment,ge),w(me.$$.fragment,ge),w(_e.$$.fragment,ge),ie=!1},d(ge){ge&&l(e),C(a),C(p),C(y),C(k),C(G),C(De),C(me),C(_e)}}}function wV(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DV(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[wV]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[IV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function CV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SV(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[CV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if a supported format could not be
        found. Also throws if the `),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if a supported format could not be
        found. Also throws if the `),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function RV(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`std::unique_ptr<Image> makeDepthImage(
    LogicalDevice* pLogicalDevice, 
    unsigned int width, 
    unsigned int height, 
    VkSampleCountFlagBits samples,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Se({props:{$$slots:{throws:[SV],return:[DV],params:[bV],details:[uV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class AV extends ve{constructor(e){super(),Ee(this,e,null,RV,be,{})}}function PV(c){let e;return{c(){e=i("Image Director")},l(t){e=f(t,"Image Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BV(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LV(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/image_builder.hpp>"}}),m=new H({props:{sectionID:L.IMAGE_DIRECTOR,$$slots:{default:[PV]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.IMAGE,$$slots:{default:[BV]},$$scope:{ctx:c}}}),T=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
VkImageCreateFlags flags = 0;
VkImageType type = VK_IMAGE_TYPE_2D;
VkFormat format = VK_FORMAT_R8G8B8A8_SRGB;
VkExtent3D extent = {1, 1, 1};
unsigned int mipLevels = 1;
unsigned int arrayLayers = 1;
VkSampleCountFlagBits samples = VK_SAMPLE_COUNT_1_BIT;
VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT;
VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE;
std::vector<uint32_t> queueFamilyIndices = {};
VkImageLayout initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image Builder"),n=i(` class is part of the creational design pattern to
construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
It is recommended to use the `),I(m.$$.fragment),_=i(" for creating "),I(v.$$.fragment),R=i(` unless the
director doesn't offer the required configuration.`),P=d("br"),A=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var M=E(r);$=f(M,"Image Builder"),M.forEach(l),n=f(B,` class is part of the creational design pattern to
construct complex objects step by step.`),s=g(B,"BR",{}),a=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(B,"BR",{}),p=f(B,`
It is recommended to use the `),S(m.$$.fragment,B),_=f(B," for creating "),S(v.$$.fragment,B),R=f(B,` unless the
director doesn't offer the required configuration.`),P=g(B,"BR",{}),A=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(T.$$.fragment,B)},m(B,M){D(e,B,M),h(B,t,M),h(B,r,M),o(r,$),h(B,n,M),h(B,s,M),h(B,a,M),h(B,u,M),h(B,p,M),D(m,B,M),h(B,_,M),D(v,B,M),h(B,R,M),h(B,P,M),h(B,A,M),D(T,B,M),y=!0},p(B,[M]){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),m.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),v.$set(x)},i(B){y||(b(e.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),y=!0)},o(B){w(e.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),y=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(a),B&&l(u),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(R),B&&l(P),B&&l(A),C(T,B)}}}class kV extends ve{constructor(e){super(),Ee(this,e,null,LV,be,{})}}function TV(c){let e,t;return{c(){e=d("span"),t=i("Create a new Image Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Image Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function OV(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"ImageBuilder();"}}),r=new Se({props:{$$slots:{details:[TV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class VV extends ve{constructor(e){super(),Ee(this,e,null,OV,be,{})}}function yV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FV(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[yV]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[MV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function xV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UV(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[xV]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[NV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P,` should
            be associated with.`),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function GV(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[UV],details:[FV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class HV extends ve{constructor(e){super(),Ee(this,e,null,GV,be,{})}}function qV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WV(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[qV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function QV(c){let e;return{c(){e=i("VkImageCreateFlagBits")},l(t){e=f(t,"VkImageCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KV(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html",target:"_blank",$$slots:{default:[QV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that describe some properties of the image."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"flags"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A bitmask of `),S(a.$$.fragment,v),u=f(v," that describe some properties of the image."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function zV(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFlags(VkImageCreateFlags flags);"}}),r=new Se({props:{$$slots:{params:[KV],details:[WV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jV extends ve{constructor(e){super(),Ee(this,e,null,zV,be,{})}}function YV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XV(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[YV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Set the image type for
        the `),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`Set the image type for
        the `),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ZV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ey(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ty(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ry(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ZV]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[JV]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ey]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ty]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("type"),n=d("br"),s=i(`
            The type of `),I(a.$$.fragment),u=i(`
            being created. The `),I(p.$$.fragment),m=i(" type is essentially the dimensionality of the "),I(_.$$.fragment),v=i(" and can be "),R=d("code"),P=i("VK_IMAGE_TYPE_1D"),A=i(`,
            `),T=d("code"),y=i("VK_IMAGE_TYPE_2D"),B=i(`
            or `),M=d("code"),O=i("VK_IMAGE_TYPE_3D"),x=i(`
            for a 1D, 2D or 3D `),I(F.$$.fragment),V=i(" respectively."),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"type"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The type of `),S(a.$$.fragment,Q),u=f(Q,`
            being created. The `),S(p.$$.fragment,Q),m=f(Q," type is essentially the dimensionality of the "),S(_.$$.fragment,Q),v=f(Q," and can be "),R=g(Q,"CODE",{});var Z=E(R);P=f(Z,"VK_IMAGE_TYPE_1D"),Z.forEach(l),A=f(Q,`,
            `),T=g(Q,"CODE",{});var K=E(T);y=f(K,"VK_IMAGE_TYPE_2D"),K.forEach(l),B=f(Q,`
            or `),M=g(Q,"CODE",{});var W=E(M);O=f(W,"VK_IMAGE_TYPE_3D"),W.forEach(l),x=f(Q,`
            for a 1D, 2D or 3D `),S(F.$$.fragment,Q),V=f(Q," respectively."),Q.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),o(t,R),o(R,P),o(t,A),o(t,T),o(T,y),o(t,B),o(t,M),o(M,O),o(t,x),D(F,t,null),o(t,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),a.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),p.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),_.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),F.$set(K)},i(k){q||(b(a.$$.fragment,k),b(p.$$.fragment,k),b(_.$$.fragment,k),b(F.$$.fragment,k),q=!0)},o(k){w(a.$$.fragment,k),w(p.$$.fragment,k),w(_.$$.fragment,k),w(F.$$.fragment,k),q=!1},d(k){k&&l(e),C(a),C(p),C(_),C(F)}}}function ny(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setImageType(VkImageType type);"}}),r=new Se({props:{$$slots:{params:[ry],details:[XV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sy extends ve{constructor(e){super(),Ee(this,e,null,ny,be,{})}}function ay(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oy(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ay]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the format for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the format for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ly(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"format"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function iy(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFormat(VkFormat format);"}}),r=new Se({props:{$$slots:{params:[ly],details:[oy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fy extends ve{constructor(e){super(),Ee(this,e,null,iy,be,{})}}function cy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $y(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[cy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the extent for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the extent for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function uy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function py(c){let e;return{c(){e=i("VkExtent3D")},l(t){e=f(t,"VkExtent3D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function my(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hy(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dy(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gy(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[uy]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html",target:"_blank",$$slots:{default:[py]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.IMAGE,$$slots:{default:[my]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.IMAGE,$$slots:{default:[hy]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[dy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("extent"),n=d("br"),s=i(`
            The size of the `),I(a.$$.fragment),u=i(" in texels. This should be an instance of the "),I(p.$$.fragment),m=i(`
            structure , which has three members: `),_=d("code"),v=i("width"),R=i(`,
            `),P=d("code"),A=i("height"),T=i(", and "),y=d("code"),B=i("depth"),M=i(`. These should be set
            respectively to the width, height and depth of the desired `),I(O.$$.fragment),x=i(". For 1D "),I(F.$$.fragment),V=i(`,
            the height should be set to `),q=d("code"),k=i("1"),N=i(`, and for 1D and 2D
            `),I(Q.$$.fragment),X=i(`, the depth
            should be set to `),Z=d("code"),K=i("1"),W=i("."),this.h()},l(G){e=g(G,"DIV",{slot:!0});var te=E(e);t=g(te,"LI",{});var ee=E(t);r=g(ee,"CODE",{});var ne=E(r);$=f(ne,"extent"),ne.forEach(l),n=g(ee,"BR",{}),s=f(ee,`
            The size of the `),S(a.$$.fragment,ee),u=f(ee," in texels. This should be an instance of the "),S(p.$$.fragment,ee),m=f(ee,`
            structure , which has three members: `),_=g(ee,"CODE",{});var le=E(_);v=f(le,"width"),le.forEach(l),R=f(ee,`,
            `),P=g(ee,"CODE",{});var ae=E(P);A=f(ae,"height"),ae.forEach(l),T=f(ee,", and "),y=g(ee,"CODE",{});var J=E(y);B=f(J,"depth"),J.forEach(l),M=f(ee,`. These should be set
            respectively to the width, height and depth of the desired `),S(O.$$.fragment,ee),x=f(ee,". For 1D "),S(F.$$.fragment,ee),V=f(ee,`,
            the height should be set to `),q=g(ee,"CODE",{});var ue=E(q);k=f(ue,"1"),ue.forEach(l),N=f(ee,`, and for 1D and 2D
            `),S(Q.$$.fragment,ee),X=f(ee,`, the depth
            should be set to `),Z=g(ee,"CODE",{});var De=E(Z);K=f(De,"1"),De.forEach(l),W=f(ee,"."),ee.forEach(l),te.forEach(l),this.h()},h(){z(e,"slot","params")},m(G,te){h(G,e,te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(_,v),o(t,R),o(t,P),o(P,A),o(t,T),o(t,y),o(y,B),o(t,M),D(O,t,null),o(t,x),D(F,t,null),o(t,V),o(t,q),o(q,k),o(t,N),D(Q,t,null),o(t,X),o(t,Z),o(Z,K),o(t,W),U=!0},p(G,te){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:G}),a.$set(ee);const ne={};te&1&&(ne.$$scope={dirty:te,ctx:G}),p.$set(ne);const le={};te&1&&(le.$$scope={dirty:te,ctx:G}),O.$set(le);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:G}),F.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:G}),Q.$set(J)},i(G){U||(b(a.$$.fragment,G),b(p.$$.fragment,G),b(O.$$.fragment,G),b(F.$$.fragment,G),b(Q.$$.fragment,G),U=!0)},o(G){w(a.$$.fragment,G),w(p.$$.fragment,G),w(O.$$.fragment,G),w(F.$$.fragment,G),w(Q.$$.fragment,G),U=!1},d(G){G&&l(e),C(a),C(p),C(O),C(F),C(Q)}}}function _y(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setExtent(VkExtent3D extent);"}}),r=new Se({props:{$$slots:{params:[gy],details:[$y]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vy extends ve{constructor(e){super(),Ee(this,e,null,_y,be,{})}}function Ey(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function by(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Ey]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the number of mipmap levels for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the number of mipmap levels for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iy(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[wy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipLevels"),n=d("br"),s=i(`
            The number of mipmap levels to create in the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"mipLevels"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The number of mipmap levels to create in the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function Dy(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setMipLevels(unsigned int mipLevels);"}}),r=new Se({props:{$$slots:{params:[Iy],details:[by]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cy extends ve{constructor(e){super(),Ee(this,e,null,Dy,be,{})}}function Sy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ry(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Sy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the number of array layers for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the number of array layers for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ay(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Py(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function By(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Ay]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Py]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("arrayLayers"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" each mipmap level of the "),I(p.$$.fragment),m=i(" has."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"arrayLayers"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The amount of `),S(a.$$.fragment,P),u=f(P," each mipmap level of the "),S(p.$$.fragment,P),m=f(P," has."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Ly(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setArrayLayers(unsigned int arrayLayers);"}}),r=new Se({props:{$$slots:{params:[By],details:[Ry]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ky extends ve{constructor(e){super(),Ee(this,e,null,Ly,be,{})}}function Ty(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oy(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Ty]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sample count for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sample count for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Vy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yy(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function My(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Vy]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html",target:"_blank",$$slots:{default:[yy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("samples"),n=d("br"),s=i(`
            The number of samples in the `),I(a.$$.fragment),u=i(". It must be a member of the "),I(p.$$.fragment),m=i("-enumerant."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"samples"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The number of samples in the `),S(a.$$.fragment,P),u=f(P,". It must be a member of the "),S(p.$$.fragment,P),m=f(P,"-enumerant."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Fy(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setSamples(VkSampleCountFlagBits samples);"}}),r=new Se({props:{$$slots:{params:[My],details:[Oy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class xy extends ve{constructor(e){super(),Ee(this,e,null,Fy,be,{})}}function Ny(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uy(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Ny]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sample count for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sample count for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Gy(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hy(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qy(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wy(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qy(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[Gy]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Hy]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[qy]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Wy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("tiling"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant, which contains only "),p=d("code"),m=i("VK_IMAGE_TILING_LINEAR"),_=i(`
            or
            `),v=d("code"),R=i("VK_IMAGE_TILING_OPTIMAL"),P=i(". Linear tiling means that "),I(A.$$.fragment),T=i(`
            data is laid out from left to right, top to bottom, so that if the underlying
            memory is mapped and it is written with the CPU, it would form a linear
            `),I(y.$$.fragment),B=i(`. Meanwhile,
            optimal tiling is an opaque display used by Vulkan to store data in
            memory to improve the efficiency of the memory subsystem on the
            device. This is generally what should be chosen unless the `),I(M.$$.fragment),O=i(` needs to be CPU mapped and manipulated. Optimal tiling is likely to
            outperform linear tiling in most operations, and linear tiling may not
            be supported at all for some operations or formats, depending on the
            Vulkan implementation.`),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"tiling"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A member of the `),S(a.$$.fragment,q),u=f(q,"-enumerant, which contains only "),p=g(q,"CODE",{});var N=E(p);m=f(N,"VK_IMAGE_TILING_LINEAR"),N.forEach(l),_=f(q,`
            or
            `),v=g(q,"CODE",{});var Q=E(v);R=f(Q,"VK_IMAGE_TILING_OPTIMAL"),Q.forEach(l),P=f(q,". Linear tiling means that "),S(A.$$.fragment,q),T=f(q,`
            data is laid out from left to right, top to bottom, so that if the underlying
            memory is mapped and it is written with the CPU, it would form a linear
            `),S(y.$$.fragment,q),B=f(q,`. Meanwhile,
            optimal tiling is an opaque display used by Vulkan to store data in
            memory to improve the efficiency of the memory subsystem on the
            device. This is generally what should be chosen unless the `),S(M.$$.fragment,q),O=f(q,` needs to be CPU mapped and manipulated. Optimal tiling is likely to
            outperform linear tiling in most operations, and linear tiling may not
            be supported at all for some operations or formats, depending on the
            Vulkan implementation.`),q.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(p,m),o(t,_),o(t,v),o(v,R),o(t,P),D(A,t,null),o(t,T),D(y,t,null),o(t,B),D(M,t,null),o(t,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),A.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(A.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(A.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(A),C(y),C(M)}}}function Ky(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setImageTiling(VkImageTiling tiling);"}}),r=new Se({props:{$$slots:{params:[Qy],details:[Uy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zy extends ve{constructor(e){super(),Ee(this,e,null,Ky,be,{})}}function jy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yy(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[jy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the usage for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the usage for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Xy(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zy(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jy(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[Xy]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Zy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("usage"),n=d("br"),s=i(`
            A bitmask of members of the `),I(a.$$.fragment),u=i("-enumerant telling Vulkan how the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"usage"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A bitmask of members of the `),S(a.$$.fragment,P),u=f(P,"-enumerant telling Vulkan how the "),S(p.$$.fragment,P),m=f(P," will be used."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function e3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setImageTiling(VkImageTiling tiling);"}}),r=new Se({props:{$$slots:{params:[Jy],details:[Yy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class t3 extends ve{constructor(e){super(),Ee(this,e,null,e3,be,{})}}function r3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n3(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[r3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sharing mode for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sharing mode for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function s3(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o3(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f3(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $3(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u3(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[s3]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[a3]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.QUEUE,$$slots:{default:[o3]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.IMAGE,$$slots:{default:[l3]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.IMAGE,$$slots:{default:[i3]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.QUEUE,$$slots:{default:[f3]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.IMAGE,$$slots:{default:[c3]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.QUEUE,$$slots:{default:[$3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("sharingMode"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant indicating how the "),I(p.$$.fragment),m=i(" will be used in the multiple device "),I(_.$$.fragment),v=i(` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),I(R.$$.fragment),P=i(` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=d("code"),T=i("sharingMode"),y=i(`
            to `),B=d("code"),M=i("VK_SHARING_MODE_EXCLUSIVE"),O=i(` tells Vulkan that the
            `),I(x.$$.fragment),F=i(` will only be
            used for a single `),I(V.$$.fragment),q=i(`, while setting
            `),k=d("code"),N=i("sharingMode"),Q=i(`
            to
            `),X=d("code"),Z=i("VK_SHARING_MODE_CONCURRENT"),K=i(` specifies that the
            application will use the `),I(W.$$.fragment),U=i(" on multiple "),I(G.$$.fragment),te=i(` at once. Using
            `),ee=d("code"),ne=i("VK_SHARING_MODE_CONCURRENT"),le=i(` may result in lower
            performance on some systems, so unless necessary,
            `),ae=d("code"),J=i("sharingMode"),ue=i(`
            should be set to `),De=d("code"),de=i("VK_SHARING_MODE_EXCLUSIVE"),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var se=E(e);t=g(se,"LI",{});var ie=E(t);r=g(ie,"CODE",{});var ge=E(r);$=f(ge,"sharingMode"),ge.forEach(l),n=g(ie,"BR",{}),s=f(ie,`
            A member of the `),S(a.$$.fragment,ie),u=f(ie,"-enumerant indicating how the "),S(p.$$.fragment,ie),m=f(ie," will be used in the multiple device "),S(_.$$.fragment,ie),v=f(ie,` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),S(R.$$.fragment,ie),P=f(ie,` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=g(ie,"CODE",{});var we=E(A);T=f(we,"sharingMode"),we.forEach(l),y=f(ie,`
            to `),B=g(ie,"CODE",{});var Re=E(B);M=f(Re,"VK_SHARING_MODE_EXCLUSIVE"),Re.forEach(l),O=f(ie,` tells Vulkan that the
            `),S(x.$$.fragment,ie),F=f(ie,` will only be
            used for a single `),S(V.$$.fragment,ie),q=f(ie,`, while setting
            `),k=g(ie,"CODE",{});var Be=E(k);N=f(Be,"sharingMode"),Be.forEach(l),Q=f(ie,`
            to
            `),X=g(ie,"CODE",{});var Ie=E(X);Z=f(Ie,"VK_SHARING_MODE_CONCURRENT"),Ie.forEach(l),K=f(ie,` specifies that the
            application will use the `),S(W.$$.fragment,ie),U=f(ie," on multiple "),S(G.$$.fragment,ie),te=f(ie,` at once. Using
            `),ee=g(ie,"CODE",{});var re=E(ee);ne=f(re,"VK_SHARING_MODE_CONCURRENT"),re.forEach(l),le=f(ie,` may result in lower
            performance on some systems, so unless necessary,
            `),ae=g(ie,"CODE",{});var he=E(ae);J=f(he,"sharingMode"),he.forEach(l),ue=f(ie,`
            should be set to `),De=g(ie,"CODE",{});var Ae=E(De);de=f(Ae,"VK_SHARING_MODE_EXCLUSIVE"),Ae.forEach(l),me=f(ie,"."),ie.forEach(l),se.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,se){h(_e,e,se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),D(R,t,null),o(t,P),o(t,A),o(A,T),o(t,y),o(t,B),o(B,M),o(t,O),D(x,t,null),o(t,F),D(V,t,null),o(t,q),o(t,k),o(k,N),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,U),D(G,t,null),o(t,te),o(t,ee),o(ee,ne),o(t,le),o(t,ae),o(ae,J),o(t,ue),o(t,De),o(De,de),o(t,me),Ce=!0},p(_e,se){const ie={};se&1&&(ie.$$scope={dirty:se,ctx:_e}),a.$set(ie);const ge={};se&1&&(ge.$$scope={dirty:se,ctx:_e}),p.$set(ge);const we={};se&1&&(we.$$scope={dirty:se,ctx:_e}),_.$set(we);const Re={};se&1&&(Re.$$scope={dirty:se,ctx:_e}),R.$set(Re);const Be={};se&1&&(Be.$$scope={dirty:se,ctx:_e}),x.$set(Be);const Ie={};se&1&&(Ie.$$scope={dirty:se,ctx:_e}),V.$set(Ie);const re={};se&1&&(re.$$scope={dirty:se,ctx:_e}),W.$set(re);const he={};se&1&&(he.$$scope={dirty:se,ctx:_e}),G.$set(he)},i(_e){Ce||(b(a.$$.fragment,_e),b(p.$$.fragment,_e),b(_.$$.fragment,_e),b(R.$$.fragment,_e),b(x.$$.fragment,_e),b(V.$$.fragment,_e),b(W.$$.fragment,_e),b(G.$$.fragment,_e),Ce=!0)},o(_e){w(a.$$.fragment,_e),w(p.$$.fragment,_e),w(_.$$.fragment,_e),w(R.$$.fragment,_e),w(x.$$.fragment,_e),w(V.$$.fragment,_e),w(W.$$.fragment,_e),w(G.$$.fragment,_e),Ce=!1},d(_e){_e&&l(e),C(a),C(p),C(_),C(R),C(x),C(V),C(W),C(G)}}}function p3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setSharingMode(VkSharingMode sharingMode);"}}),r=new Se({props:{$$slots:{params:[u3],details:[n3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class m3 extends ve{constructor(e){super(),Ee(this,e,null,p3,be,{})}}function h3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d3(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[h3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function g3(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _3(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v3(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.QUEUE,$$slots:{default:[g3]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[_3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("queueFamilyIndices"),n=d("br"),s=i(`
            A pointer to an array of `),I(a.$$.fragment),u=i(" family indices on which the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"queueFamilyIndices"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to an array of `),S(a.$$.fragment,P),u=f(P," family indices on which the "),S(p.$$.fragment,P),m=f(P," will be used."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function E3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setQueueFamilyIndices(std::vector<uint32_t>& queueFamilyIndices);"}}),r=new Se({props:{$$slots:{params:[v3],details:[d3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class b3 extends ve{constructor(e){super(),Ee(this,e,null,E3,be,{})}}function w3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I3(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[w3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function D3(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C3(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S3(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R3(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A3(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P3(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function B3(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[D3]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.IMAGE,$$slots:{default:[C3]},$$scope:{ctx:c}}}),_=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[S3]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[R3]},$$scope:{ctx:c}}}),N=new H({props:{sectionID:L.IMAGE,$$slots:{default:[A3]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.IMAGE,$$slots:{default:[P3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("initialLayout"),n=d("br"),s=j(),I(a.$$.fragment),u=i(` have a layout,
            which partially indicates how they will be used at a given time. This
            field determines the layout in which the `),I(p.$$.fragment),m=i(" is created. The available layouts are the members of the "),I(_.$$.fragment),v=i("-enumerant."),R=d("br"),P=j(),I(A.$$.fragment),T=i(` should initially
            be created in the format
            `),y=d("code"),B=i("VK_IMAGE_LAYOUT_UNDEFINED"),M=i(`
            or `),O=d("code"),x=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),F=i(`.
            `),V=d("code"),q=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),k=i(`
            should only be used if there is data in memory that is bound immediately
            to the `),I(N.$$.fragment),Q=i(` source.
            `),X=d("code"),Z=i("VK_IMAGE_LAYOUT_UNDEFINED"),K=i(`
            should be used when moving the resource to another layout before use.
            `),I(W.$$.fragment),U=i(` can be moved
            out of the
            `),G=d("code"),te=i("VK_IMAGE_LAYOUT_UNDEFINED"),ee=i(` layout at any time with little
            or no time cost.`),this.h()},l(le){e=g(le,"DIV",{slot:!0});var ae=E(e);t=g(ae,"LI",{});var J=E(t);r=g(J,"CODE",{});var ue=E(r);$=f(ue,"initialLayout"),ue.forEach(l),n=g(J,"BR",{}),s=Y(J),S(a.$$.fragment,J),u=f(J,` have a layout,
            which partially indicates how they will be used at a given time. This
            field determines the layout in which the `),S(p.$$.fragment,J),m=f(J," is created. The available layouts are the members of the "),S(_.$$.fragment,J),v=f(J,"-enumerant."),R=g(J,"BR",{}),P=Y(J),S(A.$$.fragment,J),T=f(J,` should initially
            be created in the format
            `),y=g(J,"CODE",{});var De=E(y);B=f(De,"VK_IMAGE_LAYOUT_UNDEFINED"),De.forEach(l),M=f(J,`
            or `),O=g(J,"CODE",{});var de=E(O);x=f(de,"VK_IMAGE_LAYOUT_PREINITIALIZED"),de.forEach(l),F=f(J,`.
            `),V=g(J,"CODE",{});var me=E(V);q=f(me,"VK_IMAGE_LAYOUT_PREINITIALIZED"),me.forEach(l),k=f(J,`
            should only be used if there is data in memory that is bound immediately
            to the `),S(N.$$.fragment,J),Q=f(J,` source.
            `),X=g(J,"CODE",{});var Ce=E(X);Z=f(Ce,"VK_IMAGE_LAYOUT_UNDEFINED"),Ce.forEach(l),K=f(J,`
            should be used when moving the resource to another layout before use.
            `),S(W.$$.fragment,J),U=f(J,` can be moved
            out of the
            `),G=g(J,"CODE",{});var _e=E(G);te=f(_e,"VK_IMAGE_LAYOUT_UNDEFINED"),_e.forEach(l),ee=f(J,` layout at any time with little
            or no time cost.`),J.forEach(l),ae.forEach(l),this.h()},h(){z(e,"slot","params")},m(le,ae){h(le,e,ae),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),o(t,R),o(t,P),D(A,t,null),o(t,T),o(t,y),o(y,B),o(t,M),o(t,O),o(O,x),o(t,F),o(t,V),o(V,q),o(t,k),D(N,t,null),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,U),o(t,G),o(G,te),o(t,ee),ne=!0},p(le,ae){const J={};ae&1&&(J.$$scope={dirty:ae,ctx:le}),a.$set(J);const ue={};ae&1&&(ue.$$scope={dirty:ae,ctx:le}),p.$set(ue);const De={};ae&1&&(De.$$scope={dirty:ae,ctx:le}),_.$set(De);const de={};ae&1&&(de.$$scope={dirty:ae,ctx:le}),A.$set(de);const me={};ae&1&&(me.$$scope={dirty:ae,ctx:le}),N.$set(me);const Ce={};ae&1&&(Ce.$$scope={dirty:ae,ctx:le}),W.$set(Ce)},i(le){ne||(b(a.$$.fragment,le),b(p.$$.fragment,le),b(_.$$.fragment,le),b(A.$$.fragment,le),b(N.$$.fragment,le),b(W.$$.fragment,le),ne=!0)},o(le){w(a.$$.fragment,le),w(p.$$.fragment,le),w(_.$$.fragment,le),w(A.$$.fragment,le),w(N.$$.fragment,le),w(W.$$.fragment,le),ne=!1},d(le){le&&l(e),C(a),C(p),C(_),C(A),C(N),C(W)}}}function L3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setInitialLayout(VkImageLayout initialLayout);"}}),r=new Se({props:{$$slots:{params:[B3],details:[I3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class k3 extends ve{constructor(e){super(),Ee(this,e,null,L3,be,{})}}function T3(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O3(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function V3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[O3],default:[T3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class y3 extends ve{constructor(e){super(),Ee(this,e,null,V3,be,{})}}function M3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F3(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[M3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function x3(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U3(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[x3]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[N3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function G3(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H3(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[G3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function q3(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<Image> getResult();"}}),r=new Se({props:{$$slots:{throws:[H3],return:[U3],details:[F3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class W3 extends ve{constructor(e){super(),Ee(this,e,null,q3,be,{})}}function Q3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K3(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z3(c){let e,t,r,$,n,s,a,u,p,m,_,v;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/fence.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Q3]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[K3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Fence"),n=i(" class takes in a pointer to a "),I(s.$$.fragment),a=i(" and a bitmask of optional flags and uses this information to construct a new "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: waiting for the fence
to be signaled and resetting the fence.`),m=d("br"),_=i(`
A fence is a kind of synchronization primitive. Fences are used when the host has
to wait for the device to complete the execution of (large) pieces of work represented
by a submission, usually with the help of the operating system.`)},l(R){S(e.$$.fragment,R),t=f(R,`
The `),r=g(R,"CODE",{});var P=E(r);$=f(P,"Fence"),P.forEach(l),n=f(R," class takes in a pointer to a "),S(s.$$.fragment,R),a=f(R," and a bitmask of optional flags and uses this information to construct a new "),S(u.$$.fragment,R),p=f(R,` which it will wrap around to offer functionality such as: waiting for the fence
to be signaled and resetting the fence.`),m=g(R,"BR",{}),_=f(R,`
A fence is a kind of synchronization primitive. Fences are used when the host has
to wait for the device to complete the execution of (large) pieces of work represented
by a submission, usually with the help of the operating system.`)},m(R,P){D(e,R,P),h(R,t,P),h(R,r,P),o(r,$),h(R,n,P),D(s,R,P),h(R,a,P),D(u,R,P),h(R,p,P),h(R,m,P),h(R,_,P),v=!0},p(R,[P]){const A={};P&1&&(A.$$scope={dirty:P,ctx:R}),s.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:R}),u.$set(T)},i(R){v||(b(e.$$.fragment,R),b(s.$$.fragment,R),b(u.$$.fragment,R),v=!0)},o(R){w(e.$$.fragment,R),w(s.$$.fragment,R),w(u.$$.fragment,R),v=!1},d(R){C(e,R),R&&l(t),R&&l(r),R&&l(n),C(s,R),R&&l(a),C(u,R),R&&l(p),R&&l(m),R&&l(_)}}}class j3 extends ve{constructor(e){super(),Ee(this,e,null,z3,be,{})}}function Y3(c){let e,t;return{c(){e=d("span"),t=i("Create a new Fence."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Fence."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function X3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z3(c){let e;return{c(){e=i("VkFenceCreateFlagBits")},l(t){e=f(t,"VkFenceCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J3(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[X3]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html",target:"_blank",$$slots:{default:[Z3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Fence should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" which specify the initial state and behaviour of the fence."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"pLogicalDevice"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            A pointer to the `),S(a.$$.fragment,O),u=f(O," the Fence should be associated with."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"flags"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            A bitmask of `),S(A.$$.fragment,F),T=f(F," which specify the initial state and behaviour of the fence."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function e2(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t2(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[e2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function r2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Fence(LogicalDevice* pLogicalDevice, VkFenceCreateFlags flags = 0);"}}),r=new Se({props:{$$slots:{throws:[t2],params:[J3],details:[Y3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class n2 extends ve{constructor(e){super(),Ee(this,e,null,r2,be,{})}}function s2(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[s2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function o2(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[o2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function i2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkFence getFenceHandle() const;"}}),r=new Se({props:{$$slots:{return:[l2],details:[a2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class f2 extends ve{constructor(e){super(),Ee(this,e,null,i2,be,{})}}function c2(c){let e,t;return{c(){e=d("span"),t=i("Wait for the Fence to be signaled."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Wait for the Fence to be signaled."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function $2(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("timeout"),n=d("br"),s=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"timeout"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The timeout period in units of nanoseconds to wait before returning.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function u2(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Fence was succesfully waited for.
        `),n=d("code"),s=i("false"),a=i(" if the timeout expired."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Fence was succesfully waited for.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the timeout expired."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function p2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool waitFor(uint64_t timeout = UINT64_MAX);"}}),r=new Se({props:{$$slots:{return:[u2],params:[$2],details:[c2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class m2 extends ve{constructor(e){super(),Ee(this,e,null,p2,be,{})}}function h2(c){let e,t;return{c(){e=d("span"),t=i("Wait for all given Fences to be signaled."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Wait for all given Fences to be signaled."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function d2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g2(c){let e;return{c(){e=i("Fences")},l(t){e=f(t,"Fences")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _2(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[d2]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.FENCE,$$slots:{default:[g2]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" which owns the given Fences."),p=j(),m=d("li"),_=d("code"),v=i("pFences"),R=d("br"),P=i(`
            A list of pointers to the `),I(A.$$.fragment),T=i(" to wait for."),y=j(),B=d("li"),M=d("code"),O=i("timeout"),x=d("br"),F=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"pLogicalDevice"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            The `),S(a.$$.fragment,N),u=f(N," which owns the given Fences."),N.forEach(l),p=Y(k),m=g(k,"LI",{});var X=E(m);_=g(X,"CODE",{});var Z=E(_);v=f(Z,"pFences"),Z.forEach(l),R=g(X,"BR",{}),P=f(X,`
            A list of pointers to the `),S(A.$$.fragment,X),T=f(X," to wait for."),X.forEach(l),y=Y(k),B=g(k,"LI",{});var K=E(B);M=g(K,"CODE",{});var W=E(M);O=f(W,"timeout"),W.forEach(l),x=g(K,"BR",{}),F=f(K,`
            The timeout period in units of nanoseconds to wait before returning.`),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,k){h(q,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),V=!0},p(q,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:q}),a.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:q}),A.$set(Q)},i(q){V||(b(a.$$.fragment,q),b(A.$$.fragment,q),V=!0)},o(q){w(a.$$.fragment,q),w(A.$$.fragment,q),V=!1},d(q){q&&l(e),C(a),C(A)}}}function v2(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fences were succesfully waited for.
        `),n=d("code"),s=i("false"),a=i(" if the timeout expired."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fences were succesfully waited for.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the timeout expired."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function E2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"static bool s_waitForAll(LogicalDevice* pLogicalDevice, std::vector<Fence*> pFences, uint64_t timeout = UINT64_MAX);"}}),r=new Se({props:{$$slots:{return:[v2],params:[_2],details:[h2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class b2 extends ve{constructor(e){super(),Ee(this,e,null,E2,be,{})}}function w2(c){let e,t;return{c(){e=d("span"),t=i("Reset all given Fences."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset all given Fences."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function I2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D2(c){let e;return{c(){e=i("Fences")},l(t){e=f(t,"Fences")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C2(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[I2]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.FENCE,$$slots:{default:[D2]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" which owns the given Fences."),p=j(),m=d("li"),_=d("code"),v=i("pFences"),R=d("br"),P=i(`
            A list of pointers to the `),I(A.$$.fragment),T=i(" to reset."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"pLogicalDevice"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The `),S(a.$$.fragment,O),u=f(O," which owns the given Fences."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"pFences"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            A list of pointers to the `),S(A.$$.fragment,F),T=f(F," to reset."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function S2(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fences were succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if not all Fences could be reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fences were succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all Fences could be reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function R2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"static bool s_resetAll(LogicalDevice* pLogicalDevice, std::vector<Fence*> pFences);"}}),r=new Se({props:{$$slots:{return:[S2],params:[C2],details:[w2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class A2 extends ve{constructor(e){super(),Ee(this,e,null,R2,be,{})}}function P2(c){let e,t;return{c(){e=d("span"),t=i("Reset the Fence to an unsignaled state."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Fence to an unsignaled state."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function B2(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fence was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Fence failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fence was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Fence failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function L2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool reset();"}}),r=new Se({props:{$$slots:{return:[B2],details:[P2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class k2 extends ve{constructor(e){super(),Ee(this,e,null,L2,be,{})}}function T2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O2(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V2(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y2(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M2(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return e=new $e({props:{language:pe,code:"#include <fillcan/memory/semaphore.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[T2]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[O2]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.QUEUE,$$slots:{default:[V2]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.QUEUE,$$slots:{default:[y2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Semaphore"),n=i(" class takes in a pointer to a "),I(s.$$.fragment),a=i(" uses this information to construct a new "),I(u.$$.fragment),p=d("br"),m=i(`
A semaphore is a type of synchronization primitive that allows work performed by
different `),I(_.$$.fragment),v=i(` to be properly
planned and coordinated. Semaphores are used to manage the ownership of resources
in different `),I(R.$$.fragment),P=i(` on a single
device.`)},l(T){S(e.$$.fragment,T),t=f(T,`
The `),r=g(T,"CODE",{});var y=E(r);$=f(y,"Semaphore"),y.forEach(l),n=f(T," class takes in a pointer to a "),S(s.$$.fragment,T),a=f(T," uses this information to construct a new "),S(u.$$.fragment,T),p=g(T,"BR",{}),m=f(T,`
A semaphore is a type of synchronization primitive that allows work performed by
different `),S(_.$$.fragment,T),v=f(T,` to be properly
planned and coordinated. Semaphores are used to manage the ownership of resources
in different `),S(R.$$.fragment,T),P=f(T,` on a single
device.`)},m(T,y){D(e,T,y),h(T,t,y),h(T,r,y),o(r,$),h(T,n,y),D(s,T,y),h(T,a,y),D(u,T,y),h(T,p,y),h(T,m,y),D(_,T,y),h(T,v,y),D(R,T,y),h(T,P,y),A=!0},p(T,[y]){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),s.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),u.$set(M);const O={};y&1&&(O.$$scope={dirty:y,ctx:T}),_.$set(O);const x={};y&1&&(x.$$scope={dirty:y,ctx:T}),R.$set(x)},i(T){A||(b(e.$$.fragment,T),b(s.$$.fragment,T),b(u.$$.fragment,T),b(_.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(e.$$.fragment,T),w(s.$$.fragment,T),w(u.$$.fragment,T),w(_.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){C(e,T),T&&l(t),T&&l(r),T&&l(n),C(s,T),T&&l(a),C(u,T),T&&l(p),T&&l(m),C(_,T),T&&l(v),C(R,T),T&&l(P)}}}class F2 extends ve{constructor(e){super(),Ee(this,e,null,M2,be,{})}}function x2(c){let e,t;return{c(){e=d("span"),t=i("Create a new Semaphore."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Semaphore."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function N2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U2(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[N2]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Semaphore should be associated with."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pLogicalDevice"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," the Semaphore should be associated with."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function G2(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H2(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[G2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function q2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"Semaphore(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{throws:[H2],params:[U2],details:[x2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class W2 extends ve{constructor(e){super(),Ee(this,e,null,q2,be,{})}}function Q2(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[Q2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function z2(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[z2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Y2(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkSemaphore getSemaphoreHandle() const;"}}),r=new Se({props:{$$slots:{return:[j2],details:[K2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class X2 extends ve{constructor(e){super(),Ee(this,e,null,Y2,be,{})}}function Z2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J2(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eM(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rM(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nM(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aM(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oM(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lM(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function iM(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fM(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cM(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $M(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uM(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pM(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mM(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hM(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dM(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/shader_module.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Z2]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[J2]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[eM]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[tM]},$$scope:{ctx:c}}}),P=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[rM]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[nM]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[sM]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[aM]},$$scope:{ctx:c}}}),q=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[oM]},$$scope:{ctx:c}}}),N=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[lM]},$$scope:{ctx:c}}}),U=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[iM]},$$scope:{ctx:c}}}),te=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[fM]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[cM]},$$scope:{ctx:c}}}),ue=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[$M]},$$scope:{ctx:c}}}),de=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[uM]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[pM]},$$scope:{ctx:c}}}),Ie=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[mM]},$$scope:{ctx:c}}}),he=new fe({props:{href:"https://github.com/google/shaderc",target:"_blank",$$slots:{default:[hM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Shader Module"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a list of characters representing the GLSL code and a list of "),I(u.$$.fragment),p=i(" to the "),I(m.$$.fragment),_=i(" describing the "),I(v.$$.fragment),R=i(" that expose resources to the shader, and a "),I(P.$$.fragment),A=i(" to a "),I(T.$$.fragment),y=i(" from which the "),I(B.$$.fragment),M=i(" will be allocated."),O=d("br"),x=i(`
Note that the ownership of both the `),I(F.$$.fragment),V=i(" and the "),I(q.$$.fragment),k=i(" needs to be transferred using "),I(N.$$.fragment),Q=i("."),X=d("br"),Z=i(`
Shaders are small programs that run directly on the device (like a GPU). Shaders
are the fundamental building blocks of the work to be done on the device.`),K=d("br"),W=i(`
Vulkan shaders are represented by `),I(U.$$.fragment),G=i(` (Standard Portable Intermediate Representation), a binary intermediate representation
of program code. `),I(te.$$.fragment),ee=i(` can be generated outside the application using a compiler, directly in the application
or by passing a high-level language to a library at run-time.`),ne=d("br"),le=i(`
The original shaders are written in `),I(ae.$$.fragment),J=i(` using the Vulkan profile. This is a modified and extended version of the same shading
language used with OpenGL. Most examples therefore discuss Vulkan features in terms
of their representation in `),I(ue.$$.fragment),De=i(". Note that Vulkan itself knows nothing about "),I(de.$$.fragment),me=i(" and only cares about the compiled "),I(Ce.$$.fragment),_e=i(" representation."),se=d("br"),ie=d("br"),ge=i(`

The `),we=d("code"),Re=i("Shader Module"),Be=i(" class compiles "),I(Ie.$$.fragment),re=i(" shaders at run-time using "),I(he.$$.fragment),Ae=i(".")},l(oe){S(e.$$.fragment,oe),t=f(oe,`

The `),r=g(oe,"CODE",{});var ce=E(r);$=f(ce,"Shader Module"),ce.forEach(l),n=f(oe," class takes a pointer to a "),S(s.$$.fragment,oe),a=f(oe," along with a list of characters representing the GLSL code and a list of "),S(u.$$.fragment,oe),p=f(oe," to the "),S(m.$$.fragment,oe),_=f(oe," describing the "),S(v.$$.fragment,oe),R=f(oe," that expose resources to the shader, and a "),S(P.$$.fragment,oe),A=f(oe," to a "),S(T.$$.fragment,oe),y=f(oe," from which the "),S(B.$$.fragment,oe),M=f(oe," will be allocated."),O=g(oe,"BR",{}),x=f(oe,`
Note that the ownership of both the `),S(F.$$.fragment,oe),V=f(oe," and the "),S(q.$$.fragment,oe),k=f(oe," needs to be transferred using "),S(N.$$.fragment,oe),Q=f(oe,"."),X=g(oe,"BR",{}),Z=f(oe,`
Shaders are small programs that run directly on the device (like a GPU). Shaders
are the fundamental building blocks of the work to be done on the device.`),K=g(oe,"BR",{}),W=f(oe,`
Vulkan shaders are represented by `),S(U.$$.fragment,oe),G=f(oe,` (Standard Portable Intermediate Representation), a binary intermediate representation
of program code. `),S(te.$$.fragment,oe),ee=f(oe,` can be generated outside the application using a compiler, directly in the application
or by passing a high-level language to a library at run-time.`),ne=g(oe,"BR",{}),le=f(oe,`
The original shaders are written in `),S(ae.$$.fragment,oe),J=f(oe,` using the Vulkan profile. This is a modified and extended version of the same shading
language used with OpenGL. Most examples therefore discuss Vulkan features in terms
of their representation in `),S(ue.$$.fragment,oe),De=f(oe,". Note that Vulkan itself knows nothing about "),S(de.$$.fragment,oe),me=f(oe," and only cares about the compiled "),S(Ce.$$.fragment,oe),_e=f(oe," representation."),se=g(oe,"BR",{}),ie=g(oe,"BR",{}),ge=f(oe,`

The `),we=g(oe,"CODE",{});var Pe=E(we);Re=f(Pe,"Shader Module"),Pe.forEach(l),Be=f(oe," class compiles "),S(Ie.$$.fragment,oe),re=f(oe," shaders at run-time using "),S(he.$$.fragment,oe),Ae=f(oe,".")},m(oe,ce){D(e,oe,ce),h(oe,t,ce),h(oe,r,ce),o(r,$),h(oe,n,ce),D(s,oe,ce),h(oe,a,ce),D(u,oe,ce),h(oe,p,ce),D(m,oe,ce),h(oe,_,ce),D(v,oe,ce),h(oe,R,ce),D(P,oe,ce),h(oe,A,ce),D(T,oe,ce),h(oe,y,ce),D(B,oe,ce),h(oe,M,ce),h(oe,O,ce),h(oe,x,ce),D(F,oe,ce),h(oe,V,ce),D(q,oe,ce),h(oe,k,ce),D(N,oe,ce),h(oe,Q,ce),h(oe,X,ce),h(oe,Z,ce),h(oe,K,ce),h(oe,W,ce),D(U,oe,ce),h(oe,G,ce),D(te,oe,ce),h(oe,ee,ce),h(oe,ne,ce),h(oe,le,ce),D(ae,oe,ce),h(oe,J,ce),D(ue,oe,ce),h(oe,De,ce),D(de,oe,ce),h(oe,me,ce),D(Ce,oe,ce),h(oe,_e,ce),h(oe,se,ce),h(oe,ie,ce),h(oe,ge,ce),h(oe,we,ce),o(we,Re),h(oe,Be,ce),D(Ie,oe,ce),h(oe,re,ce),D(he,oe,ce),h(oe,Ae,ce),Ve=!0},p(oe,[ce]){const Pe={};ce&1&&(Pe.$$scope={dirty:ce,ctx:oe}),s.$set(Pe);const Fe={};ce&1&&(Fe.$$scope={dirty:ce,ctx:oe}),u.$set(Fe);const ke={};ce&1&&(ke.$$scope={dirty:ce,ctx:oe}),m.$set(ke);const Te={};ce&1&&(Te.$$scope={dirty:ce,ctx:oe}),v.$set(Te);const Me={};ce&1&&(Me.$$scope={dirty:ce,ctx:oe}),P.$set(Me);const Ue={};ce&1&&(Ue.$$scope={dirty:ce,ctx:oe}),T.$set(Ue);const qe={};ce&1&&(qe.$$scope={dirty:ce,ctx:oe}),B.$set(qe);const xe={};ce&1&&(xe.$$scope={dirty:ce,ctx:oe}),F.$set(xe);const Ge={};ce&1&&(Ge.$$scope={dirty:ce,ctx:oe}),q.$set(Ge);const ye={};ce&1&&(ye.$$scope={dirty:ce,ctx:oe}),N.$set(ye);const We={};ce&1&&(We.$$scope={dirty:ce,ctx:oe}),U.$set(We);const ze={};ce&1&&(ze.$$scope={dirty:ce,ctx:oe}),te.$set(ze);const Ye={};ce&1&&(Ye.$$scope={dirty:ce,ctx:oe}),ae.$set(Ye);const rt={};ce&1&&(rt.$$scope={dirty:ce,ctx:oe}),ue.$set(rt);const Ne={};ce&1&&(Ne.$$scope={dirty:ce,ctx:oe}),de.$set(Ne);const He={};ce&1&&(He.$$scope={dirty:ce,ctx:oe}),Ce.$set(He);const $t={};ce&1&&($t.$$scope={dirty:ce,ctx:oe}),Ie.$set($t);const ut={};ce&1&&(ut.$$scope={dirty:ce,ctx:oe}),he.$set(ut)},i(oe){Ve||(b(e.$$.fragment,oe),b(s.$$.fragment,oe),b(u.$$.fragment,oe),b(m.$$.fragment,oe),b(v.$$.fragment,oe),b(P.$$.fragment,oe),b(T.$$.fragment,oe),b(B.$$.fragment,oe),b(F.$$.fragment,oe),b(q.$$.fragment,oe),b(N.$$.fragment,oe),b(U.$$.fragment,oe),b(te.$$.fragment,oe),b(ae.$$.fragment,oe),b(ue.$$.fragment,oe),b(de.$$.fragment,oe),b(Ce.$$.fragment,oe),b(Ie.$$.fragment,oe),b(he.$$.fragment,oe),Ve=!0)},o(oe){w(e.$$.fragment,oe),w(s.$$.fragment,oe),w(u.$$.fragment,oe),w(m.$$.fragment,oe),w(v.$$.fragment,oe),w(P.$$.fragment,oe),w(T.$$.fragment,oe),w(B.$$.fragment,oe),w(F.$$.fragment,oe),w(q.$$.fragment,oe),w(N.$$.fragment,oe),w(U.$$.fragment,oe),w(te.$$.fragment,oe),w(ae.$$.fragment,oe),w(ue.$$.fragment,oe),w(de.$$.fragment,oe),w(Ce.$$.fragment,oe),w(Ie.$$.fragment,oe),w(he.$$.fragment,oe),Ve=!1},d(oe){C(e,oe),oe&&l(t),oe&&l(r),oe&&l(n),C(s,oe),oe&&l(a),C(u,oe),oe&&l(p),C(m,oe),oe&&l(_),C(v,oe),oe&&l(R),C(P,oe),oe&&l(A),C(T,oe),oe&&l(y),C(B,oe),oe&&l(M),oe&&l(O),oe&&l(x),C(F,oe),oe&&l(V),C(q,oe),oe&&l(k),C(N,oe),oe&&l(Q),oe&&l(X),oe&&l(Z),oe&&l(K),oe&&l(W),C(U,oe),oe&&l(G),C(te,oe),oe&&l(ee),oe&&l(ne),oe&&l(le),C(ae,oe),oe&&l(J),C(ue,oe),oe&&l(De),C(de,oe),oe&&l(me),C(Ce,oe),oe&&l(_e),oe&&l(se),oe&&l(ie),oe&&l(ge),oe&&l(we),oe&&l(Be),C(Ie,oe),oe&&l(re),C(he,oe),oe&&l(Ae)}}}class gM extends ve{constructor(e){super(),Ee(this,e,null,dM,be,{})}}function _M(c){let e;return{c(){e=i("createShaderModule")},l(t){e=f(t,"createShaderModule")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vM(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.FILLCAN_createShaderModule,$$slots:{default:[_M]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Shader Module."),r=d("br"),$=i(`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(` instead.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Shader Module."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p,` instead.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function EM(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bM(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wM(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DM(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function CM(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SM(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RM(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function AM(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[EM]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[bM]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[wM]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[IM]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[DM]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[CM]},$$scope:{ctx:c}}}),le=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[SM]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[RM]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Shader Module."),p=j(),m=d("li"),_=d("code"),v=i("code"),R=d("br"),P=i(`
            The SPIR-V code.`),A=j(),T=d("li"),y=d("code"),B=i("upDescriptorSetLayouts"),M=d("br"),O=i(`
            A list of `),I(x.$$.fragment),F=i(" to the "),I(V.$$.fragment),q=i(" describing the "),I(k.$$.fragment),N=i(` that expose resources to the shader. Ownerships needs to be transferred
            using `),I(Q.$$.fragment),X=i("."),Z=j(),K=d("li"),W=d("code"),U=i("upDescriptorPool"),G=d("br"),te=i(`
            A `),I(ee.$$.fragment),ne=i(" to a "),I(le.$$.fragment),ae=i(` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),I(J.$$.fragment),ue=i("."),De=j(),this.h()},l(me){e=g(me,"DIV",{slot:!0});var Ce=E(e);t=g(Ce,"LI",{});var _e=E(t);r=g(_e,"CODE",{});var se=E(r);$=f(se,"pLogicalDevice"),se.forEach(l),n=g(_e,"BR",{}),s=f(_e,`
            A pointer to the `),S(a.$$.fragment,_e),u=f(_e," that owns the Shader Module."),_e.forEach(l),p=Y(Ce),m=g(Ce,"LI",{});var ie=E(m);_=g(ie,"CODE",{});var ge=E(_);v=f(ge,"code"),ge.forEach(l),R=g(ie,"BR",{}),P=f(ie,`
            The SPIR-V code.`),ie.forEach(l),A=Y(Ce),T=g(Ce,"LI",{});var we=E(T);y=g(we,"CODE",{});var Re=E(y);B=f(Re,"upDescriptorSetLayouts"),Re.forEach(l),M=g(we,"BR",{}),O=f(we,`
            A list of `),S(x.$$.fragment,we),F=f(we," to the "),S(V.$$.fragment,we),q=f(we," describing the "),S(k.$$.fragment,we),N=f(we,` that expose resources to the shader. Ownerships needs to be transferred
            using `),S(Q.$$.fragment,we),X=f(we,"."),we.forEach(l),Z=Y(Ce),K=g(Ce,"LI",{});var Be=E(K);W=g(Be,"CODE",{});var Ie=E(W);U=f(Ie,"upDescriptorPool"),Ie.forEach(l),G=g(Be,"BR",{}),te=f(Be,`
            A `),S(ee.$$.fragment,Be),ne=f(Be," to a "),S(le.$$.fragment,Be),ae=f(Be,` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),S(J.$$.fragment,Be),ue=f(Be,"."),Be.forEach(l),De=Y(Ce),Ce.forEach(l),this.h()},h(){z(e,"slot","params")},m(me,Ce){h(me,e,Ce),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),D(V,T,null),o(T,q),D(k,T,null),o(T,N),D(Q,T,null),o(T,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),D(ee,K,null),o(K,ne),D(le,K,null),o(K,ae),D(J,K,null),o(K,ue),o(e,De),de=!0},p(me,Ce){const _e={};Ce&1&&(_e.$$scope={dirty:Ce,ctx:me}),a.$set(_e);const se={};Ce&1&&(se.$$scope={dirty:Ce,ctx:me}),x.$set(se);const ie={};Ce&1&&(ie.$$scope={dirty:Ce,ctx:me}),V.$set(ie);const ge={};Ce&1&&(ge.$$scope={dirty:Ce,ctx:me}),k.$set(ge);const we={};Ce&1&&(we.$$scope={dirty:Ce,ctx:me}),Q.$set(we);const Re={};Ce&1&&(Re.$$scope={dirty:Ce,ctx:me}),ee.$set(Re);const Be={};Ce&1&&(Be.$$scope={dirty:Ce,ctx:me}),le.$set(Be);const Ie={};Ce&1&&(Ie.$$scope={dirty:Ce,ctx:me}),J.$set(Ie)},i(me){de||(b(a.$$.fragment,me),b(x.$$.fragment,me),b(V.$$.fragment,me),b(k.$$.fragment,me),b(Q.$$.fragment,me),b(ee.$$.fragment,me),b(le.$$.fragment,me),b(J.$$.fragment,me),de=!0)},o(me){w(a.$$.fragment,me),w(x.$$.fragment,me),w(V.$$.fragment,me),w(k.$$.fragment,me),w(Q.$$.fragment,me),w(ee.$$.fragment,me),w(le.$$.fragment,me),w(J.$$.fragment,me),de=!1},d(me){me&&l(e),C(a),C(x),C(V),C(k),C(Q),C(ee),C(le),C(J)}}}function PM(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BM(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[PM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function LM(c){let e;return{c(){e=i("createShaderModule")},l(t){e=f(t,"createShaderModule")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kM(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.FILLCAN_createShaderModule,$$slots:{default:[LM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Shader Module."),r=d("br"),$=i(`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Shader Module."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function TM(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OM(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VM(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MM(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function FM(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xM(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NM(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function UM(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[TM]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[OM]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[VM]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[yM]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[MM]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[FM]},$$scope:{ctx:c}}}),le=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[xM]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[NM]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Shader Module."),p=j(),m=d("li"),_=d("code"),v=i("code"),R=d("br"),P=i(`
            The SPIR-V code.`),A=j(),T=d("li"),y=d("code"),B=i("upDescriptorSetLayouts"),M=d("br"),O=i(`
            A list of `),I(x.$$.fragment),F=i(" to the "),I(V.$$.fragment),q=i(" describing the "),I(k.$$.fragment),N=i(` that expose resources to the shader. Ownerships needs to be transferred
            using `),I(Q.$$.fragment),X=i("."),Z=j(),K=d("li"),W=d("code"),U=i("upDescriptorPool"),G=d("br"),te=i(`
            A `),I(ee.$$.fragment),ne=i(" to a "),I(le.$$.fragment),ae=i(` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),I(J.$$.fragment),ue=i("."),this.h()},l(de){e=g(de,"DIV",{slot:!0});var me=E(e);t=g(me,"LI",{});var Ce=E(t);r=g(Ce,"CODE",{});var _e=E(r);$=f(_e,"pLogicalDevice"),_e.forEach(l),n=g(Ce,"BR",{}),s=f(Ce,`
            A pointer to the `),S(a.$$.fragment,Ce),u=f(Ce," that owns the Shader Module."),Ce.forEach(l),p=Y(me),m=g(me,"LI",{});var se=E(m);_=g(se,"CODE",{});var ie=E(_);v=f(ie,"code"),ie.forEach(l),R=g(se,"BR",{}),P=f(se,`
            The SPIR-V code.`),se.forEach(l),A=Y(me),T=g(me,"LI",{});var ge=E(T);y=g(ge,"CODE",{});var we=E(y);B=f(we,"upDescriptorSetLayouts"),we.forEach(l),M=g(ge,"BR",{}),O=f(ge,`
            A list of `),S(x.$$.fragment,ge),F=f(ge," to the "),S(V.$$.fragment,ge),q=f(ge," describing the "),S(k.$$.fragment,ge),N=f(ge,` that expose resources to the shader. Ownerships needs to be transferred
            using `),S(Q.$$.fragment,ge),X=f(ge,"."),ge.forEach(l),Z=Y(me),K=g(me,"LI",{});var Re=E(K);W=g(Re,"CODE",{});var Be=E(W);U=f(Be,"upDescriptorPool"),Be.forEach(l),G=g(Re,"BR",{}),te=f(Re,`
            A `),S(ee.$$.fragment,Re),ne=f(Re," to a "),S(le.$$.fragment,Re),ae=f(Re,` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),S(J.$$.fragment,Re),ue=f(Re,"."),Re.forEach(l),me.forEach(l),this.h()},h(){z(e,"slot","params")},m(de,me){h(de,e,me),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),D(V,T,null),o(T,q),D(k,T,null),o(T,N),D(Q,T,null),o(T,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),D(ee,K,null),o(K,ne),D(le,K,null),o(K,ae),D(J,K,null),o(K,ue),De=!0},p(de,me){const Ce={};me&1&&(Ce.$$scope={dirty:me,ctx:de}),a.$set(Ce);const _e={};me&1&&(_e.$$scope={dirty:me,ctx:de}),x.$set(_e);const se={};me&1&&(se.$$scope={dirty:me,ctx:de}),V.$set(se);const ie={};me&1&&(ie.$$scope={dirty:me,ctx:de}),k.$set(ie);const ge={};me&1&&(ge.$$scope={dirty:me,ctx:de}),Q.$set(ge);const we={};me&1&&(we.$$scope={dirty:me,ctx:de}),ee.$set(we);const Re={};me&1&&(Re.$$scope={dirty:me,ctx:de}),le.$set(Re);const Be={};me&1&&(Be.$$scope={dirty:me,ctx:de}),J.$set(Be)},i(de){De||(b(a.$$.fragment,de),b(x.$$.fragment,de),b(V.$$.fragment,de),b(k.$$.fragment,de),b(Q.$$.fragment,de),b(ee.$$.fragment,de),b(le.$$.fragment,de),b(J.$$.fragment,de),De=!0)},o(de){w(a.$$.fragment,de),w(x.$$.fragment,de),w(V.$$.fragment,de),w(k.$$.fragment,de),w(Q.$$.fragment,de),w(ee.$$.fragment,de),w(le.$$.fragment,de),w(J.$$.fragment,de),De=!1},d(de){de&&l(e),C(a),C(x),C(V),C(k),C(Q),C(ee),C(le),C(J)}}}function GM(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HM(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[GM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function qM(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:`ShaderModule(
    LogicalDevice* pLogicalDevice, 
    std::vector<char>& code, 
    std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
    std::unique_ptr<DescriptorPool> upDescriptorPool
);`}}),r=new Se({props:{$$slots:{throws:[BM],params:[AM],details:[vM]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`ShaderModule(
    LogicalDevice* pLogicalDevice, 
    std::vector<uint32_t>& code, 
    std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
    std::unique_ptr<DescriptorPool> upDescriptorPool
);`}}),u=new Se({props:{$$slots:{throws:[HM],params:[UM],details:[kM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class WM extends ve{constructor(e){super(),Ee(this,e,null,qM,be,{})}}function QM(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KM(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[QM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zM(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jM(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[zM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function YM(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkShaderModule getShaderModuleHandle() const;"}}),r=new Se({props:{$$slots:{return:[jM],details:[KM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class XM extends ve{constructor(e){super(),Ee(this,e,null,YM,be,{})}}function ZM(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JM(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[ZM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function eF(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tF(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[eF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<DescriptorSetLayout*> getDescriptorSetLayouts();"}}),r=new Se({props:{$$slots:{return:[tF],details:[JM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nF extends ve{constructor(e){super(),Ee(this,e,null,rF,be,{})}}function sF(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aF(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[sF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function oF(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lF(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[oF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function iF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorPool* getDescriptorPool();"}}),r=new Se({props:{$$slots:{return:[lF],details:[aF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fF extends ve{constructor(e){super(),Ee(this,e,null,iF,be,{})}}function cF(c){return{name:"GLSL",keywords:{keyword:"break continue discard do else for if return while switch case default attribute binding buffer ccw centroid centroid varying coherent column_major const cw depth_any depth_greater depth_less depth_unchanged early_fragment_tests equal_spacing flat fractional_even_spacing fractional_odd_spacing highp in index inout invariant invocations isolines layout line_strip lines lines_adjacency local_size_x local_size_y local_size_z location lowp max_vertices mediump noperspective offset origin_upper_left out packed patch pixel_center_integer point_mode points precise precision quads r11f_g11f_b10f r16 r16_snorm r16f r16i r16ui r32f r32i r32ui r8 r8_snorm r8i r8ui readonly restrict rg16 rg16_snorm rg16f rg16i rg16ui rg32f rg32i rg32ui rg8 rg8_snorm rg8i rg8ui rgb10_a2 rgb10_a2ui rgba16 rgba16_snorm rgba16f rgba16i rgba16ui rgba32f rgba32i rgba32ui rgba8 rgba8_snorm rgba8i rgba8ui row_major sample shared smooth std140 std430 stream triangle_strip triangles triangles_adjacency uniform varying vertices volatile writeonly",type:"atomic_uint bool bvec2 bvec3 bvec4 dmat2 dmat2x2 dmat2x3 dmat2x4 dmat3 dmat3x2 dmat3x3 dmat3x4 dmat4 dmat4x2 dmat4x3 dmat4x4 double dvec2 dvec3 dvec4 float iimage1D iimage1DArray iimage2D iimage2DArray iimage2DMS iimage2DMSArray iimage2DRect iimage3D iimageBuffer iimageCube iimageCubeArray image1D image1DArray image2D image2DArray image2DMS image2DMSArray image2DRect image3D imageBuffer imageCube imageCubeArray int isampler1D isampler1DArray isampler2D isampler2DArray isampler2DMS isampler2DMSArray isampler2DRect isampler3D isamplerBuffer isamplerCube isamplerCubeArray ivec2 ivec3 ivec4 mat2 mat2x2 mat2x3 mat2x4 mat3 mat3x2 mat3x3 mat3x4 mat4 mat4x2 mat4x3 mat4x4 sampler1D sampler1DArray sampler1DArrayShadow sampler1DShadow sampler2D sampler2DArray sampler2DArrayShadow sampler2DMS sampler2DMSArray sampler2DRect sampler2DRectShadow sampler2DShadow sampler3D samplerBuffer samplerCube samplerCubeArray samplerCubeArrayShadow samplerCubeShadow image1D uimage1DArray uimage2D uimage2DArray uimage2DMS uimage2DMSArray uimage2DRect uimage3D uimageBuffer uimageCube uimageCubeArray uint usampler1D usampler1DArray usampler2D usampler2DArray usampler2DMS usampler2DMSArray usampler2DRect usampler3D samplerBuffer usamplerCube usamplerCubeArray uvec2 uvec3 uvec4 vec2 vec3 vec4 void",built_in:"gl_MaxAtomicCounterBindings gl_MaxAtomicCounterBufferSize gl_MaxClipDistances gl_MaxClipPlanes gl_MaxCombinedAtomicCounterBuffers gl_MaxCombinedAtomicCounters gl_MaxCombinedImageUniforms gl_MaxCombinedImageUnitsAndFragmentOutputs gl_MaxCombinedTextureImageUnits gl_MaxComputeAtomicCounterBuffers gl_MaxComputeAtomicCounters gl_MaxComputeImageUniforms gl_MaxComputeTextureImageUnits gl_MaxComputeUniformComponents gl_MaxComputeWorkGroupCount gl_MaxComputeWorkGroupSize gl_MaxDrawBuffers gl_MaxFragmentAtomicCounterBuffers gl_MaxFragmentAtomicCounters gl_MaxFragmentImageUniforms gl_MaxFragmentInputComponents gl_MaxFragmentInputVectors gl_MaxFragmentUniformComponents gl_MaxFragmentUniformVectors gl_MaxGeometryAtomicCounterBuffers gl_MaxGeometryAtomicCounters gl_MaxGeometryImageUniforms gl_MaxGeometryInputComponents gl_MaxGeometryOutputComponents gl_MaxGeometryOutputVertices gl_MaxGeometryTextureImageUnits gl_MaxGeometryTotalOutputComponents gl_MaxGeometryUniformComponents gl_MaxGeometryVaryingComponents gl_MaxImageSamples gl_MaxImageUnits gl_MaxLights gl_MaxPatchVertices gl_MaxProgramTexelOffset gl_MaxTessControlAtomicCounterBuffers gl_MaxTessControlAtomicCounters gl_MaxTessControlImageUniforms gl_MaxTessControlInputComponents gl_MaxTessControlOutputComponents gl_MaxTessControlTextureImageUnits gl_MaxTessControlTotalOutputComponents gl_MaxTessControlUniformComponents gl_MaxTessEvaluationAtomicCounterBuffers gl_MaxTessEvaluationAtomicCounters gl_MaxTessEvaluationImageUniforms gl_MaxTessEvaluationInputComponents gl_MaxTessEvaluationOutputComponents gl_MaxTessEvaluationTextureImageUnits gl_MaxTessEvaluationUniformComponents gl_MaxTessGenLevel gl_MaxTessPatchComponents gl_MaxTextureCoords gl_MaxTextureImageUnits gl_MaxTextureUnits gl_MaxVaryingComponents gl_MaxVaryingFloats gl_MaxVaryingVectors gl_MaxVertexAtomicCounterBuffers gl_MaxVertexAtomicCounters gl_MaxVertexAttribs gl_MaxVertexImageUniforms gl_MaxVertexOutputComponents gl_MaxVertexOutputVectors gl_MaxVertexTextureImageUnits gl_MaxVertexUniformComponents gl_MaxVertexUniformVectors gl_MaxViewports gl_MinProgramTexelOffset gl_BackColor gl_BackLightModelProduct gl_BackLightProduct gl_BackMaterial gl_BackSecondaryColor gl_ClipDistance gl_ClipPlane gl_ClipVertex gl_Color gl_DepthRange gl_EyePlaneQ gl_EyePlaneR gl_EyePlaneS gl_EyePlaneT gl_Fog gl_FogCoord gl_FogFragCoord gl_FragColor gl_FragCoord gl_FragData gl_FragDepth gl_FrontColor gl_FrontFacing gl_FrontLightModelProduct gl_FrontLightProduct gl_FrontMaterial gl_FrontSecondaryColor gl_GlobalInvocationID gl_InstanceID gl_InvocationID gl_Layer gl_LightModel gl_LightSource gl_LocalInvocationID gl_LocalInvocationIndex gl_ModelViewMatrix gl_ModelViewMatrixInverse gl_ModelViewMatrixInverseTranspose gl_ModelViewMatrixTranspose gl_ModelViewProjectionMatrix gl_ModelViewProjectionMatrixInverse gl_ModelViewProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixTranspose gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_Normal gl_NormalMatrix gl_NormalScale gl_NumSamples gl_NumWorkGroups gl_ObjectPlaneQ gl_ObjectPlaneR gl_ObjectPlaneS gl_ObjectPlaneT gl_PatchVerticesIn gl_Point gl_PointCoord gl_PointSize gl_Position gl_PrimitiveID gl_PrimitiveIDIn gl_ProjectionMatrix gl_ProjectionMatrixInverse gl_ProjectionMatrixInverseTranspose gl_ProjectionMatrixTranspose gl_SampleID gl_SampleMask gl_SampleMaskIn gl_SamplePosition gl_SecondaryColor gl_TessCoord gl_TessLevelInner gl_TessLevelOuter gl_TexCoord gl_TextureEnvColor gl_TextureMatrix gl_TextureMatrixInverse gl_TextureMatrixInverseTranspose gl_TextureMatrixTranspose gl_Vertex gl_VertexID gl_ViewportIndex gl_WorkGroupID gl_WorkGroupSize gl_in gl_out EmitStreamVertex EmitVertex EndPrimitive EndStreamPrimitive abs acos acosh all any asin asinh atan atanh atomicAdd atomicAnd atomicCompSwap atomicCounter atomicCounterDecrement atomicCounterIncrement atomicExchange atomicMax atomicMin atomicOr atomicXor barrier bitCount bitfieldExtract bitfieldInsert bitfieldReverse ceil clamp cos cosh cross dFdx dFdy degrees determinant distance dot equal exp exp2 faceforward findLSB findMSB floatBitsToInt floatBitsToUint floor fma fract frexp ftransform fwidth greaterThan greaterThanEqual groupMemoryBarrier imageAtomicAdd imageAtomicAnd imageAtomicCompSwap imageAtomicExchange imageAtomicMax imageAtomicMin imageAtomicOr imageAtomicXor imageLoad imageSize imageStore imulExtended intBitsToFloat interpolateAtCentroid interpolateAtOffset interpolateAtSample inverse inversesqrt isinf isnan ldexp length lessThan lessThanEqual log log2 matrixCompMult max memoryBarrier memoryBarrierAtomicCounter memoryBarrierBuffer memoryBarrierImage memoryBarrierShared min mix mod modf noise1 noise2 noise3 noise4 normalize not notEqual outerProduct packDouble2x32 packHalf2x16 packSnorm2x16 packSnorm4x8 packUnorm2x16 packUnorm4x8 pow radians reflect refract round roundEven shadow1D shadow1DLod shadow1DProj shadow1DProjLod shadow2D shadow2DLod shadow2DProj shadow2DProjLod sign sin sinh smoothstep sqrt step tan tanh texelFetch texelFetchOffset texture texture1D texture1DLod texture1DProj texture1DProjLod texture2D texture2DLod texture2DProj texture2DProjLod texture3D texture3DLod texture3DProj texture3DProjLod textureCube textureCubeLod textureGather textureGatherOffset textureGatherOffsets textureGrad textureGradOffset textureLod textureLodOffset textureOffset textureProj textureProjGrad textureProjGradOffset textureProjLod textureProjLodOffset textureProjOffset textureQueryLevels textureQueryLod textureSize transpose trunc uaddCarry uintBitsToFloat umulExtended unpackDouble2x32 unpackHalf2x16 unpackSnorm2x16 unpackSnorm4x8 unpackUnorm2x16 unpackUnorm4x8 usubBorrow",literal:"true false"},illegal:'"',contains:[c.C_LINE_COMMENT_MODE,c.C_BLOCK_COMMENT_MODE,c.C_NUMBER_MODE,{className:"meta",begin:"#",end:"$"}]}}const $F={name:"glsl",register:cF};var hn=$F;function uF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout Bindings")},l(t){e=f(t,"Vulkan Descriptor Set Layout Bindings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hF(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dF(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gF(c){let e;return{c(){e=i("texelFetch")},l(t){e=f(t,"texelFetch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _F(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vF(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EF(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,yt,mt,Ot,Pt,Tt,vt,gt,kt,Ft,Mt,Ht,$r,Ut,or,Xt,Vt,Zt,Ar,br,ur,Qt,Vr,rr,Kr,lr,gr,yr,Kt,ir,Mr;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/descriptor_set_layout.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[uF]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[pF]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[mF]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.BUFFER,$$slots:{default:[hF]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.BUFFER,$$slots:{default:[dF]},$$scope:{ctx:c}}}),W=new $e({props:{language:hn,code:`#version 450 core

layout (set = 0, binding = 1) uniform UniformBlock
{
    float float_value;
    vec4 vec4_value;
} uniform_buffer;

layout (set = 0, binding = 2) buffer StorageBlock
{
    float float_value;
    vec4 vec4_value
} storage_buffer;
`}}),te=new $e({props:{language:hn,code:`storage_qualifier block_name
{
    <define members here>
} instance_name;
`}}),ct=new $e({props:{language:hn,code:`// With interface name
uniform MatrixBlock
{
    mat4 projection;
    mat4 modelView;
} matrices;
// To access projection, use matrices.projection

uniform vec3 modelView; // Allowed
`}}),Qe=new $e({props:{language:hn,code:`// Without interface name
uniform MatrixBlock
{
    mat4 projection;
    mat4 modelView;
};
// To access projection, use projection

uniform vec3 modelView; // Redefining variable. Compile error.
`}}),ot=new $e({props:{language:hn,code:`layout (set = 0, binding = 3) uniform samplerBuffer floatTexelBuffer;
layout (set = 0, binding = 4) uniform isamplerBuffer signedTexelBuffer;
layout (set = 0, binding = 5) uniform usamplerBuffer unsignedTexelBuffer;
`}}),it=new fe({props:{href:"https://registry.khronos.org/OpenGL-Refpages/gl4/html/texelFetch.xhtml",target:"_blank",$$slots:{default:[gF]},$$scope:{ctx:c}}}),br=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[_F]},$$scope:{ctx:c}}}),gr=new $e({props:{language:hn,code:`layout (push_constant) uniform block_name 
{
    <define members here>
} interface_name;

// Example
layout (push_constant) uniform PushConstant 
{
    int var1;
    vec3 var2;
    mat4 var3;
} push_constant;
`}}),Kt=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[vF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Descriptor Set Layout"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along a list of "),I(u.$$.fragment),p=i(" and uses this information to construct a "),I(m.$$.fragment),_=i("."),v=d("br"),R=i(`

The shaders in the application consume and produce data in two ways. The first
is by interacting with fixed function hardware and the second is by directly
reading and writing resources. Shaders can access the contents of the buffer
memory directly from three types of sources:
`),P=d("ul"),A=d("li"),T=i(`Uniform blocks provide quick access to constant (read-only) data stored
        in `),I(y.$$.fragment),B=i(` objects. They
        are declared as if they were structures in a shader and are mapped to memory
        using a buffer resource bound to the descriptor set.`),M=j(),O=d("li"),x=i("Storage blocks provide read-write access to "),I(F.$$.fragment),V=i(` objects. Declared in the same way as uniform blocks, data is arranged as
        if it were a structure, but can be written to. Shader storage blocks also
        support atomic operations.`),q=j(),k=d("li"),N=i(`Texel buffers provide access to long, linear arrays of formatted Texel
        data. They are read-only and a texel buffer binding performs format
        conversion from the underlying data format to the floating-point
        representation that the shader expects when the buffer is read.`),Q=i(`
The type of resource used depends on how it is to be accessed. The maximum size of
a uniform block is often limited, while access to it is generally very fast. On the
other hand, the maximum size of a shader storage block is very large, but in some
implementations access to it can be slower, especially if writes are enabled. For
accessing large arrays of formatted data, a texel buffer is probably the best choice.`),X=d("br"),Z=d("br"),K=i(`
To declare a uniform block in GLSL, the uniform keyword is used. A shader storage
block is declared in the same way, except that the uniform keyword is omitted and
the buffer keyword is used instead.
`),I(W.$$.fragment),U=d("br"),G=i(`
An interface block has the following definition. although it looks like a structure
definition, it is not:
`),I(te.$$.fragment),ee=i(`
The storage qualifier (`),ne=d("code"),le=i("storage_qualifier"),ae=i(`) defines what kind of
interface block is created. `),J=d("code"),ue=i("storage_qualifier"),De=i(` can be the following:
`),de=d("ul"),me=d("li"),Ce=d("code"),_e=i("uniform"),se=i(`. A uniform is a global shader variable declared
        with the storage qualifier uniform. They are so named because they do
        not change from one shader call to the next within a given rendering
        call, so their value is uniform among all calls`),ie=j(),ge=d("li"),we=d("code"),Re=i("in"),Be=i(`. Global variables declared with the
        `),Ie=d("code"),re=i("in"),he=i(`-qualifier are input variables of the shader stage. These
        variables are given values by the previous stage. These variables are
        not constant (in the sense of `),Ae=d("code"),Ve=i("const"),oe=i(`), but cannot be changed
        by user code.`),ce=j(),Pe=d("li"),Fe=d("code"),ke=i("out"),Te=i(`. Global variables declared with the
        `),Me=d("code"),Ue=i("out"),qe=i(`-qualifier are shader stage output variables. These
        values are passed to the next stage of the pipeline. The shader must set
        all output variables at some point during execution; there are only two
        exceptions to this:
        `),xe=d("ol"),Ge=d("li"),ye=i("The shader is a Fragment Shader that executes the "),We=d("code"),ze=i("discard"),Ye=i(`
                statement.`),rt=j(),Ne=d("li"),He=i(`The output variables that are not written are not read by the
                next shader stage or pipeline process. This includes writes to
                fragment shader outputs that are masked.`),$t=j(),ut=d("li"),ht=d("code"),Je=i("buffer"),dt=i(`. The storage for the contents of the block comes
        from a buffer object, similar to Uniform Buffer Objects and Uniform
        Blocks. Unlike UBOs, storage blocks can be written to.`),et=j(),Ze=d("code"),nt=i("block_name"),Ke=i(` is the real name for the interface block. This is the
name used to refer to it. A shader cannot have multiple blocks that have the
same block_name and the same storage_qualifier. instance_name is a GLSL name for
one or more instances of the block named block_name. It's optional; if it is
present, all GLSL variables defined in the block must be qualified with the
instance name when referenced in the GLSL code.
`),I(ct.$$.fragment),st=j(),I(Qe.$$.fragment),at=d("br"),bt=i(`
A texel buffer is a special type of buffer binding used in a shader that can perform
format conversion when the data is read. Texel buffers are read-only and are declared
in GLSL using a `),wt=d("code"),St=i("samplerBuffer"),tt=i(`-type variable. Sampler buffers can
return floating-point data or integers (signed or unsigned) to the shader.

`),I(ot.$$.fragment),At=i(`
To fetch a texel from a texelbuffer in GLSL, the `),I(it.$$.fragment),Xe=i(" function is used with the sampler variable ("),Dt=d("code"),Ct=i("floatTexelBuffer"),pt=i(`,
`),yt=d("code"),mt=i("signedTexelBuffer"),Ot=i(`
or `),Pt=d("code"),Tt=i("unsignedTexelBuffer"),vt=i(`) to read individual texels. A
`),gt=d("code"),kt=i("samplerBuffer"),Ft=i(`
(or the corresponding `),Mt=d("code"),Ht=i("isamplerBuffer"),$r=i(` and
`),Ut=d("code"),or=i("usamplerBuffer"),Xt=i(`) can be seen as a 1D texture that only supports
point sampling (because only one texel can be queried). However, the maximum
size of a texel buffer associated with one of these variables is generally much
larger than the maximum size of a 1D structure. For example, the minimum
required upper bound for a texel buffer in Vulkan is 65,535 elements, while the
minimum required size for a 1D texture is only 4,096 texels. In some cases
implementations will support texel buffers that are gigabytes in size.`),Vt=d("br"),Zt=d("br"),Ar=i(`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants are logically
considered part of the pipeline's resources and therefore are declared along with
the other resources in the `),I(br.$$.fragment),ur=i(" used to create pipeline objects."),Qt=d("br"),Vr=i(`
To declare a push constant in GLSL, the `),rr=d("code"),Kr=i("push_constant"),lr=i(` layout
qualifier can be used.
`),I(gr.$$.fragment),yr=i(`
Push constants become part of the `),I(Kt.$$.fragment),ir=i(` that will use them. When push constants are pipelined, they can consume some of
the resources Vulkan would otherwise use to track pipeline or descriptor bindings.
Therefore, push constants should be considered relatively precious resources.`)},l(Le){S(e.$$.fragment,Le),t=f(Le,`

The `),r=g(Le,"CODE",{});var lt=E(r);$=f(lt,"Descriptor Set Layout"),lt.forEach(l),n=f(Le," class takes a pointer to a "),S(s.$$.fragment,Le),a=f(Le," along a list of "),S(u.$$.fragment,Le),p=f(Le," and uses this information to construct a "),S(m.$$.fragment,Le),_=f(Le,"."),v=g(Le,"BR",{}),R=f(Le,`

The shaders in the application consume and produce data in two ways. The first
is by interacting with fixed function hardware and the second is by directly
reading and writing resources. Shaders can access the contents of the buffer
memory directly from three types of sources:
`),P=g(Le,"UL",{});var Jt=E(P);A=g(Jt,"LI",{});var _r=E(A);T=f(_r,`Uniform blocks provide quick access to constant (read-only) data stored
        in `),S(y.$$.fragment,_r),B=f(_r,` objects. They
        are declared as if they were structures in a shader and are mapped to memory
        using a buffer resource bound to the descriptor set.`),_r.forEach(l),M=Y(Jt),O=g(Jt,"LI",{});var jt=E(O);x=f(jt,"Storage blocks provide read-write access to "),S(F.$$.fragment,jt),V=f(jt,` objects. Declared in the same way as uniform blocks, data is arranged as
        if it were a structure, but can be written to. Shader storage blocks also
        support atomic operations.`),jt.forEach(l),q=Y(Jt),k=g(Jt,"LI",{});var nr=E(k);N=f(nr,`Texel buffers provide access to long, linear arrays of formatted Texel
        data. They are read-only and a texel buffer binding performs format
        conversion from the underlying data format to the floating-point
        representation that the shader expects when the buffer is read.`),nr.forEach(l),Jt.forEach(l),Q=f(Le,`
The type of resource used depends on how it is to be accessed. The maximum size of
a uniform block is often limited, while access to it is generally very fast. On the
other hand, the maximum size of a shader storage block is very large, but in some
implementations access to it can be slower, especially if writes are enabled. For
accessing large arrays of formatted data, a texel buffer is probably the best choice.`),X=g(Le,"BR",{}),Z=g(Le,"BR",{}),K=f(Le,`
To declare a uniform block in GLSL, the uniform keyword is used. A shader storage
block is declared in the same way, except that the uniform keyword is omitted and
the buffer keyword is used instead.
`),S(W.$$.fragment,Le),U=g(Le,"BR",{}),G=f(Le,`
An interface block has the following definition. although it looks like a structure
definition, it is not:
`),S(te.$$.fragment,Le),ee=f(Le,`
The storage qualifier (`),ne=g(Le,"CODE",{});var vr=E(ne);le=f(vr,"storage_qualifier"),vr.forEach(l),ae=f(Le,`) defines what kind of
interface block is created. `),J=g(Le,"CODE",{});var Tr=E(J);ue=f(Tr,"storage_qualifier"),Tr.forEach(l),De=f(Le,` can be the following:
`),de=g(Le,"UL",{});var fr=E(de);me=g(fr,"LI",{});var cr=E(me);Ce=g(cr,"CODE",{});var sr=E(Ce);_e=f(sr,"uniform"),sr.forEach(l),se=f(cr,`. A uniform is a global shader variable declared
        with the storage qualifier uniform. They are so named because they do
        not change from one shader call to the next within a given rendering
        call, so their value is uniform among all calls`),cr.forEach(l),ie=Y(fr),ge=g(fr,"LI",{});var er=E(ge);we=g(er,"CODE",{});var zr=E(we);Re=f(zr,"in"),zr.forEach(l),Be=f(er,`. Global variables declared with the
        `),Ie=g(er,"CODE",{});var _t=E(Ie);re=f(_t,"in"),_t.forEach(l),he=f(er,`-qualifier are input variables of the shader stage. These
        variables are given values by the previous stage. These variables are
        not constant (in the sense of `),Ae=g(er,"CODE",{});var ft=E(Ae);Ve=f(ft,"const"),ft.forEach(l),oe=f(er,`), but cannot be changed
        by user code.`),er.forEach(l),ce=Y(fr),Pe=g(fr,"LI",{});var qt=E(Pe);Fe=g(qt,"CODE",{});var Fr=E(Fe);ke=f(Fr,"out"),Fr.forEach(l),Te=f(qt,`. Global variables declared with the
        `),Me=g(qt,"CODE",{});var wr=E(Me);Ue=f(wr,"out"),wr.forEach(l),qe=f(qt,`-qualifier are shader stage output variables. These
        values are passed to the next stage of the pipeline. The shader must set
        all output variables at some point during execution; there are only two
        exceptions to this:
        `),xe=g(qt,"OL",{});var Nt=E(xe);Ge=g(Nt,"LI",{});var Wt=E(Ge);ye=f(Wt,"The shader is a Fragment Shader that executes the "),We=g(Wt,"CODE",{});var xr=E(We);ze=f(xr,"discard"),xr.forEach(l),Ye=f(Wt,`
                statement.`),Wt.forEach(l),rt=Y(Nt),Ne=g(Nt,"LI",{});var pr=E(Ne);He=f(pr,`The output variables that are not written are not read by the
                next shader stage or pipeline process. This includes writes to
                fragment shader outputs that are masked.`),pr.forEach(l),Nt.forEach(l),qt.forEach(l),$t=Y(fr),ut=g(fr,"LI",{});var Or=E(ut);ht=g(Or,"CODE",{});var Yt=E(ht);Je=f(Yt,"buffer"),Yt.forEach(l),dt=f(Or,`. The storage for the contents of the block comes
        from a buffer object, similar to Uniform Buffer Objects and Uniform
        Blocks. Unlike UBOs, storage blocks can be written to.`),Or.forEach(l),fr.forEach(l),et=Y(Le),Ze=g(Le,"CODE",{});var Pr=E(Ze);nt=f(Pr,"block_name"),Pr.forEach(l),Ke=f(Le,` is the real name for the interface block. This is the
name used to refer to it. A shader cannot have multiple blocks that have the
same block_name and the same storage_qualifier. instance_name is a GLSL name for
one or more instances of the block named block_name. It's optional; if it is
present, all GLSL variables defined in the block must be qualified with the
instance name when referenced in the GLSL code.
`),S(ct.$$.fragment,Le),st=Y(Le),S(Qe.$$.fragment,Le),at=g(Le,"BR",{}),bt=f(Le,`
A texel buffer is a special type of buffer binding used in a shader that can perform
format conversion when the data is read. Texel buffers are read-only and are declared
in GLSL using a `),wt=g(Le,"CODE",{});var Ir=E(wt);St=f(Ir,"samplerBuffer"),Ir.forEach(l),tt=f(Le,`-type variable. Sampler buffers can
return floating-point data or integers (signed or unsigned) to the shader.

`),S(ot.$$.fragment,Le),At=f(Le,`
To fetch a texel from a texelbuffer in GLSL, the `),S(it.$$.fragment,Le),Xe=f(Le," function is used with the sampler variable ("),Dt=g(Le,"CODE",{});var Nr=E(Dt);Ct=f(Nr,"floatTexelBuffer"),Nr.forEach(l),pt=f(Le,`,
`),yt=g(Le,"CODE",{});var mr=E(yt);mt=f(mr,"signedTexelBuffer"),mr.forEach(l),Ot=f(Le,`
or `),Pt=g(Le,"CODE",{});var Dr=E(Pt);Tt=f(Dr,"unsignedTexelBuffer"),Dr.forEach(l),vt=f(Le,`) to read individual texels. A
`),gt=g(Le,"CODE",{});var hr=E(gt);kt=f(hr,"samplerBuffer"),hr.forEach(l),Ft=f(Le,`
(or the corresponding `),Mt=g(Le,"CODE",{});var Br=E(Mt);Ht=f(Br,"isamplerBuffer"),Br.forEach(l),$r=f(Le,` and
`),Ut=g(Le,"CODE",{});var Cr=E(Ut);or=f(Cr,"usamplerBuffer"),Cr.forEach(l),Xt=f(Le,`) can be seen as a 1D texture that only supports
point sampling (because only one texel can be queried). However, the maximum
size of a texel buffer associated with one of these variables is generally much
larger than the maximum size of a 1D structure. For example, the minimum
required upper bound for a texel buffer in Vulkan is 65,535 elements, while the
minimum required size for a 1D texture is only 4,096 texels. In some cases
implementations will support texel buffers that are gigabytes in size.`),Vt=g(Le,"BR",{}),Zt=g(Le,"BR",{}),Ar=f(Le,`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants are logically
considered part of the pipeline's resources and therefore are declared along with
the other resources in the `),S(br.$$.fragment,Le),ur=f(Le," used to create pipeline objects."),Qt=g(Le,"BR",{}),Vr=f(Le,`
To declare a push constant in GLSL, the `),rr=g(Le,"CODE",{});var en=E(rr);Kr=f(en,"push_constant"),en.forEach(l),lr=f(Le,` layout
qualifier can be used.
`),S(gr.$$.fragment,Le),yr=f(Le,`
Push constants become part of the `),S(Kt.$$.fragment,Le),ir=f(Le,` that will use them. When push constants are pipelined, they can consume some of
the resources Vulkan would otherwise use to track pipeline or descriptor bindings.
Therefore, push constants should be considered relatively precious resources.`)},m(Le,lt){D(e,Le,lt),h(Le,t,lt),h(Le,r,lt),o(r,$),h(Le,n,lt),D(s,Le,lt),h(Le,a,lt),D(u,Le,lt),h(Le,p,lt),D(m,Le,lt),h(Le,_,lt),h(Le,v,lt),h(Le,R,lt),h(Le,P,lt),o(P,A),o(A,T),D(y,A,null),o(A,B),o(P,M),o(P,O),o(O,x),D(F,O,null),o(O,V),o(P,q),o(P,k),o(k,N),h(Le,Q,lt),h(Le,X,lt),h(Le,Z,lt),h(Le,K,lt),D(W,Le,lt),h(Le,U,lt),h(Le,G,lt),D(te,Le,lt),h(Le,ee,lt),h(Le,ne,lt),o(ne,le),h(Le,ae,lt),h(Le,J,lt),o(J,ue),h(Le,De,lt),h(Le,de,lt),o(de,me),o(me,Ce),o(Ce,_e),o(me,se),o(de,ie),o(de,ge),o(ge,we),o(we,Re),o(ge,Be),o(ge,Ie),o(Ie,re),o(ge,he),o(ge,Ae),o(Ae,Ve),o(ge,oe),o(de,ce),o(de,Pe),o(Pe,Fe),o(Fe,ke),o(Pe,Te),o(Pe,Me),o(Me,Ue),o(Pe,qe),o(Pe,xe),o(xe,Ge),o(Ge,ye),o(Ge,We),o(We,ze),o(Ge,Ye),o(xe,rt),o(xe,Ne),o(Ne,He),o(de,$t),o(de,ut),o(ut,ht),o(ht,Je),o(ut,dt),h(Le,et,lt),h(Le,Ze,lt),o(Ze,nt),h(Le,Ke,lt),D(ct,Le,lt),h(Le,st,lt),D(Qe,Le,lt),h(Le,at,lt),h(Le,bt,lt),h(Le,wt,lt),o(wt,St),h(Le,tt,lt),D(ot,Le,lt),h(Le,At,lt),D(it,Le,lt),h(Le,Xe,lt),h(Le,Dt,lt),o(Dt,Ct),h(Le,pt,lt),h(Le,yt,lt),o(yt,mt),h(Le,Ot,lt),h(Le,Pt,lt),o(Pt,Tt),h(Le,vt,lt),h(Le,gt,lt),o(gt,kt),h(Le,Ft,lt),h(Le,Mt,lt),o(Mt,Ht),h(Le,$r,lt),h(Le,Ut,lt),o(Ut,or),h(Le,Xt,lt),h(Le,Vt,lt),h(Le,Zt,lt),h(Le,Ar,lt),D(br,Le,lt),h(Le,ur,lt),h(Le,Qt,lt),h(Le,Vr,lt),h(Le,rr,lt),o(rr,Kr),h(Le,lr,lt),D(gr,Le,lt),h(Le,yr,lt),D(Kt,Le,lt),h(Le,ir,lt),Mr=!0},p(Le,[lt]){const Jt={};lt&1&&(Jt.$$scope={dirty:lt,ctx:Le}),s.$set(Jt);const _r={};lt&1&&(_r.$$scope={dirty:lt,ctx:Le}),u.$set(_r);const jt={};lt&1&&(jt.$$scope={dirty:lt,ctx:Le}),m.$set(jt);const nr={};lt&1&&(nr.$$scope={dirty:lt,ctx:Le}),y.$set(nr);const vr={};lt&1&&(vr.$$scope={dirty:lt,ctx:Le}),F.$set(vr);const Tr={};lt&1&&(Tr.$$scope={dirty:lt,ctx:Le}),it.$set(Tr);const fr={};lt&1&&(fr.$$scope={dirty:lt,ctx:Le}),br.$set(fr);const cr={};lt&1&&(cr.$$scope={dirty:lt,ctx:Le}),Kt.$set(cr)},i(Le){Mr||(b(e.$$.fragment,Le),b(s.$$.fragment,Le),b(u.$$.fragment,Le),b(m.$$.fragment,Le),b(y.$$.fragment,Le),b(F.$$.fragment,Le),b(W.$$.fragment,Le),b(te.$$.fragment,Le),b(ct.$$.fragment,Le),b(Qe.$$.fragment,Le),b(ot.$$.fragment,Le),b(it.$$.fragment,Le),b(br.$$.fragment,Le),b(gr.$$.fragment,Le),b(Kt.$$.fragment,Le),Mr=!0)},o(Le){w(e.$$.fragment,Le),w(s.$$.fragment,Le),w(u.$$.fragment,Le),w(m.$$.fragment,Le),w(y.$$.fragment,Le),w(F.$$.fragment,Le),w(W.$$.fragment,Le),w(te.$$.fragment,Le),w(ct.$$.fragment,Le),w(Qe.$$.fragment,Le),w(ot.$$.fragment,Le),w(it.$$.fragment,Le),w(br.$$.fragment,Le),w(gr.$$.fragment,Le),w(Kt.$$.fragment,Le),Mr=!1},d(Le){C(e,Le),Le&&l(t),Le&&l(r),Le&&l(n),C(s,Le),Le&&l(a),C(u,Le),Le&&l(p),C(m,Le),Le&&l(_),Le&&l(v),Le&&l(R),Le&&l(P),C(y),C(F),Le&&l(Q),Le&&l(X),Le&&l(Z),Le&&l(K),C(W,Le),Le&&l(U),Le&&l(G),C(te,Le),Le&&l(ee),Le&&l(ne),Le&&l(ae),Le&&l(J),Le&&l(De),Le&&l(de),Le&&l(et),Le&&l(Ze),Le&&l(Ke),C(ct,Le),Le&&l(st),C(Qe,Le),Le&&l(at),Le&&l(bt),Le&&l(wt),Le&&l(tt),C(ot,Le),Le&&l(At),C(it,Le),Le&&l(Xe),Le&&l(Dt),Le&&l(pt),Le&&l(yt),Le&&l(Ot),Le&&l(Pt),Le&&l(vt),Le&&l(gt),Le&&l(Ft),Le&&l(Mt),Le&&l($r),Le&&l(Ut),Le&&l(Xt),Le&&l(Vt),Le&&l(Zt),Le&&l(Ar),C(br,Le),Le&&l(ur),Le&&l(Qt),Le&&l(Vr),Le&&l(rr),Le&&l(lr),C(gr,Le),Le&&l(yr),C(Kt,Le),Le&&l(ir)}}}class bF extends ve{constructor(e){super(),Ee(this,e,null,EF,be,{})}}function wF(c){let e;return{c(){e=i("Descriptor Set Layout Builder")},l(t){e=f(t,"Descriptor Set Layout Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IF(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[wF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Set Layout."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Set Layout by it's Constructor,
        but to use a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Set Layout."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Set Layout by it's Constructor,
        but to use a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function DF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CF(c){let e;return{c(){e=i("VkDescriptorSetLayoutBinding")},l(t){e=f(t,"VkDescriptorSetLayoutBinding")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SF(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[DF]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[CF]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Descriptor Set Layout should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("bindings"),R=d("br"),P=i(`
            A list of `),I(A.$$.fragment),T=i("-structures."),y=d("br"),B=i(`
            Resources are bound by binding points in the descriptor set. Each member
            of the supplied list provides a description of a descriptor set layout
            binding.`),this.h()},l(O){e=g(O,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var F=E(t);r=g(F,"CODE",{});var V=E(r);$=f(V,"pLogicalDevice"),V.forEach(l),n=g(F,"BR",{}),s=f(F,`
            A pointer to the `),S(a.$$.fragment,F),u=f(F," the Descriptor Set Layout should be associated with."),F.forEach(l),p=Y(x),m=g(x,"LI",{});var q=E(m);_=g(q,"CODE",{});var k=E(_);v=f(k,"bindings"),k.forEach(l),R=g(q,"BR",{}),P=f(q,`
            A list of `),S(A.$$.fragment,q),T=f(q,"-structures."),y=g(q,"BR",{}),B=f(q,`
            Resources are bound by binding points in the descriptor set. Each member
            of the supplied list provides a description of a descriptor set layout
            binding.`),q.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,x){h(O,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(m,y),o(m,B),M=!0},p(O,x){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),a.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),A.$set(V)},i(O){M||(b(a.$$.fragment,O),b(A.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(A.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(A)}}}function RF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AF(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[RF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function PF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSetLayout(LogicalDevice* pLogicalDevice, std::vector<VkDescriptorSetLayoutBinding> bindings);"}}),r=new Se({props:{$$slots:{throws:[AF],params:[SF],details:[IF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BF extends ve{constructor(e){super(),Ee(this,e,null,PF,be,{})}}function LF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kF(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[LF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function TF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OF(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[TF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function VF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkDescriptorSetLayout getDescriptorSetLayoutHandle() const;"}}),r=new Se({props:{$$slots:{return:[OF],details:[kF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yF extends ve{constructor(e){super(),Ee(this,e,null,VF,be,{})}}function MF(c){let e,t;return{c(){e=d("span"),t=i("Get a list of the Descriptor Set Layout Bindings.."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get a list of the Descriptor Set Layout Bindings.."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function FF(c){let e,t;return{c(){e=d("span"),t=i("A list of the Descriptor Set Layout Bindings.."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the Descriptor Set Layout Bindings.."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function xF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkDescriptorSetLayoutBinding>& getBindings() const;"}}),r=new Se({props:{$$slots:{return:[FF],details:[MF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class NF extends ve{constructor(e){super(),Ee(this,e,null,xF,be,{})}}function UF(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/descriptor_set_layout_builder.hpp>"}}),m=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
std::vector<VkDescriptorSetLayoutBinding> bindings = {};`}}),R=new $e({props:{language:hn,code:`#version 450 core

layout (local_size_x=256, local_size_y=1, local_size_z=1) in;

layout (set=0, binding=0) uniform Config
{
    int transform;
    int integerCount;
} configData;

layout (set=0, binding=1) readonly buffer InputBuffer
{
    int integers[4096];
} inputData;

layout (set=0, binding=2) buffer OutputBuffer
{
    int integers[4096];
} outputData;

void main(void)
{
    // Grab global ID
    uint globalID = gl_GlobalInvocationID.x;

    // Don't access past the buffer size
    if (globalID < configData.integerCount)
    {
        // Perform some calculations
        outputData.integers[globalID] = inputData.integers[globalID] * configData.transform;
    }
}
`}}),A=new $e({props:{language:pe,code:`fillcan::DescriptorSetLayoutBuilder descriptorSetLayoutBuilder{};
descriptorSetLayoutBuilder.setLogicalDevice(fillcan.getCurrentDevice());

// Config
descriptorSetLayoutBuilder.addBinding(0, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

// InputBuffer
descriptorSetLayoutBuilder.addBinding(1, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

// OutputBuffer
descriptorSetLayoutBuilder.addBinding(2, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

fillcan::DescriptorSetLayout descriptorSetLayout = descriptorSetLayoutBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Set Layout Builder"),n=i(` class is part of the creational
design pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(R.$$.fragment),P=j(),I(A.$$.fragment)},l(y){S(e.$$.fragment,y),t=f(y,`
The `),r=g(y,"CODE",{});var B=E(r);$=f(B,"Descriptor Set Layout Builder"),B.forEach(l),n=f(y,` class is part of the creational
design pattern to construct complex objects step by step.`),s=g(y,"BR",{}),a=f(y,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(y,"BR",{}),p=f(y,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,y),_=g(y,"BR",{}),v=f(y,`
Example:
`),S(R.$$.fragment,y),P=Y(y),S(A.$$.fragment,y)},m(y,B){D(e,y,B),h(y,t,B),h(y,r,B),o(r,$),h(y,n,B),h(y,s,B),h(y,a,B),h(y,u,B),h(y,p,B),D(m,y,B),h(y,_,B),h(y,v,B),D(R,y,B),h(y,P,B),D(A,y,B),T=!0},p:Oe,i(y){T||(b(e.$$.fragment,y),b(m.$$.fragment,y),b(R.$$.fragment,y),b(A.$$.fragment,y),T=!0)},o(y){w(e.$$.fragment,y),w(m.$$.fragment,y),w(R.$$.fragment,y),w(A.$$.fragment,y),T=!1},d(y){C(e,y),y&&l(t),y&&l(r),y&&l(n),y&&l(s),y&&l(a),y&&l(u),y&&l(p),C(m,y),y&&l(_),y&&l(v),C(R,y),y&&l(P),C(A,y)}}}class GF extends ve{constructor(e){super(),Ee(this,e,null,UF,be,{})}}function HF(c){let e,t;return{c(){e=d("span"),t=i("Create a new Descriptor Set Layout Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Descriptor Set Layout Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function qF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSetLayoutBuilder();"}}),r=new Se({props:{$$slots:{details:[HF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class WF extends ve{constructor(e){super(),Ee(this,e,null,qF,be,{})}}function QF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KF(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zF(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[QF]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[KF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function jF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YF(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XF(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[jF]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[YF]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P," should be associated with."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function ZF(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[XF],details:[zF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class JF extends ve{constructor(e){super(),Ee(this,e,null,ZF,be,{})}}function ex(c){let e;return{c(){e=i("descriptor set layout binding")},l(t){e=f(t,"descriptor set layout binding")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tx(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rx(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[ex]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[tx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Add a "),I(r.$$.fragment),$=i(". Resources are bound by binding points in the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Add a "),S(r.$$.fragment,p),$=f(p,". Resources are bound by binding points in the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function nx(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sx(c){let e;return{c(){e=i("VkDescriptorType")},l(t){e=f(t,"VkDescriptorType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ax(c){let e;return{c(){e=i("VkShaderStageFlagBits")},l(t){e=f(t,"VkShaderStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ox(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lx(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ix(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fx(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cx(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $x(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ux(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function px(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[nx]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorType.html",target:"_blank",$$slots:{default:[sx]},$$scope:{ctx:c}}}),Ce=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html",target:"_blank",$$slots:{default:[ax]},$$scope:{ctx:c}}}),Ie=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[ox]},$$scope:{ctx:c}}}),xe=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[lx]},$$scope:{ctx:c}}}),ye=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[ix]},$$scope:{ctx:c}}}),Ne=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[fx]},$$scope:{ctx:c}}}),Je=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[cx]},$$scope:{ctx:c}}}),et=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[$x]},$$scope:{ctx:c}}}),nt=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[ux]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            Each resource accessible to a shader is assigned a binding number. The
            bindings used in a `),I(a.$$.fragment),u=i(` do not have to be contiguous and there may be gaps (unused binding
            numbers) in a set. However, it is recommended that sparsely populated
            sets are not created as this can waste resources in the device.`),p=j(),m=d("li"),_=d("code"),v=i("descriptorType"),R=d("br"),P=i(`
            The type descriptor on this binding point. This is a member of the `),I(A.$$.fragment),T=i("-enumerator."),y=j(),B=d("li"),M=d("code"),O=i("descriptorCount"),x=d("br"),F=i(`
            The number of descriptors in the binding, accessible in a shader as an
            array, unless `),V=d("code"),q=i("descriptorType"),k=i(` is
            `),N=d("code"),Q=i("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),X=i(`. In that case,
            `),Z=d("code"),K=i("descriptorCount"),W=i(` is the size in bytes of the inline
            uniform block. If
            `),U=d("code"),G=i("descriptorCount"),te=i(" is "),ee=d("code"),ne=i("0"),le=i(`, this binding entry
            is reserved and the resource should not be accessed from any stage
            through this binding within a pipeline with the layout set.`),ae=j(),J=d("li"),ue=d("code"),De=i("stageFlags"),de=d("br"),me=i(`
            A bitmask of the `),I(Ce.$$.fragment),_e=i(`-enumerant that specifies which pipeline shader stages can access a
            resource for this binding.`),se=j(),ie=d("li"),ge=d("code"),we=i("immutableSamplers"),Re=d("br"),Be=i(`
            Affects `),I(Ie.$$.fragment),re=i(`
            initialization. If `),he=d("code"),Ae=i("descriptorType"),Ve=i(`
            specifies a
            `),oe=d("code"),ce=i("VK_DESCRIPTOR_TYPE_SAMPLER"),Pe=i(`
            or `),Fe=d("code"),ke=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Te=i(` type
            descriptor, then `),Me=d("code"),Ue=i("pImmutableSamplers"),qe=i(` can be used to
            initialize a set of immutable `),I(xe.$$.fragment),Ge=i(". Immutable "),I(ye.$$.fragment),We=i(` are permanently embedded in the set layout and should not be modified;
            updating a
            `),ze=d("code"),Ye=i("VK_DESCRIPTOR_TYPE_SAMPLER"),rt=i(` descriptor with immutable
            `),I(Ne.$$.fragment),He=i(` is not
            allowed and updates of a
            `),$t=d("code"),ut=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),ht=i(`
            descriptor with immutable `),I(Je.$$.fragment),dt=i(" do not change the "),I(et.$$.fragment),Ze=i(" (the image views are updated, but the "),I(nt.$$.fragment),Ke=i(" updates are ignored)."),this.h()},l(st){e=g(st,"DIV",{slot:!0});var Qe=E(e);t=g(Qe,"LI",{});var at=E(t);r=g(at,"CODE",{});var bt=E(r);$=f(bt,"binding"),bt.forEach(l),n=g(at,"BR",{}),s=f(at,`
            Each resource accessible to a shader is assigned a binding number. The
            bindings used in a `),S(a.$$.fragment,at),u=f(at,` do not have to be contiguous and there may be gaps (unused binding
            numbers) in a set. However, it is recommended that sparsely populated
            sets are not created as this can waste resources in the device.`),at.forEach(l),p=Y(Qe),m=g(Qe,"LI",{});var wt=E(m);_=g(wt,"CODE",{});var St=E(_);v=f(St,"descriptorType"),St.forEach(l),R=g(wt,"BR",{}),P=f(wt,`
            The type descriptor on this binding point. This is a member of the `),S(A.$$.fragment,wt),T=f(wt,"-enumerator."),wt.forEach(l),y=Y(Qe),B=g(Qe,"LI",{});var tt=E(B);M=g(tt,"CODE",{});var ot=E(M);O=f(ot,"descriptorCount"),ot.forEach(l),x=g(tt,"BR",{}),F=f(tt,`
            The number of descriptors in the binding, accessible in a shader as an
            array, unless `),V=g(tt,"CODE",{});var At=E(V);q=f(At,"descriptorType"),At.forEach(l),k=f(tt,` is
            `),N=g(tt,"CODE",{});var it=E(N);Q=f(it,"VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),it.forEach(l),X=f(tt,`. In that case,
            `),Z=g(tt,"CODE",{});var Xe=E(Z);K=f(Xe,"descriptorCount"),Xe.forEach(l),W=f(tt,` is the size in bytes of the inline
            uniform block. If
            `),U=g(tt,"CODE",{});var Dt=E(U);G=f(Dt,"descriptorCount"),Dt.forEach(l),te=f(tt," is "),ee=g(tt,"CODE",{});var Ct=E(ee);ne=f(Ct,"0"),Ct.forEach(l),le=f(tt,`, this binding entry
            is reserved and the resource should not be accessed from any stage
            through this binding within a pipeline with the layout set.`),tt.forEach(l),ae=Y(Qe),J=g(Qe,"LI",{});var pt=E(J);ue=g(pt,"CODE",{});var yt=E(ue);De=f(yt,"stageFlags"),yt.forEach(l),de=g(pt,"BR",{}),me=f(pt,`
            A bitmask of the `),S(Ce.$$.fragment,pt),_e=f(pt,`-enumerant that specifies which pipeline shader stages can access a
            resource for this binding.`),pt.forEach(l),se=Y(Qe),ie=g(Qe,"LI",{});var mt=E(ie);ge=g(mt,"CODE",{});var Ot=E(ge);we=f(Ot,"immutableSamplers"),Ot.forEach(l),Re=g(mt,"BR",{}),Be=f(mt,`
            Affects `),S(Ie.$$.fragment,mt),re=f(mt,`
            initialization. If `),he=g(mt,"CODE",{});var Pt=E(he);Ae=f(Pt,"descriptorType"),Pt.forEach(l),Ve=f(mt,`
            specifies a
            `),oe=g(mt,"CODE",{});var Tt=E(oe);ce=f(Tt,"VK_DESCRIPTOR_TYPE_SAMPLER"),Tt.forEach(l),Pe=f(mt,`
            or `),Fe=g(mt,"CODE",{});var vt=E(Fe);ke=f(vt,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),vt.forEach(l),Te=f(mt,` type
            descriptor, then `),Me=g(mt,"CODE",{});var gt=E(Me);Ue=f(gt,"pImmutableSamplers"),gt.forEach(l),qe=f(mt,` can be used to
            initialize a set of immutable `),S(xe.$$.fragment,mt),Ge=f(mt,". Immutable "),S(ye.$$.fragment,mt),We=f(mt,` are permanently embedded in the set layout and should not be modified;
            updating a
            `),ze=g(mt,"CODE",{});var kt=E(ze);Ye=f(kt,"VK_DESCRIPTOR_TYPE_SAMPLER"),kt.forEach(l),rt=f(mt,` descriptor with immutable
            `),S(Ne.$$.fragment,mt),He=f(mt,` is not
            allowed and updates of a
            `),$t=g(mt,"CODE",{});var Ft=E($t);ut=f(Ft,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Ft.forEach(l),ht=f(mt,`
            descriptor with immutable `),S(Je.$$.fragment,mt),dt=f(mt," do not change the "),S(et.$$.fragment,mt),Ze=f(mt," (the image views are updated, but the "),S(nt.$$.fragment,mt),Ke=f(mt," updates are ignored)."),mt.forEach(l),Qe.forEach(l),this.h()},h(){z(e,"slot","params")},m(st,Qe){h(st,e,Qe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),o(B,V),o(V,q),o(B,k),o(B,N),o(N,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,U),o(U,G),o(B,te),o(B,ee),o(ee,ne),o(B,le),o(e,ae),o(e,J),o(J,ue),o(ue,De),o(J,de),o(J,me),D(Ce,J,null),o(J,_e),o(e,se),o(e,ie),o(ie,ge),o(ge,we),o(ie,Re),o(ie,Be),D(Ie,ie,null),o(ie,re),o(ie,he),o(he,Ae),o(ie,Ve),o(ie,oe),o(oe,ce),o(ie,Pe),o(ie,Fe),o(Fe,ke),o(ie,Te),o(ie,Me),o(Me,Ue),o(ie,qe),D(xe,ie,null),o(ie,Ge),D(ye,ie,null),o(ie,We),o(ie,ze),o(ze,Ye),o(ie,rt),D(Ne,ie,null),o(ie,He),o(ie,$t),o($t,ut),o(ie,ht),D(Je,ie,null),o(ie,dt),D(et,ie,null),o(ie,Ze),D(nt,ie,null),o(ie,Ke),ct=!0},p(st,Qe){const at={};Qe&1&&(at.$$scope={dirty:Qe,ctx:st}),a.$set(at);const bt={};Qe&1&&(bt.$$scope={dirty:Qe,ctx:st}),A.$set(bt);const wt={};Qe&1&&(wt.$$scope={dirty:Qe,ctx:st}),Ce.$set(wt);const St={};Qe&1&&(St.$$scope={dirty:Qe,ctx:st}),Ie.$set(St);const tt={};Qe&1&&(tt.$$scope={dirty:Qe,ctx:st}),xe.$set(tt);const ot={};Qe&1&&(ot.$$scope={dirty:Qe,ctx:st}),ye.$set(ot);const At={};Qe&1&&(At.$$scope={dirty:Qe,ctx:st}),Ne.$set(At);const it={};Qe&1&&(it.$$scope={dirty:Qe,ctx:st}),Je.$set(it);const Xe={};Qe&1&&(Xe.$$scope={dirty:Qe,ctx:st}),et.$set(Xe);const Dt={};Qe&1&&(Dt.$$scope={dirty:Qe,ctx:st}),nt.$set(Dt)},i(st){ct||(b(a.$$.fragment,st),b(A.$$.fragment,st),b(Ce.$$.fragment,st),b(Ie.$$.fragment,st),b(xe.$$.fragment,st),b(ye.$$.fragment,st),b(Ne.$$.fragment,st),b(Je.$$.fragment,st),b(et.$$.fragment,st),b(nt.$$.fragment,st),ct=!0)},o(st){w(a.$$.fragment,st),w(A.$$.fragment,st),w(Ce.$$.fragment,st),w(Ie.$$.fragment,st),w(xe.$$.fragment,st),w(ye.$$.fragment,st),w(Ne.$$.fragment,st),w(Je.$$.fragment,st),w(et.$$.fragment,st),w(nt.$$.fragment,st),ct=!1},d(st){st&&l(e),C(a),C(A),C(Ce),C(Ie),C(xe),C(ye),C(Ne),C(Je),C(et),C(nt)}}}function mx(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void addBinding(
    unsigned int binding, 
    VkDescriptorType descriptorType, 
    unsigned int descriptorCount, 
    VkShaderStageFlags stageFlags,
    std::vector<VkSampler> immutableSamplers = {}
);`}}),r=new Se({props:{$$slots:{params:[px],details:[rx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hx extends ve{constructor(e){super(),Ee(this,e,null,mx,be,{})}}function dx(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gx(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[dx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _x(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vx(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ex(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[_x]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[vx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function bx(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wx(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[bx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Ix(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<DescriptorSetLayout> getResult();"}}),r=new Se({props:{$$slots:{throws:[wx],return:[Ex],details:[gx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Dx extends ve{constructor(e){super(),Ee(this,e,null,Ix,be,{})}}function Cx(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sx(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Rx(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[Sx],default:[Cx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ax extends ve{constructor(e){super(),Ee(this,e,null,Rx,be,{})}}function Px(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bx(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lx(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kx(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tx(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/descriptor_pool.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Px]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Bx]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[Lx]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[kx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Descriptor Pool"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with flags describing the supported operations and information about the
`),I(u.$$.fragment),p=i(` to be
allocated and uses this information to construct a `),I(m.$$.fragment),_=i(" from which it can allocate "),I(v.$$.fragment),R=i("."),P=d("br"),A=d("br"),T=i(`
Resources are represented by descriptors and are bound to the pipeline by first binding
their descriptors into sets and then binding those descriptor sets to the pipeline.
This allows a large number of resources to be bound with very little processing time,
as the exact set of resources used by a particular drawing command can be predetermined
and the descriptor set containing them can be pre-created.`),y=d("br"),B=i(`
The descriptors are allocated from descriptor pools. Descriptors for different types of resources are likely to
have similar data structures in a given implementation. Pooling the mappings used
to store descriptors allows drivers to make efficient use of memory.`)},l(O){S(e.$$.fragment,O),t=f(O,`

The `),r=g(O,"CODE",{});var x=E(r);$=f(x,"Descriptor Pool"),x.forEach(l),n=f(O," class takes a pointer to a "),S(s.$$.fragment,O),a=f(O,` along with flags describing the supported operations and information about the
`),S(u.$$.fragment,O),p=f(O,` to be
allocated and uses this information to construct a `),S(m.$$.fragment,O),_=f(O," from which it can allocate "),S(v.$$.fragment,O),R=f(O,"."),P=g(O,"BR",{}),A=g(O,"BR",{}),T=f(O,`
Resources are represented by descriptors and are bound to the pipeline by first binding
their descriptors into sets and then binding those descriptor sets to the pipeline.
This allows a large number of resources to be bound with very little processing time,
as the exact set of resources used by a particular drawing command can be predetermined
and the descriptor set containing them can be pre-created.`),y=g(O,"BR",{}),B=f(O,`
The descriptors are allocated from descriptor pools. Descriptors for different types of resources are likely to
have similar data structures in a given implementation. Pooling the mappings used
to store descriptors allows drivers to make efficient use of memory.`)},m(O,x){D(e,O,x),h(O,t,x),h(O,r,x),o(r,$),h(O,n,x),D(s,O,x),h(O,a,x),D(u,O,x),h(O,p,x),D(m,O,x),h(O,_,x),D(v,O,x),h(O,R,x),h(O,P,x),h(O,A,x),h(O,T,x),h(O,y,x),h(O,B,x),M=!0},p(O,[x]){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),s.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),u.$set(V);const q={};x&1&&(q.$$scope={dirty:x,ctx:O}),m.$set(q);const k={};x&1&&(k.$$scope={dirty:x,ctx:O}),v.$set(k)},i(O){M||(b(e.$$.fragment,O),b(s.$$.fragment,O),b(u.$$.fragment,O),b(m.$$.fragment,O),b(v.$$.fragment,O),M=!0)},o(O){w(e.$$.fragment,O),w(s.$$.fragment,O),w(u.$$.fragment,O),w(m.$$.fragment,O),w(v.$$.fragment,O),M=!1},d(O){C(e,O),O&&l(t),O&&l(r),O&&l(n),C(s,O),O&&l(a),C(u,O),O&&l(p),C(m,O),O&&l(_),C(v,O),O&&l(R),O&&l(P),O&&l(A),O&&l(T),O&&l(y),O&&l(B)}}}class Ox extends ve{constructor(e){super(),Ee(this,e,null,Tx,be,{})}}function Vx(c){let e;return{c(){e=i("Descriptor Pool Builder")},l(t){e=f(t,"Descriptor Pool Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yx(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.DESCRIPTOR_POOL_BUILDER,$$slots:{default:[Vx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Pool."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Pool by it's Constructor, but
        to use a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Pool."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Pool by it's Constructor, but
        to use a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Mx(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fx(c){let e;return{c(){e=i("VkDescriptorPoolCreateFlagBits")},l(t){e=f(t,"VkDescriptorPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xx(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nx(c){let e;return{c(){e=i("VkDescriptorPoolSize")},l(t){e=f(t,"VkDescriptorPoolSize")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ux(c){let e;return{c(){e=i("VkDescriptorPoolSize")},l(t){e=f(t,"VkDescriptorPoolSize")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gx(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Mx]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[Fx]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[xx]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html",target:"_blank",$$slots:{default:[Nx]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html",target:"_blank",$$slots:{default:[Ux]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Descriptor Pool should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(` that specify additional information about the allocation strategy to
            use to manage the resources consumed by the pool.`),y=j(),B=d("li"),M=d("code"),O=i("maxSets"),x=d("br"),F=i(`
            The maximum total number of `),I(V.$$.fragment),q=i(" that can be allocated from the pool."),k=j(),N=d("li"),Q=d("code"),X=i("poolSizes"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),U=i(`-structures where each structure specifies the number of
            descriptors of a particular type that can be allocated from the
            pool.`),G=d("br"),te=i(`
            If no element in the list specifies a particular type of resource, then
            no descriptors of that type can be allocated from the resulting pool. If
            a particular resource type appears twice in the array, the sum of all
            their
            `),ee=d("code"),ne=i("descriptorCount"),le=i(`
            fields (of the `),I(ae.$$.fragment),J=i(`-structure) is used to determine the pool for that resource type.
            The total number of resources in the pool is distributed across the
            sets allocated from the pool.`),this.h()},l(De){e=g(De,"DIV",{slot:!0});var de=E(e);t=g(de,"LI",{});var me=E(t);r=g(me,"CODE",{});var Ce=E(r);$=f(Ce,"pLogicalDevice"),Ce.forEach(l),n=g(me,"BR",{}),s=f(me,`
            A pointer to the `),S(a.$$.fragment,me),u=f(me," the Descriptor Pool should be associated with."),me.forEach(l),p=Y(de),m=g(de,"LI",{});var _e=E(m);_=g(_e,"CODE",{});var se=E(_);v=f(se,"flags"),se.forEach(l),R=g(_e,"BR",{}),P=f(_e,`
            A bitmask of `),S(A.$$.fragment,_e),T=f(_e,` that specify additional information about the allocation strategy to
            use to manage the resources consumed by the pool.`),_e.forEach(l),y=Y(de),B=g(de,"LI",{});var ie=E(B);M=g(ie,"CODE",{});var ge=E(M);O=f(ge,"maxSets"),ge.forEach(l),x=g(ie,"BR",{}),F=f(ie,`
            The maximum total number of `),S(V.$$.fragment,ie),q=f(ie," that can be allocated from the pool."),ie.forEach(l),k=Y(de),N=g(de,"LI",{});var we=E(N);Q=g(we,"CODE",{});var Re=E(Q);X=f(Re,"poolSizes"),Re.forEach(l),Z=g(we,"BR",{}),K=f(we,`
            A list of `),S(W.$$.fragment,we),U=f(we,`-structures where each structure specifies the number of
            descriptors of a particular type that can be allocated from the
            pool.`),G=g(we,"BR",{}),te=f(we,`
            If no element in the list specifies a particular type of resource, then
            no descriptors of that type can be allocated from the resulting pool. If
            a particular resource type appears twice in the array, the sum of all
            their
            `),ee=g(we,"CODE",{});var Be=E(ee);ne=f(Be,"descriptorCount"),Be.forEach(l),le=f(we,`
            fields (of the `),S(ae.$$.fragment,we),J=f(we,`-structure) is used to determine the pool for that resource type.
            The total number of resources in the pool is distributed across the
            sets allocated from the pool.`),we.forEach(l),de.forEach(l),this.h()},h(){z(e,"slot","params")},m(De,de){h(De,e,de),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(N,G),o(N,te),o(N,ee),o(ee,ne),o(N,le),D(ae,N,null),o(N,J),ue=!0},p(De,de){const me={};de&1&&(me.$$scope={dirty:de,ctx:De}),a.$set(me);const Ce={};de&1&&(Ce.$$scope={dirty:de,ctx:De}),A.$set(Ce);const _e={};de&1&&(_e.$$scope={dirty:de,ctx:De}),V.$set(_e);const se={};de&1&&(se.$$scope={dirty:de,ctx:De}),W.$set(se);const ie={};de&1&&(ie.$$scope={dirty:de,ctx:De}),ae.$set(ie)},i(De){ue||(b(a.$$.fragment,De),b(A.$$.fragment,De),b(V.$$.fragment,De),b(W.$$.fragment,De),b(ae.$$.fragment,De),ue=!0)},o(De){w(a.$$.fragment,De),w(A.$$.fragment,De),w(V.$$.fragment,De),w(W.$$.fragment,De),w(ae.$$.fragment,De),ue=!1},d(De){De&&l(e),C(a),C(A),C(V),C(W),C(ae)}}}function Hx(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qx(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[Hx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Wx(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSetLayout(LogicalDevice* pLogicalDevice, std::vector<VkDescriptorSetLayoutBinding> bindings);"}}),r=new Se({props:{$$slots:{throws:[qx],params:[Gx],details:[yx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Qx extends ve{constructor(e){super(),Ee(this,e,null,Wx,be,{})}}function Kx(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zx(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[Kx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function jx(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yx(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[jx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Xx(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkDescriptorPool getDescriptorPoolHandle() const;"}}),r=new Se({props:{$$slots:{return:[Yx],details:[zx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Zx extends ve{constructor(e){super(),Ee(this,e,null,Xx,be,{})}}function Jx(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rN(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Jx]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[eN]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[tN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Allocate a single "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Assigns a block with descriptors from the pool by creating a new `),I(a.$$.fragment),u=i(". The given "),p=d("code"),m=i("name"),_=i(` can be used as an identifier to retrieve
        and identify the allocated
        `),I(v.$$.fragment),R=i("."),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=f(T,"Allocate a single "),S(r.$$.fragment,T),$=f(T,"."),n=g(T,"BR",{}),s=f(T,`
        Assigns a block with descriptors from the pool by creating a new `),S(a.$$.fragment,T),u=f(T,". The given "),p=g(T,"CODE",{});var y=E(p);m=f(y,"name"),y.forEach(l),_=f(T,` can be used as an identifier to retrieve
        and identify the allocated
        `),S(v.$$.fragment,T),R=f(T,"."),T.forEach(l),this.h()},h(){z(e,"slot","details")},m(A,T){h(A,e,T),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,R),P=!0},p(A,T){const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),r.$set(y);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),a.$set(B);const M={};T&1&&(M.$$scope={dirty:T,ctx:A}),v.$set(M)},i(A){P||(b(r.$$.fragment,A),b(a.$$.fragment,A),b(v.$$.fragment,A),P=!0)},o(A){w(r.$$.fragment,A),w(a.$$.fragment,A),w(v.$$.fragment,A),P=!1},d(A){A&&l(e),C(r),C(a),C(v)}}}function nN(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oN(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M;return a=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[nN]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[sN]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[aN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSetLayout"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" describing the "),I(p.$$.fragment),m=i("."),_=j(),v=d("li"),R=d("code"),P=i("name"),A=d("br"),T=i(`
            The identifying name of the `),I(y.$$.fragment),B=i("."),this.h()},l(O){e=g(O,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var F=E(t);r=g(F,"CODE",{});var V=E(r);$=f(V,"pDescriptorSetLayout"),V.forEach(l),n=g(F,"BR",{}),s=f(F,`
            A pointer to the `),S(a.$$.fragment,F),u=f(F," describing the "),S(p.$$.fragment,F),m=f(F,"."),F.forEach(l),_=Y(x),v=g(x,"LI",{});var q=E(v);R=g(q,"CODE",{});var k=E(R);P=f(k,"name"),k.forEach(l),A=g(q,"BR",{}),T=f(q,`
            The identifying name of the `),S(y.$$.fragment,q),B=f(q,"."),q.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,x){h(O,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),M=!0},p(O,x){const F={};x&1&&(F.$$scope={dirty:x,ctx:O}),a.$set(F);const V={};x&1&&(V.$$scope={dirty:x,ctx:O}),p.$set(V);const q={};x&1&&(q.$$scope={dirty:x,ctx:O}),y.$set(q)},i(O){M||(b(a.$$.fragment,O),b(p.$$.fragment,O),b(y.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(p.$$.fragment,O),w(y.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(p),C(y)}}}function lN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iN(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[lN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function fN(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cN(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[fN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" failed to be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," failed to be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function $N(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSet* allocateDescriptorSet(DescriptorSetLayout* pDescriptorSetLayout, std::string name);"}}),r=new Se({props:{$$slots:{throws:[cN],return:[iN],params:[oN],details:[rN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uN extends ve{constructor(e){super(),Ee(this,e,null,$N,be,{})}}function pN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mN(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[pN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dN(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[hN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gN(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<DescriptorSet*> getDescriptorSets();"}}),r=new Se({props:{$$slots:{return:[dN],details:[mN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _N extends ve{constructor(e){super(),Ee(this,e,null,gN,be,{})}}function vN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EN(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[vN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get an allocated "),I(r.$$.fragment),$=i(" by name."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get an allocated "),S(r.$$.fragment,a),$=f(a," by name."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wN(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[bN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"name"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The name of the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function IN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DN(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CN(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[IN]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[DN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" with the given name was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the requested "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," with the given name was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function SN(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSet* getDescriptorSet(std::string name);"}}),r=new Se({props:{$$slots:{return:[CN],params:[wN],details:[EN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RN extends ve{constructor(e){super(),Ee(this,e,null,SN,be,{})}}function AN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BN(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[AN]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[PN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free all the allocated "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        If the descriptor pool was created with the `),a=d("code"),u=i("flags"),p=i(` field set
        to `),m=d("code"),_=i("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),v=i(`,
        `),I(R.$$.fragment),P=i(` can be returned to the pool by freeing them.
    `),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var y=E(e);t=f(y,"Free all the allocated "),S(r.$$.fragment,y),$=f(y,"."),n=g(y,"BR",{}),s=f(y,`
        If the descriptor pool was created with the `),a=g(y,"CODE",{});var B=E(a);u=f(B,"flags"),B.forEach(l),p=f(y,` field set
        to `),m=g(y,"CODE",{});var M=E(m);_=f(M,"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),M.forEach(l),v=f(y,`,
        `),S(R.$$.fragment,y),P=f(y,` can be returned to the pool by freeing them.
    `),y.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,y){h(T,e,y),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(R,e,null),o(e,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),r.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),R.$set(M)},i(T){A||(b(r.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(R)}}}function LN(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the descriptor sets were succesfully freed.
        `),n=d("code"),s=i("false"),a=i(" if not all descriptor sets could be freed."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the descriptor sets were succesfully freed.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all descriptor sets could be freed."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function kN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ON(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[kN]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[TN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free all the given allocated "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        If the descriptor pool was created with the `),a=d("code"),u=i("flags"),p=i(` field set
        to `),m=d("code"),_=i("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),v=i(`,
        `),I(R.$$.fragment),P=i(" can be returned to the pool by freeing them."),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var y=E(e);t=f(y,"Free all the given allocated "),S(r.$$.fragment,y),$=f(y,"."),n=g(y,"BR",{}),s=f(y,`
        If the descriptor pool was created with the `),a=g(y,"CODE",{});var B=E(a);u=f(B,"flags"),B.forEach(l),p=f(y,` field set
        to `),m=g(y,"CODE",{});var M=E(m);_=f(M,"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),M.forEach(l),v=f(y,`,
        `),S(R.$$.fragment,y),P=f(y," can be returned to the pool by freeing them."),y.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,y){h(T,e,y),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(R,e,null),o(e,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),r.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),R.$set(M)},i(T){A||(b(r.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(R)}}}function VN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yN(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[VN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSets"),n=d("br"),s=i(`
            A list of pointers to `),I(a.$$.fragment),u=i(" to be freed."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pDescriptorSets"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A list of pointers to `),S(a.$$.fragment,v),u=f(v," to be freed."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function MN(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the descriptor sets were succesfully freed.
        `),n=d("code"),s=i("false"),a=i(" if not all descriptor sets could be freed."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the descriptor sets were succesfully freed.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all descriptor sets could be freed."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function FN(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"bool freeDescriptorSets();"}}),r=new Se({props:{$$slots:{return:[LN],details:[BN]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:"bool freeDescriptorSets(std::vector<DescriptorSet*> pDescriptorSets);"}}),u=new Se({props:{$$slots:{return:[MN],params:[yN],details:[ON]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class xN extends ve{constructor(e){super(),Ee(this,e,null,FN,be,{})}}function NN(c){let e,t;return{c(){e=d("span"),t=i("Reset the descriptor pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the descriptor pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function UN(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the descriptor pool was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the descriptor pool failed to reset. >"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the descriptor pool was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the descriptor pool failed to reset. >"),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function GN(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"bool reset();"}}),r=new Se({props:{$$slots:{return:[UN],details:[NN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class HN extends ve{constructor(e){super(),Ee(this,e,null,GN,be,{})}}function qN(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/descriptor_pool_builder.hpp>"}}),m=new $e({props:{language:pe,code:`struct DescriptorSetInfo {
    std::string name = "undefined";
    DescriptorSetLayout* pLayout = nullptr;
    std::vector<VkDescriptorPoolSize> poolSizes = {};
};
LogicalDevice* pLogicalDevice = nullptr;
VkDescriptorPoolCreateFlags flags = 0;
unsigned int maxSets = 0;
std::vector<DescriptorSetLayout*> pDescriptorSetLayouts = {};
std::vector<DescriptorSetInfo> descriptorSetInfos = {};`}}),R=new $e({props:{language:pe,code:`// Prepare some descriptor set layouts
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample1 = descriptorSetLayoutBuilder.getResult();
descriptorSetLayoutBuilder.reset();
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample2 = descriptorSetLayoutBuilder.getResult();
descriptorSetLayoutBuilder.reset();
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample3 = descriptorSetLayoutBuilder.getResult();

// Create descriptor pool
fillcan::DescriptorPoolBuilder descriptorPoolBuilder{};

descriptorPoolBuilder.setLogicalDevice(fillcan.getCurrentDevice());

descriptorPoolBuilder.addSet(descriptorSetLayoutExample1, "DescriptorSetExample1");
descriptorPoolBuilder.addSet(descriptorSetLayoutExample2, "DescriptorSetExample2");
descriptorPoolBuilder.addSet(descriptorSetLayoutExample3, "DescriptorSetExample3");

fillcan::DescriptorPool descriptorPool = descriptorPoolBuilder.getResult();
`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Pool Builder"),n=i(` class is part of the creational design
pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(R.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Descriptor Pool Builder"),T.forEach(l),n=f(A,` class is part of the creational design
pattern to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(R.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(R,A,T),P=!0},p:Oe,i(A){P||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(R.$$.fragment,A),P=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(R.$$.fragment,A),P=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(R,A)}}}class WN extends ve{constructor(e){super(),Ee(this,e,null,qN,be,{})}}function QN(c){let e,t;return{c(){e=d("span"),t=i("Create a new Descriptor Pool Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Descriptor Pool Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function KN(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorPoolBuilder();"}}),r=new Se({props:{$$slots:{details:[QN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zN extends ve{constructor(e){super(),Ee(this,e,null,KN,be,{})}}function jN(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YN(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XN(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[jN]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[YN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function ZN(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JN(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eU(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[ZN]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[JN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P," should be associated with."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function tU(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[eU],details:[XN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rU extends ve{constructor(e){super(),Ee(this,e,null,tU,be,{})}}function nU(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sU(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[nU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aU(c){let e;return{c(){e=i("VkDescriptorPoolCreateFlagBits")},l(t){e=f(t,"VkDescriptorPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oU(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lU(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[aU]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[oU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that specify certain supported operations on the "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"flags"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A bitmask of `),S(a.$$.fragment,P),u=f(P," that specify certain supported operations on the "),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function iU(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFlags(VkDescriptorPoolCreateFlags flags);"}}),r=new Se({props:{$$slots:{params:[lU],details:[sU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fU extends ve{constructor(e){super(),Ee(this,e,null,iU,be,{})}}function cU(c){let e,t;return{c(){e=d("span"),t=i(`Specify a set of descriptors of a certain type that should be
        allocatable from the pool.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Specify a set of descriptors of a certain type that should be
        allocatable from the pool.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function $U(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uU(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pU(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[$U]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[uU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSetLayout"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(` describing the order and types of resources in the set. Two sets with
            the same layout are considered compatible and interchangeable.`),p=j(),m=d("li"),_=d("code"),v=i("name"),R=d("br"),P=i(`
            The identifying name of the `),I(A.$$.fragment),T=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"pDescriptorSetLayout"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The `),S(a.$$.fragment,O),u=f(O,` describing the order and types of resources in the set. Two sets with
            the same layout are considered compatible and interchangeable.`),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"name"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            The identifying name of the `),S(A.$$.fragment,F),T=f(F,"."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function mU(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFlags(VkDescriptorPoolCreateFlags flags);"}}),r=new Se({props:{$$slots:{params:[pU],details:[cU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hU extends ve{constructor(e){super(),Ee(this,e,null,mU,be,{})}}function dU(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gU(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[dU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _U(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vU(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[_U]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("allocate"),n=d("br"),s=i(`
            Whether to automatically allocate the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"allocate"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            Whether to automatically allocate the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function EU(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bU(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wU(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[EU]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[bU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function IU(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DU(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CU(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return n=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[IU]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[DU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created. Also throws "),a=d("code"),u=i("std::runtime_error"),p=i(` if
        `),m=d("code"),_=i("allocate"),v=i(`
        is `),R=d("code"),P=i("true"),A=i(" and the "),I(T.$$.fragment),y=i(" failed to be created."),this.h()},l(M){e=g(M,"SPAN",{slot:!0});var O=E(e);t=g(O,"CODE",{});var x=E(t);r=f(x,"std::runtime_error"),x.forEach(l),$=f(O," if the "),S(n.$$.fragment,O),s=f(O," couldn't be created. Also throws "),a=g(O,"CODE",{});var F=E(a);u=f(F,"std::runtime_error"),F.forEach(l),p=f(O,` if
        `),m=g(O,"CODE",{});var V=E(m);_=f(V,"allocate"),V.forEach(l),v=f(O,`
        is `),R=g(O,"CODE",{});var q=E(R);P=f(q,"true"),q.forEach(l),A=f(O," and the "),S(T.$$.fragment,O),y=f(O," failed to be created."),O.forEach(l),this.h()},h(){z(e,"slot","throws")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),o(e,R),o(R,P),o(e,A),D(T,e,null),o(e,y),B=!0},p(M,O){const x={};O&1&&(x.$$scope={dirty:O,ctx:M}),n.$set(x);const F={};O&1&&(F.$$scope={dirty:O,ctx:M}),T.$set(F)},i(M){B||(b(n.$$.fragment,M),b(T.$$.fragment,M),B=!0)},o(M){w(n.$$.fragment,M),w(T.$$.fragment,M),B=!1},d(M){M&&l(e),C(n),C(T)}}}function SU(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<DescriptorPool> getResult(bool allocate = true);"}}),r=new Se({props:{$$slots:{throws:[CU],return:[wU],params:[vU],details:[gU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RU extends ve{constructor(e){super(),Ee(this,e,null,SU,be,{})}}function AU(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PU(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function BU(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[PU],default:[AU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LU extends ve{constructor(e){super(),Ee(this,e,null,BU,be,{})}}function kU(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TU(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OU(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VU(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yU(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MU(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FU(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xU(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NU(c){let e;return{c(){e=i("layout")},l(t){e=f(t,"layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UU(c){let e;return{c(){e=i("layout")},l(t){e=f(t,"layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GU(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HU(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qU(c){let e;return{c(){e=i("Pipelines")},l(t){e=f(t,"Pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WU(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QU(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/descriptor_set.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[kU]},$$scope:{ctx:c}}}),u=new fe({props:{href:"",target:"_blank",$$slots:{default:[TU]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[OU]},$$scope:{ctx:c}}}),y=new fe({props:{href:"",target:"_blank",$$slots:{default:[VU]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.BUFFER,$$slots:{default:[yU]},$$scope:{ctx:c}}}),q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[MU]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[FU]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[xU]},$$scope:{ctx:c}}}),G=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[NU]},$$scope:{ctx:c}}}),ee=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[UU]},$$scope:{ctx:c}}}),le=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[GU]},$$scope:{ctx:c}}}),J=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[HU]},$$scope:{ctx:c}}}),De=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[qU]},$$scope:{ctx:c}}}),me=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[WU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Set"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a handle to the "),I(u.$$.fragment),p=i(" which it will wrap around and the "),I(m.$$.fragment),_=i(" which describes it's bindings"),v=d("br"),R=i(`
The `),P=d("code"),A=i("Descriptor Set"),T=i(" class acts as a wrapper around the "),I(y.$$.fragment),B=i(" for updating and copying it's contents."),M=d("br"),O=d("br"),x=i(`
A descriptor is a special opaque shader variable used by shaders to indirectly access
`),I(F.$$.fragment),V=i(" and "),I(q.$$.fragment),k=i(` resources. It can be seen as a "pointer" to a resource. The Vulkan API allows these
variables to be changed between drawing operations so that the shaders have access
to different resources for each rendering. A descriptor set is called a "set" because
it can refer to a set of homogeneous resources that can be described with the same
layout binding.`),N=d("br"),Q=d("br"),X=i(`
A descriptor set is a set of resources tied to the `),I(Z.$$.fragment),K=i(" as a group. Multiple sets can be tied to a "),I(W.$$.fragment),U=i(" at the same time. Each set has a "),I(G.$$.fragment),te=i(`, which describes the order and types of resources in the set. Two sets with
the same layout are considered compatible and interchangeable. The `),I(ee.$$.fragment),ne=i(` of the descriptor set is represented by an object and sets are created with respect
to this object. Furthermore, the set of sets accessible to a `),I(le.$$.fragment),ae=i(" is grouped together in another object: the "),I(J.$$.fragment),ue=i(". "),I(De.$$.fragment),de=i(` are created in
relation to this `),I(me.$$.fragment),Ce=i(" object.")},l(se){S(e.$$.fragment,se),t=f(se,`
The `),r=g(se,"CODE",{});var ie=E(r);$=f(ie,"Descriptor Set"),ie.forEach(l),n=f(se," class takes a pointer to a "),S(s.$$.fragment,se),a=f(se,", a handle to the "),S(u.$$.fragment,se),p=f(se," which it will wrap around and the "),S(m.$$.fragment,se),_=f(se," which describes it's bindings"),v=g(se,"BR",{}),R=f(se,`
The `),P=g(se,"CODE",{});var ge=E(P);A=f(ge,"Descriptor Set"),ge.forEach(l),T=f(se," class acts as a wrapper around the "),S(y.$$.fragment,se),B=f(se," for updating and copying it's contents."),M=g(se,"BR",{}),O=g(se,"BR",{}),x=f(se,`
A descriptor is a special opaque shader variable used by shaders to indirectly access
`),S(F.$$.fragment,se),V=f(se," and "),S(q.$$.fragment,se),k=f(se,` resources. It can be seen as a "pointer" to a resource. The Vulkan API allows these
variables to be changed between drawing operations so that the shaders have access
to different resources for each rendering. A descriptor set is called a "set" because
it can refer to a set of homogeneous resources that can be described with the same
layout binding.`),N=g(se,"BR",{}),Q=g(se,"BR",{}),X=f(se,`
A descriptor set is a set of resources tied to the `),S(Z.$$.fragment,se),K=f(se," as a group. Multiple sets can be tied to a "),S(W.$$.fragment,se),U=f(se," at the same time. Each set has a "),S(G.$$.fragment,se),te=f(se,`, which describes the order and types of resources in the set. Two sets with
the same layout are considered compatible and interchangeable. The `),S(ee.$$.fragment,se),ne=f(se,` of the descriptor set is represented by an object and sets are created with respect
to this object. Furthermore, the set of sets accessible to a `),S(le.$$.fragment,se),ae=f(se," is grouped together in another object: the "),S(J.$$.fragment,se),ue=f(se,". "),S(De.$$.fragment,se),de=f(se,` are created in
relation to this `),S(me.$$.fragment,se),Ce=f(se," object.")},m(se,ie){D(e,se,ie),h(se,t,ie),h(se,r,ie),o(r,$),h(se,n,ie),D(s,se,ie),h(se,a,ie),D(u,se,ie),h(se,p,ie),D(m,se,ie),h(se,_,ie),h(se,v,ie),h(se,R,ie),h(se,P,ie),o(P,A),h(se,T,ie),D(y,se,ie),h(se,B,ie),h(se,M,ie),h(se,O,ie),h(se,x,ie),D(F,se,ie),h(se,V,ie),D(q,se,ie),h(se,k,ie),h(se,N,ie),h(se,Q,ie),h(se,X,ie),D(Z,se,ie),h(se,K,ie),D(W,se,ie),h(se,U,ie),D(G,se,ie),h(se,te,ie),D(ee,se,ie),h(se,ne,ie),D(le,se,ie),h(se,ae,ie),D(J,se,ie),h(se,ue,ie),D(De,se,ie),h(se,de,ie),D(me,se,ie),h(se,Ce,ie),_e=!0},p(se,[ie]){const ge={};ie&1&&(ge.$$scope={dirty:ie,ctx:se}),s.$set(ge);const we={};ie&1&&(we.$$scope={dirty:ie,ctx:se}),u.$set(we);const Re={};ie&1&&(Re.$$scope={dirty:ie,ctx:se}),m.$set(Re);const Be={};ie&1&&(Be.$$scope={dirty:ie,ctx:se}),y.$set(Be);const Ie={};ie&1&&(Ie.$$scope={dirty:ie,ctx:se}),F.$set(Ie);const re={};ie&1&&(re.$$scope={dirty:ie,ctx:se}),q.$set(re);const he={};ie&1&&(he.$$scope={dirty:ie,ctx:se}),Z.$set(he);const Ae={};ie&1&&(Ae.$$scope={dirty:ie,ctx:se}),W.$set(Ae);const Ve={};ie&1&&(Ve.$$scope={dirty:ie,ctx:se}),G.$set(Ve);const oe={};ie&1&&(oe.$$scope={dirty:ie,ctx:se}),ee.$set(oe);const ce={};ie&1&&(ce.$$scope={dirty:ie,ctx:se}),le.$set(ce);const Pe={};ie&1&&(Pe.$$scope={dirty:ie,ctx:se}),J.$set(Pe);const Fe={};ie&1&&(Fe.$$scope={dirty:ie,ctx:se}),De.$set(Fe);const ke={};ie&1&&(ke.$$scope={dirty:ie,ctx:se}),me.$set(ke)},i(se){_e||(b(e.$$.fragment,se),b(s.$$.fragment,se),b(u.$$.fragment,se),b(m.$$.fragment,se),b(y.$$.fragment,se),b(F.$$.fragment,se),b(q.$$.fragment,se),b(Z.$$.fragment,se),b(W.$$.fragment,se),b(G.$$.fragment,se),b(ee.$$.fragment,se),b(le.$$.fragment,se),b(J.$$.fragment,se),b(De.$$.fragment,se),b(me.$$.fragment,se),_e=!0)},o(se){w(e.$$.fragment,se),w(s.$$.fragment,se),w(u.$$.fragment,se),w(m.$$.fragment,se),w(y.$$.fragment,se),w(F.$$.fragment,se),w(q.$$.fragment,se),w(Z.$$.fragment,se),w(W.$$.fragment,se),w(G.$$.fragment,se),w(ee.$$.fragment,se),w(le.$$.fragment,se),w(J.$$.fragment,se),w(De.$$.fragment,se),w(me.$$.fragment,se),_e=!1},d(se){C(e,se),se&&l(t),se&&l(r),se&&l(n),C(s,se),se&&l(a),C(u,se),se&&l(p),C(m,se),se&&l(_),se&&l(v),se&&l(R),se&&l(P),se&&l(T),C(y,se),se&&l(B),se&&l(M),se&&l(O),se&&l(x),C(F,se),se&&l(V),C(q,se),se&&l(k),se&&l(N),se&&l(Q),se&&l(X),C(Z,se),se&&l(K),C(W,se),se&&l(U),C(G,se),se&&l(te),C(ee,se),se&&l(ne),C(le,se),se&&l(ae),C(J,se),se&&l(ue),C(De,se),se&&l(de),C(me,se),se&&l(Ce)}}}class KU extends ve{constructor(e){super(),Ee(this,e,null,QU,be,{})}}function zU(c){let e;return{c(){e=i("allocateDescriptorSet")},l(t){e=f(t,"allocateDescriptorSet")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jU(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.DESCRIPTOR_POOL_allocateDescriptorSet,$$slots:{default:[zU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Set."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Set by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Set."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Set by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function YU(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XU(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZU(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JU(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YU]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[XU]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[ZU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the descriptor set should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("pDescriptorPool"),R=d("br"),P=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to allocate from."),y=j(),B=d("li"),M=d("code"),O=i("pDescriptorSetLayout"),x=d("br"),F=i(`
            A pointer to the `),I(V.$$.fragment),q=i(" describing the bindings."),k=j(),N=d("li"),Q=d("code"),X=i("name"),Z=d("br"),K=i(`
            The identifying name of the descriptor set.`),this.h()},l(U){e=g(U,"DIV",{slot:!0});var G=E(e);t=g(G,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            A pointer to the `),S(a.$$.fragment,te),u=f(te," the descriptor set should be associated with."),te.forEach(l),p=Y(G),m=g(G,"LI",{});var ne=E(m);_=g(ne,"CODE",{});var le=E(_);v=f(le,"pDescriptorPool"),le.forEach(l),R=g(ne,"BR",{}),P=f(ne,`
            A pointer to the `),S(A.$$.fragment,ne),T=f(ne," to allocate from."),ne.forEach(l),y=Y(G),B=g(G,"LI",{});var ae=E(B);M=g(ae,"CODE",{});var J=E(M);O=f(J,"pDescriptorSetLayout"),J.forEach(l),x=g(ae,"BR",{}),F=f(ae,`
            A pointer to the `),S(V.$$.fragment,ae),q=f(ae," describing the bindings."),ae.forEach(l),k=Y(G),N=g(G,"LI",{});var ue=E(N);Q=g(ue,"CODE",{});var De=E(Q);X=f(De,"name"),De.forEach(l),Z=g(ue,"BR",{}),K=f(ue,`
            The identifying name of the descriptor set.`),ue.forEach(l),G.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,G){h(U,e,G),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),W=!0},p(U,G){const te={};G&1&&(te.$$scope={dirty:G,ctx:U}),a.$set(te);const ee={};G&1&&(ee.$$scope={dirty:G,ctx:U}),A.$set(ee);const ne={};G&1&&(ne.$$scope={dirty:G,ctx:U}),V.$set(ne)},i(U){W||(b(a.$$.fragment,U),b(A.$$.fragment,U),b(V.$$.fragment,U),W=!0)},o(U){w(a.$$.fragment,U),w(A.$$.fragment,U),w(V.$$.fragment,U),W=!1},d(U){U&&l(e),C(a),C(A),C(V)}}}function eG(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tG(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[eG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" failed to be allocated."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," failed to be allocated."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function rG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`DescriptorSet(
    LogicalDevice* pLogicalDevice, 
    VkDescriptorSet hDescriptorSet, 
    DescriptorSetLayout* pDescriptorSetLayout
);`}}),r=new Se({props:{$$slots:{throws:[tG],params:[JU],details:[jU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nG extends ve{constructor(e){super(),Ee(this,e,null,rG,be,{})}}function sG(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aG(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[sG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function oG(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lG(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[oG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function iG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkDescriptorSet getDescriptorSetHandle() const;"}}),r=new Se({props:{$$slots:{return:[lG],details:[aG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fG extends ve{constructor(e){super(),Ee(this,e,null,iG,be,{})}}function cG(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $G(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[cG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" this descriptor set is associated with."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," this descriptor set is associated with."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function uG(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pG(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[uG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" this descriptor set is associated with."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," this descriptor set is associated with."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSetLayout* DescriptorSet::getLayout() { return this->pDescriptorSetLayout; }"}}),r=new Se({props:{$$slots:{return:[pG],details:[$G]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hG extends ve{constructor(e){super(),Ee(this,e,null,mG,be,{})}}function dG(c){let e,t;return{c(){e=d("span"),t=i("Get the identifying name of the descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the identifying name of the descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function gG(c){let e,t;return{c(){e=d("span"),t=i("The identifying name of the descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The identifying name of the descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function _G(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::string DescriptorSet::getName() { return this->name; }"}}),r=new Se({props:{$$slots:{return:[gG],details:[dG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vG extends ve{constructor(e){super(),Ee(this,e,null,_G,be,{})}}function EG(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bG(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[EG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind an "),I(r.$$.fragment),$=i(` to a given
        binding of the descriptor set.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind an "),S(r.$$.fragment,a),$=f(a,` to a given
        binding of the descriptor set.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wG(c){let e;return{c(){e=i("image view")},l(t){e=f(t,"image view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IG(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DG(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CG(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SG(c){let e;return{c(){e=i("image view")},l(t){e=f(t,"image view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RG(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AG(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge;return R=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[wG]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.IMAGE,$$slots:{default:[IG]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.IMAGE,$$slots:{default:[DG]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[CG]},$$scope:{ctx:c}}}),ne=new H({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[SG]},$$scope:{ctx:c}}}),ae=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[RG]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=j(),u=d("li"),p=d("code"),m=i("pImageView"),_=d("br"),v=i(`
            A pointer to the `),I(R.$$.fragment),P=i(" of the "),I(A.$$.fragment),T=i(` to
            be bound in the descriptor set.`),y=j(),B=d("li"),M=d("code"),O=i("imageLayout"),x=d("br"),F=i(`
            The layout in which the `),I(V.$$.fragment),q=i(` is expected to be when used in the descriptor set. This is a member
            of the `),I(k.$$.fragment),N=i("-enumerant."),Q=j(),X=d("li"),Z=d("code"),K=i("pSampler"),W=d("br"),U=i(`
            If the descriptor set was created with the descriptor type set to
            `),G=d("code"),te=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),ee=i(`, A pointer to
            the the corresponding `),I(ne.$$.fragment),le=i(`'s
            `),I(ae.$$.fragment),J=i(` (given in
            the `),ue=d("code"),De=i("pImageView"),de=i(" field) is specified here."),me=j(),Ce=d("li"),_e=d("code"),se=i("dstArrayElement"),ie=d("br"),ge=i(`
            If the binding in the set references an array of resources,
            `),we=d("code"),Re=i("dstArrayElement"),Be=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),Ie=d("code"),re=i("0"),he=i("."),Ae=j(),Ve=d("li"),oe=d("code"),ce=i("descriptorCount"),Pe=d("br"),Fe=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),ke=d("code"),Te=i("dstArrayElement"),Me=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),Ue=d("code"),qe=i("1"),xe=i("."),this.h()},l(ye){e=g(ye,"DIV",{slot:!0});var We=E(e);t=g(We,"LI",{});var ze=E(t);r=g(ze,"CODE",{});var Ye=E(r);$=f(Ye,"binding"),Ye.forEach(l),n=g(ze,"BR",{}),s=f(ze,`
            The binding-index of the descriptor set the resource should be bound
            to.`),ze.forEach(l),a=Y(We),u=g(We,"LI",{});var rt=E(u);p=g(rt,"CODE",{});var Ne=E(p);m=f(Ne,"pImageView"),Ne.forEach(l),_=g(rt,"BR",{}),v=f(rt,`
            A pointer to the `),S(R.$$.fragment,rt),P=f(rt," of the "),S(A.$$.fragment,rt),T=f(rt,` to
            be bound in the descriptor set.`),rt.forEach(l),y=Y(We),B=g(We,"LI",{});var He=E(B);M=g(He,"CODE",{});var $t=E(M);O=f($t,"imageLayout"),$t.forEach(l),x=g(He,"BR",{}),F=f(He,`
            The layout in which the `),S(V.$$.fragment,He),q=f(He,` is expected to be when used in the descriptor set. This is a member
            of the `),S(k.$$.fragment,He),N=f(He,"-enumerant."),He.forEach(l),Q=Y(We),X=g(We,"LI",{});var ut=E(X);Z=g(ut,"CODE",{});var ht=E(Z);K=f(ht,"pSampler"),ht.forEach(l),W=g(ut,"BR",{}),U=f(ut,`
            If the descriptor set was created with the descriptor type set to
            `),G=g(ut,"CODE",{});var Je=E(G);te=f(Je,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Je.forEach(l),ee=f(ut,`, A pointer to
            the the corresponding `),S(ne.$$.fragment,ut),le=f(ut,`'s
            `),S(ae.$$.fragment,ut),J=f(ut,` (given in
            the `),ue=g(ut,"CODE",{});var dt=E(ue);De=f(dt,"pImageView"),dt.forEach(l),de=f(ut," field) is specified here."),ut.forEach(l),me=Y(We),Ce=g(We,"LI",{});var et=E(Ce);_e=g(et,"CODE",{});var Ze=E(_e);se=f(Ze,"dstArrayElement"),Ze.forEach(l),ie=g(et,"BR",{}),ge=f(et,`
            If the binding in the set references an array of resources,
            `),we=g(et,"CODE",{});var nt=E(we);Re=f(nt,"dstArrayElement"),nt.forEach(l),Be=f(et,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),Ie=g(et,"CODE",{});var Ke=E(Ie);re=f(Ke,"0"),Ke.forEach(l),he=f(et,"."),et.forEach(l),Ae=Y(We),Ve=g(We,"LI",{});var ct=E(Ve);oe=g(ct,"CODE",{});var st=E(oe);ce=f(st,"descriptorCount"),st.forEach(l),Pe=g(ct,"BR",{}),Fe=f(ct,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),ke=g(ct,"CODE",{});var Qe=E(ke);Te=f(Qe,"dstArrayElement"),Qe.forEach(l),Me=f(ct,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),Ue=g(ct,"CODE",{});var at=E(Ue);qe=f(at,"1"),at.forEach(l),xe=f(ct,"."),ct.forEach(l),We.forEach(l),this.h()},h(){z(e,"slot","params")},m(ye,We){h(ye,e,We),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),D(A,u,null),o(u,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),o(X,G),o(G,te),o(X,ee),D(ne,X,null),o(X,le),D(ae,X,null),o(X,J),o(X,ue),o(ue,De),o(X,de),o(e,me),o(e,Ce),o(Ce,_e),o(_e,se),o(Ce,ie),o(Ce,ge),o(Ce,we),o(we,Re),o(Ce,Be),o(Ce,Ie),o(Ie,re),o(Ce,he),o(e,Ae),o(e,Ve),o(Ve,oe),o(oe,ce),o(Ve,Pe),o(Ve,Fe),o(Ve,ke),o(ke,Te),o(Ve,Me),o(Ve,Ue),o(Ue,qe),o(Ve,xe),Ge=!0},p(ye,We){const ze={};We&1&&(ze.$$scope={dirty:We,ctx:ye}),R.$set(ze);const Ye={};We&1&&(Ye.$$scope={dirty:We,ctx:ye}),A.$set(Ye);const rt={};We&1&&(rt.$$scope={dirty:We,ctx:ye}),V.$set(rt);const Ne={};We&1&&(Ne.$$scope={dirty:We,ctx:ye}),k.$set(Ne);const He={};We&1&&(He.$$scope={dirty:We,ctx:ye}),ne.$set(He);const $t={};We&1&&($t.$$scope={dirty:We,ctx:ye}),ae.$set($t)},i(ye){Ge||(b(R.$$.fragment,ye),b(A.$$.fragment,ye),b(V.$$.fragment,ye),b(k.$$.fragment,ye),b(ne.$$.fragment,ye),b(ae.$$.fragment,ye),Ge=!0)},o(ye){w(R.$$.fragment,ye),w(A.$$.fragment,ye),w(V.$$.fragment,ye),w(k.$$.fragment,ye),w(ne.$$.fragment,ye),w(ae.$$.fragment,ye),Ge=!1},d(ye){ye&&l(e),C(R),C(A),C(V),C(k),C(ne),C(ae)}}}function PG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void writeImage(
    VkDescriptorSetLayoutBinding binding, 
    ImageView* pImageView, 
    VkImageLayout imageLayout, 
    Sampler* pSampler,
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Se({props:{$$slots:{params:[AG],details:[bG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BG extends ve{constructor(e){super(),Ee(this,e,null,PG,be,{})}}function LG(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kG(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER,$$slots:{default:[LG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind a "),I(r.$$.fragment),$=i(` to a given
        binding of the descriptor set.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind a "),S(r.$$.fragment,a),$=f(a,` to a given
        binding of the descriptor set.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function TG(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OG(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VG(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yG(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MG(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe;return R=new H({props:{sectionID:L.BUFFER,$$slots:{default:[TG]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.BUFFER,$$slots:{default:[OG]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.BUFFER,$$slots:{default:[VG]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.BUFFER,$$slots:{default:[yG]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=j(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the  `),I(R.$$.fragment),P=i(` to be
            bound in the descriptor set.`),A=j(),T=d("li"),y=d("code"),B=i("offset"),M=d("br"),O=i(`
            From which point in the `),I(x.$$.fragment),F=i(" to bind. The offset of the binding in bytes."),V=j(),q=d("li"),k=d("code"),N=i("range"),Q=d("br"),X=i(`
            How much of the `),I(Z.$$.fragment),K=i(` to bind. The size of the binding in bytes. The bound range must be
            completely within the `),I(W.$$.fragment),U=i(" object."),G=j(),te=d("li"),ee=d("code"),ne=i("dstArrayElement"),le=d("br"),ae=i(`
            If the binding in the set references an array of resources,
            `),J=d("code"),ue=i("dstArrayElement"),De=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),de=d("code"),me=i("0"),Ce=i("."),_e=j(),se=d("li"),ie=d("code"),ge=i("descriptorCount"),we=d("br"),Re=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Be=d("code"),Ie=i("dstArrayElement"),re=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),he=d("code"),Ae=i("1"),Ve=i("."),this.h()},l(ce){e=g(ce,"DIV",{slot:!0});var Pe=E(e);t=g(Pe,"LI",{});var Fe=E(t);r=g(Fe,"CODE",{});var ke=E(r);$=f(ke,"binding"),ke.forEach(l),n=g(Fe,"BR",{}),s=f(Fe,`
            The binding-index of the descriptor set the resource should be bound
            to.`),Fe.forEach(l),a=Y(Pe),u=g(Pe,"LI",{});var Te=E(u);p=g(Te,"CODE",{});var Me=E(p);m=f(Me,"pBuffer"),Me.forEach(l),_=g(Te,"BR",{}),v=f(Te,`
            A pointer to the  `),S(R.$$.fragment,Te),P=f(Te,` to be
            bound in the descriptor set.`),Te.forEach(l),A=Y(Pe),T=g(Pe,"LI",{});var Ue=E(T);y=g(Ue,"CODE",{});var qe=E(y);B=f(qe,"offset"),qe.forEach(l),M=g(Ue,"BR",{}),O=f(Ue,`
            From which point in the `),S(x.$$.fragment,Ue),F=f(Ue," to bind. The offset of the binding in bytes."),Ue.forEach(l),V=Y(Pe),q=g(Pe,"LI",{});var xe=E(q);k=g(xe,"CODE",{});var Ge=E(k);N=f(Ge,"range"),Ge.forEach(l),Q=g(xe,"BR",{}),X=f(xe,`
            How much of the `),S(Z.$$.fragment,xe),K=f(xe,` to bind. The size of the binding in bytes. The bound range must be
            completely within the `),S(W.$$.fragment,xe),U=f(xe," object."),xe.forEach(l),G=Y(Pe),te=g(Pe,"LI",{});var ye=E(te);ee=g(ye,"CODE",{});var We=E(ee);ne=f(We,"dstArrayElement"),We.forEach(l),le=g(ye,"BR",{}),ae=f(ye,`
            If the binding in the set references an array of resources,
            `),J=g(ye,"CODE",{});var ze=E(J);ue=f(ze,"dstArrayElement"),ze.forEach(l),De=f(ye,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),de=g(ye,"CODE",{});var Ye=E(de);me=f(Ye,"0"),Ye.forEach(l),Ce=f(ye,"."),ye.forEach(l),_e=Y(Pe),se=g(Pe,"LI",{});var rt=E(se);ie=g(rt,"CODE",{});var Ne=E(ie);ge=f(Ne,"descriptorCount"),Ne.forEach(l),we=g(rt,"BR",{}),Re=f(rt,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Be=g(rt,"CODE",{});var He=E(Be);Ie=f(He,"dstArrayElement"),He.forEach(l),re=f(rt,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),he=g(rt,"CODE",{});var $t=E(he);Ae=f($t,"1"),$t.forEach(l),Ve=f(rt,"."),rt.forEach(l),Pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Pe){h(ce,e,Pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),o(e,V),o(e,q),o(q,k),o(k,N),o(q,Q),o(q,X),D(Z,q,null),o(q,K),D(W,q,null),o(q,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),o(te,J),o(J,ue),o(te,De),o(te,de),o(de,me),o(te,Ce),o(e,_e),o(e,se),o(se,ie),o(ie,ge),o(se,we),o(se,Re),o(se,Be),o(Be,Ie),o(se,re),o(se,he),o(he,Ae),o(se,Ve),oe=!0},p(ce,Pe){const Fe={};Pe&1&&(Fe.$$scope={dirty:Pe,ctx:ce}),R.$set(Fe);const ke={};Pe&1&&(ke.$$scope={dirty:Pe,ctx:ce}),x.$set(ke);const Te={};Pe&1&&(Te.$$scope={dirty:Pe,ctx:ce}),Z.$set(Te);const Me={};Pe&1&&(Me.$$scope={dirty:Pe,ctx:ce}),W.$set(Me)},i(ce){oe||(b(R.$$.fragment,ce),b(x.$$.fragment,ce),b(Z.$$.fragment,ce),b(W.$$.fragment,ce),oe=!0)},o(ce){w(R.$$.fragment,ce),w(x.$$.fragment,ce),w(Z.$$.fragment,ce),w(W.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(R),C(x),C(Z),C(W)}}}function FG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void writeBuffer(
    VkDescriptorSetLayoutBinding binding, 
    Buffer* pBuffer, 
    VkDeviceSize offset = 0, 
    VkDeviceSize range = VK_WHOLE_SIZE,
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Se({props:{$$slots:{params:[MG],details:[kG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class xG extends ve{constructor(e){super(),Ee(this,e,null,FG,be,{})}}function NG(c){let e;return{c(){e=i("texel buffer view")},l(t){e=f(t,"texel buffer view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UG(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[NG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind a "),I(r.$$.fragment),$=i(" to a given binding of the descriptor set."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind a "),S(r.$$.fragment,a),$=f(a," to a given binding of the descriptor set."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function GG(c){let e;return{c(){e=i("texel buffer view")},l(t){e=f(t,"texel buffer view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HG(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J;return R=new H({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[GG]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=j(),u=d("li"),p=d("code"),m=i("pBufferView"),_=d("br"),v=i(`
            A pointer to the `),I(R.$$.fragment),P=i(" to be bound in the descriptor set."),A=j(),T=d("li"),y=d("code"),B=i("dstArrayElement"),M=d("br"),O=i(`
            If the binding in the set references an array of resources,
            `),x=d("code"),F=i("dstArrayElement"),V=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),q=d("code"),k=i("0"),N=i("."),Q=j(),X=d("li"),Z=d("code"),K=i("descriptorCount"),W=d("br"),U=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),G=d("code"),te=i("dstArrayElement"),ee=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),ne=d("code"),le=i("1"),ae=i("."),this.h()},l(ue){e=g(ue,"DIV",{slot:!0});var De=E(e);t=g(De,"LI",{});var de=E(t);r=g(de,"CODE",{});var me=E(r);$=f(me,"binding"),me.forEach(l),n=g(de,"BR",{}),s=f(de,`
            The binding-index of the descriptor set the resource should be bound
            to.`),de.forEach(l),a=Y(De),u=g(De,"LI",{});var Ce=E(u);p=g(Ce,"CODE",{});var _e=E(p);m=f(_e,"pBufferView"),_e.forEach(l),_=g(Ce,"BR",{}),v=f(Ce,`
            A pointer to the `),S(R.$$.fragment,Ce),P=f(Ce," to be bound in the descriptor set."),Ce.forEach(l),A=Y(De),T=g(De,"LI",{});var se=E(T);y=g(se,"CODE",{});var ie=E(y);B=f(ie,"dstArrayElement"),ie.forEach(l),M=g(se,"BR",{}),O=f(se,`
            If the binding in the set references an array of resources,
            `),x=g(se,"CODE",{});var ge=E(x);F=f(ge,"dstArrayElement"),ge.forEach(l),V=f(se,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),q=g(se,"CODE",{});var we=E(q);k=f(we,"0"),we.forEach(l),N=f(se,"."),se.forEach(l),Q=Y(De),X=g(De,"LI",{});var Re=E(X);Z=g(Re,"CODE",{});var Be=E(Z);K=f(Be,"descriptorCount"),Be.forEach(l),W=g(Re,"BR",{}),U=f(Re,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),G=g(Re,"CODE",{});var Ie=E(G);te=f(Ie,"dstArrayElement"),Ie.forEach(l),ee=f(Re,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),ne=g(Re,"CODE",{});var re=E(ne);le=f(re,"1"),re.forEach(l),ae=f(Re,"."),Re.forEach(l),De.forEach(l),this.h()},h(){z(e,"slot","params")},m(ue,De){h(ue,e,De),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),o(T,x),o(x,F),o(T,V),o(T,q),o(q,k),o(T,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),o(X,G),o(G,te),o(X,ee),o(X,ne),o(ne,le),o(X,ae),J=!0},p(ue,De){const de={};De&1&&(de.$$scope={dirty:De,ctx:ue}),R.$set(de)},i(ue){J||(b(R.$$.fragment,ue),J=!0)},o(ue){w(R.$$.fragment,ue),J=!1},d(ue){ue&&l(e),C(R)}}}function qG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void writeTexelBufferView(
    VkDescriptorSetLayoutBinding binding, 
    BufferView* pTexelBufferView, 
    unsigned int dstArrayElement = 0,
    unsigned int descriptorCount = 1
);`}}),r=new Se({props:{$$slots:{params:[HG],details:[UG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class WG extends ve{constructor(e){super(),Ee(this,e,null,qG,be,{})}}function QG(c){let e,t;return{c(){e=d("span"),t=i("Copy this descriptor set to another descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this descriptor set to another descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function KG(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("srcDescriptorSetBinding"),n=d("br"),s=i(`
            The binding index of the descriptor within the set to copy from.`),a=j(),u=d("li"),p=d("code"),m=i("pDstDescriptorSet"),_=d("br"),v=i(`
            A pointer to the descriptor set to copy to.`),R=j(),P=d("li"),A=d("code"),T=i("dstDescriptorSetBinding"),y=d("br"),B=i(`
            The binding index of the descriptor within the set to copy to.`),M=j(),O=d("li"),x=d("code"),F=i("dstArrayElement"),V=d("br"),q=i(`
            If the binding in the set references an array of resources,
            `),k=d("code"),N=i("dstArrayElement"),Q=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),X=d("code"),Z=i("0"),K=i("."),W=j(),U=d("li"),G=d("code"),te=i("descriptorCount"),ee=d("br"),ne=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),le=d("code"),ae=i("dstArrayElement"),J=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),ue=d("code"),De=i("1"),de=i("."),this.h()},l(me){e=g(me,"DIV",{slot:!0});var Ce=E(e);t=g(Ce,"LI",{});var _e=E(t);r=g(_e,"CODE",{});var se=E(r);$=f(se,"srcDescriptorSetBinding"),se.forEach(l),n=g(_e,"BR",{}),s=f(_e,`
            The binding index of the descriptor within the set to copy from.`),_e.forEach(l),a=Y(Ce),u=g(Ce,"LI",{});var ie=E(u);p=g(ie,"CODE",{});var ge=E(p);m=f(ge,"pDstDescriptorSet"),ge.forEach(l),_=g(ie,"BR",{}),v=f(ie,`
            A pointer to the descriptor set to copy to.`),ie.forEach(l),R=Y(Ce),P=g(Ce,"LI",{});var we=E(P);A=g(we,"CODE",{});var Re=E(A);T=f(Re,"dstDescriptorSetBinding"),Re.forEach(l),y=g(we,"BR",{}),B=f(we,`
            The binding index of the descriptor within the set to copy to.`),we.forEach(l),M=Y(Ce),O=g(Ce,"LI",{});var Be=E(O);x=g(Be,"CODE",{});var Ie=E(x);F=f(Ie,"dstArrayElement"),Ie.forEach(l),V=g(Be,"BR",{}),q=f(Be,`
            If the binding in the set references an array of resources,
            `),k=g(Be,"CODE",{});var re=E(k);N=f(re,"dstArrayElement"),re.forEach(l),Q=f(Be,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),X=g(Be,"CODE",{});var he=E(X);Z=f(he,"0"),he.forEach(l),K=f(Be,"."),Be.forEach(l),W=Y(Ce),U=g(Ce,"LI",{});var Ae=E(U);G=g(Ae,"CODE",{});var Ve=E(G);te=f(Ve,"descriptorCount"),Ve.forEach(l),ee=g(Ae,"BR",{}),ne=f(Ae,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),le=g(Ae,"CODE",{});var oe=E(le);ae=f(oe,"dstArrayElement"),oe.forEach(l),J=f(Ae,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),ue=g(Ae,"CODE",{});var ce=E(ue);De=f(ce,"1"),ce.forEach(l),de=f(Ae,"."),Ae.forEach(l),Ce.forEach(l),this.h()},h(){z(e,"slot","params")},m(me,Ce){h(me,e,Ce),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),o(O,k),o(k,N),o(O,Q),o(O,X),o(X,Z),o(O,K),o(e,W),o(e,U),o(U,G),o(G,te),o(U,ee),o(U,ne),o(U,le),o(le,ae),o(U,J),o(U,ue),o(ue,De),o(U,de)},p:Oe,d(me){me&&l(e)}}}function zG(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void copy(
    VkDescriptorSetLayoutBinding srcDescriptorSetBinding, 
    DescriptorSet* pDstDescriptorSet,
    VkDescriptorSetLayoutBinding dstDescriptorSetBinding, 
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Se({props:{$$slots:{params:[KG],details:[QG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jG extends ve{constructor(e){super(),Ee(this,e,null,zG,be,{})}}function YG(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XG(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZG(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JG(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e4(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t4(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r4(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n4(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s4(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/pipeline_layout.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YG]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[XG]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[ZG]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[JG]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[e4]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[t4]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[r4]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[n4]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[s4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline Layout"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a list of "),I(u.$$.fragment),p=i(" and a list of "),I(m.$$.fragment),_=i(" and uses this information to construct a "),I(v.$$.fragment),R=i(" which can be used to bind multiple "),I(P.$$.fragment),A=i(" to a "),I(T.$$.fragment),y=i("."),B=d("br"),M=d("br"),O=i(`
Multiple descriptor set layouts can be used in a single `),I(x.$$.fragment),F=i(". To group two or more descriptor sets into something that the "),I(V.$$.fragment),q=i(" can use, they must be merged into a "),I(k.$$.fragment),N=i(" object.")},l(X){S(e.$$.fragment,X),t=f(X,`

The `),r=g(X,"CODE",{});var Z=E(r);$=f(Z,"Pipeline Layout"),Z.forEach(l),n=f(X," class takes a pointer to a "),S(s.$$.fragment,X),a=f(X," along with a list of "),S(u.$$.fragment,X),p=f(X," and a list of "),S(m.$$.fragment,X),_=f(X," and uses this information to construct a "),S(v.$$.fragment,X),R=f(X," which can be used to bind multiple "),S(P.$$.fragment,X),A=f(X," to a "),S(T.$$.fragment,X),y=f(X,"."),B=g(X,"BR",{}),M=g(X,"BR",{}),O=f(X,`
Multiple descriptor set layouts can be used in a single `),S(x.$$.fragment,X),F=f(X,". To group two or more descriptor sets into something that the "),S(V.$$.fragment,X),q=f(X," can use, they must be merged into a "),S(k.$$.fragment,X),N=f(X," object.")},m(X,Z){D(e,X,Z),h(X,t,Z),h(X,r,Z),o(r,$),h(X,n,Z),D(s,X,Z),h(X,a,Z),D(u,X,Z),h(X,p,Z),D(m,X,Z),h(X,_,Z),D(v,X,Z),h(X,R,Z),D(P,X,Z),h(X,A,Z),D(T,X,Z),h(X,y,Z),h(X,B,Z),h(X,M,Z),h(X,O,Z),D(x,X,Z),h(X,F,Z),D(V,X,Z),h(X,q,Z),D(k,X,Z),h(X,N,Z),Q=!0},p(X,[Z]){const K={};Z&1&&(K.$$scope={dirty:Z,ctx:X}),s.$set(K);const W={};Z&1&&(W.$$scope={dirty:Z,ctx:X}),u.$set(W);const U={};Z&1&&(U.$$scope={dirty:Z,ctx:X}),m.$set(U);const G={};Z&1&&(G.$$scope={dirty:Z,ctx:X}),v.$set(G);const te={};Z&1&&(te.$$scope={dirty:Z,ctx:X}),P.$set(te);const ee={};Z&1&&(ee.$$scope={dirty:Z,ctx:X}),T.$set(ee);const ne={};Z&1&&(ne.$$scope={dirty:Z,ctx:X}),x.$set(ne);const le={};Z&1&&(le.$$scope={dirty:Z,ctx:X}),V.$set(le);const ae={};Z&1&&(ae.$$scope={dirty:Z,ctx:X}),k.$set(ae)},i(X){Q||(b(e.$$.fragment,X),b(s.$$.fragment,X),b(u.$$.fragment,X),b(m.$$.fragment,X),b(v.$$.fragment,X),b(P.$$.fragment,X),b(T.$$.fragment,X),b(x.$$.fragment,X),b(V.$$.fragment,X),b(k.$$.fragment,X),Q=!0)},o(X){w(e.$$.fragment,X),w(s.$$.fragment,X),w(u.$$.fragment,X),w(m.$$.fragment,X),w(v.$$.fragment,X),w(P.$$.fragment,X),w(T.$$.fragment,X),w(x.$$.fragment,X),w(V.$$.fragment,X),w(k.$$.fragment,X),Q=!1},d(X){C(e,X),X&&l(t),X&&l(r),X&&l(n),C(s,X),X&&l(a),C(u,X),X&&l(p),C(m,X),X&&l(_),C(v,X),X&&l(R),C(P,X),X&&l(A),C(T,X),X&&l(y),X&&l(B),X&&l(M),X&&l(O),C(x,X),X&&l(F),C(V,X),X&&l(q),C(k,X),X&&l(N)}}}class o4 extends ve{constructor(e){super(),Ee(this,e,null,a4,be,{})}}function l4(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i4(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[l4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Pipeline Layout."),r=d("br"),$=i(`
        It is recommended to not create a Pipeline Layout by it's Constructor as
        a `),I(n.$$.fragment),s=i(` will create
        a Pipeline Layout as part of it's construction.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Pipeline Layout."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Pipeline Layout by it's Constructor as
        a `),S(n.$$.fragment,p),s=f(p,` will create
        a Pipeline Layout as part of it's construction.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function f4(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c4(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $4(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[f4]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[c4]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[$4]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline Layout should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("pDescriptorSetLayouts"),R=d("br"),P=i(`
            A list of pointers to `),I(A.$$.fragment),T=i(" to be bound in the pipeline layout."),y=j(),B=d("li"),M=d("code"),O=i("pushConstants"),x=d("br"),F=i(`
            A list of `),I(V.$$.fragment),q=i(" to be bound in the pipeline layout."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"pLogicalDevice"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            A pointer to the `),S(a.$$.fragment,X),u=f(X," the Pipeline Layout should be associated with."),X.forEach(l),p=Y(Q),m=g(Q,"LI",{});var K=E(m);_=g(K,"CODE",{});var W=E(_);v=f(W,"pDescriptorSetLayouts"),W.forEach(l),R=g(K,"BR",{}),P=f(K,`
            A list of pointers to `),S(A.$$.fragment,K),T=f(K," to be bound in the pipeline layout."),K.forEach(l),y=Y(Q),B=g(Q,"LI",{});var U=E(B);M=g(U,"CODE",{});var G=E(M);O=f(G,"pushConstants"),G.forEach(l),x=g(U,"BR",{}),F=f(U,`
            A list of `),S(V.$$.fragment,U),q=f(U," to be bound in the pipeline layout."),U.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),A.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),V.$set(K)},i(N){k||(b(a.$$.fragment,N),b(A.$$.fragment,N),b(V.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(A.$$.fragment,N),w(V.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(A),C(V)}}}function p4(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m4(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[p4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function h4(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`PipelineLayout(
    LogicalDevice* pLogicalDevice, 
    std::vector<DescriptorSetLayout*>& pDescriptorSetLayouts,
    std::vector<PushConstant> pushConstants
);`}}),r=new Se({props:{$$slots:{throws:[m4],params:[u4],details:[i4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class d4 extends ve{constructor(e){super(),Ee(this,e,null,h4,be,{})}}function g4(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _4(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[g4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function v4(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E4(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[v4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function b4(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPipelineLayout getPipelineLayoutHandle() const;"}}),r=new Se({props:{$$slots:{return:[E4],details:[_4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class w4 extends ve{constructor(e){super(),Ee(this,e,null,b4,be,{})}}function I4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D4(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[I4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Update the value of a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Update the value of a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function C4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R4(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P4(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function B4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[C4]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[S4]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[R4]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[A4]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[P4]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            A pointer to a `),I(a.$$.fragment),u=i(" to execute the update with."),p=j(),m=d("li"),_=d("code"),v=i("name"),R=d("br"),P=i(`
            The name of the `),I(A.$$.fragment),T=i(" to update."),y=j(),B=d("li"),M=d("code"),O=i("upPushConstantData"),x=d("br"),F=i(`
            A `),I(V.$$.fragment),q=i(" to the new value of the "),I(k.$$.fragment),N=i(", please use "),I(Q.$$.fragment),X=i(" to transfer ownership."),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var U=E(t);r=g(U,"CODE",{});var G=E(r);$=f(G,"pCommandBuffer"),G.forEach(l),n=g(U,"BR",{}),s=f(U,`
            A pointer to a `),S(a.$$.fragment,U),u=f(U," to execute the update with."),U.forEach(l),p=Y(W),m=g(W,"LI",{});var te=E(m);_=g(te,"CODE",{});var ee=E(_);v=f(ee,"name"),ee.forEach(l),R=g(te,"BR",{}),P=f(te,`
            The name of the `),S(A.$$.fragment,te),T=f(te," to update."),te.forEach(l),y=Y(W),B=g(W,"LI",{});var ne=E(B);M=g(ne,"CODE",{});var le=E(M);O=f(le,"upPushConstantData"),le.forEach(l),x=g(ne,"BR",{}),F=f(ne,`
            A `),S(V.$$.fragment,ne),q=f(ne," to the new value of the "),S(k.$$.fragment,ne),N=f(ne,", please use "),S(Q.$$.fragment,ne),X=f(ne," to transfer ownership."),ne.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),D(k,B,null),o(B,N),D(Q,B,null),o(B,X),Z=!0},p(K,W){const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),a.$set(U);const G={};W&1&&(G.$$scope={dirty:W,ctx:K}),A.$set(G);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),V.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),k.$set(ee);const ne={};W&1&&(ne.$$scope={dirty:W,ctx:K}),Q.$set(ne)},i(K){Z||(b(a.$$.fragment,K),b(A.$$.fragment,K),b(V.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(a.$$.fragment,K),w(A.$$.fragment,K),w(V.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){K&&l(e),C(a),C(A),C(V),C(k),C(Q)}}}function L4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k4(c){let e,t,r,$,n,s,a,u,p,m;return n=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[L4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no "),I(n.$$.fragment),s=i(" with the requested "),a=d("code"),u=i("name"),p=i(" could be found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=g(v,"CODE",{});var R=E(t);r=f(R,"std::runtime_error"),R.forEach(l),$=f(v," if no "),S(n.$$.fragment,v),s=f(v," with the requested "),a=g(v,"CODE",{});var P=E(a);u=f(P,"name"),P.forEach(l),p=f(v," could be found."),v.forEach(l),this.h()},h(){z(e,"slot","throws")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),n.$set(R)},i(_){m||(b(n.$$.fragment,_),m=!0)},o(_){w(n.$$.fragment,_),m=!1},d(_){_&&l(e),C(n)}}}function T4(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void pushConstantData(
    CommandBuffer* pCommandBuffer, 
    std::string name, 
    std::unique_ptr<PushConstantData> upPushConstantData
);`}}),r=new Se({props:{$$slots:{throws:[k4],params:[B4],details:[D4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class O4 extends ve{constructor(e){super(),Ee(this,e,null,T4,be,{})}}function V4(c){let e;return{c(){e=i("Pipeline Layout Builder")},l(t){e=f(t,"Pipeline Layout Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y4(c){let e;return{c(){e=i("addPushConstant")},l(t){e=f(t,"addPushConstant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M4(c){let e;return{c(){e=i("pushConstantData")},l(t){e=f(t,"pushConstantData")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F4(c){let e;return{c(){e=i("VkPushConstantRange")},l(t){e=f(t,"VkPushConstantRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x4(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X;return a=new H({props:{sectionID:L.PIPELINE_LAYOUT_pushConstantData,$$slots:{default:[M4]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html",target:"_blank",$$slots:{default:[F4]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[x4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The identifying name of the push constant. Can be used to push the data
            using `),I(a.$$.fragment),u=i("."),p=j(),m=d("li"),_=d("code"),v=i("range"),R=d("br"),P=i(`
            A `),I(A.$$.fragment),T=i("-structure defining the size and offset of the push constant."),y=j(),B=d("li"),M=d("code"),O=i("upData"),x=d("br"),F=i(`
            A `),I(V.$$.fragment),q=i(" to the "),k=d("code"),N=i("PushConstantData"),Q=i(` defining the data of the push
            constant.`),this.h()},l(Z){e=g(Z,"SPAN",{slot:!0});var K=E(e);t=g(K,"LI",{});var W=E(t);r=g(W,"CODE",{});var U=E(r);$=f(U,"name"),U.forEach(l),n=g(W,"BR",{}),s=f(W,`
            The identifying name of the push constant. Can be used to push the data
            using `),S(a.$$.fragment,W),u=f(W,"."),W.forEach(l),p=Y(K),m=g(K,"LI",{});var G=E(m);_=g(G,"CODE",{});var te=E(_);v=f(te,"range"),te.forEach(l),R=g(G,"BR",{}),P=f(G,`
            A `),S(A.$$.fragment,G),T=f(G,"-structure defining the size and offset of the push constant."),G.forEach(l),y=Y(K),B=g(K,"LI",{});var ee=E(B);M=g(ee,"CODE",{});var ne=E(M);O=f(ne,"upData"),ne.forEach(l),x=g(ee,"BR",{}),F=f(ee,`
            A `),S(V.$$.fragment,ee),q=f(ee," to the "),k=g(ee,"CODE",{});var le=E(k);N=f(le,"PushConstantData"),le.forEach(l),Q=f(ee,` defining the data of the push
            constant.`),ee.forEach(l),K.forEach(l),this.h()},h(){z(e,"slot","params")},m(Z,K){h(Z,e,K),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(B,k),o(k,N),o(B,Q),X=!0},p(Z,K){const W={};K&1&&(W.$$scope={dirty:K,ctx:Z}),a.$set(W);const U={};K&1&&(U.$$scope={dirty:K,ctx:Z}),A.$set(U);const G={};K&1&&(G.$$scope={dirty:K,ctx:Z}),V.$set(G)},i(Z){X||(b(a.$$.fragment,Z),b(A.$$.fragment,Z),b(V.$$.fragment,Z),X=!0)},o(Z){w(a.$$.fragment,Z),w(A.$$.fragment,Z),w(V.$$.fragment,Z),X=!1},d(Z){Z&&l(e),C(a),C(A),C(V)}}}function U4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k;return e=new $e({props:{language:pe,code:`struct PushConstantData {};

struct PushConstant {
    std::string name = "undefined";
    VkPushConstantRange range;
    std::unique_ptr<PushConstantData> upData = nullptr;
};`}}),O=new H({props:{sectionID:L.PIPELINE_BUILDER,$$slots:{default:[V4]},$$scope:{ctx:c}}}),F=new H({props:{sectionID:L.PIPELINE_BUILDER_addPushConstant,$$slots:{default:[y4]},$$scope:{ctx:c}}}),q=new Se({props:{$$slots:{params:[N4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Push Constant"),n=i(` structure is used by the Pipeline Layout to keep
track of the information needed for pushing data to push constants.`),s=d("br"),a=i(`
The `),u=d("code"),p=i("Push Constant Data"),m=i(` structure can be extended and expanded with
any data the push constant should contain.`),_=d("br"),v=d("br"),R=i(`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants become
part of the layout of the pipeline that will use them. When pipelined push constants,
they can consume some of the resources Vulkan would otherwise use to track pipeline
or descriptor bindings. Therefore, push constants should be considered relatively
precious resources.`),P=d("br"),A=d("br"),T=i(`
It is recommended to not create the `),y=d("code"),B=i("Push Constant"),M=i(` structure
directly, but to add it to the Pipeline Layout using the `),I(O.$$.fragment),x=i("'s "),I(F.$$.fragment),V=i(` method.
`),I(q.$$.fragment)},l(N){S(e.$$.fragment,N),t=f(N,`

The `),r=g(N,"CODE",{});var Q=E(r);$=f(Q,"Push Constant"),Q.forEach(l),n=f(N,` structure is used by the Pipeline Layout to keep
track of the information needed for pushing data to push constants.`),s=g(N,"BR",{}),a=f(N,`
The `),u=g(N,"CODE",{});var X=E(u);p=f(X,"Push Constant Data"),X.forEach(l),m=f(N,` structure can be extended and expanded with
any data the push constant should contain.`),_=g(N,"BR",{}),v=g(N,"BR",{}),R=f(N,`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants become
part of the layout of the pipeline that will use them. When pipelined push constants,
they can consume some of the resources Vulkan would otherwise use to track pipeline
or descriptor bindings. Therefore, push constants should be considered relatively
precious resources.`),P=g(N,"BR",{}),A=g(N,"BR",{}),T=f(N,`
It is recommended to not create the `),y=g(N,"CODE",{});var Z=E(y);B=f(Z,"Push Constant"),Z.forEach(l),M=f(N,` structure
directly, but to add it to the Pipeline Layout using the `),S(O.$$.fragment,N),x=f(N,"'s "),S(F.$$.fragment,N),V=f(N,` method.
`),S(q.$$.fragment,N)},m(N,Q){D(e,N,Q),h(N,t,Q),h(N,r,Q),o(r,$),h(N,n,Q),h(N,s,Q),h(N,a,Q),h(N,u,Q),o(u,p),h(N,m,Q),h(N,_,Q),h(N,v,Q),h(N,R,Q),h(N,P,Q),h(N,A,Q),h(N,T,Q),h(N,y,Q),o(y,B),h(N,M,Q),D(O,N,Q),h(N,x,Q),D(F,N,Q),h(N,V,Q),D(q,N,Q),k=!0},p(N,[Q]){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),O.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),F.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),q.$set(K)},i(N){k||(b(e.$$.fragment,N),b(O.$$.fragment,N),b(F.$$.fragment,N),b(q.$$.fragment,N),k=!0)},o(N){w(e.$$.fragment,N),w(O.$$.fragment,N),w(F.$$.fragment,N),w(q.$$.fragment,N),k=!1},d(N){C(e,N),N&&l(t),N&&l(r),N&&l(n),N&&l(s),N&&l(a),N&&l(u),N&&l(m),N&&l(_),N&&l(v),N&&l(R),N&&l(P),N&&l(A),N&&l(T),N&&l(y),N&&l(M),C(O,N),N&&l(x),C(F,N),N&&l(V),C(q,N)}}}class G4 extends ve{constructor(e){super(),Ee(this,e,null,U4,be,{})}}function H4(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q4(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W4(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q4(c){let e;return{c(){e=i("shader modules")},l(t){e=f(t,"shader modules")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K4(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z4(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j4(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/pipeline.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[H4]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[q4]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[W4]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[Q4]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[K4]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[z4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with flags controlling how the pipeline is created, a list of shader stages,
a list of push constants and a optionally pipeline cache and a base pipeline, and
uses this information to construct a `),I(u.$$.fragment),p=i(" and a "),I(m.$$.fragment),_=i(" describing it's bound resources."),v=d("br"),R=d("br"),P=i(`
Before `),I(A.$$.fragment),T=i(`
can be used to do useful work on the device, you must create a pipeline. There are
two types of pipelines in Vulkan: "compute" and "graphics". The `),I(y.$$.fragment),B=i(`
is quite complex and contains many phases that have nothing to do with shaders. However,
a `),I(M.$$.fragment),O=i(`
is conceptually much simpler and essentially contains nothing but just the shader
code.`)},l(F){S(e.$$.fragment,F),t=f(F,`

The `),r=g(F,"CODE",{});var V=E(r);$=f(V,"Pipeline"),V.forEach(l),n=f(F," class takes a pointer to a "),S(s.$$.fragment,F),a=f(F,` along with flags controlling how the pipeline is created, a list of shader stages,
a list of push constants and a optionally pipeline cache and a base pipeline, and
uses this information to construct a `),S(u.$$.fragment,F),p=f(F," and a "),S(m.$$.fragment,F),_=f(F," describing it's bound resources."),v=g(F,"BR",{}),R=g(F,"BR",{}),P=f(F,`
Before `),S(A.$$.fragment,F),T=f(F,`
can be used to do useful work on the device, you must create a pipeline. There are
two types of pipelines in Vulkan: "compute" and "graphics". The `),S(y.$$.fragment,F),B=f(F,`
is quite complex and contains many phases that have nothing to do with shaders. However,
a `),S(M.$$.fragment,F),O=f(F,`
is conceptually much simpler and essentially contains nothing but just the shader
code.`)},m(F,V){D(e,F,V),h(F,t,V),h(F,r,V),o(r,$),h(F,n,V),D(s,F,V),h(F,a,V),D(u,F,V),h(F,p,V),D(m,F,V),h(F,_,V),h(F,v,V),h(F,R,V),h(F,P,V),D(A,F,V),h(F,T,V),D(y,F,V),h(F,B,V),D(M,F,V),h(F,O,V),x=!0},p(F,[V]){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),s.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),u.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),m.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),A.$set(Q);const X={};V&1&&(X.$$scope={dirty:V,ctx:F}),y.$set(X);const Z={};V&1&&(Z.$$scope={dirty:V,ctx:F}),M.$set(Z)},i(F){x||(b(e.$$.fragment,F),b(s.$$.fragment,F),b(u.$$.fragment,F),b(m.$$.fragment,F),b(A.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(e.$$.fragment,F),w(s.$$.fragment,F),w(u.$$.fragment,F),w(m.$$.fragment,F),w(A.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){C(e,F),F&&l(t),F&&l(r),F&&l(n),C(s,F),F&&l(a),C(u,F),F&&l(p),C(m,F),F&&l(_),F&&l(v),F&&l(R),F&&l(P),C(A,F),F&&l(T),C(y,F),F&&l(B),C(M,F),F&&l(O)}}}class Y4 extends ve{constructor(e){super(),Ee(this,e,null,j4,be,{})}}function X4(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=i("Create a new Pipeline."),r=d("br"),$=i(`
        The `),n=d("code"),s=i("Pipeline"),a=i(` class is meant to be extended as it only contains
        the generic information and functionality shared by all pipelines.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Pipeline."),r=g(p,"BR",{}),$=f(p,`
        The `),n=g(p,"CODE",{});var m=E(n);s=f(m,"Pipeline"),m.forEach(l),a=f(p,` class is meant to be extended as it only contains
        the generic information and functionality shared by all pipelines.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function Z4(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J4(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e5(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t5(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r5(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n5(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Z4]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[J4]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[e5]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[t5]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[r5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),y=j(),B=d("li"),M=d("code"),O=i("shaderStages"),x=d("br"),F=i(`
            A list of `),I(V.$$.fragment),q=i("-structures each of which defining a shader stage of the pipeline."),k=j(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),U=i(" to be bound to the pipeline."),G=j(),te=d("li"),ee=d("code"),ne=i("pipelineCache"),le=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),ue=i(" object."),De=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=j(),Ce=d("li"),_e=d("code"),se=i("pBasePipeline"),ie=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Re=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Ae=E(r);$=f(Ae,"pLogicalDevice"),Ae.forEach(l),n=g(he,"BR",{}),s=f(he,`
            A pointer to the `),S(a.$$.fragment,he),u=f(he," the Pipeline should be associated with."),he.forEach(l),p=Y(re),m=g(re,"LI",{});var Ve=E(m);_=g(Ve,"CODE",{});var oe=E(_);v=f(oe,"flags"),oe.forEach(l),R=g(Ve,"BR",{}),P=f(Ve,`
            A bitmask of `),S(A.$$.fragment,Ve),T=f(Ve," controlling how the pipeline is created."),Ve.forEach(l),y=Y(re),B=g(re,"LI",{});var ce=E(B);M=g(ce,"CODE",{});var Pe=E(M);O=f(Pe,"shaderStages"),Pe.forEach(l),x=g(ce,"BR",{}),F=f(ce,`
            A list of `),S(V.$$.fragment,ce),q=f(ce,"-structures each of which defining a shader stage of the pipeline."),ce.forEach(l),k=Y(re),N=g(re,"LI",{});var Fe=E(N);Q=g(Fe,"CODE",{});var ke=E(Q);X=f(ke,"pushConstants"),ke.forEach(l),Z=g(Fe,"BR",{}),K=f(Fe,`
            A list of `),S(W.$$.fragment,Fe),U=f(Fe," to be bound to the pipeline."),Fe.forEach(l),G=Y(re),te=g(re,"LI",{});var Te=E(te);ee=g(Te,"CODE",{});var Me=E(ee);ne=f(Me,"pipelineCache"),Me.forEach(l),le=g(Te,"BR",{}),ae=f(Te,`
            A handle to a `),S(J.$$.fragment,Te),ue=f(Te," object."),De=g(Te,"BR",{}),de=f(Te,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),Te.forEach(l),me=Y(re),Ce=g(re,"LI",{});var Ue=E(Ce);_e=g(Ue,"CODE",{});var qe=E(_e);se=f(qe,"pBasePipeline"),qe.forEach(l),ie=g(Ue,"BR",{}),ge=f(Ue,`
            A pointer to the pipeline to derive from.`),we=g(Ue,"BR",{}),Re=f(Ue,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Ue.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),D(J,te,null),o(te,ue),o(te,De),o(te,de),o(e,me),o(e,Ce),o(Ce,_e),o(_e,se),o(Ce,ie),o(Ce,ge),o(Ce,we),o(Ce,Re),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),a.$set(he);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),A.$set(Ae);const Ve={};re&1&&(Ve.$$scope={dirty:re,ctx:Ie}),V.$set(Ve);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),W.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),J.$set(ce)},i(Ie){Be||(b(a.$$.fragment,Ie),b(A.$$.fragment,Ie),b(V.$$.fragment,Ie),b(W.$$.fragment,Ie),b(J.$$.fragment,Ie),Be=!0)},o(Ie){w(a.$$.fragment,Ie),w(A.$$.fragment,Ie),w(V.$$.fragment,Ie),w(W.$$.fragment,Ie),w(J.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(a),C(A),C(V),C(W),C(J)}}}function s5(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a5(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[s5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function o5(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Pipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags,
    std::vector<PipelineShaderStage> shaderStages, 
    std::vector<PushConstant> pushConstants,
    VkPipelineCache pipelineCache = VK_NULL_HANDLE, 
    Pipeline* pBasePipeline = nullptr
);`}}),r=new Se({props:{$$slots:{throws:[a5],params:[n5],details:[X4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class l5 extends ve{constructor(e){super(),Ee(this,e,null,o5,be,{})}}function i5(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f5(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[i5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function c5(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $5(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[c5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function u5(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkPipeline getPipelineHandle() const;"}}),r=new Se({props:{$$slots:{return:[$5],details:[f5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class p5 extends ve{constructor(e){super(),Ee(this,e,null,u5,be,{})}}function m5(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h5(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[m5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function d5(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g5(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[d5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _5(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"PipelineLayout* getPipelineLayout();"}}),r=new Se({props:{$$slots:{return:[g5],details:[h5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class v5 extends ve{constructor(e){super(),Ee(this,e,null,_5,be,{})}}function E5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w5(c){let e,t,r,$,n,s,a,u,p;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[E5]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[b5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind the pipeline to a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Before a pipeline can be used, it must be bound to a `),I(a.$$.fragment),u=i(` that executes draw or send commands. This can be done with a command. When
        this command is executed, the current pipeline (and all shaders in it) is
        used to process the commands.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Bind the pipeline to a "),S(r.$$.fragment,_),$=f(_,"."),n=g(_,"BR",{}),s=f(_,`
        Before a pipeline can be used, it must be bound to a `),S(a.$$.fragment,_),u=f(_,` that executes draw or send commands. This can be done with a command. When
        this command is executed, the current pipeline (and all shaders in it) is
        used to process the commands.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(a)}}}function I5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D5(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[I5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pCommandBuffer"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to bind to."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function C5(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set, this
        should be done by the class that extends the pipeline.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s,` if the pipeline bindpoint is not set, this
        should be done by the class that extends the pipeline.`),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function S5(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void bindToCommandBuffer(CommandBuffer* pCommandBuffer);"}}),r=new Se({props:{$$slots:{throws:[C5],params:[D5],details:[w5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class R5 extends ve{constructor(e){super(),Ee(this,e,null,S5,be,{})}}function A5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P5(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[A5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the bound "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the bound "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function B5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k5(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[B5]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[L5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function T5(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"CommandBuffer* getCommandBuffer();"}}),r=new Se({props:{$$slots:{return:[k5],details:[P5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class O5 extends ve{constructor(e){super(),Ee(this,e,null,T5,be,{})}}function V5(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y5(c){let e;return{c(){e=i("shader modules")},l(t){e=f(t,"shader modules")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M5(c){let e;return{c(){e=i("shader stages")},l(t){e=f(t,"shader stages")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H5(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[V5]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[y5]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[M5]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[F5]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[x5]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[N5]},$$scope:{ctx:c}}}),B=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[U5]},$$scope:{ctx:c}}}),O=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[G5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind all the "),I(r.$$.fragment),$=i(" defined within the "),I(n.$$.fragment),s=i(" of the "),I(a.$$.fragment),u=i(" to the bound "),I(p.$$.fragment),m=i("."),_=d("br"),v=d("br"),R=i(`
        To access the resources associated with a `),I(P.$$.fragment),A=i(", the "),I(T.$$.fragment),y=i(" must be bound to the "),I(B.$$.fragment),M=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(O.$$.fragment),x=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.
    `),this.h()},l(V){e=g(V,"SPAN",{slot:!0});var q=E(e);t=f(q,"bind all the "),S(r.$$.fragment,q),$=f(q," defined within the "),S(n.$$.fragment,q),s=f(q," of the "),S(a.$$.fragment,q),u=f(q," to the bound "),S(p.$$.fragment,q),m=f(q,"."),_=g(q,"BR",{}),v=g(q,"BR",{}),R=f(q,`
        To access the resources associated with a `),S(P.$$.fragment,q),A=f(q,", the "),S(T.$$.fragment,q),y=f(q," must be bound to the "),S(B.$$.fragment,q),M=f(q,` that executes the commands that access those descriptors. There are two
        binding points for `),S(O.$$.fragment,q),x=f(q,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.
    `),q.forEach(l),this.h()},h(){z(e,"slot","details")},m(V,q){h(V,e,q),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),o(e,_),o(e,v),o(e,R),D(P,e,null),o(e,A),D(T,e,null),o(e,y),D(B,e,null),o(e,M),D(O,e,null),o(e,x),F=!0},p(V,q){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),r.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),n.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),a.$set(Q);const X={};q&1&&(X.$$scope={dirty:q,ctx:V}),p.$set(X);const Z={};q&1&&(Z.$$scope={dirty:q,ctx:V}),P.$set(Z);const K={};q&1&&(K.$$scope={dirty:q,ctx:V}),T.$set(K);const W={};q&1&&(W.$$scope={dirty:q,ctx:V}),B.$set(W);const U={};q&1&&(U.$$scope={dirty:q,ctx:V}),O.$set(U)},i(V){F||(b(r.$$.fragment,V),b(n.$$.fragment,V),b(a.$$.fragment,V),b(p.$$.fragment,V),b(P.$$.fragment,V),b(T.$$.fragment,V),b(B.$$.fragment,V),b(O.$$.fragment,V),F=!0)},o(V){w(r.$$.fragment,V),w(n.$$.fragment,V),w(a.$$.fragment,V),w(p.$$.fragment,V),w(P.$$.fragment,V),w(T.$$.fragment,V),w(B.$$.fragment,V),w(O.$$.fragment,V),F=!1},d(V){V&&l(e),C(r),C(n),C(a),C(p),C(P),C(T),C(B),C(O)}}}function q5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W5(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[q5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(` bound.
    `),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_,` bound.
    `),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function Q5(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y5(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X5(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z5(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Q5]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[K5]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[z5]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[j5]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Y5]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[X5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind the given "),I(r.$$.fragment),$=i(" to the bound "),I(n.$$.fragment),s=i("."),a=d("br"),u=d("br"),p=i(`
        To access the resources associated with a `),I(m.$$.fragment),_=i(", the "),I(v.$$.fragment),R=i(" must be bound to the "),I(P.$$.fragment),A=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(T.$$.fragment),y=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),this.h()},l(M){e=g(M,"SPAN",{slot:!0});var O=E(e);t=f(O,"bind the given "),S(r.$$.fragment,O),$=f(O," to the bound "),S(n.$$.fragment,O),s=f(O,"."),a=g(O,"BR",{}),u=g(O,"BR",{}),p=f(O,`
        To access the resources associated with a `),S(m.$$.fragment,O),_=f(O,", the "),S(v.$$.fragment,O),R=f(O," must be bound to the "),S(P.$$.fragment,O),A=f(O,` that executes the commands that access those descriptors. There are two
        binding points for `),S(T.$$.fragment,O),y=f(O,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),O.forEach(l),this.h()},h(){z(e,"slot","details")},m(M,O){h(M,e,O),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),D(m,e,null),o(e,_),D(v,e,null),o(e,R),D(P,e,null),o(e,A),D(T,e,null),o(e,y),B=!0},p(M,O){const x={};O&1&&(x.$$scope={dirty:O,ctx:M}),r.$set(x);const F={};O&1&&(F.$$scope={dirty:O,ctx:M}),n.$set(F);const V={};O&1&&(V.$$scope={dirty:O,ctx:M}),m.$set(V);const q={};O&1&&(q.$$scope={dirty:O,ctx:M}),v.$set(q);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),P.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),T.$set(N)},i(M){B||(b(r.$$.fragment,M),b(n.$$.fragment,M),b(m.$$.fragment,M),b(v.$$.fragment,M),b(P.$$.fragment,M),b(T.$$.fragment,M),B=!0)},o(M){w(r.$$.fragment,M),w(n.$$.fragment,M),w(m.$$.fragment,M),w(v.$$.fragment,M),w(P.$$.fragment,M),w(T.$$.fragment,M),B=!1},d(M){M&&l(e),C(r),C(n),C(m),C(v),C(P),C(T)}}}function J5(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rH(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[J5]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[eH]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[tH]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[rH]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSets"),n=d("br"),s=i(`
            A list of pointers to the `),I(a.$$.fragment),u=i(" to bind to the bound "),I(p.$$.fragment),m=i("."),_=j(),v=d("li"),R=d("code"),P=i("firstSet"),A=d("br"),T=i(`
            The set number of the first `),I(y.$$.fragment),B=i(` to bind. This is used to bind a subset of the sets accessible to the
            `),I(M.$$.fragment),O=i("."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"pDescriptorSets"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A list of pointers to the `),S(a.$$.fragment,q),u=f(q," to bind to the bound "),S(p.$$.fragment,q),m=f(q,"."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"firstSet"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The set number of the first `),S(y.$$.fragment,N),B=f(N,` to bind. This is used to bind a subset of the sets accessible to the
            `),S(M.$$.fragment,N),O=f(N,"."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function sH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aH(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[sH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(" bound."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_," bound."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function oH(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $H(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[oH]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[lH]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[iH]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[fH]},$$scope:{ctx:c}}}),P=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[cH]},$$scope:{ctx:c}}}),T=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[$H]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind the given "),I(r.$$.fragment),$=i(" by name to the bound "),I(n.$$.fragment),s=i("."),a=d("br"),u=d("br"),p=i(`
        To access the resources associated with a `),I(m.$$.fragment),_=i(", the "),I(v.$$.fragment),R=i(" must be bound to the "),I(P.$$.fragment),A=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(T.$$.fragment),y=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),this.h()},l(M){e=g(M,"SPAN",{slot:!0});var O=E(e);t=f(O,"bind the given "),S(r.$$.fragment,O),$=f(O," by name to the bound "),S(n.$$.fragment,O),s=f(O,"."),a=g(O,"BR",{}),u=g(O,"BR",{}),p=f(O,`
        To access the resources associated with a `),S(m.$$.fragment,O),_=f(O,", the "),S(v.$$.fragment,O),R=f(O," must be bound to the "),S(P.$$.fragment,O),A=f(O,` that executes the commands that access those descriptors. There are two
        binding points for `),S(T.$$.fragment,O),y=f(O,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),O.forEach(l),this.h()},h(){z(e,"slot","details")},m(M,O){h(M,e,O),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),D(m,e,null),o(e,_),D(v,e,null),o(e,R),D(P,e,null),o(e,A),D(T,e,null),o(e,y),B=!0},p(M,O){const x={};O&1&&(x.$$scope={dirty:O,ctx:M}),r.$set(x);const F={};O&1&&(F.$$scope={dirty:O,ctx:M}),n.$set(F);const V={};O&1&&(V.$$scope={dirty:O,ctx:M}),m.$set(V);const q={};O&1&&(q.$$scope={dirty:O,ctx:M}),v.$set(q);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),P.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),T.$set(N)},i(M){B||(b(r.$$.fragment,M),b(n.$$.fragment,M),b(m.$$.fragment,M),b(v.$$.fragment,M),b(P.$$.fragment,M),b(T.$$.fragment,M),B=!0)},o(M){w(r.$$.fragment,M),w(n.$$.fragment,M),w(m.$$.fragment,M),w(v.$$.fragment,M),w(P.$$.fragment,M),w(T.$$.fragment,M),B=!1},d(M){M&&l(e),C(r),C(n),C(m),C(v),C(P),C(T)}}}function pH(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dH(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[pH]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[mH]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[hH]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[dH]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("names"),n=d("br"),s=i(`
            A list of names of the `),I(a.$$.fragment),u=i(" to bind to the bound "),I(p.$$.fragment),m=i("."),_=j(),v=d("li"),R=d("code"),P=i("firstSet"),A=d("br"),T=i(`
            The set number of the first `),I(y.$$.fragment),B=i(` to bind. This is used to bind a subset of the sets accessible to the
            `),I(M.$$.fragment),O=i("."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"names"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A list of names of the `),S(a.$$.fragment,q),u=f(q," to bind to the bound "),S(p.$$.fragment,q),m=f(q,"."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"firstSet"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The set number of the first `),S(y.$$.fragment,N),B=f(N,` to bind. This is used to bind a subset of the sets accessible to the
            `),S(M.$$.fragment,N),O=f(N,"."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function _H(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vH(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[_H]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(" bound."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_," bound."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function EH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return e=new $e({props:{language:pe,code:"void bindDescriptorSets();"}}),r=new Se({props:{$$slots:{throws:[W5],details:[H5]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:"void bindDescriptorSets(std::vector<DescriptorSet*> pDescriptorSets, unsigned int firstSet);"}}),u=new Se({props:{$$slots:{throws:[aH],params:[nH],details:[Z5]},$$scope:{ctx:c}}}),m=new $e({props:{language:pe,code:"void bindDescriptorSets(std::vector<std::string> names, unsigned int firstSet);"}}),v=new Se({props:{$$slots:{throws:[vH],params:[gH],details:[uH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment),p=j(),I(m.$$.fragment),_=j(),I(v.$$.fragment)},l(P){S(e.$$.fragment,P),t=Y(P),S(r.$$.fragment,P),$=g(P,"BR",{}),n=Y(P),S(s.$$.fragment,P),a=Y(P),S(u.$$.fragment,P),p=Y(P),S(m.$$.fragment,P),_=Y(P),S(v.$$.fragment,P)},m(P,A){D(e,P,A),h(P,t,A),D(r,P,A),h(P,$,A),h(P,n,A),D(s,P,A),h(P,a,A),D(u,P,A),h(P,p,A),D(m,P,A),h(P,_,A),D(v,P,A),R=!0},p(P,[A]){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),r.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),u.$set(y);const B={};A&1&&(B.$$scope={dirty:A,ctx:P}),v.$set(B)},i(P){R||(b(e.$$.fragment,P),b(r.$$.fragment,P),b(s.$$.fragment,P),b(u.$$.fragment,P),b(m.$$.fragment,P),b(v.$$.fragment,P),R=!0)},o(P){w(e.$$.fragment,P),w(r.$$.fragment,P),w(s.$$.fragment,P),w(u.$$.fragment,P),w(m.$$.fragment,P),w(v.$$.fragment,P),R=!1},d(P){C(e,P),P&&l(t),C(r,P),P&&l($),P&&l(n),C(s,P),P&&l(a),C(u,P),P&&l(p),C(m,P),P&&l(_),C(v,P)}}}class bH extends ve{constructor(e){super(),Ee(this,e,null,EH,be,{})}}function wH(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IH(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[wH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the "),I(r.$$.fragment),$=i(" of this pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the "),S(r.$$.fragment,a),$=f(a," of this pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function DH(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CH(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SH(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[DH]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[CH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to all the "),I(r.$$.fragment),$=i(" of this "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of pointers to all the "),S(r.$$.fragment,p),$=f(p," of this "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function RH(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::vector<DescriptorSet*>& getDescriptorSets();"}}),r=new Se({props:{$$slots:{return:[SH],details:[IH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class AH extends ve{constructor(e){super(),Ee(this,e,null,RH,be,{})}}function PH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BH(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[PH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a "),I(r.$$.fragment),$=i(" by name."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a "),S(r.$$.fragment,a),$=f(a," by name."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function LH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kH(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[LH]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i(" to get."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"name"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The name of the `),S(a.$$.fragment,v),u=f(v," to get."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function TH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OH(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VH(c){let e,t,r,$,n,s,a,u,p,m;return r=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[TH]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[OH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(" with the given name, or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(`
        with the given name was found.`),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"The "),S(r.$$.fragment,v),$=f(v," with the given name, or "),n=g(v,"CODE",{});var R=E(n);s=f(R,"nullptr"),R.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v,`
        with the given name was found.`),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function yH(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"DescriptorSet* getDescriptorSet(std::string name);"}}),r=new Se({props:{$$slots:{return:[VH],params:[kH],details:[BH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class MH extends ve{constructor(e){super(),Ee(this,e,null,yH,be,{})}}function FH(c){let e;return{c(){e=i("VkPipelineShaderStageCreateInfo")},l(t){e=f(t,"VkPipelineShaderStageCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xH(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NH(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UH(c){let e;return{c(){e=i("VkShaderStageFlagBits")},l(t){e=f(t,"VkShaderStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GH(c){let e;return{c(){e=i("shader module")},l(t){e=f(t,"shader module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html",target:"_blank",$$slots:{default:[UH]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[GH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("stage"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant specifying the pipeline stage."),p=j(),m=d("li"),_=d("code"),v=i("pShaderModule"),R=d("br"),P=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" containing the shader code for this stage or nullptr."),y=j(),B=d("li"),M=d("code"),O=i("name"),x=d("br"),F=i(`
            The entry point name of the shader of this stage.`),this.h()},l(q){e=g(q,"SPAN",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"stage"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            A member of the `),S(a.$$.fragment,N),u=f(N,"-enumerant specifying the pipeline stage."),N.forEach(l),p=Y(k),m=g(k,"LI",{});var X=E(m);_=g(X,"CODE",{});var Z=E(_);v=f(Z,"pShaderModule"),Z.forEach(l),R=g(X,"BR",{}),P=f(X,`
            A pointer to the `),S(A.$$.fragment,X),T=f(X," containing the shader code for this stage or nullptr."),X.forEach(l),y=Y(k),B=g(k,"LI",{});var K=E(B);M=g(K,"CODE",{});var W=E(M);O=f(W,"name"),W.forEach(l),x=g(K,"BR",{}),F=f(K,`
            The entry point name of the shader of this stage.`),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,k){h(q,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),V=!0},p(q,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:q}),a.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:q}),A.$set(Q)},i(q){V||(b(a.$$.fragment,q),b(A.$$.fragment,q),V=!0)},o(q){w(a.$$.fragment,q),w(A.$$.fragment,q),V=!1},d(q){q&&l(e),C(a),C(A)}}}function qH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return e=new $e({props:{language:pe,code:`struct PipelineShaderStage {
    VkShaderStageFlagBits stage;
    ShaderModule* pShaderModule;
    std::string name;
    // TODO: Specialization Constants
};`}}),s=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html",target:"_blank",$$slots:{default:[FH]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[xH]},$$scope:{ctx:c}}}),m=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[NH]},$$scope:{ctx:c}}}),P=new Se({props:{$$slots:{params:[HH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline Shader Stage"),n=i(` structure is used by the Pipeline to
construct the `),I(s.$$.fragment),a=i("-structure which is used by both the "),I(u.$$.fragment),p=i(" and the "),I(m.$$.fragment),_=i("."),v=d("br"),R=j(),I(P.$$.fragment)},l(T){S(e.$$.fragment,T),t=f(T,`

The `),r=g(T,"CODE",{});var y=E(r);$=f(y,"Pipeline Shader Stage"),y.forEach(l),n=f(T,` structure is used by the Pipeline to
construct the `),S(s.$$.fragment,T),a=f(T,"-structure which is used by both the "),S(u.$$.fragment,T),p=f(T," and the "),S(m.$$.fragment,T),_=f(T,"."),v=g(T,"BR",{}),R=Y(T),S(P.$$.fragment,T)},m(T,y){D(e,T,y),h(T,t,y),h(T,r,y),o(r,$),h(T,n,y),D(s,T,y),h(T,a,y),D(u,T,y),h(T,p,y),D(m,T,y),h(T,_,y),h(T,v,y),h(T,R,y),D(P,T,y),A=!0},p(T,[y]){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),s.$set(B);const M={};y&1&&(M.$$scope={dirty:y,ctx:T}),u.$set(M);const O={};y&1&&(O.$$scope={dirty:y,ctx:T}),m.$set(O);const x={};y&1&&(x.$$scope={dirty:y,ctx:T}),P.$set(x)},i(T){A||(b(e.$$.fragment,T),b(s.$$.fragment,T),b(u.$$.fragment,T),b(m.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(e.$$.fragment,T),w(s.$$.fragment,T),w(u.$$.fragment,T),w(m.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){C(e,T),T&&l(t),T&&l(r),T&&l(n),C(s,T),T&&l(a),C(u,T),T&&l(p),C(m,T),T&&l(_),T&&l(v),T&&l(R),C(P,T)}}}class WH extends ve{constructor(e){super(),Ee(this,e,null,qH,be,{})}}function QH(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KH(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zH(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[QH]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[KH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Update the value of a "),I(r.$$.fragment),$=i(" using the bound "),I(n.$$.fragment),s=i(`.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Update the value of a "),S(r.$$.fragment,p),$=f(p," using the bound "),S(n.$$.fragment,p),s=f(p,`.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function jH(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YH(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XH(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZH(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JH(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return a=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[jH]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[YH]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[XH]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[ZH]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i(" to update."),p=j(),m=d("li"),_=d("code"),v=i("upPushConstantData"),R=d("br"),P=i(`
            A `),I(A.$$.fragment),T=i(" to the new value of the "),I(y.$$.fragment),B=i(", please use "),I(M.$$.fragment),O=i(" to transfer ownership."),x=j(),this.h()},l(V){e=g(V,"DIV",{slot:!0});var q=E(e);t=g(q,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"name"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            The name of the `),S(a.$$.fragment,k),u=f(k," to update."),k.forEach(l),p=Y(q),m=g(q,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"upPushConstantData"),X.forEach(l),R=g(Q,"BR",{}),P=f(Q,`
            A `),S(A.$$.fragment,Q),T=f(Q," to the new value of the "),S(y.$$.fragment,Q),B=f(Q,", please use "),S(M.$$.fragment,Q),O=f(Q," to transfer ownership."),Q.forEach(l),x=Y(q),q.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,q){h(V,e,q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),D(M,m,null),o(m,O),o(e,x),F=!0},p(V,q){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),a.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),A.$set(N);const Q={};q&1&&(Q.$$scope={dirty:q,ctx:V}),y.$set(Q);const X={};q&1&&(X.$$scope={dirty:q,ctx:V}),M.$set(X)},i(V){F||(b(a.$$.fragment,V),b(A.$$.fragment,V),b(y.$$.fragment,V),b(M.$$.fragment,V),F=!0)},o(V){w(a.$$.fragment,V),w(A.$$.fragment,V),w(y.$$.fragment,V),w(M.$$.fragment,V),F=!1},d(V){V&&l(e),C(a),C(A),C(y),C(M)}}}function e6(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t6(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r6(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return n=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[e6]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[t6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no "),I(n.$$.fragment),s=i(" with the requested "),a=d("code"),u=i("name"),p=i(" could be found."),m=d("br"),_=i(`
        Also throws std::runtime_error if there is no `),I(v.$$.fragment),R=i(` bound.
    `),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=g(T,"CODE",{});var y=E(t);r=f(y,"std::runtime_error"),y.forEach(l),$=f(T," if no "),S(n.$$.fragment,T),s=f(T," with the requested "),a=g(T,"CODE",{});var B=E(a);u=f(B,"name"),B.forEach(l),p=f(T," could be found."),m=g(T,"BR",{}),_=f(T,`
        Also throws std::runtime_error if there is no `),S(v.$$.fragment,T),R=f(T,` bound.
    `),T.forEach(l),this.h()},h(){z(e,"slot","throws")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(e,_),D(v,e,null),o(e,R),P=!0},p(A,T){const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),n.$set(y);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),v.$set(B)},i(A){P||(b(n.$$.fragment,A),b(v.$$.fragment,A),P=!0)},o(A){w(n.$$.fragment,A),w(v.$$.fragment,A),P=!1},d(A){A&&l(e),C(n),C(v)}}}function n6(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:pe,code:`void pushConstantData(
    std::string name, 
    std::unique_ptr<PushConstantData> upPushConstantData
);`}}),r=new Se({props:{$$slots:{throws:[r6],params:[JH],details:[zH]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct SimplePushConstantData : public fillcan::PushConstantData {
    int exampleValue;
};

SimplePushConstantData data = { .exampleValue = 1 };
std::unique_ptr<SimplePushConstantData> simplePushConstantData = std::make_unique<SimplePushConstantData>(data);
graphicsPipeline.pushConstantData("SimplePushConstant", std::move(simplePushConstantData));`}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=Y(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class s6 extends ve{constructor(e){super(),Ee(this,e,null,n6,be,{})}}function a6(c){let e,t,r,$,n,s,a,u,p,m,_;return e=new $e({props:{language:pe,code:"#include <fillcan/shader/pipeline_builder.hpp>"}}),m=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
VkPipelineCreateFlags flags = 0;
std::vector<PushConstant> pushConstants = {};
VkPipelineCache pipelineCache = VK_NULL_HANDLE;
Pipeline* pBasePipeline = nullptr;`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Pipeline Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment)},l(v){S(e.$$.fragment,v),t=f(v,`
The `),r=g(v,"CODE",{});var R=E(r);$=f(R,"Pipeline Builder"),R.forEach(l),n=f(v,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(v,"BR",{}),a=f(v,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(v,"BR",{}),p=f(v,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,v)},m(v,R){D(e,v,R),h(v,t,R),h(v,r,R),o(r,$),h(v,n,R),h(v,s,R),h(v,a,R),h(v,u,R),h(v,p,R),D(m,v,R),_=!0},p:Oe,i(v){_||(b(e.$$.fragment,v),b(m.$$.fragment,v),_=!0)},o(v){w(e.$$.fragment,v),w(m.$$.fragment,v),_=!1},d(v){C(e,v),v&&l(t),v&&l(r),v&&l(n),v&&l(s),v&&l(a),v&&l(u),v&&l(p),C(m,v)}}}class o6 extends ve{constructor(e){super(),Ee(this,e,null,a6,be,{})}}function l6(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i6(c){let e,t,r,$,n,s,a,u,p,m;return u=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[l6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Pipeline Builder."),r=d("br"),$=i(`
        The `),n=d("code"),s=i("Pipeline Builder"),a=i(` class is meant to be extended as it
        only asks for the generic information shared by all `),I(u.$$.fragment),p=i("."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"Create a new Pipeline Builder."),r=g(v,"BR",{}),$=f(v,`
        The `),n=g(v,"CODE",{});var R=E(n);s=f(R,"Pipeline Builder"),R.forEach(l),a=f(v,` class is meant to be extended as it
        only asks for the generic information shared by all `),S(u.$$.fragment,v),p=f(v,"."),v.forEach(l),this.h()},h(){z(e,"slot","details")},m(_,v){h(_,e,v),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(u.$$.fragment,_),m=!0)},o(_){w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(u)}}}function f6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"PipelineBuilder();"}}),r=new Se({props:{$$slots:{details:[i6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class c6 extends ve{constructor(e){super(),Ee(this,e,null,f6,be,{})}}function $6(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u6(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p6(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[$6]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[u6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function m6(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h6(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d6(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[m6]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[h6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(`
            should be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P,`
            should be associated with.`),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function g6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[d6],details:[p6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _6 extends ve{constructor(e){super(),Ee(this,e,null,g6,be,{})}}function v6(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E6(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[v6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function b6(c){let e;return{c(){e=i("VkPipelineCreateFlags")},l(t){e=f(t,"VkPipelineCreateFlags")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w6(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlags.html",target:"_blank",$$slots:{default:[b6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" controlling how the pipeline is created."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"flags"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A bitmask of `),S(a.$$.fragment,v),u=f(v," controlling how the pipeline is created."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function I6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFlags(VkPipelineCreateFlags flags);"}}),r=new Se({props:{$$slots:{params:[w6],details:[E6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class D6 extends ve{constructor(e){super(),Ee(this,e,null,I6,be,{})}}function C6(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S6(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[C6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," for the pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function R6(c){let e;return{c(){e=i("VkPushConstantRange")},l(t){e=f(t,"VkPushConstantRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A6(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return R=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html",target:"_blank",$$slots:{default:[R6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The identifying name for the push constant.`),a=j(),u=d("li"),p=d("code"),m=i("pushConstantRange"),_=d("br"),v=i(`
            A `),I(R.$$.fragment),P=i("-structure defining the size and offset of the push constant."),this.h()},l(T){e=g(T,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var B=E(t);r=g(B,"CODE",{});var M=E(r);$=f(M,"name"),M.forEach(l),n=g(B,"BR",{}),s=f(B,`
            The identifying name for the push constant.`),B.forEach(l),a=Y(y),u=g(y,"LI",{});var O=E(u);p=g(O,"CODE",{});var x=E(p);m=f(x,"pushConstantRange"),x.forEach(l),_=g(O,"BR",{}),v=f(O,`
            A `),S(R.$$.fragment,O),P=f(O,"-structure defining the size and offset of the push constant."),O.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(T,y){h(T,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),R.$set(B)},i(T){A||(b(R.$$.fragment,T),A=!0)},o(T){w(R.$$.fragment,T),A=!1},d(T){T&&l(e),C(R)}}}function P6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void addPushConstant(std::string name, VkPushConstantRange pushConstantRange);"}}),r=new Se({props:{$$slots:{params:[A6],details:[S6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class B6 extends ve{constructor(e){super(),Ee(this,e,null,P6,be,{})}}function L6(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k6(c){let e,t,r,$,n;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[L6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," for the pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function T6(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O6(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V6(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y6(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M6(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F6(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x6(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N6(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U6(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[T6]},$$scope:{ctx:c}}}),_=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[O6]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[V6]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[y6]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[M6]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[F6]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[x6]},$$scope:{ctx:c}}}),V=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[N6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineCache"),n=d("br"),s=i(`
            A handle to a `),I(a.$$.fragment),u=i(" object."),p=d("br"),m=i(`
            Allows the result of `),I(_.$$.fragment),v=i(" construction to be reused between "),I(R.$$.fragment),P=i(`
            and between runs of an application. Reuse between `),I(A.$$.fragment),T=i(" is achieved by passing the same "),I(y.$$.fragment),B=i(` object when creating multiple related
            `),I(M.$$.fragment),O=i(`.
            Reuse across runs of an application is achieved by retrieving
            `),I(x.$$.fragment),F=i(` contents in one run of an application, saving the contents, and using
            them to preinitialize a `),I(V.$$.fragment),q=i(" on a subsequent run."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"pipelineCache"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            A handle to a `),S(a.$$.fragment,X),u=f(X," object."),p=g(X,"BR",{}),m=f(X,`
            Allows the result of `),S(_.$$.fragment,X),v=f(X," construction to be reused between "),S(R.$$.fragment,X),P=f(X,`
            and between runs of an application. Reuse between `),S(A.$$.fragment,X),T=f(X," is achieved by passing the same "),S(y.$$.fragment,X),B=f(X,` object when creating multiple related
            `),S(M.$$.fragment,X),O=f(X,`.
            Reuse across runs of an application is achieved by retrieving
            `),S(x.$$.fragment,X),F=f(X,` contents in one run of an application, saving the contents, and using
            them to preinitialize a `),S(V.$$.fragment,X),q=f(X," on a subsequent run."),X.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),D(_,t,null),o(t,v),D(R,t,null),o(t,P),D(A,t,null),o(t,T),D(y,t,null),o(t,B),D(M,t,null),o(t,O),D(x,t,null),o(t,F),D(V,t,null),o(t,q),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),_.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),R.$set(K);const W={};Q&1&&(W.$$scope={dirty:Q,ctx:N}),A.$set(W);const U={};Q&1&&(U.$$scope={dirty:Q,ctx:N}),y.$set(U);const G={};Q&1&&(G.$$scope={dirty:Q,ctx:N}),M.$set(G);const te={};Q&1&&(te.$$scope={dirty:Q,ctx:N}),x.$set(te);const ee={};Q&1&&(ee.$$scope={dirty:Q,ctx:N}),V.$set(ee)},i(N){k||(b(a.$$.fragment,N),b(_.$$.fragment,N),b(R.$$.fragment,N),b(A.$$.fragment,N),b(y.$$.fragment,N),b(M.$$.fragment,N),b(x.$$.fragment,N),b(V.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(_.$$.fragment,N),w(R.$$.fragment,N),w(A.$$.fragment,N),w(y.$$.fragment,N),w(M.$$.fragment,N),w(x.$$.fragment,N),w(V.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(_),C(R),C(A),C(y),C(M),C(x),C(V)}}}function G6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setPipelineCache(VkPipelineCache pipelineCache);"}}),r=new Se({props:{$$slots:{params:[U6],details:[k6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class H6 extends ve{constructor(e){super(),Ee(this,e,null,G6,be,{})}}function q6(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W6(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Q6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[W6],default:[q6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class K6 extends ve{constructor(e){super(),Ee(this,e,null,Q6,be,{})}}function z6(c){let e,t;return{c(){e=d("span"),t=i("Set the base pipeline for the pipeline."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the base pipeline for the pipeline."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function j6(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y6(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[j6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pBasePipeline"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to derive from."),p=d("br"),m=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pBasePipeline"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," to derive from."),p=g(P,"BR",{}),m=f(P,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P)},i(v){_||(b(a.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),_=!1},d(v){v&&l(e),C(a)}}}function X6(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setPipelineCache(VkPipelineCache pipelineCache);"}}),r=new Se({props:{$$slots:{params:[Y6],details:[z6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Z6 extends ve{constructor(e){super(),Ee(this,e,null,X6,be,{})}}function J6(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e7(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t7(c){let e;return{c(){e=i("VkPhysicalDeviceProperties")},l(t){e=f(t,"VkPhysicalDeviceProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r7(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n7(c){let e;return{c(){e=i("vkCmdDispatch")},l(t){e=f(t,"vkCmdDispatch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s7(c){let e;return{c(){e=i("vkCmdDispatch")},l(t){e=f(t,"vkCmdDispatch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a7(c){let e;return{c(){e=i("vkCmdDispatchIndirect")},l(t){e=f(t,"vkCmdDispatchIndirect")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o7(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie;return e=new $e({props:{language:pe,code:"#include <fillcan/computing/compute_pipeline.hpp>"}}),a=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[J6]},$$scope:{ctx:c}}}),y=new $e({props:{language:pe,code:`#version 450 core
layout (local_size_x = 2, local_size_y, local_size = 4) in;

void main(void)
{
    // Do something
}`}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html",target:"_blank",$$slots:{default:[e7]},$$scope:{ctx:c}}}),Z=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html",target:"_blank",$$slots:{default:[t7]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[r7]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html",target:"_blank",$$slots:{default:[n7]},$$scope:{ctx:c}}}),me=new $e({props:{language:hn,code:`#version 450 core

layout (local_size_x=256, local_size_y=1, local_size_z=1) in;

layout (set=0, binding=0) uniform Config
{
    int transform;
    int integerCount;
} configData;
        
layout (set=0, binding=1) readonly buffer InputBuffer
{
    int integers[4096];
} inputData;
        
layout (set=0, binding=2) buffer OutputBuffer
{
    int integers[4096];
} outputData;
        
void main(void)
{
    // Grab global ID
    uint globalID = gl_GlobalInvocationID.x;
        
    // Don't access past the buffer size
    if (globalID < configData.integerCount)
    {
        // Perform some calculations
        outputData.integers[globalID] = inputData.integers[globalID] * configData.transform;
    }
}`}}),_e=new $e({props:{language:pe,code:`// Create recording to gain access to a primary commandbuffer
fillcan::CommandRecording* pComputeCommandRecording = fillcan.getCurrentDevice()->getComputeQueue()->createRecording(1, 0);
fillcan::CommandBuffer* pComputePrimaryCommandBuffer = pComputeCommandRecording->pPrimaryCommandBuffers.at(0);

// Begin compute recording commands
pComputePrimaryCommandBuffer->begin();

// Bind a command buffer to the compute pipeline
upComputePipeline->bindToCommandBuffer(pComputePrimaryCommandBuffer);

// Bind the descriptor sets to the bound command buffer
upComputePipeline->bindDescriptorSets();

// Define the amount of local workgroups for the x-dimension
// (the amount of computations to execute divided by the size of the local workgroup)
int groupCount = ((4096) / 256) + 1;

// Dispatch all the work
vkCmdDispatch(pComputePrimaryCommandBuffer->getCommandBufferHandle(), groupCount, 1, 1);

// End the recording
pComputePrimaryCommandBuffer->end();`}}),ge=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html",target:"_blank",$$slots:{default:[s7]},$$scope:{ctx:c}}}),Re=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html",target:"_blank",$$slots:{default:[a7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Compute Pipeline"),n=i(` class extends the
`),s=d("code"),I(a.$$.fragment),u=i(`
class.`),p=d("br"),m=d("br"),_=i(`
The compute shader provides direct access to the computing capabilities of the Vulkan
device. The device can be thought of as a collection of broad vector processing units
operating on related data. A compute shader is written as if it were a serial, single
run track. However, many of these run tracks can run simultaneously. This is how
most Vulkan devices are built. Each track of execution is called an invocation.`),v=d("br"),R=i(`
When a compute shader is running, many calls are made at once. The invocations are
grouped into fixed size local workgroups, then one or more of these groups are run
together in what is sometimes known as a global workgroup. Logically, both the local
and global workgroups are three-dimensional. However, if the size of one of the three
dimensions is set to one, the dimensionality of the group is reduced.`),P=d("br"),A=d("br"),T=i(`
Once a pipeline is tied, it can be used to perform work. Compute shaders that run
as part of a compute pipeline run in groups called local workgroups. The size of
the local workgroup is set in the compute shader. In GLSL this is done using a layout
qualifier:
`),I(y.$$.fragment),B=i(`
The maximum size of a local workgroup for a compute shader is generally quite small
and only needs to be a minimum of 128 calls in the x and y dimensions and 64 calls
in the z dimension. Furthermore, the total "volume" of the workgroup (the product
of the limit in x, y, and z directions) is subject to a further limit, which may
only be a minimum of 128 x 128 x 64 invocations. While many implementations support
higher limits, the limits should always be queried if the required minimums are to
be exceeded.`),M=d("br"),O=i(`
The maximum size of a workgroup and the maximum total calls in the workgroup can
be determined from the `),x=d("code"),F=i("maxComputeWorkGroupSize"),V=i(` field and
`),q=d("code"),k=i("maxComputeWorkGroupInvocations"),N=i(`
field, respectively, of the `),I(Q.$$.fragment),X=i("-structure within the "),I(Z.$$.fragment),K=i("-structure returned by a call to "),I(W.$$.fragment),U=i("."),G=d("br"),te=d("br"),ee=i(`
Because there are limitations to the use of some local workgroups, local workgroups
are started in larger groups, also called the global workgroup or "dispatch". Kicking
off work in a compute shader is therefore called dispatch work or a dispatch (or
"dispatch"). The local workgroup is logically a 3D construct, or a volume of invocations,
although as many as one or two of the dimensions may have a single invocation in
size, flattening the workgroup in that direction. Likewise, these local workgroups
are sent together in three dimensions, even if one or more of those dimensions is
a single workgroup deep (so 32 x 32 x 1 and 64 x 1 x 1 workgroups is valid).`),ne=d("br"),le=i(`
The command to dispatch a global workgroup using a compute pipeline is `),I(ae.$$.fragment),J=i("."),ue=d("br"),De=d("br"),de=i(`

Example:
`),I(me.$$.fragment),Ce=j(),I(_e.$$.fragment),se=d("br"),ie=i(`
In addition to being able to specify the number of workgroups in the dispatch using
parameters to `),I(ge.$$.fragment),we=i(`, it is possible to perform an indirect dispatch, where the size of the
dispatch in workgroups comes from a buffer object. This allows the calculation
of send sizes after a command buffer is built by performing an indirect dispatch
using a buffer and then overwriting the contents of the buffer using the host.
The contents of the buffer can even be updated using the device itself to
provide a limited means for the device to feed itself work. This can be done
with `),I(Re.$$.fragment),Be=i(".")},l(re){S(e.$$.fragment,re),t=f(re,`

The `),r=g(re,"CODE",{});var he=E(r);$=f(he,"Compute Pipeline"),he.forEach(l),n=f(re,` class extends the
`),s=g(re,"CODE",{});var Ae=E(s);S(a.$$.fragment,Ae),Ae.forEach(l),u=f(re,`
class.`),p=g(re,"BR",{}),m=g(re,"BR",{}),_=f(re,`
The compute shader provides direct access to the computing capabilities of the Vulkan
device. The device can be thought of as a collection of broad vector processing units
operating on related data. A compute shader is written as if it were a serial, single
run track. However, many of these run tracks can run simultaneously. This is how
most Vulkan devices are built. Each track of execution is called an invocation.`),v=g(re,"BR",{}),R=f(re,`
When a compute shader is running, many calls are made at once. The invocations are
grouped into fixed size local workgroups, then one or more of these groups are run
together in what is sometimes known as a global workgroup. Logically, both the local
and global workgroups are three-dimensional. However, if the size of one of the three
dimensions is set to one, the dimensionality of the group is reduced.`),P=g(re,"BR",{}),A=g(re,"BR",{}),T=f(re,`
Once a pipeline is tied, it can be used to perform work. Compute shaders that run
as part of a compute pipeline run in groups called local workgroups. The size of
the local workgroup is set in the compute shader. In GLSL this is done using a layout
qualifier:
`),S(y.$$.fragment,re),B=f(re,`
The maximum size of a local workgroup for a compute shader is generally quite small
and only needs to be a minimum of 128 calls in the x and y dimensions and 64 calls
in the z dimension. Furthermore, the total "volume" of the workgroup (the product
of the limit in x, y, and z directions) is subject to a further limit, which may
only be a minimum of 128 x 128 x 64 invocations. While many implementations support
higher limits, the limits should always be queried if the required minimums are to
be exceeded.`),M=g(re,"BR",{}),O=f(re,`
The maximum size of a workgroup and the maximum total calls in the workgroup can
be determined from the `),x=g(re,"CODE",{});var Ve=E(x);F=f(Ve,"maxComputeWorkGroupSize"),Ve.forEach(l),V=f(re,` field and
`),q=g(re,"CODE",{});var oe=E(q);k=f(oe,"maxComputeWorkGroupInvocations"),oe.forEach(l),N=f(re,`
field, respectively, of the `),S(Q.$$.fragment,re),X=f(re,"-structure within the "),S(Z.$$.fragment,re),K=f(re,"-structure returned by a call to "),S(W.$$.fragment,re),U=f(re,"."),G=g(re,"BR",{}),te=g(re,"BR",{}),ee=f(re,`
Because there are limitations to the use of some local workgroups, local workgroups
are started in larger groups, also called the global workgroup or "dispatch". Kicking
off work in a compute shader is therefore called dispatch work or a dispatch (or
"dispatch"). The local workgroup is logically a 3D construct, or a volume of invocations,
although as many as one or two of the dimensions may have a single invocation in
size, flattening the workgroup in that direction. Likewise, these local workgroups
are sent together in three dimensions, even if one or more of those dimensions is
a single workgroup deep (so 32 x 32 x 1 and 64 x 1 x 1 workgroups is valid).`),ne=g(re,"BR",{}),le=f(re,`
The command to dispatch a global workgroup using a compute pipeline is `),S(ae.$$.fragment,re),J=f(re,"."),ue=g(re,"BR",{}),De=g(re,"BR",{}),de=f(re,`

Example:
`),S(me.$$.fragment,re),Ce=Y(re),S(_e.$$.fragment,re),se=g(re,"BR",{}),ie=f(re,`
In addition to being able to specify the number of workgroups in the dispatch using
parameters to `),S(ge.$$.fragment,re),we=f(re,`, it is possible to perform an indirect dispatch, where the size of the
dispatch in workgroups comes from a buffer object. This allows the calculation
of send sizes after a command buffer is built by performing an indirect dispatch
using a buffer and then overwriting the contents of the buffer using the host.
The contents of the buffer can even be updated using the device itself to
provide a limited means for the device to feed itself work. This can be done
with `),S(Re.$$.fragment,re),Be=f(re,".")},m(re,he){D(e,re,he),h(re,t,he),h(re,r,he),o(r,$),h(re,n,he),h(re,s,he),D(a,s,null),h(re,u,he),h(re,p,he),h(re,m,he),h(re,_,he),h(re,v,he),h(re,R,he),h(re,P,he),h(re,A,he),h(re,T,he),D(y,re,he),h(re,B,he),h(re,M,he),h(re,O,he),h(re,x,he),o(x,F),h(re,V,he),h(re,q,he),o(q,k),h(re,N,he),D(Q,re,he),h(re,X,he),D(Z,re,he),h(re,K,he),D(W,re,he),h(re,U,he),h(re,G,he),h(re,te,he),h(re,ee,he),h(re,ne,he),h(re,le,he),D(ae,re,he),h(re,J,he),h(re,ue,he),h(re,De,he),h(re,de,he),D(me,re,he),h(re,Ce,he),D(_e,re,he),h(re,se,he),h(re,ie,he),D(ge,re,he),h(re,we,he),D(Re,re,he),h(re,Be,he),Ie=!0},p(re,[he]){const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),a.$set(Ae);const Ve={};he&1&&(Ve.$$scope={dirty:he,ctx:re}),Q.$set(Ve);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),Z.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),W.$set(ce);const Pe={};he&1&&(Pe.$$scope={dirty:he,ctx:re}),ae.$set(Pe);const Fe={};he&1&&(Fe.$$scope={dirty:he,ctx:re}),ge.$set(Fe);const ke={};he&1&&(ke.$$scope={dirty:he,ctx:re}),Re.$set(ke)},i(re){Ie||(b(e.$$.fragment,re),b(a.$$.fragment,re),b(y.$$.fragment,re),b(Q.$$.fragment,re),b(Z.$$.fragment,re),b(W.$$.fragment,re),b(ae.$$.fragment,re),b(me.$$.fragment,re),b(_e.$$.fragment,re),b(ge.$$.fragment,re),b(Re.$$.fragment,re),Ie=!0)},o(re){w(e.$$.fragment,re),w(a.$$.fragment,re),w(y.$$.fragment,re),w(Q.$$.fragment,re),w(Z.$$.fragment,re),w(W.$$.fragment,re),w(ae.$$.fragment,re),w(me.$$.fragment,re),w(_e.$$.fragment,re),w(ge.$$.fragment,re),w(Re.$$.fragment,re),Ie=!1},d(re){C(e,re),re&&l(t),re&&l(r),re&&l(n),re&&l(s),C(a),re&&l(u),re&&l(p),re&&l(m),re&&l(_),re&&l(v),re&&l(R),re&&l(P),re&&l(A),re&&l(T),C(y,re),re&&l(B),re&&l(M),re&&l(O),re&&l(x),re&&l(V),re&&l(q),re&&l(N),C(Q,re),re&&l(X),C(Z,re),re&&l(K),C(W,re),re&&l(U),re&&l(G),re&&l(te),re&&l(ee),re&&l(ne),re&&l(le),C(ae,re),re&&l(J),re&&l(ue),re&&l(De),re&&l(de),C(me,re),re&&l(Ce),C(_e,re),re&&l(se),re&&l(ie),C(ge,re),re&&l(we),C(Re,re),re&&l(Be)}}}class l7 extends ve{constructor(e){super(),Ee(this,e,null,o7,be,{})}}function i7(c){let e;return{c(){e=i("Compute Pipeline Builder")},l(t){e=f(t,"Compute Pipeline Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f7(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.COMPUTE_PIPELINE_BUILDER,$$slots:{default:[i7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Compute Pipeline."),r=d("br"),$=i(`
        It is recommended to not create a Compute Pipeline by it's Constructor, but
        to use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Compute Pipeline."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Compute Pipeline by it's Constructor, but
        to use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function c7(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $7(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u7(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p7(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m7(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h7(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[c7]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[$7]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[u7]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[p7]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[m7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),y=j(),B=d("li"),M=d("code"),O=i("shaderStages"),x=d("br"),F=i(`
            A list of `),I(V.$$.fragment),q=i("-structures each of which defining a shader stage of the pipeline."),k=j(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),U=i(" to be bound to the pipeline."),G=j(),te=d("li"),ee=d("code"),ne=i("pipelineCache"),le=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),ue=i(" object."),De=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=j(),Ce=d("li"),_e=d("code"),se=i("pBasePipeline"),ie=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Re=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Ae=E(r);$=f(Ae,"pLogicalDevice"),Ae.forEach(l),n=g(he,"BR",{}),s=f(he,`
            A pointer to the `),S(a.$$.fragment,he),u=f(he," the Pipeline should be associated with."),he.forEach(l),p=Y(re),m=g(re,"LI",{});var Ve=E(m);_=g(Ve,"CODE",{});var oe=E(_);v=f(oe,"flags"),oe.forEach(l),R=g(Ve,"BR",{}),P=f(Ve,`
            A bitmask of `),S(A.$$.fragment,Ve),T=f(Ve," controlling how the pipeline is created."),Ve.forEach(l),y=Y(re),B=g(re,"LI",{});var ce=E(B);M=g(ce,"CODE",{});var Pe=E(M);O=f(Pe,"shaderStages"),Pe.forEach(l),x=g(ce,"BR",{}),F=f(ce,`
            A list of `),S(V.$$.fragment,ce),q=f(ce,"-structures each of which defining a shader stage of the pipeline."),ce.forEach(l),k=Y(re),N=g(re,"LI",{});var Fe=E(N);Q=g(Fe,"CODE",{});var ke=E(Q);X=f(ke,"pushConstants"),ke.forEach(l),Z=g(Fe,"BR",{}),K=f(Fe,`
            A list of `),S(W.$$.fragment,Fe),U=f(Fe," to be bound to the pipeline."),Fe.forEach(l),G=Y(re),te=g(re,"LI",{});var Te=E(te);ee=g(Te,"CODE",{});var Me=E(ee);ne=f(Me,"pipelineCache"),Me.forEach(l),le=g(Te,"BR",{}),ae=f(Te,`
            A handle to a `),S(J.$$.fragment,Te),ue=f(Te," object."),De=g(Te,"BR",{}),de=f(Te,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),Te.forEach(l),me=Y(re),Ce=g(re,"LI",{});var Ue=E(Ce);_e=g(Ue,"CODE",{});var qe=E(_e);se=f(qe,"pBasePipeline"),qe.forEach(l),ie=g(Ue,"BR",{}),ge=f(Ue,`
            A pointer to the pipeline to derive from.`),we=g(Ue,"BR",{}),Re=f(Ue,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Ue.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),D(J,te,null),o(te,ue),o(te,De),o(te,de),o(e,me),o(e,Ce),o(Ce,_e),o(_e,se),o(Ce,ie),o(Ce,ge),o(Ce,we),o(Ce,Re),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),a.$set(he);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),A.$set(Ae);const Ve={};re&1&&(Ve.$$scope={dirty:re,ctx:Ie}),V.$set(Ve);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),W.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),J.$set(ce)},i(Ie){Be||(b(a.$$.fragment,Ie),b(A.$$.fragment,Ie),b(V.$$.fragment,Ie),b(W.$$.fragment,Ie),b(J.$$.fragment,Ie),Be=!0)},o(Ie){w(a.$$.fragment,Ie),w(A.$$.fragment,Ie),w(V.$$.fragment,Ie),w(W.$$.fragment,Ie),w(J.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(a),C(A),C(V),C(W),C(J)}}}function d7(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g7(c){let e;return{c(){e=i("Vulkan Compute Pipeline")},l(t){e=f(t,"Vulkan Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _7(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[d7]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[g7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        Also throws std::runtime_error if the `),I(p.$$.fragment),m=i(" couldn't be created."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var P=E(t);r=f(P,"std::runtime_error"),P.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R," couldn't be created."),a=g(R,"BR",{}),u=f(R,`
        Also throws std::runtime_error if the `),S(p.$$.fragment,R),m=f(R," couldn't be created."),R.forEach(l),this.h()},h(){z(e,"slot","throws")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),n.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(p)}}}function v7(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`ComputePipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags, 
    std::vector<PipelineShaderStage> shaderStages,
    std::vector<PushConstant> pushConstants, 
    VkPipelineCache pipelineCache = VK_NULL_HANDLE, 
    Pipeline* pBasePipeline = nullptr
);`}}),r=new Se({props:{$$slots:{throws:[_7],params:[h7],details:[f7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class E7 extends ve{constructor(e){super(),Ee(this,e,null,v7,be,{})}}function b7(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return e=new $e({props:{language:pe,code:"#include <fillcan/computing/compute_pipeline_builder.hpp>"}}),R=new $e({props:{language:pe,code:"PipelineShaderStage pipelineShaderStage = {};"}}),T=new $e({props:{language:pe,code:`// Create Shader Module
std::unique_ptr<fillcan::ShaderModule> upComputeShaderModule = fillcan.createShaderModule(...);

fillcan::ComputePipelineBuilder computePipelineBuilder{};
computePipelineBuilder.setLogicalDevice(fillcan.getCurrentDevice());
computePipelineBuilder.setFlags(0);
computePipelineBuilder.setBasePipeline(nullptr);

// Set the compute shader stage
computePipelineBuilder.setShaderStage({
    .stage = VK_SHADER_STAGE_COMPUTE_BIT,
    .pShaderModule = upComputeShaderModule.get(),
    .name = "main",
});

this->upComputePipeline = computePipelineBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Command Pipeline Builder"),n=i(` class extends the
`),s=d("code"),a=i("Pipeline Builder"),u=i(`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=d("br"),m=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=d("br"),v=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(R.$$.fragment),P=d("br"),A=i(`
Example:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var M=E(r);$=f(M,"Command Pipeline Builder"),M.forEach(l),n=f(B,` class extends the
`),s=g(B,"CODE",{});var O=E(s);a=f(O,"Pipeline Builder"),O.forEach(l),u=f(B,`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=g(B,"BR",{}),m=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=g(B,"BR",{}),v=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(R.$$.fragment,B),P=g(B,"BR",{}),A=f(B,`
Example:
`),S(T.$$.fragment,B)},m(B,M){D(e,B,M),h(B,t,M),h(B,r,M),o(r,$),h(B,n,M),h(B,s,M),o(s,a),h(B,u,M),h(B,p,M),h(B,m,M),h(B,_,M),h(B,v,M),D(R,B,M),h(B,P,M),h(B,A,M),D(T,B,M),y=!0},p:Oe,i(B){y||(b(e.$$.fragment,B),b(R.$$.fragment,B),b(T.$$.fragment,B),y=!0)},o(B){w(e.$$.fragment,B),w(R.$$.fragment,B),w(T.$$.fragment,B),y=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(u),B&&l(p),B&&l(m),B&&l(_),B&&l(v),C(R,B),B&&l(P),B&&l(A),C(T,B)}}}class w7 extends ve{constructor(e){super(),Ee(this,e,null,b7,be,{})}}function I7(c){let e,t;return{c(){e=d("span"),t=i("Create a new Compute Pipeline Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Compute Pipeline Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function D7(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"ComputePipelineBuilder();"}}),r=new Se({props:{$$slots:{details:[I7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class C7 extends ve{constructor(e){super(),Ee(this,e,null,D7,be,{})}}function S7(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R7(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A7(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[S7]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[R7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function P7(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function B7(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[P7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineShaderStage"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pipelineShaderStage"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function L7(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setShaderStage(PipelineShaderStage pipelineShaderStage);"}}),r=new Se({props:{$$slots:{params:[B7],details:[A7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class k7 extends ve{constructor(e){super(),Ee(this,e,null,L7,be,{})}}function T7(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O7(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[T7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function V7(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y7(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M7(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[V7]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[y7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function F7(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x7(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[F7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function N7(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<ComputePipeline> getResult();"}}),r=new Se({props:{$$slots:{throws:[x7],return:[M7],details:[O7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class U7 extends ve{constructor(e){super(),Ee(this,e,null,N7,be,{})}}function G7(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H7(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function q7(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset() override;"}}),r=new Se({props:{$$slots:{details:[H7],default:[G7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class W7 extends ve{constructor(e){super(),Ee(this,e,null,q7,be,{})}}function Q7(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K7(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z7(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j7(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y7(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X7(c){let e;return{c(){e=i("graphics pipelines")},l(t){e=f(t,"graphics pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z7(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J7(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/render_pass.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Q7]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",$$slots:{default:[K7]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[z7]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[j7]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[Y7]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[X7]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[Z7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Render Pass"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with lists to attachments, the subpasses in which these attachments are used
and which attachments are dependent on eachother. It will use this information to
create a `),I(u.$$.fragment),p=i(" which it will wrap around to offer the ability to begin and end a rendering."),m=d("br"),_=d("br"),v=i(`
One of the things that distinguishes a Vulkan `),I(R.$$.fragment),P=i(" from a "),I(A.$$.fragment),T=i(`
is that the `),I(y.$$.fragment),B=i(` is usually used to convert pixels into images that can be further processed or
presented to the user. In complex graphics applications, the image is built over
many passes with each pass responsible for producing a different part of the scene,
applying full-frame effects such as post-processing or compositing, rendering user
interface elements, and so on. These passages can be rendered in Vulkan using a renderpass
object.`),M=d("br"),O=d("br"),x=i(`
A single renderpass object spans multiple passes or render stages over a single set
of output images. Each pass within the render pass is known as a subpass. Renderpass
objects can contain many subpasses, but even in simple applications with only a single
pass over a single output image, the renderpass object contains information about
that output image.`),F=d("br"),V=d("br"),q=i(`
All drawings must be in a render pass. Furthermore, `),I(k.$$.fragment),N=i(` need to know where they are being rendered; therefore it is necessary to create
a renderpass object before creating a `),I(Q.$$.fragment),X=i(" so that the pipeline can be told about the images it will produce.")},l(K){S(e.$$.fragment,K),t=f(K,`

The `),r=g(K,"CODE",{});var W=E(r);$=f(W,"Render Pass"),W.forEach(l),n=f(K," class takes a pointer to a "),S(s.$$.fragment,K),a=f(K,` along with lists to attachments, the subpasses in which these attachments are used
and which attachments are dependent on eachother. It will use this information to
create a `),S(u.$$.fragment,K),p=f(K," which it will wrap around to offer the ability to begin and end a rendering."),m=g(K,"BR",{}),_=g(K,"BR",{}),v=f(K,`
One of the things that distinguishes a Vulkan `),S(R.$$.fragment,K),P=f(K," from a "),S(A.$$.fragment,K),T=f(K,`
is that the `),S(y.$$.fragment,K),B=f(K,` is usually used to convert pixels into images that can be further processed or
presented to the user. In complex graphics applications, the image is built over
many passes with each pass responsible for producing a different part of the scene,
applying full-frame effects such as post-processing or compositing, rendering user
interface elements, and so on. These passages can be rendered in Vulkan using a renderpass
object.`),M=g(K,"BR",{}),O=g(K,"BR",{}),x=f(K,`
A single renderpass object spans multiple passes or render stages over a single set
of output images. Each pass within the render pass is known as a subpass. Renderpass
objects can contain many subpasses, but even in simple applications with only a single
pass over a single output image, the renderpass object contains information about
that output image.`),F=g(K,"BR",{}),V=g(K,"BR",{}),q=f(K,`
All drawings must be in a render pass. Furthermore, `),S(k.$$.fragment,K),N=f(K,` need to know where they are being rendered; therefore it is necessary to create
a renderpass object before creating a `),S(Q.$$.fragment,K),X=f(K," so that the pipeline can be told about the images it will produce.")},m(K,W){D(e,K,W),h(K,t,W),h(K,r,W),o(r,$),h(K,n,W),D(s,K,W),h(K,a,W),D(u,K,W),h(K,p,W),h(K,m,W),h(K,_,W),h(K,v,W),D(R,K,W),h(K,P,W),D(A,K,W),h(K,T,W),D(y,K,W),h(K,B,W),h(K,M,W),h(K,O,W),h(K,x,W),h(K,F,W),h(K,V,W),h(K,q,W),D(k,K,W),h(K,N,W),D(Q,K,W),h(K,X,W),Z=!0},p(K,[W]){const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),s.$set(U);const G={};W&1&&(G.$$scope={dirty:W,ctx:K}),u.$set(G);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),R.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),A.$set(ee);const ne={};W&1&&(ne.$$scope={dirty:W,ctx:K}),y.$set(ne);const le={};W&1&&(le.$$scope={dirty:W,ctx:K}),k.$set(le);const ae={};W&1&&(ae.$$scope={dirty:W,ctx:K}),Q.$set(ae)},i(K){Z||(b(e.$$.fragment,K),b(s.$$.fragment,K),b(u.$$.fragment,K),b(R.$$.fragment,K),b(A.$$.fragment,K),b(y.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(e.$$.fragment,K),w(s.$$.fragment,K),w(u.$$.fragment,K),w(R.$$.fragment,K),w(A.$$.fragment,K),w(y.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){C(e,K),K&&l(t),K&&l(r),K&&l(n),C(s,K),K&&l(a),C(u,K),K&&l(p),K&&l(m),K&&l(_),K&&l(v),C(R,K),K&&l(P),C(A,K),K&&l(T),C(y,K),K&&l(B),K&&l(M),K&&l(O),K&&l(x),K&&l(F),K&&l(V),K&&l(q),C(k,K),K&&l(N),C(Q,K),K&&l(X)}}}class eq extends ve{constructor(e){super(),Ee(this,e,null,J7,be,{})}}function tq(c){let e;return{c(){e=i("Render Pass Builder")},l(t){e=f(t,"Render Pass Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rq(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.RENDER_PASS_BUILDER,$$slots:{default:[tq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Render Pass."),r=d("br"),$=i(`
        It is recommended to not create a Render Pass by it's Constructor, but to
        use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Render Pass."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Render Pass by it's Constructor, but to
        use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function nq(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sq(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aq(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oq(c){let e;return{c(){e=i("VkSubpassDescription")},l(t){e=f(t,"VkSubpassDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lq(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iq(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[nq]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html",target:"_blank",$$slots:{default:[sq]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.IMAGE,$$slots:{default:[aq]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html",target:"_blank",$$slots:{default:[oq]},$$scope:{ctx:c}}}),ue=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html",target:"_blank",$$slots:{default:[lq]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Render Pass should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("attachments"),R=d("br"),P=i(`
            A list of `),I(A.$$.fragment),T=i("-structures."),y=d("br"),B=i(`
            Each of these structures defines a single `),I(M.$$.fragment),O=i(` to be used as input, output, or both within one or more of the subpasses
            in the render pass.`),x=j(),F=d("li"),V=d("code"),q=i("subpasses"),k=d("br"),N=i(`
            A list of `),I(Q.$$.fragment),X=i("-structures."),Z=d("br"),K=i(`
            Each of these structures defines a single subpass. Each subpass refers
            to a number of attachments (from the list given in the
            `),W=d("code"),U=i("attachments"),G=i(" field) as input or output."),te=j(),ee=d("li"),ne=d("code"),le=i("dependencies"),ae=d("br"),J=i(`
            A list of `),I(ue.$$.fragment),De=i("-structures."),de=d("br"),me=i(`
            When there is more than one subpass in a render pass, Vulkan can figure
            out which subpasses are dependent on each other by following the attachment
            references and looking for inputs and outputs that make subpasses dependent
            on each other. However, there are cases where dependencies cannot be
            easily represented by a simple input-to-output relationship. This generally
            happens when a subpass writes directly to a resource, such as an image
            or buffer, and a subsequent subpass reads that data back. Vulkan cannot
            figure this out automatically, so it must explicitly indicate such dependency
            information.`),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var se=E(e);t=g(se,"LI",{});var ie=E(t);r=g(ie,"CODE",{});var ge=E(r);$=f(ge,"pLogicalDevice"),ge.forEach(l),n=g(ie,"BR",{}),s=f(ie,`
            A pointer to the `),S(a.$$.fragment,ie),u=f(ie," the Render Pass should be associated with."),ie.forEach(l),p=Y(se),m=g(se,"LI",{});var we=E(m);_=g(we,"CODE",{});var Re=E(_);v=f(Re,"attachments"),Re.forEach(l),R=g(we,"BR",{}),P=f(we,`
            A list of `),S(A.$$.fragment,we),T=f(we,"-structures."),y=g(we,"BR",{}),B=f(we,`
            Each of these structures defines a single `),S(M.$$.fragment,we),O=f(we,` to be used as input, output, or both within one or more of the subpasses
            in the render pass.`),we.forEach(l),x=Y(se),F=g(se,"LI",{});var Be=E(F);V=g(Be,"CODE",{});var Ie=E(V);q=f(Ie,"subpasses"),Ie.forEach(l),k=g(Be,"BR",{}),N=f(Be,`
            A list of `),S(Q.$$.fragment,Be),X=f(Be,"-structures."),Z=g(Be,"BR",{}),K=f(Be,`
            Each of these structures defines a single subpass. Each subpass refers
            to a number of attachments (from the list given in the
            `),W=g(Be,"CODE",{});var re=E(W);U=f(re,"attachments"),re.forEach(l),G=f(Be," field) as input or output."),Be.forEach(l),te=Y(se),ee=g(se,"LI",{});var he=E(ee);ne=g(he,"CODE",{});var Ae=E(ne);le=f(Ae,"dependencies"),Ae.forEach(l),ae=g(he,"BR",{}),J=f(he,`
            A list of `),S(ue.$$.fragment,he),De=f(he,"-structures."),de=g(he,"BR",{}),me=f(he,`
            When there is more than one subpass in a render pass, Vulkan can figure
            out which subpasses are dependent on each other by following the attachment
            references and looking for inputs and outputs that make subpasses dependent
            on each other. However, there are cases where dependencies cannot be
            easily represented by a simple input-to-output relationship. This generally
            happens when a subpass writes directly to a resource, such as an image
            or buffer, and a subsequent subpass reads that data back. Vulkan cannot
            figure this out automatically, so it must explicitly indicate such dependency
            information.`),he.forEach(l),se.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,se){h(_e,e,se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(m,y),o(m,B),D(M,m,null),o(m,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),o(F,Z),o(F,K),o(F,W),o(W,U),o(F,G),o(e,te),o(e,ee),o(ee,ne),o(ne,le),o(ee,ae),o(ee,J),D(ue,ee,null),o(ee,De),o(ee,de),o(ee,me),Ce=!0},p(_e,se){const ie={};se&1&&(ie.$$scope={dirty:se,ctx:_e}),a.$set(ie);const ge={};se&1&&(ge.$$scope={dirty:se,ctx:_e}),A.$set(ge);const we={};se&1&&(we.$$scope={dirty:se,ctx:_e}),M.$set(we);const Re={};se&1&&(Re.$$scope={dirty:se,ctx:_e}),Q.$set(Re);const Be={};se&1&&(Be.$$scope={dirty:se,ctx:_e}),ue.$set(Be)},i(_e){Ce||(b(a.$$.fragment,_e),b(A.$$.fragment,_e),b(M.$$.fragment,_e),b(Q.$$.fragment,_e),b(ue.$$.fragment,_e),Ce=!0)},o(_e){w(a.$$.fragment,_e),w(A.$$.fragment,_e),w(M.$$.fragment,_e),w(Q.$$.fragment,_e),w(ue.$$.fragment,_e),Ce=!1},d(_e){_e&&l(e),C(a),C(A),C(M),C(Q),C(ue)}}}function fq(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cq(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkRenderPass",version:1.3,$$slots:{default:[fq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(`
        couldn't be created.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,`
        couldn't be created.`),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function $q(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`RenderPass(
    LogicalDevice* pLogicalDevice, 
    std::vector<VkAttachmentDescription> attachments, 
    std::vector<VkSubpassDescription> subpasses,
    std::vector<VkSubpassDependency> dependencies
);`}}),r=new Se({props:{$$slots:{throws:[cq],params:[iq],details:[rq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uq extends ve{constructor(e){super(),Ee(this,e,null,$q,be,{})}}function pq(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mq(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",target:"_blank",$$slots:{default:[pq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hq(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dq(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",target:"_blank",$$slots:{default:[hq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkRenderPass getRenderPassHandle() const;"}}),r=new Se({props:{$$slots:{return:[dq],details:[mq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _q extends ve{constructor(e){super(),Ee(this,e,null,gq,be,{})}}function vq(c){let e,t;return{c(){e=d("span"),t=i("Get all the attachments."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the attachments."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Eq(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bq(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkAttachmentDescription",version:1.3,$$slots:{default:[Eq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the attachments."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the attachments."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkAttachmentDescription>& getAttachments() const;"}}),r=new Se({props:{$$slots:{return:[bq],details:[vq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Iq extends ve{constructor(e){super(),Ee(this,e,null,wq,be,{})}}function Dq(c){let e,t;return{c(){e=d("span"),t=i("Get all the subpasses."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the subpasses."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Cq(c){let e;return{c(){e=i("VkSubpassDescription")},l(t){e=f(t,"VkSubpassDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sq(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkSubpassDescription",version:1.3,$$slots:{default:[Cq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the subpasses."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the subpasses."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Rq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkSubpassDescription>& getSubpasses() const;"}}),r=new Se({props:{$$slots:{return:[Sq],details:[Dq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Aq extends ve{constructor(e){super(),Ee(this,e,null,Rq,be,{})}}function Pq(c){let e,t;return{c(){e=d("span"),t=i("Get all the dependencies."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the dependencies."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Bq(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lq(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkSubpassDependency",version:1.3,$$slots:{default:[Bq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the dependencies."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the dependencies."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function kq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const std::vector<VkSubpassDependency>& getDependencies() const;"}}),r=new Se({props:{$$slots:{return:[Lq],details:[Pq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Tq extends ve{constructor(e){super(),Ee(this,e,null,kq,be,{})}}function Oq(c){let e,t,r,$;return{c(){e=d("span"),t=i("Prepare to render."),r=d("br"),$=i(`
        All drawings are in a render pass. While renderpass objects can encapsulate
        many subpasses, even a simple rendering that is included in a single output
        image must be part of a renderpass.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Prepare to render."),r=g(s,"BR",{}),$=f(s,`
        All drawings are in a render pass. While renderpass objects can encapsulate
        many subpasses, even a simple rendering that is included in a single output
        image must be part of a renderpass.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function Vq(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yq(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mq(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xq(c){let e;return{c(){e=i("VkClearValue")},l(t){e=f(t,"VkClearValue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nq(c){let e;return{c(){e=i("VkClearValue")},l(t){e=f(t,"VkClearValue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uq(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge;return a=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Vq]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[yq]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[Mq]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.IMAGE,$$slots:{default:[Fq]},$$scope:{ctx:c}}}),Q=new Bt({props:{reference:"VkClearValue",version:1.3,$$slots:{default:[xq]},$$scope:{ctx:c}}}),le=new Bt({props:{reference:"VkClearValue",version:1.3,$$slots:{default:[Nq]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" that contains the commands specified in the render pass."),p=j(),m=d("li"),_=d("code"),v=i("pFramebuffer"),R=d("br"),P=i(`
            The `),I(A.$$.fragment),T=i(" in which to render. The "),I(y.$$.fragment),B=i(" is the collection of "),I(M.$$.fragment),O=i(" rendered to by graphics commands."),x=j(),F=d("li"),V=d("code"),q=i("pClearValues"),k=d("br"),N=i(`
            A list of `),I(Q.$$.fragment),X=i(`-unions. If one of the attachments in the render pass has a load of
            `),Z=d("code"),K=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),W=i(`, then the colors or values
            to which they are cleared are specified in this array.`),U=d("br"),G=i(`
            The index of each attachment of the `),te=d("code"),ee=i("attachments"),ne=i(` field
            given in the constructor is used to index into the array of
            `),I(le.$$.fragment),ae=i(`-unions. This means that if only some of the attachments have a
            load of `),J=d("code"),ue=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),De=i(`, there may be
            unused items in the array. There must be at least as many items in
            the `),de=d("code"),me=i("pClearValues"),Ce=i(` list as the highest indexed attachment
            with a load of `),_e=d("code"),se=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),ie=i("."),this.h()},l(we){e=g(we,"DIV",{slot:!0});var Re=E(e);t=g(Re,"LI",{});var Be=E(t);r=g(Be,"CODE",{});var Ie=E(r);$=f(Ie,"pCommandBuffer"),Ie.forEach(l),n=g(Be,"BR",{}),s=f(Be,`
            The `),S(a.$$.fragment,Be),u=f(Be," that contains the commands specified in the render pass."),Be.forEach(l),p=Y(Re),m=g(Re,"LI",{});var re=E(m);_=g(re,"CODE",{});var he=E(_);v=f(he,"pFramebuffer"),he.forEach(l),R=g(re,"BR",{}),P=f(re,`
            The `),S(A.$$.fragment,re),T=f(re," in which to render. The "),S(y.$$.fragment,re),B=f(re," is the collection of "),S(M.$$.fragment,re),O=f(re," rendered to by graphics commands."),re.forEach(l),x=Y(Re),F=g(Re,"LI",{});var Ae=E(F);V=g(Ae,"CODE",{});var Ve=E(V);q=f(Ve,"pClearValues"),Ve.forEach(l),k=g(Ae,"BR",{}),N=f(Ae,`
            A list of `),S(Q.$$.fragment,Ae),X=f(Ae,`-unions. If one of the attachments in the render pass has a load of
            `),Z=g(Ae,"CODE",{});var oe=E(Z);K=f(oe,"VK_ATTACHMENT_LOAD_OP_CLEAR"),oe.forEach(l),W=f(Ae,`, then the colors or values
            to which they are cleared are specified in this array.`),U=g(Ae,"BR",{}),G=f(Ae,`
            The index of each attachment of the `),te=g(Ae,"CODE",{});var ce=E(te);ee=f(ce,"attachments"),ce.forEach(l),ne=f(Ae,` field
            given in the constructor is used to index into the array of
            `),S(le.$$.fragment,Ae),ae=f(Ae,`-unions. This means that if only some of the attachments have a
            load of `),J=g(Ae,"CODE",{});var Pe=E(J);ue=f(Pe,"VK_ATTACHMENT_LOAD_OP_CLEAR"),Pe.forEach(l),De=f(Ae,`, there may be
            unused items in the array. There must be at least as many items in
            the `),de=g(Ae,"CODE",{});var Fe=E(de);me=f(Fe,"pClearValues"),Fe.forEach(l),Ce=f(Ae,` list as the highest indexed attachment
            with a load of `),_e=g(Ae,"CODE",{});var ke=E(_e);se=f(ke,"VK_ATTACHMENT_LOAD_OP_CLEAR"),ke.forEach(l),ie=f(Ae,"."),Ae.forEach(l),Re.forEach(l),this.h()},h(){z(e,"slot","params")},m(we,Re){h(we,e,Re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),D(M,m,null),o(m,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),o(F,Z),o(Z,K),o(F,W),o(F,U),o(F,G),o(F,te),o(te,ee),o(F,ne),D(le,F,null),o(F,ae),o(F,J),o(J,ue),o(F,De),o(F,de),o(de,me),o(F,Ce),o(F,_e),o(_e,se),o(F,ie),ge=!0},p(we,Re){const Be={};Re&1&&(Be.$$scope={dirty:Re,ctx:we}),a.$set(Be);const Ie={};Re&1&&(Ie.$$scope={dirty:Re,ctx:we}),A.$set(Ie);const re={};Re&1&&(re.$$scope={dirty:Re,ctx:we}),y.$set(re);const he={};Re&1&&(he.$$scope={dirty:Re,ctx:we}),M.$set(he);const Ae={};Re&1&&(Ae.$$scope={dirty:Re,ctx:we}),Q.$set(Ae);const Ve={};Re&1&&(Ve.$$scope={dirty:Re,ctx:we}),le.$set(Ve)},i(we){ge||(b(a.$$.fragment,we),b(A.$$.fragment,we),b(y.$$.fragment,we),b(M.$$.fragment,we),b(Q.$$.fragment,we),b(le.$$.fragment,we),ge=!0)},o(we){w(a.$$.fragment,we),w(A.$$.fragment,we),w(y.$$.fragment,we),w(M.$$.fragment,we),w(Q.$$.fragment,we),w(le.$$.fragment,we),ge=!1},d(we){we&&l(e),C(a),C(A),C(y),C(M),C(Q),C(le)}}}function Gq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`void begin(
    CommandBuffer* pCommandBuffer, 
    Framebuffer* pFramebuffer, 
    std::vector<VkClearValue>* pClearValues = nullptr,
    VkRect2D* pRenderArea = nullptr
);`}}),r=new Se({props:{$$slots:{params:[Uq],details:[Oq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Hq extends ve{constructor(e){super(),Ee(this,e,null,Gq,be,{})}}function qq(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wq(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qq(c){let e;return{c(){e=i("begin")},l(t){e=f(t,"begin")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kq(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return n=new H({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[qq]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[Wq]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.RENDER_PASS_begin,$$slots:{default:[Qq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Terminate the rendering in the render pass."),r=d("br"),$=i(`
        Once the render pass has started, drawing commands can be placed in the `),I(n.$$.fragment),s=i(". All rendering is directed to the "),I(a.$$.fragment),u=i(` specified in the
        `),p=d("code"),m=i("framebuffer"),_=i(" field passed to "),I(v.$$.fragment),R=i("."),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=f(T,"Terminate the rendering in the render pass."),r=g(T,"BR",{}),$=f(T,`
        Once the render pass has started, drawing commands can be placed in the `),S(n.$$.fragment,T),s=f(T,". All rendering is directed to the "),S(a.$$.fragment,T),u=f(T,` specified in the
        `),p=g(T,"CODE",{});var y=E(p);m=f(y,"framebuffer"),y.forEach(l),_=f(T," field passed to "),S(v.$$.fragment,T),R=f(T,"."),T.forEach(l),this.h()},h(){z(e,"slot","details")},m(A,T){h(A,e,T),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,R),P=!0},p(A,T){const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),n.$set(y);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),a.$set(B);const M={};T&1&&(M.$$scope={dirty:T,ctx:A}),v.$set(M)},i(A){P||(b(n.$$.fragment,A),b(a.$$.fragment,A),b(v.$$.fragment,A),P=!0)},o(A){w(n.$$.fragment,A),w(a.$$.fragment,A),w(v.$$.fragment,A),P=!1},d(A){A&&l(e),C(n),C(a),C(v)}}}function zq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void end();"}}),r=new Se({props:{$$slots:{details:[Kq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jq extends ve{constructor(e){super(),Ee(this,e,null,zq,be,{})}}function Yq(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/render_pass_builder.hpp>"}}),m=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
std::vector<VkAttachmentDescription> attachmentDescriptions = {};
std::vector<VkAttachmentReference> inputAttachments = {};
std::vector<VkAttachmentReference> colorAttachments = {};
std::unique_ptr<VkAttachmentReference> upDepthStencilAttachment = nullptr;
std::vector<uint32_t> preserveAttachments = {};
bool resolveCurrentBatch = false;
std::vector<VkSubpassDescription> subpassDescriptions = {};
std::vector<VkSubpassDependency> dependencyDescriptions = {};`}}),R=new $e({props:{language:pe,code:`fillcan::RenderPassBuilder renderPassBuilder = {};
renderPassBuilder.setLogicalDevice(fillcan.getCurrentDevice());

// Add attachment for subpass 1 describing the swapchain image
unsigned int swapChainAttachmentIndex = renderPassBuilder.addAttachment(
    {
        .flags = 0,
        .format = fillcan.getSwapchain()->getSurfaceFormat().format,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    }
);
// Add the attachment to the subpass 1 as a color attachment
renderPassBuilder.addColorAttachment(swapChainAttachmentIndex, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, false);

// Add attachment for subpass 1 describing the depth image
std::optional<VkFormat> depthImageFormat = fillcan.getCurrentDevice()->getPhysicalDevice()->findSupportedFormat(
    { VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT }, 
    VK_IMAGE_TILING_OPTIMAL,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
);
if (!depthImageFormat.has_value()) {
    throw std::runtime_error("Failed to find a supported format for the depth image attachment.");
}
unsigned int depthImageAttachmentIndex = renderPassBuilder.addAttachment(
    {
        .flags = 0,
        .format = depthImageFormat.value(),
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
    }
);
// Add the attachment to subpass 1 as a depthstencil attachment
renderPassBuilder.setDepthStencilAttachment(depthImageAttachmentIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, false);

// Construct subpass 1, this will combine any attachments described before into a new subpass
unsigned int subpassIndex = renderPassBuilder.constructSubpass();

// Add a dependency for subpass 1 to make sure the subpass waits for the previous stages before executing
renderPassBuilder.addDependency(
    {
        .srcSubpass = VK_SUBPASS_EXTERNAL,
        .dstSubpass = subpassIndex,
        .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .srcAccessMask = 0,
        .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
    }
);

std::unique_ptr<fillcan::RenderPass> upRenderPass = renderPassBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Render Pass Builder"),n=i(` class is part of the creational design
pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(R.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Render Pass Builder"),T.forEach(l),n=f(A,` class is part of the creational design
pattern to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(R.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(R,A,T),P=!0},p:Oe,i(A){P||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(R.$$.fragment,A),P=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(R.$$.fragment,A),P=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(R,A)}}}class Xq extends ve{constructor(e){super(),Ee(this,e,null,Yq,be,{})}}function Zq(c){let e,t;return{c(){e=d("span"),t=i("Create a new Render Pass Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Render Pass Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Jq(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"RenderPassBuilder();"}}),r=new Se({props:{$$slots:{details:[Zq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class e8 extends ve{constructor(e){super(),Ee(this,e,null,Jq,be,{})}}function t8(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n8(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[t8]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[r8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function s8(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o8(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[s8]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[a8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P," should be associated with."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function l8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[o8],details:[n8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class i8 extends ve{constructor(e){super(),Ee(this,e,null,l8,be,{})}}function f8(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $8(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[f8]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[c8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function u8(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p8(c){let e,t,r,$,n,s,a,u,p;return a=new Bt({props:{reference:"VkAttachmentDescription",version:1.3,$$slots:{default:[u8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescription"),n=d("br"),s=i(`
            A `),I(a.$$.fragment),u=i(`-structure. this structure defines a single image to be used as
            input, output, or both within one or more of the subpasses in the
            render pass.`),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"attachmentDescription"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A `),S(a.$$.fragment,v),u=f(v,`-structure. this structure defines a single image to be used as
            input, output, or both within one or more of the subpasses in the
            render pass.`),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function m8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[p8],details:[$8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class h8 extends ve{constructor(e){super(),Ee(this,e,null,m8,be,{})}}function d8(c){let e,t;return{c(){e=d("span"),t=i(`Define a single input attachment, which is an attachment from which data
        can be read.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Define a single input attachment, which is an attachment from which data
        can be read.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function g8(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _8(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return m=new H({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[g8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=j(),R=d("li"),P=d("code"),A=i("layout"),T=d("br"),y=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=j(),M=d("li"),O=d("code"),x=i("preserve"),F=d("br"),V=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=Y(N),R=g(N,"LI",{});var K=E(R);P=g(K,"CODE",{});var W=E(P);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),y=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=Y(N),M=g(N,"LI",{});var U=E(M);O=g(U,"CODE",{});var G=E(O);x=f(G,"preserve"),G.forEach(l),F=g(U,"BR",{}),V=f(U,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),U.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,R),o(R,P),o(P,A),o(R,T),o(R,y),o(e,B),o(e,M),o(M,O),o(O,x),o(M,F),o(M,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){q||(b(m.$$.fragment,k),q=!0)},o(k){w(m.$$.fragment,k),q=!1},d(k){k&&l(e),C(m)}}}function v8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void addInputAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Se({props:{$$slots:{params:[_8],details:[d8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class E8 extends ve{constructor(e){super(),Ee(this,e,null,v8,be,{})}}function b8(c){let e,t;return{c(){e=d("span"),t=i(`Define a single color attachment, which is an attachment to which the
        output of the subpass is written.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Define a single color attachment, which is an attachment to which the
        output of the subpass is written.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function w8(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I8(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return m=new H({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[w8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=j(),R=d("li"),P=d("code"),A=i("layout"),T=d("br"),y=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=j(),M=d("li"),O=d("code"),x=i("preserve"),F=d("br"),V=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=Y(N),R=g(N,"LI",{});var K=E(R);P=g(K,"CODE",{});var W=E(P);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),y=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=Y(N),M=g(N,"LI",{});var U=E(M);O=g(U,"CODE",{});var G=E(O);x=f(G,"preserve"),G.forEach(l),F=g(U,"BR",{}),V=f(U,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),U.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,R),o(R,P),o(P,A),o(R,T),o(R,y),o(e,B),o(e,M),o(M,O),o(O,x),o(M,F),o(M,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){q||(b(m.$$.fragment,k),q=!0)},o(k){w(m.$$.fragment,k),q=!1},d(k){k&&l(e),C(m)}}}function D8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void addColorAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Se({props:{$$slots:{params:[I8],details:[b8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class C8 extends ve{constructor(e){super(),Ee(this,e,null,D8,be,{})}}function S8(c){let e,t;return{c(){e=d("span"),t=i("Define the depth and stencil buffer for this subpass."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Define the depth and stencil buffer for this subpass."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function R8(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A8(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q;return m=new H({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[R8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=j(),R=d("li"),P=d("code"),A=i("layout"),T=d("br"),y=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=j(),M=d("li"),O=d("code"),x=i("preserve"),F=d("br"),V=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=Y(N),R=g(N,"LI",{});var K=E(R);P=g(K,"CODE",{});var W=E(P);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),y=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=Y(N),M=g(N,"LI",{});var U=E(M);O=g(U,"CODE",{});var G=E(O);x=f(G,"preserve"),G.forEach(l),F=g(U,"BR",{}),V=f(U,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),U.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,R),o(R,P),o(P,A),o(R,T),o(R,y),o(e,B),o(e,M),o(M,O),o(O,x),o(M,F),o(M,V),q=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){q||(b(m.$$.fragment,k),q=!0)},o(k){w(m.$$.fragment,k),q=!1},d(k){k&&l(e),C(m)}}}function P8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setDepthStencilAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Se({props:{$$slots:{params:[A8],details:[S8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class B8 extends ve{constructor(e){super(),Ee(this,e,null,P8,be,{})}}function L8(c){let e,t;return{c(){e=d("span"),t=i(`Mark the current batch of color attachments as resolved, these are
        attachments to which multisample image data is converted.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Mark the current batch of color attachments as resolved, these are
        attachments to which multisample image data is converted.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function k8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void resolveCurrentAttachments();"}}),r=new Se({props:{$$slots:{details:[L8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class T8 extends ve{constructor(e){super(),Ee(this,e,null,k8,be,{})}}function O8(c){let e,t;return{c(){e=d("span"),t=i(`Construct a new subpass from the current batch of attachments. The
        current batch contains all the attachments added after the last subpass
        construction or after the initialization of the builder.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Construct a new subpass from the current batch of attachments. The
        current batch contains all the attachments added after the last subpass
        construction or after the initialization of the builder.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function V8(c){let e,t;return{c(){e=d("span"),t=i("The index of the newly constructed subpass."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of the newly constructed subpass."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function y8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int constructSubpass();"}}),r=new Se({props:{$$slots:{return:[V8],details:[O8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class M8 extends ve{constructor(e){super(),Ee(this,e,null,y8,be,{})}}function F8(c){let e,t,r,$,n;return{c(){e=d("span"),t=i("Add a subpass dependency."),r=d("br"),$=d("br"),n=i(`
        When there is more than one subpass in a render pass, Vulkan can figure out
        which subpasses are dependent on each other by following the attachment references
        and looking for inputs and outputs that make subpasses dependent on each
        other. However, there are cases where dependencies cannot be easily represented
        by a simple input-to-output relationship. This generally happens when a subpass
        writes directly to a resource, such as an image or buffer, and a subsequent
        subpass reads that data back. Vulkan cannot figure this out automatically,
        so it must explicitly indicate such dependency information.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Add a subpass dependency."),r=g(a,"BR",{}),$=g(a,"BR",{}),n=f(a,`
        When there is more than one subpass in a render pass, Vulkan can figure out
        which subpasses are dependent on each other by following the attachment references
        and looking for inputs and outputs that make subpasses dependent on each
        other. However, there are cases where dependencies cannot be easily represented
        by a simple input-to-output relationship. This generally happens when a subpass
        writes directly to a resource, such as an image or buffer, and a subsequent
        subpass reads that data back. Vulkan cannot figure this out automatically,
        so it must explicitly indicate such dependency information.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),o(e,r),o(e,$),o(e,n)},p:Oe,d(s){s&&l(e)}}}function x8(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N8(c){let e;return{c(){e=i("constructSubpass")},l(t){e=f(t,"constructSubpass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U8(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new Bt({props:{reference:"VkSubpassDependency",version:1.3,$$slots:{default:[x8]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.RENDER_PASS_BUILDER_constructSubpass,$$slots:{default:[N8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dependencyDescription"),n=d("br"),s=i(`
            A `),I(a.$$.fragment),u=i(`-structure. The indices of both the source subpass and the
            destination subpass can be determined using the index return by `),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"dependencyDescription"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A `),S(a.$$.fragment,P),u=f(P,`-structure. The indices of both the source subpass and the
            destination subpass can be determined using the index return by `),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function G8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void addDependency(VkSubpassDependency dependencyDescription);"}}),r=new Se({props:{$$slots:{params:[U8],details:[F8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class H8 extends ve{constructor(e){super(),Ee(this,e,null,G8,be,{})}}function q8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W8(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[q8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Q8(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z8(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[Q8]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[K8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function j8(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y8(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[j8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function X8(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<RenderPass> getResult();"}}),r=new Se({props:{$$slots:{throws:[Y8],return:[z8],details:[W8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Z8 extends ve{constructor(e){super(),Ee(this,e,null,X8,be,{})}}function J8(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eW(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function tW(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[eW],default:[J8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rW extends ve{constructor(e){super(),Ee(this,e,null,tW,be,{})}}function nW(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sW(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aW(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oW(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lW(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fW(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $W(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pW(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mW(c){let e;return{c(){e=i("graphics pipelines")},l(t){e=f(t,"graphics pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dW(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/framebuffer.hpp>"}}),s=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[nW]},$$scope:{ctx:c}}}),u=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[sW]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",$$slots:{default:[aW]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[oW]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[lW]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[iW]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.IMAGE,$$slots:{default:[fW]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[cW]},$$scope:{ctx:c}}}),k=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[$W]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[uW]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.IMAGE,$$slots:{default:[pW]},$$scope:{ctx:c}}}),te=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[mW]},$$scope:{ctx:c}}}),ne=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[hW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Frambuffer"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to a "),I(u.$$.fragment),p=i(` along with lists of attachments, the width, the height and a number of array layers.
It uses this information to create a `),I(m.$$.fragment),_=i("."),v=d("br"),R=d("br"),P=i(`
A `),I(A.$$.fragment),T=i(` renders to
a Framebuffer. The framebuffer links to the `),I(y.$$.fragment),B=i(" being rendered to and is used when starting a "),I(M.$$.fragment),O=i(" to set the target "),I(x.$$.fragment),F=i(` for
rendering. Once the `),I(V.$$.fragment),q=i(` is created, it can be used to create the framebuffers. Frame buffers are created
based on a particular `),I(k.$$.fragment),N=i(" and they act as a link between the "),I(Q.$$.fragment),X=i(" attachments and the real "),I(Z.$$.fragment),K=i(" to be rendered to."),W=d("br"),U=d("br"),G=i(`
The framebuffer is an object that represents the set of images into which `),I(te.$$.fragment),ee=i(` render. These affect the last few stages in the pipeline: depth- and stencil testing,
blending, logical operations, multisampling, and so on. A framebuffer object is created
by using a reference to a `),I(ne.$$.fragment),le=i(" and can be used with any render pass that has a similar arrangement of attachments.")},l(J){S(e.$$.fragment,J),t=f(J,`

The `),r=g(J,"CODE",{});var ue=E(r);$=f(ue,"Frambuffer"),ue.forEach(l),n=f(J," class takes a pointer to a "),S(s.$$.fragment,J),a=f(J,", a pointer to a "),S(u.$$.fragment,J),p=f(J,` along with lists of attachments, the width, the height and a number of array layers.
It uses this information to create a `),S(m.$$.fragment,J),_=f(J,"."),v=g(J,"BR",{}),R=g(J,"BR",{}),P=f(J,`
A `),S(A.$$.fragment,J),T=f(J,` renders to
a Framebuffer. The framebuffer links to the `),S(y.$$.fragment,J),B=f(J," being rendered to and is used when starting a "),S(M.$$.fragment,J),O=f(J," to set the target "),S(x.$$.fragment,J),F=f(J,` for
rendering. Once the `),S(V.$$.fragment,J),q=f(J,` is created, it can be used to create the framebuffers. Frame buffers are created
based on a particular `),S(k.$$.fragment,J),N=f(J," and they act as a link between the "),S(Q.$$.fragment,J),X=f(J," attachments and the real "),S(Z.$$.fragment,J),K=f(J," to be rendered to."),W=g(J,"BR",{}),U=g(J,"BR",{}),G=f(J,`
The framebuffer is an object that represents the set of images into which `),S(te.$$.fragment,J),ee=f(J,` render. These affect the last few stages in the pipeline: depth- and stencil testing,
blending, logical operations, multisampling, and so on. A framebuffer object is created
by using a reference to a `),S(ne.$$.fragment,J),le=f(J," and can be used with any render pass that has a similar arrangement of attachments.")},m(J,ue){D(e,J,ue),h(J,t,ue),h(J,r,ue),o(r,$),h(J,n,ue),D(s,J,ue),h(J,a,ue),D(u,J,ue),h(J,p,ue),D(m,J,ue),h(J,_,ue),h(J,v,ue),h(J,R,ue),h(J,P,ue),D(A,J,ue),h(J,T,ue),D(y,J,ue),h(J,B,ue),D(M,J,ue),h(J,O,ue),D(x,J,ue),h(J,F,ue),D(V,J,ue),h(J,q,ue),D(k,J,ue),h(J,N,ue),D(Q,J,ue),h(J,X,ue),D(Z,J,ue),h(J,K,ue),h(J,W,ue),h(J,U,ue),h(J,G,ue),D(te,J,ue),h(J,ee,ue),D(ne,J,ue),h(J,le,ue),ae=!0},p(J,[ue]){const De={};ue&1&&(De.$$scope={dirty:ue,ctx:J}),s.$set(De);const de={};ue&1&&(de.$$scope={dirty:ue,ctx:J}),u.$set(de);const me={};ue&1&&(me.$$scope={dirty:ue,ctx:J}),m.$set(me);const Ce={};ue&1&&(Ce.$$scope={dirty:ue,ctx:J}),A.$set(Ce);const _e={};ue&1&&(_e.$$scope={dirty:ue,ctx:J}),y.$set(_e);const se={};ue&1&&(se.$$scope={dirty:ue,ctx:J}),M.$set(se);const ie={};ue&1&&(ie.$$scope={dirty:ue,ctx:J}),x.$set(ie);const ge={};ue&1&&(ge.$$scope={dirty:ue,ctx:J}),V.$set(ge);const we={};ue&1&&(we.$$scope={dirty:ue,ctx:J}),k.$set(we);const Re={};ue&1&&(Re.$$scope={dirty:ue,ctx:J}),Q.$set(Re);const Be={};ue&1&&(Be.$$scope={dirty:ue,ctx:J}),Z.$set(Be);const Ie={};ue&1&&(Ie.$$scope={dirty:ue,ctx:J}),te.$set(Ie);const re={};ue&1&&(re.$$scope={dirty:ue,ctx:J}),ne.$set(re)},i(J){ae||(b(e.$$.fragment,J),b(s.$$.fragment,J),b(u.$$.fragment,J),b(m.$$.fragment,J),b(A.$$.fragment,J),b(y.$$.fragment,J),b(M.$$.fragment,J),b(x.$$.fragment,J),b(V.$$.fragment,J),b(k.$$.fragment,J),b(Q.$$.fragment,J),b(Z.$$.fragment,J),b(te.$$.fragment,J),b(ne.$$.fragment,J),ae=!0)},o(J){w(e.$$.fragment,J),w(s.$$.fragment,J),w(u.$$.fragment,J),w(m.$$.fragment,J),w(A.$$.fragment,J),w(y.$$.fragment,J),w(M.$$.fragment,J),w(x.$$.fragment,J),w(V.$$.fragment,J),w(k.$$.fragment,J),w(Q.$$.fragment,J),w(Z.$$.fragment,J),w(te.$$.fragment,J),w(ne.$$.fragment,J),ae=!1},d(J){C(e,J),J&&l(t),J&&l(r),J&&l(n),C(s,J),J&&l(a),C(u,J),J&&l(p),C(m,J),J&&l(_),J&&l(v),J&&l(R),J&&l(P),C(A,J),J&&l(T),C(y,J),J&&l(B),C(M,J),J&&l(O),C(x,J),J&&l(F),C(V,J),J&&l(q),C(k,J),J&&l(N),C(Q,J),J&&l(X),C(Z,J),J&&l(K),J&&l(W),J&&l(U),J&&l(G),C(te,J),J&&l(ee),C(ne,J),J&&l(le)}}}class gW extends ve{constructor(e){super(),Ee(this,e,null,dW,be,{})}}function _W(c){let e,t;return{c(){e=d("span"),t=i("Create a new Framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function vW(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wW(c){let e;return{c(){e=i("render passes")},l(t){e=f(t,"render passes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IW(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CW(c){let e;return{c(){e=i("Render Pass Constructor")},l(t){e=f(t,"Render Pass Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SW(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RW(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[vW]},$$scope:{ctx:c}}}),A=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[EW]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[bW]},$$scope:{ctx:c}}}),M=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[wW]},$$scope:{ctx:c}}}),Q=new H({props:{sectionID:L.IMAGE,$$slots:{default:[IW]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.IMAGE,$$slots:{default:[DW]},$$scope:{ctx:c}}}),te=new H({props:{sectionID:L.RENDER_PASS_Constructor,$$slots:{default:[CW]},$$scope:{ctx:c}}}),ne=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[SW]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Framebuffer should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("pRenderPass"),R=d("br"),P=i(`
            A pointer to a `),I(A.$$.fragment),T=i(" that defines which "),I(y.$$.fragment),B=i(" the framebuffer will be compatible with. Two "),I(M.$$.fragment),O=i(` are compatible with the same framebuffer if their attachment references
            are the same.`),x=j(),F=d("li"),V=d("code"),q=i("pAttachments"),k=d("br"),N=i(`
            The set of `),I(Q.$$.fragment),X=i(`
            to be bound into the framebuffer object. Each `),I(Z.$$.fragment),K=i(`
            (/attachment) will be used as the corresponding attachment in the
            `),W=d("code"),U=i("attachments"),G=i(`
            list of the `),I(te.$$.fragment),ee=i(" of a "),I(ne.$$.fragment),le=i(" instance."),ae=j(),J=d("li"),ue=d("code"),De=i("width"),de=d("br"),me=i(`
            The width of the framebuffer.`),Ce=j(),_e=d("li"),se=d("code"),ie=i("height"),ge=d("br"),we=i(`
            The height of the framebuffer.`),Re=j(),Be=d("li"),Ie=d("code"),re=i("layers"),he=d("br"),Ae=i(`
            The number of layers of the framebuffer.`),this.h()},l(oe){e=g(oe,"DIV",{slot:!0});var ce=E(e);t=g(ce,"LI",{});var Pe=E(t);r=g(Pe,"CODE",{});var Fe=E(r);$=f(Fe,"pLogicalDevice"),Fe.forEach(l),n=g(Pe,"BR",{}),s=f(Pe,`
            A pointer to the `),S(a.$$.fragment,Pe),u=f(Pe," the Framebuffer should be associated with."),Pe.forEach(l),p=Y(ce),m=g(ce,"LI",{});var ke=E(m);_=g(ke,"CODE",{});var Te=E(_);v=f(Te,"pRenderPass"),Te.forEach(l),R=g(ke,"BR",{}),P=f(ke,`
            A pointer to a `),S(A.$$.fragment,ke),T=f(ke," that defines which "),S(y.$$.fragment,ke),B=f(ke," the framebuffer will be compatible with. Two "),S(M.$$.fragment,ke),O=f(ke,` are compatible with the same framebuffer if their attachment references
            are the same.`),ke.forEach(l),x=Y(ce),F=g(ce,"LI",{});var Me=E(F);V=g(Me,"CODE",{});var Ue=E(V);q=f(Ue,"pAttachments"),Ue.forEach(l),k=g(Me,"BR",{}),N=f(Me,`
            The set of `),S(Q.$$.fragment,Me),X=f(Me,`
            to be bound into the framebuffer object. Each `),S(Z.$$.fragment,Me),K=f(Me,`
            (/attachment) will be used as the corresponding attachment in the
            `),W=g(Me,"CODE",{});var qe=E(W);U=f(qe,"attachments"),qe.forEach(l),G=f(Me,`
            list of the `),S(te.$$.fragment,Me),ee=f(Me," of a "),S(ne.$$.fragment,Me),le=f(Me," instance."),Me.forEach(l),ae=Y(ce),J=g(ce,"LI",{});var xe=E(J);ue=g(xe,"CODE",{});var Ge=E(ue);De=f(Ge,"width"),Ge.forEach(l),de=g(xe,"BR",{}),me=f(xe,`
            The width of the framebuffer.`),xe.forEach(l),Ce=Y(ce),_e=g(ce,"LI",{});var ye=E(_e);se=g(ye,"CODE",{});var We=E(se);ie=f(We,"height"),We.forEach(l),ge=g(ye,"BR",{}),we=f(ye,`
            The height of the framebuffer.`),ye.forEach(l),Re=Y(ce),Be=g(ce,"LI",{});var ze=E(Be);Ie=g(ze,"CODE",{});var Ye=E(Ie);re=f(Ye,"layers"),Ye.forEach(l),he=g(ze,"BR",{}),Ae=f(ze,`
            The number of layers of the framebuffer.`),ze.forEach(l),ce.forEach(l),this.h()},h(){z(e,"slot","params")},m(oe,ce){h(oe,e,ce),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),D(y,m,null),o(m,B),D(M,m,null),o(m,O),o(e,x),o(e,F),o(F,V),o(V,q),o(F,k),o(F,N),D(Q,F,null),o(F,X),D(Z,F,null),o(F,K),o(F,W),o(W,U),o(F,G),D(te,F,null),o(F,ee),D(ne,F,null),o(F,le),o(e,ae),o(e,J),o(J,ue),o(ue,De),o(J,de),o(J,me),o(e,Ce),o(e,_e),o(_e,se),o(se,ie),o(_e,ge),o(_e,we),o(e,Re),o(e,Be),o(Be,Ie),o(Ie,re),o(Be,he),o(Be,Ae),Ve=!0},p(oe,ce){const Pe={};ce&1&&(Pe.$$scope={dirty:ce,ctx:oe}),a.$set(Pe);const Fe={};ce&1&&(Fe.$$scope={dirty:ce,ctx:oe}),A.$set(Fe);const ke={};ce&1&&(ke.$$scope={dirty:ce,ctx:oe}),y.$set(ke);const Te={};ce&1&&(Te.$$scope={dirty:ce,ctx:oe}),M.$set(Te);const Me={};ce&1&&(Me.$$scope={dirty:ce,ctx:oe}),Q.$set(Me);const Ue={};ce&1&&(Ue.$$scope={dirty:ce,ctx:oe}),Z.$set(Ue);const qe={};ce&1&&(qe.$$scope={dirty:ce,ctx:oe}),te.$set(qe);const xe={};ce&1&&(xe.$$scope={dirty:ce,ctx:oe}),ne.$set(xe)},i(oe){Ve||(b(a.$$.fragment,oe),b(A.$$.fragment,oe),b(y.$$.fragment,oe),b(M.$$.fragment,oe),b(Q.$$.fragment,oe),b(Z.$$.fragment,oe),b(te.$$.fragment,oe),b(ne.$$.fragment,oe),Ve=!0)},o(oe){w(a.$$.fragment,oe),w(A.$$.fragment,oe),w(y.$$.fragment,oe),w(M.$$.fragment,oe),w(Q.$$.fragment,oe),w(Z.$$.fragment,oe),w(te.$$.fragment,oe),w(ne.$$.fragment,oe),Ve=!1},d(oe){oe&&l(e),C(a),C(A),C(y),C(M),C(Q),C(Z),C(te),C(ne)}}}function AW(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PW(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkFramebuffer",version:1.3,$$slots:{default:[AW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(`
        couldn't be created.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,`
        couldn't be created.`),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function BW(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Framebuffer(
    LogicalDevice* pLogicalDevice, 
    RenderPass* pRenderPass, 
    std::vector<ImageView*> pAttachments, 
    unsigned int width,
    unsigned int height, 
    unsigned int layers
);`}}),r=new Se({props:{$$slots:{throws:[PW],params:[RW],details:[_W]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LW extends ve{constructor(e){super(),Ee(this,e,null,BW,be,{})}}function kW(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TW(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",target:"_blank",$$slots:{default:[kW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function OW(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VW(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",target:"_blank",$$slots:{default:[OW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function yW(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkFramebuffer getFramebufferHandle() const;"}}),r=new Se({props:{$$slots:{return:[VW],details:[TW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class MW extends ve{constructor(e){super(),Ee(this,e,null,yW,be,{})}}function FW(c){let e,t;return{c(){e=d("span"),t=i("Get the extent of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the extent of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function xW(c){let e;return{c(){e=i("VkExtent2D")},l(t){e=f(t,"VkExtent2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NW(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkExtent2D",version:1.3,$$slots:{default:[xW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The extent of the framebuffer, this is a "),I(r.$$.fragment),$=i("-structure."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The extent of the framebuffer, this is a "),S(r.$$.fragment,a),$=f(a,"-structure."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function UW(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"VkExtent2D getExtent();"}}),r=new Se({props:{$$slots:{return:[NW],details:[FW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GW extends ve{constructor(e){super(),Ee(this,e,null,UW,be,{})}}function HW(c){let e,t;return{c(){e=d("span"),t=i("Get the number of layers of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the number of layers of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function qW(c){let e,t;return{c(){e=d("span"),t=i("The number of layers of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The number of layers of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function WW(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"unsigned int getLayers();"}}),r=new Se({props:{$$slots:{return:[qW],details:[HW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class QW extends ve{constructor(e){super(),Ee(this,e,null,WW,be,{})}}function KW(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YW(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/sampler.hpp>"}}),r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[KW]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[zW]},$$scope:{ctx:c}}}),a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[jW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
When shaders read from `),I(r.$$.fragment),$=i(`, they can do so in two ways. The first is to load the
`),I(n.$$.fragment),s=i(` raw, which reads formatted
or unformatted data directly from a specific location in the image. The second way
is to sample the `),I(a.$$.fragment),u=i(` using a
sampler. Sampling can include operations such as performing basic transformations
on the image-coordinates or filtering texels to smooth out the image-data returned
to the shader. The sampler is a separate object that provides an interface to extract
colors from a texture. It can be applied to any image be it 1D, 2D or 3D.`),p=d("br")},l(_){S(e.$$.fragment,_),t=f(_,`
When shaders read from `),S(r.$$.fragment,_),$=f(_,`, they can do so in two ways. The first is to load the
`),S(n.$$.fragment,_),s=f(_,` raw, which reads formatted
or unformatted data directly from a specific location in the image. The second way
is to sample the `),S(a.$$.fragment,_),u=f(_,` using a
sampler. Sampling can include operations such as performing basic transformations
on the image-coordinates or filtering texels to smooth out the image-data returned
to the shader. The sampler is a separate object that provides an interface to extract
colors from a texture. It can be applied to any image be it 1D, 2D or 3D.`),p=g(_,"BR",{})},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),D(n,_,v),h(_,s,v),D(a,_,v),h(_,u,v),h(_,p,v),m=!0},p(_,[v]){const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),r.$set(R);const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),n.$set(P);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),a.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(n.$$.fragment,_),b(a.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(n.$$.fragment,_),w(a.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),C(n,_),_&&l(s),C(a,_),_&&l(u),_&&l(p)}}}class XW extends ve{constructor(e){super(),Ee(this,e,null,YW,be,{})}}function ZW(c){let e;return{c(){e=i("Sampler Builder")},l(t){e=f(t,"Sampler Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JW(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SAMPLER_BUILDER,$$slots:{default:[ZW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Sampler."),r=d("br"),$=i(`
        It is recommended to not create a Sampler by it's Constructor, but to use
        a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Sampler."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Sampler by it's Constructor, but to use
        a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function eQ(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tQ(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rQ(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sQ(c){let e;return{c(){e=i("VkSamplerMipmapMode")},l(t){e=f(t,"VkSamplerMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aQ(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oQ(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lQ(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iQ(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fQ(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $Q(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uQ(c){let e;return{c(){e=i("VkCompareOp")},l(t){e=f(t,"VkCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pQ(c){let e;return{c(){e=i("graphical pipeline")},l(t){e=f(t,"graphical pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dQ(c){let e;return{c(){e=i("VkBorderColor")},l(t){e=f(t,"VkBorderColor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,yt,mt,Ot,Pt,Tt,vt,gt,kt,Ft,Mt,Ht,$r,Ut,or,Xt,Vt,Zt,Ar,br,ur,Qt,Vr,rr,Kr,lr,gr,yr,Kt,ir,Mr,Le,lt,Jt,_r,jt,nr,vr,Tr,fr,cr,sr,er,zr,_t,ft,qt,Fr,wr,Nt,Wt,xr,pr,Or,Yt,Pr,Ir,Nr,mr,Dr,hr,Br,Cr,en,Ur,tr,Gr,tn,Yr,ln,Er,fn,Lr,cn,jr,Lt,It,Hr,kr,qr,bn,Sr,wn,In,Xr,Dn,nn,xt,ar,Hn,qn,Wn,Bn,Qn,Kn,$n,zn,Ln,kn,un,jn,Wr,Yn,Xn,Tn,pn,Zn,Gt,Jn,es,On,ts,rs,Vn,ns,ss,rn,as,dr,yn,os,ls,Mn,is,fs,us,Ms,Fs,Ss;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[eQ]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[tQ]},$$scope:{ctx:c}}}),V=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[rQ]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.IMAGE,$$slots:{default:[nQ]},$$scope:{ctx:c}}}),G=new Bt({props:{reference:"VkSamplerMipmapMode",version:1.3,$$slots:{default:[sQ]},$$scope:{ctx:c}}}),Ie=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[aQ]},$$scope:{ctx:c}}}),Te=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[oQ]},$$scope:{ctx:c}}}),rt=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[lQ]},$$scope:{ctx:c}}}),kt=new H({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[iQ]},$$scope:{ctx:c}}}),Ut=new Bt({props:{reference:"VkPhysicalDeviceLimits",version:1.3,$$slots:{default:[fQ]},$$scope:{ctx:c}}}),Qt=new H({props:{sectionID:L.IMAGE,$$slots:{default:[cQ]},$$scope:{ctx:c}}}),rr=new H({props:{sectionID:L.IMAGE,$$slots:{default:[$Q]},$$scope:{ctx:c}}}),cr=new Bt({props:{reference:"VkCompareOp",version:1.3,$$slots:{default:[uQ]},$$scope:{ctx:c}}}),er=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[pQ]},$$scope:{ctx:c}}}),Wt=new H({props:{sectionID:L.IMAGE,$$slots:{default:[mQ]},$$scope:{ctx:c}}}),Er=new H({props:{sectionID:L.IMAGE,$$slots:{default:[hQ]},$$scope:{ctx:c}}}),Xr=new Bt({props:{reference:"VkBorderColor",version:1.3,$$slots:{default:[dQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Sampler should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("magFilter"),R=d("br"),P=i(`
            The filter mode to use when the image is magnified. This is a member
            of the `),I(A.$$.fragment),T=i("-enumerant."),y=j(),B=d("li"),M=d("code"),O=i("minFilter"),x=d("br"),F=i(`
            The filter mode to use when the image is minified. This is a member of
            the `),I(V.$$.fragment),q=i("-enumerant."),k=j(),N=d("li"),Q=d("code"),X=i("mipmapMode"),Z=d("br"),K=i(`
            How mipmaps are used in the `),I(W.$$.fragment),U=i(" when it is sampled. This is a member of the "),I(G.$$.fragment),te=i(`-enumerant. If the mipmap mode is
            `),ee=d("code"),ne=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),le=i(`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),ae=d("code"),J=i("VK_SAMPLER_MIPMAP_MODE_LINEAR"),ue=i(`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),De=d("code"),de=i("minFilter"),me=i(` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),Ce=d("br"),_e=i(`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),se=j(),ie=d("li"),ge=d("code"),we=i("addressModeU"),Re=d("br"),Be=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(Ie.$$.fragment),re=i("-enumerant."),he=d("br"),Ae=i(`
            U is the X within the convention of texture space coordinates.`),Ve=j(),oe=d("li"),ce=d("code"),Pe=i("addressModeV"),Fe=d("br"),ke=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(Te.$$.fragment),Me=i("-enumerant."),Ue=d("br"),qe=i(`
            V is the Y within the convention of texture space coordinates.`),xe=j(),Ge=d("li"),ye=d("code"),We=i("addressModeW"),ze=d("br"),Ye=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(rt.$$.fragment),Ne=i("-enumerant."),He=d("br"),$t=i(`
            W is the Z within the convention of texture space coordinates.`),ut=j(),ht=d("li"),Je=d("code"),dt=i("mipLodBias"),et=d("br"),Ze=i(`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),nt=j(),Ke=d("li"),ct=d("code"),st=i("anisotropyEnable"),Qe=d("br"),at=i(`
            If anisotropic filtering is to be used, it can be set to
            `),bt=d("code"),wt=i("VK_TRUE"),St=i(`. If not, it can be set to
            `),tt=d("code"),ot=i("VK_FALSE"),At=i(`. Anisotropic filtering generally works by
            considering a projected footprint of the area to be sampled (or
            "sampled") rather than using a fixed 2x2 footprint. An approximation
            of a surface sample is formed by taking many samples within the
            footprint.`),it=j(),Xe=d("li"),Dt=d("code"),Ct=i("maxAnisotropy"),pt=d("br"),yt=i(`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),mt=d("code"),Ot=i("maxAnisotropy"),Pt=i(`
            to a value between `),Tt=d("code"),vt=i("1.0f"),gt=i(` and the maximum value supported
            by the device. The maximum values can be determined by calling `),I(kt.$$.fragment),Ft=i(`
            and inspecting the `),Mt=d("code"),Ht=i("maxSamplerAnisotropy"),$r=i(` member of the
            embedded `),I(Ut.$$.fragment),or=i(`
            structure.`),Xt=j(),Vt=d("li"),Zt=d("code"),Ar=i("compareEnable"),br=d("br"),ur=i(`
            of the comparison instead of the raw values stored in the `),I(Qt.$$.fragment),Vr=i(`. When this mode is enabled, the comparison is performed on each
            sample taken from the `),I(rr.$$.fragment),Kr=i(`, and the resulting value is the fraction of the total number of
            samples taken that passed the test. This can be used to implement a
            technique known as percentage closer filtering or PCF. To enable
            this mode, `),lr=d("code"),gr=i("compareEnable"),yr=i(`
            must be set to `),Kt=d("code"),ir=i("VK_TRUE"),Mr=i(`
            and the compare operation must be set to `),Le=d("code"),lt=i("compareOp"),Jt=i("."),_r=j(),jt=d("li"),nr=d("code"),vr=i("compareOp"),Tr=d("br"),fr=i(`
            A member of the `),I(cr.$$.fragment),sr=i(`-enumeration, which is used in many places in Vulkan, including the
            `),I(er.$$.fragment),zr=i(". This is the enumeration used to specify the depth test operation."),_t=j(),ft=d("li"),qt=d("code"),Fr=i("minLod"),wr=d("br"),Nt=i(`
            The lowest mipmaps (highest resolution) to sample from. The sampler can
            be configured to limit sampling to a subset of the mip levels in an `),I(Wt.$$.fragment),xr=i(`
            with mipmaps. The range of mipmaps to sample from is specified in
            `),pr=d("code"),Or=i("minLod"),Yt=i(`
            and `),Pr=d("code"),Ir=i("maxLod"),Nr=i("."),mr=j(),Dr=d("li"),hr=d("code"),Br=i("maxLod"),Cr=d("br"),en=i(`
            The highest mipmaps (lowest resolution) to sample from.`),Ur=j(),tr=d("li"),Gr=d("code"),tn=i("borderColor"),Yr=d("br"),ln=i(`
            The border color used in place of data from the `),I(Er.$$.fragment),fn=i(` if
            `),Lr=d("code"),cn=i("addressmodeU"),jr=i(`,
            `),Lt=d("code"),It=i("addressmodeV"),Hr=i(" and/or "),kr=d("code"),qr=i("addressmodeW"),bn=i(` is set to
            `),Sr=d("code"),wn=i("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),In=i(`. This is a
            member of the `),I(Xr.$$.fragment),Dn=i("-enumerant."),nn=j(),xt=d("li"),ar=d("code"),Hn=i("unnormalizedCoordinates"),qn=d("br"),Wn=i(`
            A flag that, when set to `),Bn=d("code"),Qn=i("VK_TRUE"),Kn=i(`, indicates that the
            coordinates used to extract from the image are in raw texel units,
            rather than a value normalized between `),$n=d("code"),zn=i("0.0"),Ln=i(` and
            `),kn=d("code"),un=i("1.0"),jn=i(`
            for each dimension of the texture. This allows texels to be explicitly
            extracted from the image. However, there are several limitations in this
            mode. When `),Wr=d("code"),Yn=i("unnormalizedCoordinates"),Xn=i(`
            is set to `),Tn=d("code"),pn=i("VK_TRUE"),Zn=i(`,
            `),Gt=d("code"),Jn=i("minFilter"),es=i(" and "),On=d("code"),ts=i("magFilter"),rs=i(` must be the same,
            `),Vn=d("code"),ns=i("mipmapMode"),ss=i(`
            must be set to `),rn=d("code"),as=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),dr=i(` and
            `),yn=d("code"),os=i("anisotropyEnable"),ls=i(`
            and
            `),Mn=d("code"),is=i("compareEnable"),fs=i(" must be set to "),us=d("code"),Ms=i("VK_FALSE"),Fs=i("."),this.h()},l(Rt){e=g(Rt,"DIV",{slot:!0});var Et=E(e);t=g(Et,"LI",{});var Cn=E(t);r=g(Cn,"CODE",{});var ps=E(r);$=f(ps,"pLogicalDevice"),ps.forEach(l),n=g(Cn,"BR",{}),s=f(Cn,`
            A pointer to the `),S(a.$$.fragment,Cn),u=f(Cn," the Sampler should be associated with."),Cn.forEach(l),p=Y(Et),m=g(Et,"LI",{});var Sn=E(m);_=g(Sn,"CODE",{});var ms=E(_);v=f(ms,"magFilter"),ms.forEach(l),R=g(Sn,"BR",{}),P=f(Sn,`
            The filter mode to use when the image is magnified. This is a member
            of the `),S(A.$$.fragment,Sn),T=f(Sn,"-enumerant."),Sn.forEach(l),y=Y(Et),B=g(Et,"LI",{});var Rn=E(B);M=g(Rn,"CODE",{});var hs=E(M);O=f(hs,"minFilter"),hs.forEach(l),x=g(Rn,"BR",{}),F=f(Rn,`
            The filter mode to use when the image is minified. This is a member of
            the `),S(V.$$.fragment,Rn),q=f(Rn,"-enumerant."),Rn.forEach(l),k=Y(Et),N=g(Et,"LI",{});var Rr=E(N);Q=g(Rr,"CODE",{});var ds=E(Q);X=f(ds,"mipmapMode"),ds.forEach(l),Z=g(Rr,"BR",{}),K=f(Rr,`
            How mipmaps are used in the `),S(W.$$.fragment,Rr),U=f(Rr," when it is sampled. This is a member of the "),S(G.$$.fragment,Rr),te=f(Rr,`-enumerant. If the mipmap mode is
            `),ee=g(Rr,"CODE",{});var gs=E(ee);ne=f(gs,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),gs.forEach(l),le=f(Rr,`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),ae=g(Rr,"CODE",{});var _s=E(ae);J=f(_s,"VK_SAMPLER_MIPMAP_MODE_LINEAR"),_s.forEach(l),ue=f(Rr,`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),De=g(Rr,"CODE",{});var vs=E(De);de=f(vs,"minFilter"),vs.forEach(l),me=f(Rr,` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),Ce=g(Rr,"BR",{}),_e=f(Rr,`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),Rr.forEach(l),se=Y(Et),ie=g(Et,"LI",{});var sn=E(ie);ge=g(sn,"CODE",{});var Es=E(ge);we=f(Es,"addressModeU"),Es.forEach(l),Re=g(sn,"BR",{}),Be=f(sn,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(Ie.$$.fragment,sn),re=f(sn,"-enumerant."),he=g(sn,"BR",{}),Ae=f(sn,`
            U is the X within the convention of texture space coordinates.`),sn.forEach(l),Ve=Y(Et),oe=g(Et,"LI",{});var an=E(oe);ce=g(an,"CODE",{});var bs=E(ce);Pe=f(bs,"addressModeV"),bs.forEach(l),Fe=g(an,"BR",{}),ke=f(an,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(Te.$$.fragment,an),Me=f(an,"-enumerant."),Ue=g(an,"BR",{}),qe=f(an,`
            V is the Y within the convention of texture space coordinates.`),an.forEach(l),xe=Y(Et),Ge=g(Et,"LI",{});var on=E(Ge);ye=g(on,"CODE",{});var ws=E(ye);We=f(ws,"addressModeW"),ws.forEach(l),ze=g(on,"BR",{}),Ye=f(on,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(rt.$$.fragment,on),Ne=f(on,"-enumerant."),He=g(on,"BR",{}),$t=f(on,`
            W is the Z within the convention of texture space coordinates.`),on.forEach(l),ut=Y(Et),ht=g(Et,"LI",{});var Rs=E(ht);Je=g(Rs,"CODE",{});var zs=E(Je);dt=f(zs,"mipLodBias"),zs.forEach(l),et=g(Rs,"BR",{}),Ze=f(Rs,`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),Rs.forEach(l),nt=Y(Et),Ke=g(Et,"LI",{});var Fn=E(Ke);ct=g(Fn,"CODE",{});var js=E(ct);st=f(js,"anisotropyEnable"),js.forEach(l),Qe=g(Fn,"BR",{}),at=f(Fn,`
            If anisotropic filtering is to be used, it can be set to
            `),bt=g(Fn,"CODE",{});var Ys=E(bt);wt=f(Ys,"VK_TRUE"),Ys.forEach(l),St=f(Fn,`. If not, it can be set to
            `),tt=g(Fn,"CODE",{});var Xs=E(tt);ot=f(Xs,"VK_FALSE"),Xs.forEach(l),At=f(Fn,`. Anisotropic filtering generally works by
            considering a projected footprint of the area to be sampled (or
            "sampled") rather than using a fixed 2x2 footprint. An approximation
            of a surface sample is formed by taking many samples within the
            footprint.`),Fn.forEach(l),it=Y(Et),Xe=g(Et,"LI",{});var Zr=E(Xe);Dt=g(Zr,"CODE",{});var Zs=E(Dt);Ct=f(Zs,"maxAnisotropy"),Zs.forEach(l),pt=g(Zr,"BR",{}),yt=f(Zr,`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),mt=g(Zr,"CODE",{});var Js=E(mt);Ot=f(Js,"maxAnisotropy"),Js.forEach(l),Pt=f(Zr,`
            to a value between `),Tt=g(Zr,"CODE",{});var ea=E(Tt);vt=f(ea,"1.0f"),ea.forEach(l),gt=f(Zr,` and the maximum value supported
            by the device. The maximum values can be determined by calling `),S(kt.$$.fragment,Zr),Ft=f(Zr,`
            and inspecting the `),Mt=g(Zr,"CODE",{});var ta=E(Mt);Ht=f(ta,"maxSamplerAnisotropy"),ta.forEach(l),$r=f(Zr,` member of the
            embedded `),S(Ut.$$.fragment,Zr),or=f(Zr,`
            structure.`),Zr.forEach(l),Xt=Y(Et),Vt=g(Et,"LI",{});var Jr=E(Vt);Zt=g(Jr,"CODE",{});var ra=E(Zt);Ar=f(ra,"compareEnable"),ra.forEach(l),br=g(Jr,"BR",{}),ur=f(Jr,`
            of the comparison instead of the raw values stored in the `),S(Qt.$$.fragment,Jr),Vr=f(Jr,`. When this mode is enabled, the comparison is performed on each
            sample taken from the `),S(rr.$$.fragment,Jr),Kr=f(Jr,`, and the resulting value is the fraction of the total number of
            samples taken that passed the test. This can be used to implement a
            technique known as percentage closer filtering or PCF. To enable
            this mode, `),lr=g(Jr,"CODE",{});var na=E(lr);gr=f(na,"compareEnable"),na.forEach(l),yr=f(Jr,`
            must be set to `),Kt=g(Jr,"CODE",{});var sa=E(Kt);ir=f(sa,"VK_TRUE"),sa.forEach(l),Mr=f(Jr,`
            and the compare operation must be set to `),Le=g(Jr,"CODE",{});var aa=E(Le);lt=f(aa,"compareOp"),aa.forEach(l),Jt=f(Jr,"."),Jr.forEach(l),_r=Y(Et),jt=g(Et,"LI",{});var xn=E(jt);nr=g(xn,"CODE",{});var oa=E(nr);vr=f(oa,"compareOp"),oa.forEach(l),Tr=g(xn,"BR",{}),fr=f(xn,`
            A member of the `),S(cr.$$.fragment,xn),sr=f(xn,`-enumeration, which is used in many places in Vulkan, including the
            `),S(er.$$.fragment,xn),zr=f(xn,". This is the enumeration used to specify the depth test operation."),xn.forEach(l),_t=Y(Et),ft=g(Et,"LI",{});var mn=E(ft);qt=g(mn,"CODE",{});var la=E(qt);Fr=f(la,"minLod"),la.forEach(l),wr=g(mn,"BR",{}),Nt=f(mn,`
            The lowest mipmaps (highest resolution) to sample from. The sampler can
            be configured to limit sampling to a subset of the mip levels in an `),S(Wt.$$.fragment,mn),xr=f(mn,`
            with mipmaps. The range of mipmaps to sample from is specified in
            `),pr=g(mn,"CODE",{});var ia=E(pr);Or=f(ia,"minLod"),ia.forEach(l),Yt=f(mn,`
            and `),Pr=g(mn,"CODE",{});var fa=E(Pr);Ir=f(fa,"maxLod"),fa.forEach(l),Nr=f(mn,"."),mn.forEach(l),mr=Y(Et),Dr=g(Et,"LI",{});var As=E(Dr);hr=g(As,"CODE",{});var ca=E(hr);Br=f(ca,"maxLod"),ca.forEach(l),Cr=g(As,"BR",{}),en=f(As,`
            The highest mipmaps (lowest resolution) to sample from.`),As.forEach(l),Ur=Y(Et),tr=g(Et,"LI",{});var Qr=E(tr);Gr=g(Qr,"CODE",{});var $a=E(Gr);tn=f($a,"borderColor"),$a.forEach(l),Yr=g(Qr,"BR",{}),ln=f(Qr,`
            The border color used in place of data from the `),S(Er.$$.fragment,Qr),fn=f(Qr,` if
            `),Lr=g(Qr,"CODE",{});var ua=E(Lr);cn=f(ua,"addressmodeU"),ua.forEach(l),jr=f(Qr,`,
            `),Lt=g(Qr,"CODE",{});var pa=E(Lt);It=f(pa,"addressmodeV"),pa.forEach(l),Hr=f(Qr," and/or "),kr=g(Qr,"CODE",{});var ma=E(kr);qr=f(ma,"addressmodeW"),ma.forEach(l),bn=f(Qr,` is set to
            `),Sr=g(Qr,"CODE",{});var ha=E(Sr);wn=f(ha,"VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),ha.forEach(l),In=f(Qr,`. This is a
            member of the `),S(Xr.$$.fragment,Qr),Dn=f(Qr,"-enumerant."),Qr.forEach(l),nn=Y(Et),xt=g(Et,"LI",{});var zt=E(xt);ar=g(zt,"CODE",{});var da=E(ar);Hn=f(da,"unnormalizedCoordinates"),da.forEach(l),qn=g(zt,"BR",{}),Wn=f(zt,`
            A flag that, when set to `),Bn=g(zt,"CODE",{});var ga=E(Bn);Qn=f(ga,"VK_TRUE"),ga.forEach(l),Kn=f(zt,`, indicates that the
            coordinates used to extract from the image are in raw texel units,
            rather than a value normalized between `),$n=g(zt,"CODE",{});var _a=E($n);zn=f(_a,"0.0"),_a.forEach(l),Ln=f(zt,` and
            `),kn=g(zt,"CODE",{});var va=E(kn);un=f(va,"1.0"),va.forEach(l),jn=f(zt,`
            for each dimension of the texture. This allows texels to be explicitly
            extracted from the image. However, there are several limitations in this
            mode. When `),Wr=g(zt,"CODE",{});var Ea=E(Wr);Yn=f(Ea,"unnormalizedCoordinates"),Ea.forEach(l),Xn=f(zt,`
            is set to `),Tn=g(zt,"CODE",{});var ba=E(Tn);pn=f(ba,"VK_TRUE"),ba.forEach(l),Zn=f(zt,`,
            `),Gt=g(zt,"CODE",{});var wa=E(Gt);Jn=f(wa,"minFilter"),wa.forEach(l),es=f(zt," and "),On=g(zt,"CODE",{});var Ia=E(On);ts=f(Ia,"magFilter"),Ia.forEach(l),rs=f(zt,` must be the same,
            `),Vn=g(zt,"CODE",{});var Da=E(Vn);ns=f(Da,"mipmapMode"),Da.forEach(l),ss=f(zt,`
            must be set to `),rn=g(zt,"CODE",{});var Ca=E(rn);as=f(Ca,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),Ca.forEach(l),dr=f(zt,` and
            `),yn=g(zt,"CODE",{});var Sa=E(yn);os=f(Sa,"anisotropyEnable"),Sa.forEach(l),ls=f(zt,`
            and
            `),Mn=g(zt,"CODE",{});var Ra=E(Mn);is=f(Ra,"compareEnable"),Ra.forEach(l),fs=f(zt," must be set to "),us=g(zt,"CODE",{});var Aa=E(us);Ms=f(Aa,"VK_FALSE"),Aa.forEach(l),Fs=f(zt,"."),zt.forEach(l),Et.forEach(l),this.h()},h(){z(e,"slot","params")},m(Rt,Et){h(Rt,e,Et),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),D(G,N,null),o(N,te),o(N,ee),o(ee,ne),o(N,le),o(N,ae),o(ae,J),o(N,ue),o(N,De),o(De,de),o(N,me),o(N,Ce),o(N,_e),o(e,se),o(e,ie),o(ie,ge),o(ge,we),o(ie,Re),o(ie,Be),D(Ie,ie,null),o(ie,re),o(ie,he),o(ie,Ae),o(e,Ve),o(e,oe),o(oe,ce),o(ce,Pe),o(oe,Fe),o(oe,ke),D(Te,oe,null),o(oe,Me),o(oe,Ue),o(oe,qe),o(e,xe),o(e,Ge),o(Ge,ye),o(ye,We),o(Ge,ze),o(Ge,Ye),D(rt,Ge,null),o(Ge,Ne),o(Ge,He),o(Ge,$t),o(e,ut),o(e,ht),o(ht,Je),o(Je,dt),o(ht,et),o(ht,Ze),o(e,nt),o(e,Ke),o(Ke,ct),o(ct,st),o(Ke,Qe),o(Ke,at),o(Ke,bt),o(bt,wt),o(Ke,St),o(Ke,tt),o(tt,ot),o(Ke,At),o(e,it),o(e,Xe),o(Xe,Dt),o(Dt,Ct),o(Xe,pt),o(Xe,yt),o(Xe,mt),o(mt,Ot),o(Xe,Pt),o(Xe,Tt),o(Tt,vt),o(Xe,gt),D(kt,Xe,null),o(Xe,Ft),o(Xe,Mt),o(Mt,Ht),o(Xe,$r),D(Ut,Xe,null),o(Xe,or),o(e,Xt),o(e,Vt),o(Vt,Zt),o(Zt,Ar),o(Vt,br),o(Vt,ur),D(Qt,Vt,null),o(Vt,Vr),D(rr,Vt,null),o(Vt,Kr),o(Vt,lr),o(lr,gr),o(Vt,yr),o(Vt,Kt),o(Kt,ir),o(Vt,Mr),o(Vt,Le),o(Le,lt),o(Vt,Jt),o(e,_r),o(e,jt),o(jt,nr),o(nr,vr),o(jt,Tr),o(jt,fr),D(cr,jt,null),o(jt,sr),D(er,jt,null),o(jt,zr),o(e,_t),o(e,ft),o(ft,qt),o(qt,Fr),o(ft,wr),o(ft,Nt),D(Wt,ft,null),o(ft,xr),o(ft,pr),o(pr,Or),o(ft,Yt),o(ft,Pr),o(Pr,Ir),o(ft,Nr),o(e,mr),o(e,Dr),o(Dr,hr),o(hr,Br),o(Dr,Cr),o(Dr,en),o(e,Ur),o(e,tr),o(tr,Gr),o(Gr,tn),o(tr,Yr),o(tr,ln),D(Er,tr,null),o(tr,fn),o(tr,Lr),o(Lr,cn),o(tr,jr),o(tr,Lt),o(Lt,It),o(tr,Hr),o(tr,kr),o(kr,qr),o(tr,bn),o(tr,Sr),o(Sr,wn),o(tr,In),D(Xr,tr,null),o(tr,Dn),o(e,nn),o(e,xt),o(xt,ar),o(ar,Hn),o(xt,qn),o(xt,Wn),o(xt,Bn),o(Bn,Qn),o(xt,Kn),o(xt,$n),o($n,zn),o(xt,Ln),o(xt,kn),o(kn,un),o(xt,jn),o(xt,Wr),o(Wr,Yn),o(xt,Xn),o(xt,Tn),o(Tn,pn),o(xt,Zn),o(xt,Gt),o(Gt,Jn),o(xt,es),o(xt,On),o(On,ts),o(xt,rs),o(xt,Vn),o(Vn,ns),o(xt,ss),o(xt,rn),o(rn,as),o(xt,dr),o(xt,yn),o(yn,os),o(xt,ls),o(xt,Mn),o(Mn,is),o(xt,fs),o(xt,us),o(us,Ms),o(xt,Fs),Ss=!0},p(Rt,Et){const Cn={};Et&1&&(Cn.$$scope={dirty:Et,ctx:Rt}),a.$set(Cn);const ps={};Et&1&&(ps.$$scope={dirty:Et,ctx:Rt}),A.$set(ps);const Sn={};Et&1&&(Sn.$$scope={dirty:Et,ctx:Rt}),V.$set(Sn);const ms={};Et&1&&(ms.$$scope={dirty:Et,ctx:Rt}),W.$set(ms);const Rn={};Et&1&&(Rn.$$scope={dirty:Et,ctx:Rt}),G.$set(Rn);const hs={};Et&1&&(hs.$$scope={dirty:Et,ctx:Rt}),Ie.$set(hs);const Rr={};Et&1&&(Rr.$$scope={dirty:Et,ctx:Rt}),Te.$set(Rr);const ds={};Et&1&&(ds.$$scope={dirty:Et,ctx:Rt}),rt.$set(ds);const gs={};Et&1&&(gs.$$scope={dirty:Et,ctx:Rt}),kt.$set(gs);const _s={};Et&1&&(_s.$$scope={dirty:Et,ctx:Rt}),Ut.$set(_s);const vs={};Et&1&&(vs.$$scope={dirty:Et,ctx:Rt}),Qt.$set(vs);const sn={};Et&1&&(sn.$$scope={dirty:Et,ctx:Rt}),rr.$set(sn);const Es={};Et&1&&(Es.$$scope={dirty:Et,ctx:Rt}),cr.$set(Es);const an={};Et&1&&(an.$$scope={dirty:Et,ctx:Rt}),er.$set(an);const bs={};Et&1&&(bs.$$scope={dirty:Et,ctx:Rt}),Wt.$set(bs);const on={};Et&1&&(on.$$scope={dirty:Et,ctx:Rt}),Er.$set(on);const ws={};Et&1&&(ws.$$scope={dirty:Et,ctx:Rt}),Xr.$set(ws)},i(Rt){Ss||(b(a.$$.fragment,Rt),b(A.$$.fragment,Rt),b(V.$$.fragment,Rt),b(W.$$.fragment,Rt),b(G.$$.fragment,Rt),b(Ie.$$.fragment,Rt),b(Te.$$.fragment,Rt),b(rt.$$.fragment,Rt),b(kt.$$.fragment,Rt),b(Ut.$$.fragment,Rt),b(Qt.$$.fragment,Rt),b(rr.$$.fragment,Rt),b(cr.$$.fragment,Rt),b(er.$$.fragment,Rt),b(Wt.$$.fragment,Rt),b(Er.$$.fragment,Rt),b(Xr.$$.fragment,Rt),Ss=!0)},o(Rt){w(a.$$.fragment,Rt),w(A.$$.fragment,Rt),w(V.$$.fragment,Rt),w(W.$$.fragment,Rt),w(G.$$.fragment,Rt),w(Ie.$$.fragment,Rt),w(Te.$$.fragment,Rt),w(rt.$$.fragment,Rt),w(kt.$$.fragment,Rt),w(Ut.$$.fragment,Rt),w(Qt.$$.fragment,Rt),w(rr.$$.fragment,Rt),w(cr.$$.fragment,Rt),w(er.$$.fragment,Rt),w(Wt.$$.fragment,Rt),w(Er.$$.fragment,Rt),w(Xr.$$.fragment,Rt),Ss=!1},d(Rt){Rt&&l(e),C(a),C(A),C(V),C(W),C(G),C(Ie),C(Te),C(rt),C(kt),C(Ut),C(Qt),C(rr),C(cr),C(er),C(Wt),C(Er),C(Xr)}}}function _Q(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vQ(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkSampler",version:1.3,$$slots:{default:[_Q]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function EQ(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`Sampler(
    LogicalDevice* pLogicalDevice, 
    VkFilter magFilter, 
    VkFilter minFilter, 
    VkSamplerMipmapMode mipmapMode,
    VkSamplerAddressMode addressModeU, 
    VkSamplerAddressMode addressModeV, 
    VkSamplerAddressMode addressModeW, 
    float mipLodBias,
    VkBool32 anisotropyEnable, 
    float maxAnisotropy, 
    VkBool32 compareEnable, 
    VkCompareOp compareOp, 
    float minLod, 
    float maxLod,
    VkBorderColor borderColor, 
    VkBool32 unnormalizedCoordinates
);`}}),r=new Se({props:{$$slots:{throws:[vQ],params:[gQ],details:[JW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bQ extends ve{constructor(e){super(),Ee(this,e,null,EQ,be,{})}}function wQ(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IQ(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html",target:"_blank",$$slots:{default:[wQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function DQ(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CQ(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html",target:"_blank",$$slots:{default:[DQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function SQ(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"const VkSampler getSamplerHandle() const;"}}),r=new Se({props:{$$slots:{return:[CQ],details:[IQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RQ extends ve{constructor(e){super(),Ee(this,e,null,SQ,be,{})}}function AQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/sampler_builder.hpp>"}}),m=new $e({props:{language:pe,code:`LogicalDevice* pLogicalDevice = nullptr;
VkFilter magFilter = VK_FILTER_LINEAR;
VkFilter minFilter = VK_FILTER_LINEAR;
VkSamplerMipmapMode mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
VkSamplerAddressMode addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
VkSamplerAddressMode addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
VkSamplerAddressMode addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
float mipLodBias = 0.f;
VkBool32 anisotropyEnable = VK_FALSE;
float maxAnisotropy = 1.0f;
VkBool32 compareEnable = VK_FALSE;
VkCompareOp compareOp = VK_COMPARE_OP_ALWAYS;
float minLod = 0.f;
float maxLod = 0.f;
VkBorderColor borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
VkBool32 unnormalizedCoordinates = VK_FALSE;`}}),R=new $e({props:{language:pe,code:`fillcan::SamplerBuilder samplerBuilder = fillcan::SamplerBuilder();
samplerBuilder.setLogicalDevice(fillcan.getCurrentDevice());
samplerBuilder.setFilters(VK_FILTER_LINEAR, VK_FILTER_LINEAR);
samplerBuilder.setMipmapMode(VK_SAMPLER_MIPMAP_MODE_LINEAR);
samplerBuilder.setAddressModes(VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT);
samplerBuilder.setMipLodBias(0.0f);
samplerBuilder.setMaxAnisotropy(1.0f);
samplerBuilder.setCompareOp(VK_COMPARE_OP_ALWAYS);
samplerBuilder.setLod(0.0f, 0.0f);
samplerBuilder.setBorderColor(VK_BORDER_COLOR_INT_OPAQUE_BLACK);
std::unique_ptr<fillcan::Sampler> upSampler = samplerBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Sampler Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(R.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Sampler Builder"),T.forEach(l),n=f(A,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(R.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(R,A,T),P=!0},p:Oe,i(A){P||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(R.$$.fragment,A),P=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(R.$$.fragment,A),P=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(R,A)}}}class PQ extends ve{constructor(e){super(),Ee(this,e,null,AQ,be,{})}}function BQ(c){let e,t;return{c(){e=d("span"),t=i("Create a new Sampler Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Sampler Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function LQ(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"SamplerBuilder();"}}),r=new Se({props:{$$slots:{details:[BQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kQ extends ve{constructor(e){super(),Ee(this,e,null,LQ,be,{})}}function TQ(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OQ(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VQ(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[TQ]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[OQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function yQ(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MQ(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FQ(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[yQ]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[MQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," the "),S(p.$$.fragment,P),m=f(P,` should
            be associated with.`),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function xQ(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Se({props:{$$slots:{params:[FQ],details:[VQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class NQ extends ve{constructor(e){super(),Ee(this,e,null,xQ,be,{})}}function UQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GQ(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[UQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the filter modes to use when the "),I(r.$$.fragment),$=i(" is magnified or minified."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the filter modes to use when the "),S(r.$$.fragment,a),$=f(a," is magnified or minified."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function HQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qQ(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QQ(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[HQ]},$$scope:{ctx:c}}}),p=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[qQ]},$$scope:{ctx:c}}}),y=new H({props:{sectionID:L.IMAGE,$$slots:{default:[WQ]},$$scope:{ctx:c}}}),M=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[QQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("magFilter"),n=d("br"),s=i(`
            The filter mode to use when the `),I(a.$$.fragment),u=i(" is magnified. This is a member of the "),I(p.$$.fragment),m=i("-enumerant."),_=j(),v=d("li"),R=d("code"),P=i("minFilter"),A=d("br"),T=i(`
            The filter mode to use when the `),I(y.$$.fragment),B=i(" is minified. This is a member of the "),I(M.$$.fragment),O=i("-enumerant."),this.h()},l(F){e=g(F,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var q=E(t);r=g(q,"CODE",{});var k=E(r);$=f(k,"magFilter"),k.forEach(l),n=g(q,"BR",{}),s=f(q,`
            The filter mode to use when the `),S(a.$$.fragment,q),u=f(q," is magnified. This is a member of the "),S(p.$$.fragment,q),m=f(q,"-enumerant."),q.forEach(l),_=Y(V),v=g(V,"LI",{});var N=E(v);R=g(N,"CODE",{});var Q=E(R);P=f(Q,"minFilter"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The filter mode to use when the `),S(y.$$.fragment,N),B=f(N," is minified. This is a member of the "),S(M.$$.fragment,N),O=f(N,"-enumerant."),N.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(F,V){h(F,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,R),o(R,P),o(v,A),o(v,T),D(y,v,null),o(v,B),D(M,v,null),o(v,O),x=!0},p(F,V){const q={};V&1&&(q.$$scope={dirty:V,ctx:F}),a.$set(q);const k={};V&1&&(k.$$scope={dirty:V,ctx:F}),p.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:F}),y.$set(N);const Q={};V&1&&(Q.$$scope={dirty:V,ctx:F}),M.$set(Q)},i(F){x||(b(a.$$.fragment,F),b(p.$$.fragment,F),b(y.$$.fragment,F),b(M.$$.fragment,F),x=!0)},o(F){w(a.$$.fragment,F),w(p.$$.fragment,F),w(y.$$.fragment,F),w(M.$$.fragment,F),x=!1},d(F){F&&l(e),C(a),C(p),C(y),C(M)}}}function zQ(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setFilters(VkFilter magFilter, VkFilter minFilter);"}}),r=new Se({props:{$$slots:{params:[KQ],details:[GQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jQ extends ve{constructor(e){super(),Ee(this,e,null,zQ,be,{})}}function YQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XQ(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[YQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set how mipmaps are used in the "),I(r.$$.fragment),$=i(" when it is sampled."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set how mipmaps are used in the "),S(r.$$.fragment,a),$=f(a," when it is sampled."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ZQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JQ(c){let e;return{c(){e=i("VkSamplerMipmapMode")},l(t){e=f(t,"VkSamplerMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[ZQ]},$$scope:{ctx:c}}}),p=new Bt({props:{reference:"VkSamplerMipmapMode",version:1.3,$$slots:{default:[JQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipmapMode"),n=d("br"),s=i(`
            How mipmaps are used in the `),I(a.$$.fragment),u=i(" when it is sampled. This is a member of the "),I(p.$$.fragment),m=i(`-enumerant. If the mipmap mode is
            `),_=d("code"),v=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),R=i(`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),P=d("code"),A=i("VK_SAMPLER_MIPMAP_MODE_LINEAR"),T=i(`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),y=d("code"),B=i("minFilter"),M=i(` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),O=d("br"),x=i(`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),this.h()},l(V){e=g(V,"DIV",{slot:!0});var q=E(e);t=g(q,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"mipmapMode"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            How mipmaps are used in the `),S(a.$$.fragment,k),u=f(k," when it is sampled. This is a member of the "),S(p.$$.fragment,k),m=f(k,`-enumerant. If the mipmap mode is
            `),_=g(k,"CODE",{});var Q=E(_);v=f(Q,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),Q.forEach(l),R=f(k,`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),P=g(k,"CODE",{});var X=E(P);A=f(X,"VK_SAMPLER_MIPMAP_MODE_LINEAR"),X.forEach(l),T=f(k,`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),y=g(k,"CODE",{});var Z=E(y);B=f(Z,"minFilter"),Z.forEach(l),M=f(k,` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),O=g(k,"BR",{}),x=f(k,`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),k.forEach(l),q.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,q){h(V,e,q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(_,v),o(t,R),o(t,P),o(P,A),o(t,T),o(t,y),o(y,B),o(t,M),o(t,O),o(t,x),F=!0},p(V,q){const k={};q&1&&(k.$$scope={dirty:q,ctx:V}),a.$set(k);const N={};q&1&&(N.$$scope={dirty:q,ctx:V}),p.$set(N)},i(V){F||(b(a.$$.fragment,V),b(p.$$.fragment,V),F=!0)},o(V){w(a.$$.fragment,V),w(p.$$.fragment,V),F=!1},d(V){V&&l(e),C(a),C(p)}}}function tK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setMipmapMode(VkSamplerMipmapMode mipmapMode);"}}),r=new Se({props:{$$slots:{params:[eK],details:[XQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rK extends ve{constructor(e){super(),Ee(this,e,null,tK,be,{})}}function nK(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sK(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aK(c){let e,t,r,$,n,s,a;return r=new H({props:{sectionID:L.IMAGE,$$slots:{default:[nK]},$$scope:{ctx:c}}}),n=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[sK]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Set the address modes which are used to select the transformer applied
        to texture coordinates that would otherwise be sampled outside the
        `),I(r.$$.fragment),$=i(`. These are
        members of the `),I(n.$$.fragment),s=i("-enumerant."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,`Set the address modes which are used to select the transformer applied
        to texture coordinates that would otherwise be sampled outside the
        `),S(r.$$.fragment,p),$=f(p,`. These are
        members of the `),S(n.$$.fragment,p),s=f(p,"-enumerant."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function oK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("addressModeU"),n=d("br"),s=i(`
            U is the X within the convention of texture space coordinates.`),a=j(),u=d("li"),p=d("code"),m=i("addressModeV"),_=d("br"),v=i(`
            V is the Y within the convention of texture space coordinates.`),R=j(),P=d("li"),A=d("code"),T=i("addressModeW"),y=d("br"),B=i(`
            W is the Z within the convention of texture space coordinates.`),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var x=E(t);r=g(x,"CODE",{});var F=E(r);$=f(F,"addressModeU"),F.forEach(l),n=g(x,"BR",{}),s=f(x,`
            U is the X within the convention of texture space coordinates.`),x.forEach(l),a=Y(O),u=g(O,"LI",{});var V=E(u);p=g(V,"CODE",{});var q=E(p);m=f(q,"addressModeV"),q.forEach(l),_=g(V,"BR",{}),v=f(V,`
            V is the Y within the convention of texture space coordinates.`),V.forEach(l),R=Y(O),P=g(O,"LI",{});var k=E(P);A=g(k,"CODE",{});var N=E(A);T=f(N,"addressModeW"),N.forEach(l),y=g(k,"BR",{}),B=f(k,`
            W is the Z within the convention of texture space coordinates.`),k.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,R),o(e,P),o(P,A),o(A,T),o(P,y),o(P,B)},p:Oe,d(M){M&&l(e)}}}function lK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setAddressModes(VkSamplerAddressMode addressModeU, VkSamplerAddressMode addressModeV, VkSamplerAddressMode addressModeW);"}}),r=new Se({props:{$$slots:{params:[oK],details:[aK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iK extends ve{constructor(e){super(),Ee(this,e,null,lK,be,{})}}function fK(c){let e,t;return{c(){e=d("span"),t=i("Set the bias for the mip Lod."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the bias for the mip Lod."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function cK(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipLodBias"),n=d("br"),s=i(`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"mipLodBias"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function $K(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setMipLodBias(float mipLodBias);"}}),r=new Se({props:{$$slots:{params:[cK],details:[fK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uK extends ve{constructor(e){super(),Ee(this,e,null,$K,be,{})}}function pK(c){let e,t;return{c(){e=d("span"),t=i(`Set the max anisotropy if anisotropic filtering is to be used, also
        enables anisotropic filtering.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Set the max anisotropy if anisotropic filtering is to be used, also
        enables anisotropic filtering.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function mK(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hK(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O;return R=new H({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[mK]},$$scope:{ctx:c}}}),B=new Bt({props:{reference:"VkPhysicalDeviceLimits",version:1.3,$$slots:{default:[hK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("maxAnisotropy"),n=d("br"),s=i(`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),a=d("code"),u=i("maxAnisotropy"),p=i(`
            to a value between `),m=d("code"),_=i("1.0f"),v=i(` and the maximum value supported
            by the device. The maximum values can be determined by calling `),I(R.$$.fragment),P=i(`
            and inspecting the `),A=d("code"),T=i("maxSamplerAnisotropy"),y=i(` member of the
            embedded `),I(B.$$.fragment),M=i(`
            structure.`),this.h()},l(x){e=g(x,"DIV",{slot:!0});var F=E(e);t=g(F,"LI",{});var V=E(t);r=g(V,"CODE",{});var q=E(r);$=f(q,"maxAnisotropy"),q.forEach(l),n=g(V,"BR",{}),s=f(V,`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),a=g(V,"CODE",{});var k=E(a);u=f(k,"maxAnisotropy"),k.forEach(l),p=f(V,`
            to a value between `),m=g(V,"CODE",{});var N=E(m);_=f(N,"1.0f"),N.forEach(l),v=f(V,` and the maximum value supported
            by the device. The maximum values can be determined by calling `),S(R.$$.fragment,V),P=f(V,`
            and inspecting the `),A=g(V,"CODE",{});var Q=E(A);T=f(Q,"maxSamplerAnisotropy"),Q.forEach(l),y=f(V,` member of the
            embedded `),S(B.$$.fragment,V),M=f(V,`
            structure.`),V.forEach(l),F.forEach(l),this.h()},h(){z(e,"slot","params")},m(x,F){h(x,e,F),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(t,m),o(m,_),o(t,v),D(R,t,null),o(t,P),o(t,A),o(A,T),o(t,y),D(B,t,null),o(t,M),O=!0},p(x,F){const V={};F&1&&(V.$$scope={dirty:F,ctx:x}),R.$set(V);const q={};F&1&&(q.$$scope={dirty:F,ctx:x}),B.$set(q)},i(x){O||(b(R.$$.fragment,x),b(B.$$.fragment,x),O=!0)},o(x){w(R.$$.fragment,x),w(B.$$.fragment,x),O=!1},d(x){x&&l(e),C(R),C(B)}}}function gK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setMaxAnisotropy(float maxAnisotropy);"}}),r=new Se({props:{$$slots:{params:[dK],details:[pK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _K extends ve{constructor(e){super(),Ee(this,e,null,gK,be,{})}}function vK(c){let e,t;return{c(){e=d("span"),t=i(`Reset the max anisotropy to it's default value and disable anisotropic
        filtering.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Reset the max anisotropy to it's default value and disable anisotropic
        filtering.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function EK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void unsetMaxAnisotropy();"}}),r=new Se({props:{$$slots:{details:[vK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bK extends ve{constructor(e){super(),Ee(this,e,null,EK,be,{})}}function wK(c){let e,t;return{c(){e=d("span"),t=i(`When a sampler is used with a depth image, it can be configured to
        perform a compare operation and return the result of the comparison
        instead of the raw values stored in the image. When this mode is
        enabled, the comparison is performed on each sample taken from the
        image, and the resulting value is the fraction of the total number of
        samples taken that passed the test. This can be used to implement a
        technique known as percentage closer filtering or PCF. This enables this
        mode.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`When a sampler is used with a depth image, it can be configured to
        perform a compare operation and return the result of the comparison
        instead of the raw values stored in the image. When this mode is
        enabled, the comparison is performed on each sample taken from the
        image, and the resulting value is the fraction of the total number of
        samples taken that passed the test. This can be used to implement a
        technique known as percentage closer filtering or PCF. This enables this
        mode.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function IK(c){let e;return{c(){e=i("VkCompareOp")},l(t){e=f(t,"VkCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DK(c){let e;return{c(){e=i("graphical pipeline")},l(t){e=f(t,"graphical pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CK(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new Bt({props:{reference:"VkCompareOp",version:1.3,$$slots:{default:[IK]},$$scope:{ctx:c}}}),p=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[DK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("compareOp"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i(`-enumeration, which is used in many places in Vulkan, including the
            `),I(p.$$.fragment),m=i(". This is the enumeration used to specify the depth test operation."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var P=E(t);r=g(P,"CODE",{});var A=E(r);$=f(A,"compareOp"),A.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A member of the `),S(a.$$.fragment,P),u=f(P,`-enumeration, which is used in many places in Vulkan, including the
            `),S(p.$$.fragment,P),m=f(P,". This is the enumeration used to specify the depth test operation."),P.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),a.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function SK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setCompareOp(VkCompareOp compareOp);"}}),r=new Se({props:{$$slots:{params:[CK],details:[wK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RK extends ve{constructor(e){super(),Ee(this,e,null,SK,be,{})}}function AK(c){let e,t;return{c(){e=d("span"),t=i(`Reset the compare operation to it's default value and disable
        comparing.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Reset the compare operation to it's default value and disable
        comparing.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function PK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void unsetCompareOp();"}}),r=new Se({props:{$$slots:{details:[AK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BK extends ve{constructor(e){super(),Ee(this,e,null,PK,be,{})}}function LK(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kK(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R;return r=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[LK]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[kK]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(` can be configured
        to limit sampling to a subset of the mip levels in an `),I(n.$$.fragment),s=i(` with mipmaps. The range of mipmaps to sample from is specified in
        `),a=d("code"),u=i("minLod"),p=i(`
        and `),m=d("code"),_=i("maxLod"),v=i("."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var A=E(e);t=f(A,"The "),S(r.$$.fragment,A),$=f(A,` can be configured
        to limit sampling to a subset of the mip levels in an `),S(n.$$.fragment,A),s=f(A,` with mipmaps. The range of mipmaps to sample from is specified in
        `),a=g(A,"CODE",{});var T=E(a);u=f(T,"minLod"),T.forEach(l),p=f(A,`
        and `),m=g(A,"CODE",{});var y=E(m);_=f(y,"maxLod"),y.forEach(l),v=f(A,"."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(P,A){h(P,e,A),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),R=!0},p(P,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:P}),r.$set(T);const y={};A&1&&(y.$$scope={dirty:A,ctx:P}),n.$set(y)},i(P){R||(b(r.$$.fragment,P),b(n.$$.fragment,P),R=!0)},o(P){w(r.$$.fragment,P),w(n.$$.fragment,P),R=!1},d(P){P&&l(e),C(r),C(n)}}}function OK(c){let e,t,r,$,n,s,a,u,p,m,_,v;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("minLod"),n=d("br"),s=i(`
            The lowest mipmaps (highest resolution) to sample from.`),a=j(),u=d("li"),p=d("code"),m=i("maxLod"),_=d("br"),v=i(`
            The highest mipmaps (lowest resolution) to sample from.`),this.h()},l(R){e=g(R,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var A=E(t);r=g(A,"CODE",{});var T=E(r);$=f(T,"minLod"),T.forEach(l),n=g(A,"BR",{}),s=f(A,`
            The lowest mipmaps (highest resolution) to sample from.`),A.forEach(l),a=Y(P),u=g(P,"LI",{});var y=E(u);p=g(y,"CODE",{});var B=E(p);m=f(B,"maxLod"),B.forEach(l),_=g(y,"BR",{}),v=f(y,`
            The highest mipmaps (lowest resolution) to sample from.`),y.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(R,P){h(R,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v)},p:Oe,d(R){R&&l(e)}}}function VK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setLod(float minLod, float maxLod);"}}),r=new Se({props:{$$slots:{params:[OK],details:[TK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yK extends ve{constructor(e){super(),Ee(this,e,null,VK,be,{})}}function MK(c){let e,t;return{c(){e=d("span"),t=i("Set the border color."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the border color."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function FK(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xK(c){let e;return{c(){e=i("setAddressModes")},l(t){e=f(t,"setAddressModes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NK(c){let e;return{c(){e=i("VkBorderColor")},l(t){e=f(t,"VkBorderColor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k;return a=new H({props:{sectionID:L.IMAGE,$$slots:{default:[FK]},$$scope:{ctx:c}}}),x=new H({props:{sectionID:L.SAMPLER_BUILDER_setAddressModes,$$slots:{default:[xK]},$$scope:{ctx:c}}}),V=new Bt({props:{reference:"VkBorderColor",version:1.3,$$slots:{default:[NK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("borderColor"),n=d("br"),s=i(`
            The border color used in place of data from the `),I(a.$$.fragment),u=i(` if
            `),p=d("code"),m=i("addressmodeU"),_=i(`,
            `),v=d("code"),R=i("addressmodeV"),P=i(" and/or "),A=d("code"),T=i("addressmodeW"),y=i(` is set to
            `),B=d("code"),M=i("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),O=i(" using "),I(x.$$.fragment),F=i(". This is a member of the "),I(V.$$.fragment),q=i("-enumerant."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"borderColor"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            The border color used in place of data from the `),S(a.$$.fragment,X),u=f(X,` if
            `),p=g(X,"CODE",{});var K=E(p);m=f(K,"addressmodeU"),K.forEach(l),_=f(X,`,
            `),v=g(X,"CODE",{});var W=E(v);R=f(W,"addressmodeV"),W.forEach(l),P=f(X," and/or "),A=g(X,"CODE",{});var U=E(A);T=f(U,"addressmodeW"),U.forEach(l),y=f(X,` is set to
            `),B=g(X,"CODE",{});var G=E(B);M=f(G,"VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),G.forEach(l),O=f(X," using "),S(x.$$.fragment,X),F=f(X,". This is a member of the "),S(V.$$.fragment,X),q=f(X,"-enumerant."),X.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(p,m),o(t,_),o(t,v),o(v,R),o(t,P),o(t,A),o(A,T),o(t,y),o(t,B),o(B,M),o(t,O),D(x,t,null),o(t,F),D(V,t,null),o(t,q),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),x.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),V.$set(K)},i(N){k||(b(a.$$.fragment,N),b(x.$$.fragment,N),b(V.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(x.$$.fragment,N),w(V.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(x),C(V)}}}function GK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setBorderColor(VkBorderColor borderColor);"}}),r=new Se({props:{$$slots:{params:[UK],details:[MK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class HK extends ve{constructor(e){super(),Ee(this,e,null,GK,be,{})}}function qK(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WK(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QK(c){let e;return{c(){e=i("setFilters")},l(t){e=f(t,"setFilters")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KK(c){let e;return{c(){e=i("setMipmapMode")},l(t){e=f(t,"setMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zK(c){let e;return{c(){e=i("setMaxAnisotropy")},l(t){e=f(t,"setMaxAnisotropy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jK(c){let e;return{c(){e=i("unsetMaxAnisotropy")},l(t){e=f(t,"unsetMaxAnisotropy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YK(c){let e;return{c(){e=i("setCompareOp")},l(t){e=f(t,"setCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XK(c){let e;return{c(){e=i("unsetCompareOp")},l(t){e=f(t,"unsetCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZK(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be;return n=new H({props:{sectionID:L.IMAGE,$$slots:{default:[qK]},$$scope:{ctx:c}}}),R=new H({props:{sectionID:L.IMAGE,$$slots:{default:[WK]},$$scope:{ctx:c}}}),q=new H({props:{sectionID:L.SAMPLER_BUILDER_setFilters,$$slots:{default:[QK]},$$scope:{ctx:c}}}),Z=new H({props:{sectionID:L.SAMPLER_BUILDER_setMipmapMode,$$slots:{default:[KK]},$$scope:{ctx:c}}}),le=new H({props:{sectionID:L.SAMPLER_BUILDER_setMaxAnisotropy,$$slots:{default:[zK]},$$scope:{ctx:c}}}),J=new H({props:{sectionID:L.SAMPLER_BUILDER_unsetMaxAnisotropy,$$slots:{default:[jK]},$$scope:{ctx:c}}}),Ce=new H({props:{sectionID:L.SAMPLER_BUILDER_setCompareOp,$$slots:{default:[YK]},$$scope:{ctx:c}}}),se=new H({props:{sectionID:L.SAMPLER_BUILDER_unsetCompareOp,$$slots:{default:[XK]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Enable unnormalized coordinates."),r=d("br"),$=i(`
        When enabled, indicates that the coordinates used to extract from the `),I(n.$$.fragment),s=i(` are in raw texel units, rather than a value normalized between
        `),a=d("code"),u=i("0.0"),p=i(`
        and
        `),m=d("code"),_=i("1.0"),v=i(`
        for each dimension of the texture. This allows texels to be explicitly extracted
        from the `),I(R.$$.fragment),P=i(`.
        However, there are several limitations in this mode. When
        `),A=d("code"),T=i("unnormalizedCoordinates"),y=i(`
        is enabled,
        `),B=d("code"),M=i("minFilter"),O=i(" and "),x=d("code"),F=i("magFilter"),V=i(" (see "),I(q.$$.fragment),k=i(") must be the same, "),N=d("code"),Q=i("mipmapMode"),X=i(" (see "),I(Z.$$.fragment),K=i(") must be set to "),W=d("code"),U=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),G=i(` and
        `),te=d("code"),ee=i("anisotropyEnable"),ne=i(`
        (see `),I(le.$$.fragment),ae=i(" and "),I(J.$$.fragment),ue=i(`) and
        `),De=d("code"),de=i("compareEnable"),me=i(" (see "),I(Ce.$$.fragment),_e=i(" and "),I(se.$$.fragment),ie=i(") must be set to "),ge=d("code"),we=i("VK_FALSE"),Re=i("."),this.h()},l(Ie){e=g(Ie,"SPAN",{slot:!0});var re=E(e);t=f(re,"Enable unnormalized coordinates."),r=g(re,"BR",{}),$=f(re,`
        When enabled, indicates that the coordinates used to extract from the `),S(n.$$.fragment,re),s=f(re,` are in raw texel units, rather than a value normalized between
        `),a=g(re,"CODE",{});var he=E(a);u=f(he,"0.0"),he.forEach(l),p=f(re,`
        and
        `),m=g(re,"CODE",{});var Ae=E(m);_=f(Ae,"1.0"),Ae.forEach(l),v=f(re,`
        for each dimension of the texture. This allows texels to be explicitly extracted
        from the `),S(R.$$.fragment,re),P=f(re,`.
        However, there are several limitations in this mode. When
        `),A=g(re,"CODE",{});var Ve=E(A);T=f(Ve,"unnormalizedCoordinates"),Ve.forEach(l),y=f(re,`
        is enabled,
        `),B=g(re,"CODE",{});var oe=E(B);M=f(oe,"minFilter"),oe.forEach(l),O=f(re," and "),x=g(re,"CODE",{});var ce=E(x);F=f(ce,"magFilter"),ce.forEach(l),V=f(re," (see "),S(q.$$.fragment,re),k=f(re,") must be the same, "),N=g(re,"CODE",{});var Pe=E(N);Q=f(Pe,"mipmapMode"),Pe.forEach(l),X=f(re," (see "),S(Z.$$.fragment,re),K=f(re,") must be set to "),W=g(re,"CODE",{});var Fe=E(W);U=f(Fe,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),Fe.forEach(l),G=f(re,` and
        `),te=g(re,"CODE",{});var ke=E(te);ee=f(ke,"anisotropyEnable"),ke.forEach(l),ne=f(re,`
        (see `),S(le.$$.fragment,re),ae=f(re," and "),S(J.$$.fragment,re),ue=f(re,`) and
        `),De=g(re,"CODE",{});var Te=E(De);de=f(Te,"compareEnable"),Te.forEach(l),me=f(re," (see "),S(Ce.$$.fragment,re),_e=f(re," and "),S(se.$$.fragment,re),ie=f(re,") must be set to "),ge=g(re,"CODE",{});var Me=E(ge);we=f(Me,"VK_FALSE"),Me.forEach(l),Re=f(re,"."),re.forEach(l),this.h()},h(){z(e,"slot","details")},m(Ie,re){h(Ie,e,re),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(R,e,null),o(e,P),o(e,A),o(A,T),o(e,y),o(e,B),o(B,M),o(e,O),o(e,x),o(x,F),o(e,V),D(q,e,null),o(e,k),o(e,N),o(N,Q),o(e,X),D(Z,e,null),o(e,K),o(e,W),o(W,U),o(e,G),o(e,te),o(te,ee),o(e,ne),D(le,e,null),o(e,ae),D(J,e,null),o(e,ue),o(e,De),o(De,de),o(e,me),D(Ce,e,null),o(e,_e),D(se,e,null),o(e,ie),o(e,ge),o(ge,we),o(e,Re),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),n.$set(he);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),R.$set(Ae);const Ve={};re&1&&(Ve.$$scope={dirty:re,ctx:Ie}),q.$set(Ve);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),Z.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),le.$set(ce);const Pe={};re&1&&(Pe.$$scope={dirty:re,ctx:Ie}),J.$set(Pe);const Fe={};re&1&&(Fe.$$scope={dirty:re,ctx:Ie}),Ce.$set(Fe);const ke={};re&1&&(ke.$$scope={dirty:re,ctx:Ie}),se.$set(ke)},i(Ie){Be||(b(n.$$.fragment,Ie),b(R.$$.fragment,Ie),b(q.$$.fragment,Ie),b(Z.$$.fragment,Ie),b(le.$$.fragment,Ie),b(J.$$.fragment,Ie),b(Ce.$$.fragment,Ie),b(se.$$.fragment,Ie),Be=!0)},o(Ie){w(n.$$.fragment,Ie),w(R.$$.fragment,Ie),w(q.$$.fragment,Ie),w(Z.$$.fragment,Ie),w(le.$$.fragment,Ie),w(J.$$.fragment,Ie),w(Ce.$$.fragment,Ie),w(se.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(n),C(R),C(q),C(Z),C(le),C(J),C(Ce),C(se)}}}function JK(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void enableUnnormalizedCoordinates();"}}),r=new Se({props:{$$slots:{details:[ZK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ez extends ve{constructor(e){super(),Ee(this,e,null,JK,be,{})}}function tz(c){let e,t;return{c(){e=d("span"),t=i("Disable unnormalized coordinates."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Disable unnormalized coordinates."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function rz(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void disableUnnormalizedCoordinates();"}}),r=new Se({props:{$$slots:{details:[tz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nz extends ve{constructor(e){super(),Ee(this,e,null,rz,be,{})}}function sz(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function az(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[sz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function oz(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lz(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iz(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[oz]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[lz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function fz(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cz(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.SAMPLER,$$slots:{default:[fz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function $z(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<Sampler> getResult();"}}),r=new Se({props:{$$slots:{throws:[cz],return:[iz],details:[az]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uz extends ve{constructor(e){super(),Ee(this,e,null,$z,be,{})}}function pz(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mz(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function hz(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset();"}}),r=new Se({props:{$$slots:{details:[mz],default:[pz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dz extends ve{constructor(e){super(),Ee(this,e,null,hz,be,{})}}function gz(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _z(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vz(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/graphics_pipeline.hpp>"}}),a=new H({props:{sectionID:L.PIPELINE,$$slots:{default:[gz]},$$scope:{ctx:c}}}),v=new H({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[_z]},$$scope:{ctx:c}}}),V=new $e({props:{language:pe,code:`#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inColor;
        
layout(location = 0) out vec3 outColor;
        
layout(push_constant) uniform PushConstant {
    mat4 transform;
    vec3 color;
} push_constant;
        
void main() {
    gl_Position = push_constant.transform * vec4(inPosition, 1.0);
    outColor = inColor;
}`}}),k=new $e({props:{language:hn,code:`#version 450

layout(location = 0) in vec3 inColor;
    
layout(location = 0) out vec4 outColor;
    
layout(push_constant) uniform PushConstant {
    mat4 transform;
    vec3 color;
} push_constant;
    
void main() {
    outColor = vec4(inColor, 1.0);
}`}}),Q=new $e({props:{language:hn,code:`// Bind the pipeline to a command buffer
upGraphicsPipeline->bindToCommandBuffer(pCommandBuffer);

// Bind any descriptor sets to the pipeline
upGraphicsPipeline->bindDescriptorSets(std::vector<std::string>{"ExampleDescriptorSet"}, 0);

// Update any push constant data
upGraphicsPipeline->pushConstantData("ExamplePushConstant", std::move(examplePushConstantData));
`}}),Z=new $e({props:{language:pe,code:`struct SimplePushConstantData : public fillcan::PushConstantData {
    glm::mat4 transform{1.f};
    alignas(16) glm::vec3 color;
};
...
{
    // Create recording to gain access to a primary commandbuffer
    fillcan::CommandRecording* pGraphicsCommandRecording = fillcan.getCurrentDevice()->getGraphicsQueue()->createRecording(1, 0);
    fillcan::CommandBuffer* pGraphicsPrimaryCommandBuffer = pGraphicsCommandRecording->pPrimaryCommandBuffers.at(0);

    // Begin compute recording commands
    pGraphicsPrimaryCommandBuffer->begin();

    // Bind the pipeline to a command buffer
    upGraphicsPipeline->bindToCommandBuffer(pGraphicsPrimaryCommandBuffer);

    // Bind the descriptor sets to the bound command buffer
    upGraphicsPipeline->bindDescriptorSets();

    for (fillcan::GameObject& gameObject : gameObjects) {
        gameObject.transform.rotation.y = glm::mod(gameObject.transform.rotation.y + (0.5f * this->deltaTimef), glm::two_pi<float>());
        gameObject.transform.rotation.x = glm::mod(gameObject.transform.rotation.x + (0.25f * this->deltaTimef), glm::two_pi<float>());

        SimplePushConstantData data = {.transform = gameObject.transform.mat4(), .color = gameObject.color};
    
        // Update the push constant data
        std::unique_ptr<SimplePushConstantData> simplePushConstantData = std::make_unique<SimplePushConstantData>(data);
        upGraphicsPipeline->pushConstantData("SimplePushConstant", std::move(simplePushConstantData));

        gameObject.model->bind(pGraphicsPrimaryCommandBuffer);
        gameObject.model->drawIndexed();
    }

    // End the recording
    pGraphicsPrimaryCommandBuffer->end();
}`}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Graphics Pipeline"),n=i(` class extends the
`),s=d("code"),I(a.$$.fragment),u=i(`
class.`),p=d("br"),m=d("br"),_=i(`
Creating a graphics pipeline is accomplished using a method similar to that of creating
a `),I(v.$$.fragment),R=i(`. However, the graphics pipeline contains many shader stages and fixed function
processing blocks, so the description of a graphics pipeline is much more
complex.`),P=d("br"),A=d("br"),T=i(`
The most basic rendering will contain at least a vertex and a fragment shader. Each
shader stage can consume data from the previous stage or pass data to the next, forming
a pipeline. In some cases, the inputs to a shader are provided by fixed function
blocks, and sometimes the outputs of a shader are consumed by fixed function blocks.
Regardless of the source or destination of data, the way to declare the *input and
output to shaders is the same.`),y=d("br"),B=d("br"),M=i(`
Example:`),O=d("br"),x=d("br"),F=i(`

Vertex Shader:
`),I(V.$$.fragment),q=i(`

Fragment Shader:
`),I(k.$$.fragment),N=j(),I(Q.$$.fragment),X=i(`
C++ Code:
`),I(Z.$$.fragment)},l(W){S(e.$$.fragment,W),t=f(W,`

The `),r=g(W,"CODE",{});var U=E(r);$=f(U,"Graphics Pipeline"),U.forEach(l),n=f(W,` class extends the
`),s=g(W,"CODE",{});var G=E(s);S(a.$$.fragment,G),G.forEach(l),u=f(W,`
class.`),p=g(W,"BR",{}),m=g(W,"BR",{}),_=f(W,`
Creating a graphics pipeline is accomplished using a method similar to that of creating
a `),S(v.$$.fragment,W),R=f(W,`. However, the graphics pipeline contains many shader stages and fixed function
processing blocks, so the description of a graphics pipeline is much more
complex.`),P=g(W,"BR",{}),A=g(W,"BR",{}),T=f(W,`
The most basic rendering will contain at least a vertex and a fragment shader. Each
shader stage can consume data from the previous stage or pass data to the next, forming
a pipeline. In some cases, the inputs to a shader are provided by fixed function
blocks, and sometimes the outputs of a shader are consumed by fixed function blocks.
Regardless of the source or destination of data, the way to declare the *input and
output to shaders is the same.`),y=g(W,"BR",{}),B=g(W,"BR",{}),M=f(W,`
Example:`),O=g(W,"BR",{}),x=g(W,"BR",{}),F=f(W,`

Vertex Shader:
`),S(V.$$.fragment,W),q=f(W,`

Fragment Shader:
`),S(k.$$.fragment,W),N=Y(W),S(Q.$$.fragment,W),X=f(W,`
C++ Code:
`),S(Z.$$.fragment,W)},m(W,U){D(e,W,U),h(W,t,U),h(W,r,U),o(r,$),h(W,n,U),h(W,s,U),D(a,s,null),h(W,u,U),h(W,p,U),h(W,m,U),h(W,_,U),D(v,W,U),h(W,R,U),h(W,P,U),h(W,A,U),h(W,T,U),h(W,y,U),h(W,B,U),h(W,M,U),h(W,O,U),h(W,x,U),h(W,F,U),D(V,W,U),h(W,q,U),D(k,W,U),h(W,N,U),D(Q,W,U),h(W,X,U),D(Z,W,U),K=!0},p(W,[U]){const G={};U&1&&(G.$$scope={dirty:U,ctx:W}),a.$set(G);const te={};U&1&&(te.$$scope={dirty:U,ctx:W}),v.$set(te)},i(W){K||(b(e.$$.fragment,W),b(a.$$.fragment,W),b(v.$$.fragment,W),b(V.$$.fragment,W),b(k.$$.fragment,W),b(Q.$$.fragment,W),b(Z.$$.fragment,W),K=!0)},o(W){w(e.$$.fragment,W),w(a.$$.fragment,W),w(v.$$.fragment,W),w(V.$$.fragment,W),w(k.$$.fragment,W),w(Q.$$.fragment,W),w(Z.$$.fragment,W),K=!1},d(W){C(e,W),W&&l(t),W&&l(r),W&&l(n),W&&l(s),C(a),W&&l(u),W&&l(p),W&&l(m),W&&l(_),C(v,W),W&&l(R),W&&l(P),W&&l(A),W&&l(T),W&&l(y),W&&l(B),W&&l(M),W&&l(O),W&&l(x),W&&l(F),C(V,W),W&&l(q),C(k,W),W&&l(N),C(Q,W),W&&l(X),C(Z,W)}}}class Ez extends ve{constructor(e){super(),Ee(this,e,null,vz,be,{})}}function bz(c){let e;return{c(){e=i("Graphics Pipeline Builder")},l(t){e=f(t,"Graphics Pipeline Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wz(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.GRAPHICS_PIPELINE_BUILDER,$$slots:{default:[bz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Graphics Pipeline."),r=d("br"),$=i(`
        It is recommended to not create a Graphics Pipeline by it's Constructor,
        but to use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Graphics Pipeline."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Graphics Pipeline by it's Constructor,
        but to use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Iz(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dz(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cz(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sz(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rz(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Az(c){let e;return{c(){e=i("VkPipelineInputAssemblyStateCreateInfo")},l(t){e=f(t,"VkPipelineInputAssemblyStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pz(c){let e;return{c(){e=i("VkPipelineVertexInputStateCreateInfo")},l(t){e=f(t,"VkPipelineVertexInputStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bz(c){let e;return{c(){e=i("VkPipelineTessellationStateCreateInfo")},l(t){e=f(t,"VkPipelineTessellationStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lz(c){let e;return{c(){e=i("VkPipelineViewportStateCreateInfo")},l(t){e=f(t,"VkPipelineViewportStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kz(c){let e;return{c(){e=i("VkPipelineRasterizationStateCreateInfo")},l(t){e=f(t,"VkPipelineRasterizationStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tz(c){let e;return{c(){e=i("VkPipelineMultisampleStateCreateInfo")},l(t){e=f(t,"VkPipelineMultisampleStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oz(c){let e;return{c(){e=i("VkPipelineDepthStencilStateCreateInfo")},l(t){e=f(t,"VkPipelineDepthStencilStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vz(c){let e;return{c(){e=i("VkPipelineColorBlendStateCreateInfo")},l(t){e=f(t,"VkPipelineColorBlendStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yz(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mz(c){let e;return{c(){e=i("VkPipelineDynamicStateCreateInfo")},l(t){e=f(t,"VkPipelineDynamicStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nz(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze,nt,Ke,ct,st,Qe,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,yt,mt,Ot,Pt,Tt,vt,gt,kt,Ft,Mt,Ht,$r,Ut,or,Xt,Vt,Zt,Ar,br,ur,Qt,Vr,rr,Kr,lr,gr,yr,Kt,ir,Mr,Le,lt,Jt,_r,jt,nr,vr,Tr,fr,cr,sr,er,zr;return a=new H({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Iz]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[Dz]},$$scope:{ctx:c}}}),V=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[Cz]},$$scope:{ctx:c}}}),W=new H({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[Sz]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[Rz]},$$scope:{ctx:c}}}),oe=new Bt({props:{reference:"VkPipelineInputAssemblyStateCreateInfo",version:1.3,$$slots:{default:[Az]},$$scope:{ctx:c}}}),qe=new Bt({props:{reference:"VkPipelineVertexInputStateCreateInfo",version:1.3,$$slots:{default:[Pz]},$$scope:{ctx:c}}}),Ne=new Bt({props:{reference:"VkPipelineTessellationStateCreateInfo",version:1.3,$$slots:{default:[Bz]},$$scope:{ctx:c}}}),Ze=new Bt({props:{reference:"VkPipelineViewportStateCreateInfo",version:1.3,$$slots:{default:[Lz]},$$scope:{ctx:c}}}),wt=new Bt({props:{reference:"VkPipelineRasterizationStateCreateInfo",version:1.3,$$slots:{default:[kz]},$$scope:{ctx:c}}}),Ct=new Bt({props:{reference:"VkPipelineMultisampleStateCreateInfo",version:1.3,$$slots:{default:[Tz]},$$scope:{ctx:c}}}),gt=new Bt({props:{reference:"VkPipelineDepthStencilStateCreateInfo",version:1.3,$$slots:{default:[Oz]},$$scope:{ctx:c}}}),Xt=new Bt({props:{reference:"VkPipelineColorBlendStateCreateInfo",version:1.3,$$slots:{default:[Vz]},$$scope:{ctx:c}}}),Zt=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[yz]},$$scope:{ctx:c}}}),lr=new Bt({props:{reference:"VkPipelineDynamicStateCreateInfo",version:1.3,$$slots:{default:[Mz]},$$scope:{ctx:c}}}),Jt=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Fz]},$$scope:{ctx:c}}}),sr=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[xz]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=j(),m=d("li"),_=d("code"),v=i("flags"),R=d("br"),P=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),y=j(),B=d("li"),M=d("code"),O=i("shaderStages"),x=d("br"),F=i(`
            A list of `),I(V.$$.fragment),q=i("-structures each of which defining a shader stage of the pipeline."),k=j(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),U=i(" to be bound to the pipeline."),G=j(),te=d("li"),ee=d("code"),ne=i("pipelineCache"),le=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),ue=i(" object."),De=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=j(),Ce=d("li"),_e=d("code"),se=i("pBasePipeline"),ie=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Re=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Be=j(),Ie=d("li"),re=d("code"),he=i("pInputAssemblyState"),Ae=d("br"),Ve=i(`
            A pointer to a `),I(oe.$$.fragment),ce=i(`-structure describing the input assembly state. The input assembly
            stage reads the index and vertex buffers that contain information
            about the vertices making up the draw sent in the draw command.`),Pe=j(),Fe=d("li"),ke=d("code"),Te=i("pVertexInputState"),Me=d("br"),Ue=i(`
            A pointer to a `),I(qe.$$.fragment),xe=i(`-structure describing the vertex input state. The vertex input
            stage inputs vertex-data into the vertex shader.`),Ge=j(),ye=d("li"),We=d("code"),ze=i("pTessellationState"),Ye=d("br"),rt=i(`
            A pointer to a `),I(Ne.$$.fragment),He=i(`-structure describing the tessellation state. The Tessellation
            control shader is responsible for producing tessellation factors and
            other pre-patch data. that is used by the fixed-function
            tessellation engine. The tessellation evaluation shader runs on each
            new vertex produced by the tessellation primitive generator. It
            operates similarly to a vertex shader except that incoming vertices
            are generated rather than read from memory.`),$t=j(),ut=d("li"),ht=d("code"),Je=i("viewportState"),dt=d("br"),et=i(`
            A list of `),I(Ze.$$.fragment),nt=i(`-structures each of which describing a viewport state.
            Viewport-transformation is the last co\xF6rdinate transformation in the
            Graphics Pipeline before rasterization. It transforms the normalized
            device-co\xF6rdinates to window-co\xF6rdinates.`),Ke=j(),ct=d("li"),st=d("code"),Qe=i("pRasterizationState"),at=d("br"),bt=i(`
            A pointer to a `),I(wt.$$.fragment),St=i(`-structure describing the rasterization state. Rasterization is the
            fundamental core of all graphics in Vulkan. The rasterizer takes
            assembled primitives that are still represented by a sequence of
            vertices and turns them into individual fratments, which may become
            pixels that make up the output image.`),tt=j(),ot=d("li"),At=d("code"),it=i("pMultisampleState"),Xe=d("br"),Dt=i(`
            A pointer to a `),I(Ct.$$.fragment),pt=i(`-structure describing the multisample state. Multisampling is the
            process of generating multiple samples for each pixel in an image.
            It is used to counteract aliasing and can significantly improve
            image quality when used effectively.`),yt=j(),mt=d("li"),Ot=d("code"),Pt=i("pDepthStencilState"),Tt=d("br"),vt=i(`
            A pointer to a `),I(gt.$$.fragment),kt=i(`-structure describing the depth- stencil state. The depth stencil
            state determines how the depth and stencil tests are performed and
            what happens to a snippet if it passes or fails one of these tests.
            The depth and stencil tests can be performed before or after the
            fragment shader has been run. By default, the tests take place after
            the fragment shader.`),Ft=j(),Mt=d("li"),Ht=d("code"),$r=i("pColorBlendState"),Ut=d("br"),or=i(`
            A pointer to a `),I(Xt.$$.fragment),Vt=i(`-structure describing the color blend state. The color operations
            take the final results of the fragment shader and postfragment
            operations and use them to update the `),I(Zt.$$.fragment),Ar=i(`. The color operations include blending and logic operations. This
            stage is responsible for writing fragments in the color attachments.`),br=j(),ur=d("li"),Qt=d("code"),Vr=i("pDynamicState"),rr=d("br"),Kr=i(`
            A pointer to a `),I(lr.$$.fragment),gr=i(`-structure describing the dynamic state. To make fine-grained state
            changes more manageable, Vulkan provides the ability to mark certain
            parts of the graphics pipeline as dynamic, meaning they can be
            updated directly using commands directly in the command buffer
            rather than using an object. Since this reduces the chance for
            Vulkan to optimize or absorb parts of the state, it is necessary to
            specify exactly which state to make dynamically.`),yr=j(),Kt=d("li"),ir=d("code"),Mr=i("pRenderPass"),Le=d("br"),lt=i(`
            A pointer to a `),I(Jt.$$.fragment),_r=i(" that describes the environment in which the pipeline will be used."),jt=j(),nr=d("li"),vr=d("code"),Tr=i("subpass"),fr=d("br"),cr=i(`
            The index of the subpass in the `),I(sr.$$.fragment),er=i(" where this pipeline will be used."),this.h()},l(_t){e=g(_t,"DIV",{slot:!0});var ft=E(e);t=g(ft,"LI",{});var qt=E(t);r=g(qt,"CODE",{});var Fr=E(r);$=f(Fr,"pLogicalDevice"),Fr.forEach(l),n=g(qt,"BR",{}),s=f(qt,`
            A pointer to the `),S(a.$$.fragment,qt),u=f(qt," the Pipeline should be associated with."),qt.forEach(l),p=Y(ft),m=g(ft,"LI",{});var wr=E(m);_=g(wr,"CODE",{});var Nt=E(_);v=f(Nt,"flags"),Nt.forEach(l),R=g(wr,"BR",{}),P=f(wr,`
            A bitmask of `),S(A.$$.fragment,wr),T=f(wr," controlling how the pipeline is created."),wr.forEach(l),y=Y(ft),B=g(ft,"LI",{});var Wt=E(B);M=g(Wt,"CODE",{});var xr=E(M);O=f(xr,"shaderStages"),xr.forEach(l),x=g(Wt,"BR",{}),F=f(Wt,`
            A list of `),S(V.$$.fragment,Wt),q=f(Wt,"-structures each of which defining a shader stage of the pipeline."),Wt.forEach(l),k=Y(ft),N=g(ft,"LI",{});var pr=E(N);Q=g(pr,"CODE",{});var Or=E(Q);X=f(Or,"pushConstants"),Or.forEach(l),Z=g(pr,"BR",{}),K=f(pr,`
            A list of `),S(W.$$.fragment,pr),U=f(pr," to be bound to the pipeline."),pr.forEach(l),G=Y(ft),te=g(ft,"LI",{});var Yt=E(te);ee=g(Yt,"CODE",{});var Pr=E(ee);ne=f(Pr,"pipelineCache"),Pr.forEach(l),le=g(Yt,"BR",{}),ae=f(Yt,`
            A handle to a `),S(J.$$.fragment,Yt),ue=f(Yt," object."),De=g(Yt,"BR",{}),de=f(Yt,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),Yt.forEach(l),me=Y(ft),Ce=g(ft,"LI",{});var Ir=E(Ce);_e=g(Ir,"CODE",{});var Nr=E(_e);se=f(Nr,"pBasePipeline"),Nr.forEach(l),ie=g(Ir,"BR",{}),ge=f(Ir,`
            A pointer to the pipeline to derive from.`),we=g(Ir,"BR",{}),Re=f(Ir,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Ir.forEach(l),Be=Y(ft),Ie=g(ft,"LI",{});var mr=E(Ie);re=g(mr,"CODE",{});var Dr=E(re);he=f(Dr,"pInputAssemblyState"),Dr.forEach(l),Ae=g(mr,"BR",{}),Ve=f(mr,`
            A pointer to a `),S(oe.$$.fragment,mr),ce=f(mr,`-structure describing the input assembly state. The input assembly
            stage reads the index and vertex buffers that contain information
            about the vertices making up the draw sent in the draw command.`),mr.forEach(l),Pe=Y(ft),Fe=g(ft,"LI",{});var hr=E(Fe);ke=g(hr,"CODE",{});var Br=E(ke);Te=f(Br,"pVertexInputState"),Br.forEach(l),Me=g(hr,"BR",{}),Ue=f(hr,`
            A pointer to a `),S(qe.$$.fragment,hr),xe=f(hr,`-structure describing the vertex input state. The vertex input
            stage inputs vertex-data into the vertex shader.`),hr.forEach(l),Ge=Y(ft),ye=g(ft,"LI",{});var Cr=E(ye);We=g(Cr,"CODE",{});var en=E(We);ze=f(en,"pTessellationState"),en.forEach(l),Ye=g(Cr,"BR",{}),rt=f(Cr,`
            A pointer to a `),S(Ne.$$.fragment,Cr),He=f(Cr,`-structure describing the tessellation state. The Tessellation
            control shader is responsible for producing tessellation factors and
            other pre-patch data. that is used by the fixed-function
            tessellation engine. The tessellation evaluation shader runs on each
            new vertex produced by the tessellation primitive generator. It
            operates similarly to a vertex shader except that incoming vertices
            are generated rather than read from memory.`),Cr.forEach(l),$t=Y(ft),ut=g(ft,"LI",{});var Ur=E(ut);ht=g(Ur,"CODE",{});var tr=E(ht);Je=f(tr,"viewportState"),tr.forEach(l),dt=g(Ur,"BR",{}),et=f(Ur,`
            A list of `),S(Ze.$$.fragment,Ur),nt=f(Ur,`-structures each of which describing a viewport state.
            Viewport-transformation is the last co\xF6rdinate transformation in the
            Graphics Pipeline before rasterization. It transforms the normalized
            device-co\xF6rdinates to window-co\xF6rdinates.`),Ur.forEach(l),Ke=Y(ft),ct=g(ft,"LI",{});var Gr=E(ct);st=g(Gr,"CODE",{});var tn=E(st);Qe=f(tn,"pRasterizationState"),tn.forEach(l),at=g(Gr,"BR",{}),bt=f(Gr,`
            A pointer to a `),S(wt.$$.fragment,Gr),St=f(Gr,`-structure describing the rasterization state. Rasterization is the
            fundamental core of all graphics in Vulkan. The rasterizer takes
            assembled primitives that are still represented by a sequence of
            vertices and turns them into individual fratments, which may become
            pixels that make up the output image.`),Gr.forEach(l),tt=Y(ft),ot=g(ft,"LI",{});var Yr=E(ot);At=g(Yr,"CODE",{});var ln=E(At);it=f(ln,"pMultisampleState"),ln.forEach(l),Xe=g(Yr,"BR",{}),Dt=f(Yr,`
            A pointer to a `),S(Ct.$$.fragment,Yr),pt=f(Yr,`-structure describing the multisample state. Multisampling is the
            process of generating multiple samples for each pixel in an image.
            It is used to counteract aliasing and can significantly improve
            image quality when used effectively.`),Yr.forEach(l),yt=Y(ft),mt=g(ft,"LI",{});var Er=E(mt);Ot=g(Er,"CODE",{});var fn=E(Ot);Pt=f(fn,"pDepthStencilState"),fn.forEach(l),Tt=g(Er,"BR",{}),vt=f(Er,`
            A pointer to a `),S(gt.$$.fragment,Er),kt=f(Er,`-structure describing the depth- stencil state. The depth stencil
            state determines how the depth and stencil tests are performed and
            what happens to a snippet if it passes or fails one of these tests.
            The depth and stencil tests can be performed before or after the
            fragment shader has been run. By default, the tests take place after
            the fragment shader.`),Er.forEach(l),Ft=Y(ft),Mt=g(ft,"LI",{});var Lr=E(Mt);Ht=g(Lr,"CODE",{});var cn=E(Ht);$r=f(cn,"pColorBlendState"),cn.forEach(l),Ut=g(Lr,"BR",{}),or=f(Lr,`
            A pointer to a `),S(Xt.$$.fragment,Lr),Vt=f(Lr,`-structure describing the color blend state. The color operations
            take the final results of the fragment shader and postfragment
            operations and use them to update the `),S(Zt.$$.fragment,Lr),Ar=f(Lr,`. The color operations include blending and logic operations. This
            stage is responsible for writing fragments in the color attachments.`),Lr.forEach(l),br=Y(ft),ur=g(ft,"LI",{});var jr=E(ur);Qt=g(jr,"CODE",{});var Lt=E(Qt);Vr=f(Lt,"pDynamicState"),Lt.forEach(l),rr=g(jr,"BR",{}),Kr=f(jr,`
            A pointer to a `),S(lr.$$.fragment,jr),gr=f(jr,`-structure describing the dynamic state. To make fine-grained state
            changes more manageable, Vulkan provides the ability to mark certain
            parts of the graphics pipeline as dynamic, meaning they can be
            updated directly using commands directly in the command buffer
            rather than using an object. Since this reduces the chance for
            Vulkan to optimize or absorb parts of the state, it is necessary to
            specify exactly which state to make dynamically.`),jr.forEach(l),yr=Y(ft),Kt=g(ft,"LI",{});var It=E(Kt);ir=g(It,"CODE",{});var Hr=E(ir);Mr=f(Hr,"pRenderPass"),Hr.forEach(l),Le=g(It,"BR",{}),lt=f(It,`
            A pointer to a `),S(Jt.$$.fragment,It),_r=f(It," that describes the environment in which the pipeline will be used."),It.forEach(l),jt=Y(ft),nr=g(ft,"LI",{});var kr=E(nr);vr=g(kr,"CODE",{});var qr=E(vr);Tr=f(qr,"subpass"),qr.forEach(l),fr=g(kr,"BR",{}),cr=f(kr,`
            The index of the subpass in the `),S(sr.$$.fragment,kr),er=f(kr," where this pipeline will be used."),kr.forEach(l),ft.forEach(l),this.h()},h(){z(e,"slot","params")},m(_t,ft){h(_t,e,ft),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),o(e,y),o(e,B),o(B,M),o(M,O),o(B,x),o(B,F),D(V,B,null),o(B,q),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),D(J,te,null),o(te,ue),o(te,De),o(te,de),o(e,me),o(e,Ce),o(Ce,_e),o(_e,se),o(Ce,ie),o(Ce,ge),o(Ce,we),o(Ce,Re),o(e,Be),o(e,Ie),o(Ie,re),o(re,he),o(Ie,Ae),o(Ie,Ve),D(oe,Ie,null),o(Ie,ce),o(e,Pe),o(e,Fe),o(Fe,ke),o(ke,Te),o(Fe,Me),o(Fe,Ue),D(qe,Fe,null),o(Fe,xe),o(e,Ge),o(e,ye),o(ye,We),o(We,ze),o(ye,Ye),o(ye,rt),D(Ne,ye,null),o(ye,He),o(e,$t),o(e,ut),o(ut,ht),o(ht,Je),o(ut,dt),o(ut,et),D(Ze,ut,null),o(ut,nt),o(e,Ke),o(e,ct),o(ct,st),o(st,Qe),o(ct,at),o(ct,bt),D(wt,ct,null),o(ct,St),o(e,tt),o(e,ot),o(ot,At),o(At,it),o(ot,Xe),o(ot,Dt),D(Ct,ot,null),o(ot,pt),o(e,yt),o(e,mt),o(mt,Ot),o(Ot,Pt),o(mt,Tt),o(mt,vt),D(gt,mt,null),o(mt,kt),o(e,Ft),o(e,Mt),o(Mt,Ht),o(Ht,$r),o(Mt,Ut),o(Mt,or),D(Xt,Mt,null),o(Mt,Vt),D(Zt,Mt,null),o(Mt,Ar),o(e,br),o(e,ur),o(ur,Qt),o(Qt,Vr),o(ur,rr),o(ur,Kr),D(lr,ur,null),o(ur,gr),o(e,yr),o(e,Kt),o(Kt,ir),o(ir,Mr),o(Kt,Le),o(Kt,lt),D(Jt,Kt,null),o(Kt,_r),o(e,jt),o(e,nr),o(nr,vr),o(vr,Tr),o(nr,fr),o(nr,cr),D(sr,nr,null),o(nr,er),zr=!0},p(_t,ft){const qt={};ft&1&&(qt.$$scope={dirty:ft,ctx:_t}),a.$set(qt);const Fr={};ft&1&&(Fr.$$scope={dirty:ft,ctx:_t}),A.$set(Fr);const wr={};ft&1&&(wr.$$scope={dirty:ft,ctx:_t}),V.$set(wr);const Nt={};ft&1&&(Nt.$$scope={dirty:ft,ctx:_t}),W.$set(Nt);const Wt={};ft&1&&(Wt.$$scope={dirty:ft,ctx:_t}),J.$set(Wt);const xr={};ft&1&&(xr.$$scope={dirty:ft,ctx:_t}),oe.$set(xr);const pr={};ft&1&&(pr.$$scope={dirty:ft,ctx:_t}),qe.$set(pr);const Or={};ft&1&&(Or.$$scope={dirty:ft,ctx:_t}),Ne.$set(Or);const Yt={};ft&1&&(Yt.$$scope={dirty:ft,ctx:_t}),Ze.$set(Yt);const Pr={};ft&1&&(Pr.$$scope={dirty:ft,ctx:_t}),wt.$set(Pr);const Ir={};ft&1&&(Ir.$$scope={dirty:ft,ctx:_t}),Ct.$set(Ir);const Nr={};ft&1&&(Nr.$$scope={dirty:ft,ctx:_t}),gt.$set(Nr);const mr={};ft&1&&(mr.$$scope={dirty:ft,ctx:_t}),Xt.$set(mr);const Dr={};ft&1&&(Dr.$$scope={dirty:ft,ctx:_t}),Zt.$set(Dr);const hr={};ft&1&&(hr.$$scope={dirty:ft,ctx:_t}),lr.$set(hr);const Br={};ft&1&&(Br.$$scope={dirty:ft,ctx:_t}),Jt.$set(Br);const Cr={};ft&1&&(Cr.$$scope={dirty:ft,ctx:_t}),sr.$set(Cr)},i(_t){zr||(b(a.$$.fragment,_t),b(A.$$.fragment,_t),b(V.$$.fragment,_t),b(W.$$.fragment,_t),b(J.$$.fragment,_t),b(oe.$$.fragment,_t),b(qe.$$.fragment,_t),b(Ne.$$.fragment,_t),b(Ze.$$.fragment,_t),b(wt.$$.fragment,_t),b(Ct.$$.fragment,_t),b(gt.$$.fragment,_t),b(Xt.$$.fragment,_t),b(Zt.$$.fragment,_t),b(lr.$$.fragment,_t),b(Jt.$$.fragment,_t),b(sr.$$.fragment,_t),zr=!0)},o(_t){w(a.$$.fragment,_t),w(A.$$.fragment,_t),w(V.$$.fragment,_t),w(W.$$.fragment,_t),w(J.$$.fragment,_t),w(oe.$$.fragment,_t),w(qe.$$.fragment,_t),w(Ne.$$.fragment,_t),w(Ze.$$.fragment,_t),w(wt.$$.fragment,_t),w(Ct.$$.fragment,_t),w(gt.$$.fragment,_t),w(Xt.$$.fragment,_t),w(Zt.$$.fragment,_t),w(lr.$$.fragment,_t),w(Jt.$$.fragment,_t),w(sr.$$.fragment,_t),zr=!1},d(_t){_t&&l(e),C(a),C(A),C(V),C(W),C(J),C(oe),C(qe),C(Ne),C(Ze),C(wt),C(Ct),C(gt),C(Xt),C(Zt),C(lr),C(Jt),C(sr)}}}function Uz(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gz(c){let e;return{c(){e=i("Vulkan Compute Pipeline")},l(t){e=f(t,"Vulkan Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hz(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[Uz]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[Gz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        Also throws std::runtime_error if the `),I(p.$$.fragment),m=i(" couldn't be created."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var P=E(t);r=f(P,"std::runtime_error"),P.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R," couldn't be created."),a=g(R,"BR",{}),u=f(R,`
        Also throws std::runtime_error if the `),S(p.$$.fragment,R),m=f(R," couldn't be created."),R.forEach(l),this.h()},h(){z(e,"slot","throws")},m(v,R){h(v,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,R){const P={};R&1&&(P.$$scope={dirty:R,ctx:v}),n.$set(P);const A={};R&1&&(A.$$scope={dirty:R,ctx:v}),p.$set(A)},i(v){_||(b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(p)}}}function qz(c){let e,t,r,$;return e=new $e({props:{language:pe,code:`GraphicsPipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags, 
    std::vector<PipelineShaderStage> shaderStages,
    std::vector<PushConstant> pushConstants, 
    VkPipelineCache pipelineCache, 
    Pipeline* pBasePipeline,
    VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState, 
    VkPipelineVertexInputStateCreateInfo* pVertexInputState,
    VkPipelineTessellationStateCreateInfo* pTessellationState, 
    std::vector<VkPipelineViewportStateCreateInfo>& viewportState,
    VkPipelineRasterizationStateCreateInfo* pRasterizationState, 
    VkPipelineMultisampleStateCreateInfo* pMultisampleState,
    VkPipelineDepthStencilStateCreateInfo* pDepthStencilState, 
    VkPipelineColorBlendStateCreateInfo* pColorBlendState,
    VkPipelineDynamicStateCreateInfo* pDynamicState, 
    RenderPass* pRenderPass, 
    unsigned int subpass
);`}}),r=new Se({props:{$$slots:{throws:[Hz],params:[Nz],details:[wz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Wz extends ve{constructor(e){super(),Ee(this,e,null,qz,be,{})}}function Qz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kz(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Qz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" that describes the environment in which this pipeline is used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," that describes the environment in which this pipeline is used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jz(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[zz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(`
        with which this pipeline associates.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The "),S(r.$$.fragment,a),$=f(a,`
        with which this pipeline associates.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Yz(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"RenderPass* getRenderPass();"}}),r=new Se({props:{$$slots:{return:[jz],details:[Kz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Xz extends ve{constructor(e){super(),Ee(this,e,null,Yz,be,{})}}function Zz(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return e=new $e({props:{language:pe,code:"#include <fillcan/graphics/graphics_pipeline_builder.hpp>"}}),R=new $e({props:{language:pe,code:`std::vector<PipelineShaderStage> shaderStages = {};
std::unique_ptr<PipelineVertexInputState> upVertexInputState = nullptr;
std::unique_ptr<PipelineInputAssemblyState> upInputAssemblyState = nullptr;
std::unique_ptr<PipelineTessellationState> upTessellationState = nullptr;
std::vector<std::unique_ptr<PipelineViewPortState>> upViewPortStates = {};
std::unique_ptr<PipelineRasterizationState> upRasterizationState = nullptr;
std::unique_ptr<PipelineMultisampleState> upMultisampleState = nullptr;
std::unique_ptr<PipelineDepthStencilState> upDepthStencilState = nullptr;
std::unique_ptr<PipelineColorBlendState> upColorBlendState = nullptr;
std::unique_ptr<PipelineDynamicState> upDynamicState = nullptr;
RenderPass* pRenderPass = nullptr;
unsigned int subpass = 0;`}}),T=new $e({props:{language:pe,code:`fillcan::GraphicsPipelineBuilder graphicsPipelineBuilder{};
graphicsPipelineBuilder.setLogicalDevice(fillcan.getCurrentDevice());
graphicsPipelineBuilder.addShaderStage(
    {
        .stage = VK_SHADER_STAGE_VERTEX_BIT, 
        .pShaderModule = pVertexShaderModule, 
        .name = "main"
    }
);
graphicsPipelineBuilder.addShaderStage({.stage = VK_SHADER_STAGE_FRAGMENT_BIT, .pShaderModule = pFragmentShaderModule, .name = "main"});

graphicsPipelineBuilder.addPushConstant(
    "SimplePushConstant",
    {
        .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 
        .offset = 0, 
        .size = sizeof(SimplePushConstantData)
    }
);

graphicsPipelineBuilder.setInputAssemblyState({.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = VK_FALSE});

// Describe the vertex shader
graphicsPipelineBuilder.setVertexInputState(
    {
        fillcan::Model::Vertex::getBindingDescriptions(),
        {
            fillcan::Model::Vertex::getPositionAttributeDescription(0), 
            fillcan::Model::Vertex::getColorAttributeDescription(1)
        }
    }
);

// The viewports and scissors are dynamic, but the amount of viewports and scissors should still be defined
std::vector<VkViewport> viewports = {};
viewports.resize(1);
std::vector<VkRect2D> scissors = {};
scissors.resize(1);
graphicsPipelineBuilder.addViewportState({viewports, scissors});

graphicsPipelineBuilder.setRasterizationState(
    {
        .depthClampEnable = VK_FALSE,
        .rasterizerDiscardEnable = VK_FALSE,
        .polygonMode = VK_POLYGON_MODE_FILL,
        .cullmode = VK_CULL_MODE_NONE,
        .frontFace = VK_FRONT_FACE_CLOCKWISE,
        .depthBiasEnable = VK_FALSE,
        .depthBiasConstantFactor = 0.0f,
        .depthBiasClamp = 0.0f,
        .depthBiasSlopeFactor = 0.0f,
        .lineWidth = 1.0f
    }
);

graphicsPipelineBuilder.setMultisampleState(
    {
        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
        .sampleShadingEnable = VK_FALSE,
        .minSampleShading = 1.0f,
        .sampleMask = {},
        .alphaToCoverageEnable = VK_FALSE,
        .alphaToOneEnable = VK_FALSE
    }
);

// Enable z-testing
graphicsPipelineBuilder.setDepthStencilState(
    {
        .depthTestEnable = VK_TRUE,
        .depthWriteEnable = VK_TRUE,
        .depthCompareOp = VK_COMPARE_OP_LESS,
        .depthBoundsTestEnable = VK_FALSE,
        .stencilTestEnable = VK_FALSE,
        .front = {},
        .back = {},
        .minDepthBounds = 0.0f,
        .maxDepthBounds = 1.0f
    }
);

VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
colorBlendAttachment.blendEnable = VK_FALSE;
colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
colorBlendAttachment.colorWriteMask =
    VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
std::vector<VkPipelineColorBlendAttachmentState> colorBlendAttachments = {colorBlendAttachment};
graphicsPipelineBuilder.setColorBlendState(
    {
        .logicOpEnable = VK_FALSE,
        .logicOp = VK_LOGIC_OP_COPY,
        .attachments = colorBlendAttachments,
        .blendConstants = std::array<float, 4>{0.0f, 0.0f, 0.0f, 0.0f}
    }
);

// Set the viewports and scissors to dynamic to allow for window resizing
std::vector<VkDynamicState> dynamicStates = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
graphicsPipelineBuilder.setDynamicState({.dynamicStates = dynamicStates});
graphicsPipelineBuilder.setRenderPass(this->upRenderPass.get());

std::unique_ptr<fillcan::GraphicsPipeline> upGraphicsPipeline = graphicsPipelineBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Graphics Pipeline Builder"),n=i(` class extends the
`),s=d("code"),a=i("Pipeline Builder"),u=i(`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=d("br"),m=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=d("br"),v=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(R.$$.fragment),P=d("br"),A=i(`
Example:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var M=E(r);$=f(M,"Graphics Pipeline Builder"),M.forEach(l),n=f(B,` class extends the
`),s=g(B,"CODE",{});var O=E(s);a=f(O,"Pipeline Builder"),O.forEach(l),u=f(B,`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=g(B,"BR",{}),m=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=g(B,"BR",{}),v=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(R.$$.fragment,B),P=g(B,"BR",{}),A=f(B,`
Example:
`),S(T.$$.fragment,B)},m(B,M){D(e,B,M),h(B,t,M),h(B,r,M),o(r,$),h(B,n,M),h(B,s,M),o(s,a),h(B,u,M),h(B,p,M),h(B,m,M),h(B,_,M),h(B,v,M),D(R,B,M),h(B,P,M),h(B,A,M),D(T,B,M),y=!0},p:Oe,i(B){y||(b(e.$$.fragment,B),b(R.$$.fragment,B),b(T.$$.fragment,B),y=!0)},o(B){w(e.$$.fragment,B),w(R.$$.fragment,B),w(T.$$.fragment,B),y=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(u),B&&l(p),B&&l(m),B&&l(_),B&&l(v),C(R,B),B&&l(P),B&&l(A),C(T,B)}}}class Jz extends ve{constructor(e){super(),Ee(this,e,null,Zz,be,{})}}function ej(c){let e,t;return{c(){e=d("span"),t=i("Create a new Graphics Pipeline Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Graphics Pipeline Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function tj(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"GraphicsPipelineBuilder();"}}),r=new Se({props:{$$slots:{details:[ej]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rj extends ve{constructor(e){super(),Ee(this,e,null,tj,be,{})}}function nj(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sj(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[nj]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Add a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Add a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aj(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oj(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[aj]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineShaderStage"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to add."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"pipelineShaderStage"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to add."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function lj(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setShaderStage(PipelineShaderStage pipelineShaderStage);"}}),r=new Se({props:{$$slots:{params:[oj],details:[sj]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ij extends ve{constructor(e){super(),Ee(this,e,null,lj,be,{})}}function fj(c){let e,t;return{c(){e=d("span"),t=i("Set the Input Assembly State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Input Assembly State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function cj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("inputAssemblyState"),n=d("br"),s=i(`
            The input assembly state, this is a `),a=d("code"),u=i("PipelineInputAssemblyState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"inputAssemblyState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The input assembly state, this is a `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineInputAssemblyState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function $j(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the input assembly state."),r=d("br"),$=i(`
        The input assembly stage reads the index and vertex buffers that contain
        information about the vertices making up the draw sent in the draw command.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the input assembly state."),r=g(s,"BR",{}),$=f(s,`
        The input assembly stage reads the index and vertex buffers that contain
        information about the vertices making up the draw sent in the draw command.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function uj(c){let e;return{c(){e=i("VkPrimitiveTopology")},l(t){e=f(t,"VkPrimitiveTopology")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pj(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A;return a=new Bt({props:{reference:"VkPrimitiveTopology",version:1.3,$$slots:{default:[uj]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("topology"),n=d("br"),s=i(`
            The primitive topology. This is a member of the `),I(a.$$.fragment),u=i("-enumeration."),p=j(),m=d("li"),_=d("code"),v=i("primitiveRestartEnable"),R=d("br"),P=i(`
            Used to restart primitive topologies of type "strip" and "fan". Requires
            an indexed draw.`),this.h()},l(T){e=g(T,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var B=E(t);r=g(B,"CODE",{});var M=E(r);$=f(M,"topology"),M.forEach(l),n=g(B,"BR",{}),s=f(B,`
            The primitive topology. This is a member of the `),S(a.$$.fragment,B),u=f(B,"-enumeration."),B.forEach(l),p=Y(y),m=g(y,"LI",{});var O=E(m);_=g(O,"CODE",{});var x=E(_);v=f(x,"primitiveRestartEnable"),x.forEach(l),R=g(O,"BR",{}),P=f(O,`
            Used to restart primitive topologies of type "strip" and "fan". Requires
            an indexed draw.`),O.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(T,y){h(T,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),A=!0},p(T,y){const B={};y&1&&(B.$$scope={dirty:y,ctx:T}),a.$set(B)},i(T){A||(b(a.$$.fragment,T),A=!0)},o(T){w(a.$$.fragment,T),A=!1},d(T){T&&l(e),C(a)}}}function mj(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setInputAssemblyState(PipelineInputAssemblyState inputAssemblyState);"}}),r=new Se({props:{$$slots:{params:[cj],details:[fj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineInputAssemblyState {
    VkPrimitiveTopology topology;
    VkBool32 primitiveRestartEnable;
};`}}),u=new Se({props:{$$slots:{params:[pj],details:[$j]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class hj extends ve{constructor(e){super(),Ee(this,e,null,mj,be,{})}}function dj(c){let e,t;return{c(){e=d("span"),t=i("Set the Vertex Input State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Vertex Input State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function gj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("vertexInputState"),n=d("br"),s=i(`
            The vertex input state, this is a
            `),a=d("code"),u=i("PipelineVertexInputState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"vertexInputState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The vertex input state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineVertexInputState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function _j(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the vertex input state."),r=d("br"),$=i(`
        The vertex input stage inputs vertex-data into the vertex shader.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the vertex input state."),r=g(s,"BR",{}),$=f(s,`
        The vertex input stage inputs vertex-data into the vertex shader.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function vj(c){let e;return{c(){e=i("VkVertexInputBindingDescription")},l(t){e=f(t,"VkVertexInputBindingDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ej(c){let e;return{c(){e=i("VkVertexInputAttributeDescription")},l(t){e=f(t,"VkVertexInputAttributeDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bj(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new Bt({props:{reference:"VkVertexInputBindingDescription",version:1.3,$$slots:{default:[vj]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkVertexInputAttributeDescription",version:1.3,$$slots:{default:[Ej]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("vertexInputBindingDescriptions"),n=d("br"),s=i(`
            Descriptions of the vertex-bindings. This is a list of `),I(a.$$.fragment),u=i("-structures."),p=j(),m=d("li"),_=d("code"),v=i("vertexInputAttributeDescriptions"),R=d("br"),P=i(`
            Descriptions of the vertex-attributes. This is a list of `),I(A.$$.fragment),T=i("-structures."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"vertexInputBindingDescriptions"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            Descriptions of the vertex-bindings. This is a list of `),S(a.$$.fragment,O),u=f(O,"-structures."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"vertexInputAttributeDescriptions"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            Descriptions of the vertex-attributes. This is a list of `),S(A.$$.fragment,F),T=f(F,"-structures."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function wj(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"bool setVertexInputState(PipelineVertexInputState vertexInputState);"}}),r=new Se({props:{$$slots:{params:[gj],details:[dj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineVertexInputState {
    std::vector<VkVertexInputBindingDescription> vertexInputBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription> vertexInputAttributeDescriptions;
};`}}),u=new Se({props:{$$slots:{params:[bj],details:[_j]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Ij extends ve{constructor(e){super(),Ee(this,e,null,wj,be,{})}}function Dj(c){let e,t;return{c(){e=d("span"),t=i("Set the Tessellation State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Tessellation State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Cj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("tessellationState"),n=d("br"),s=i(`
            The tessellation state, this is a
            `),a=d("code"),u=i("PipelineTessellationState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"tessellationState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The tessellation state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineTessellationState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function Sj(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the tessellation control and evaluation stage."),r=d("br"),$=i(`
        The Tessellation control shader is responsible for producing tessellation
        factors and other pre-patch data. that is used by the fixed-function tessellation
        engine. The tessellation evaluation shader runs on each new vertex produced
        by the tessellation primitive generator. It operates similarly to a vertex
        shader except that incoming vertices are generated rather than read from
        memory.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the tessellation control and evaluation stage."),r=g(s,"BR",{}),$=f(s,`
        The Tessellation control shader is responsible for producing tessellation
        factors and other pre-patch data. that is used by the fixed-function tessellation
        engine. The tessellation evaluation shader runs on each new vertex produced
        by the tessellation primitive generator. It operates similarly to a vertex
        shader except that incoming vertices are generated rather than read from
        memory.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function Rj(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("patchControlPoints"),n=d("br"),s=i(`
            The amount of controlpoints that will be grouped in a single primitive.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"patchControlPoints"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The amount of controlpoints that will be grouped in a single primitive.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function Aj(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"bool setVertexInputState(PipelineVertexInputState vertexInputState);"}}),r=new Se({props:{$$slots:{params:[Cj],details:[Dj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineTessellationState {
    unsigned int patchControlPoints;
};`}}),u=new Se({props:{$$slots:{params:[Rj],details:[Sj]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Pj extends ve{constructor(e){super(),Ee(this,e,null,Aj,be,{})}}function Bj(c){let e,t;return{c(){e=d("span"),t=i("Add a Viewport State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Add a Viewport State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Lj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewportState"),n=d("br"),s=i(`
            The viewport state, this is a
            `),a=d("code"),u=i("PipelineViewPortState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"viewportState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The viewport state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineViewPortState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function kj(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tj(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[kj]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A description of a viewport state."),r=d("br"),$=i(`
        Viewport-transformation is the last co\xF6rdinate transformation in the `),I(n.$$.fragment),s=i(` before rasterization. It transforms the normalized device-co\xF6rdinates to
        window-co\xF6rdinates.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A description of a viewport state."),r=g(p,"BR",{}),$=f(p,`
        Viewport-transformation is the last co\xF6rdinate transformation in the `),S(n.$$.fragment,p),s=f(p,` before rasterization. It transforms the normalized device-co\xF6rdinates to
        window-co\xF6rdinates.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Oj(c){let e;return{c(){e=i("VkViewport")},l(t){e=f(t,"VkViewport")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vj(c){let e;return{c(){e=i("VkRect2D")},l(t){e=f(t,"VkRect2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yj(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y;return a=new Bt({props:{reference:"VkViewport",version:1.3,$$slots:{default:[Oj]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkRect2D",version:1.3,$$slots:{default:[Vj]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewports"),n=d("br"),s=i(`
            The dimensions of each viewport. This is a `),I(a.$$.fragment),u=i("-structure."),p=j(),m=d("li"),_=d("code"),v=i("scissors"),R=d("br"),P=i(`
            The scissor rectangles of each viewport. This is a `),I(A.$$.fragment),T=i("-structure."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var x=E(r);$=f(x,"viewports"),x.forEach(l),n=g(O,"BR",{}),s=f(O,`
            The dimensions of each viewport. This is a `),S(a.$$.fragment,O),u=f(O,"-structure."),O.forEach(l),p=Y(M),m=g(M,"LI",{});var F=E(m);_=g(F,"CODE",{});var V=E(_);v=f(V,"scissors"),V.forEach(l),R=g(F,"BR",{}),P=f(F,`
            The scissor rectangles of each viewport. This is a `),S(A.$$.fragment,F),T=f(F,"-structure."),F.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,M){h(B,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),D(A,m,null),o(m,T),y=!0},p(B,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:B}),a.$set(O);const x={};M&1&&(x.$$scope={dirty:M,ctx:B}),A.$set(x)},i(B){y||(b(a.$$.fragment,B),b(A.$$.fragment,B),y=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),y=!1},d(B){B&&l(e),C(a),C(A)}}}function Mj(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void addViewportState(PipelineViewPortState viewportState);"}}),r=new Se({props:{$$slots:{params:[Lj],details:[Bj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineViewPortState {
    std::vector<VkViewport> viewports;
    std::vector<VkRect2D> scissors;
};`}}),u=new Se({props:{$$slots:{params:[yj],details:[Tj]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Fj extends ve{constructor(e){super(),Ee(this,e,null,Mj,be,{})}}function xj(c){let e,t;return{c(){e=d("span"),t=i("Set the Rasterization State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Rasterization State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Nj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("rasterizationState"),n=d("br"),s=i(`
            The rasterization state, this is a
            `),a=d("code"),u=i("PipelineRasterizationState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"rasterizationState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The rasterization state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineRasterizationState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function Uj(c){let e,t;return{c(){e=d("span"),t=d("br"),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=g($,"BR",{}),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function Gj(c){let e;return{c(){e=i("VkPolygonMode")},l(t){e=f(t,"VkPolygonMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hj(c){let e;return{c(){e=i("VkCullModeFlagBits")},l(t){e=f(t,"VkCullModeFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qj(c){let e;return{c(){e=i("VkFrontFace")},l(t){e=f(t,"VkFrontFace")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wj(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We,ze,Ye,rt,Ne,He,$t,ut,ht,Je,dt,et,Ze;return F=new Bt({props:{reference:"VkPolygonMode",version:1.3,$$slots:{default:[Gj]},$$scope:{ctx:c}}}),K=new Bt({props:{reference:"VkCullModeFlagBits",version:1.3,$$slots:{default:[Hj]},$$scope:{ctx:c}}}),ae=new Bt({props:{reference:"VkFrontFace",version:1.3,$$slots:{default:[qj]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthClampEnable"),n=d("br"),s=i(`
            Used to enable or disable depth clamping. This means that fragments that
            are outside the near and far planes are clamped instead of thrown out.
            This requires the
            `),a=d("code"),u=i("VkPipelineRasterizationDepthClipStateCreateInfoEXT"),p=i(`
            extension.`),m=j(),_=d("li"),v=d("code"),R=i("rasterizerDiscardEnable"),P=d("br"),A=i(`
            Used to disable rasterization altogether. When this flag is set, the
            rasterizer will not run and no fragments will be produced.`),T=j(),y=d("li"),B=d("code"),M=i("polygonMode"),O=d("br"),x=i(`
            Can be used to have Vulkan automatically turn triangles into points or
            lines. This a member of the `),I(F.$$.fragment),V=i("-enumeration."),q=j(),k=d("li"),N=d("code"),Q=i("cullmode"),X=d("br"),Z=i(`
            Controls what parts of the input will be discarded. This is a bitmask
            of `),I(K.$$.fragment),W=i("."),U=j(),G=d("li"),te=d("code"),ee=i("frontFace"),ne=d("br"),le=i(`
            Which direction a triangle faces is determined by the winding order of
            its vertice - whether they go clockwise or counterclockwise in the window
            space. This is a member of the `),I(ae.$$.fragment),J=i("-enumerant."),ue=j(),De=d("li"),de=d("code"),me=i("depthBiasEnable"),Ce=d("br"),_e=i(`
            This feature allows fragments to be depth compensated for before the
            depth test. This can be used to avoid depth fights.`),se=j(),ie=d("li"),ge=d("code"),we=i("depthBiasConstantFactor"),Re=d("br"),Be=i(`
            A scalar factor that determines the constant depth value added to each
            clip.`),Ie=j(),re=d("li"),he=d("code"),Ae=i("depthBiasClamp"),Ve=d("br"),oe=i(`
            The maximum (or minimum) depth bias of a fragment.`),ce=j(),Pe=d("li"),Fe=d("code"),ke=i("depthBiasSlopeFactor"),Te=d("br"),Me=i(`
            A scalar factor applied to the slope of a fragment in depth bias calculations.`),Ue=j(),qe=d("li"),xe=d("code"),Ge=i("lineWidth"),ye=d("br"),We=i(`
            The width of line primitives, in pixels. This applies to all lines gridded
            with the pipeline.`),ze=d("br"),Ye=i(`
            Some Vulkan implementations do not support broad strokes and may ignore
            this field. Others can work very slowly if this field is not
            `),rt=d("code"),Ne=i("1.0f"),He=i(`; still others can fully respect this field and
            discard all lines if lineWidth is set to `),$t=d("code"),ut=i("0.0f"),ht=i(`.
            Therefore, this field should always be set to `),Je=d("code"),dt=i("1.0f"),et=i(`,
            unless it is certain that it should be otherwise.`),this.h()},l(nt){e=g(nt,"DIV",{slot:!0});var Ke=E(e);t=g(Ke,"LI",{});var ct=E(t);r=g(ct,"CODE",{});var st=E(r);$=f(st,"depthClampEnable"),st.forEach(l),n=g(ct,"BR",{}),s=f(ct,`
            Used to enable or disable depth clamping. This means that fragments that
            are outside the near and far planes are clamped instead of thrown out.
            This requires the
            `),a=g(ct,"CODE",{});var Qe=E(a);u=f(Qe,"VkPipelineRasterizationDepthClipStateCreateInfoEXT"),Qe.forEach(l),p=f(ct,`
            extension.`),ct.forEach(l),m=Y(Ke),_=g(Ke,"LI",{});var at=E(_);v=g(at,"CODE",{});var bt=E(v);R=f(bt,"rasterizerDiscardEnable"),bt.forEach(l),P=g(at,"BR",{}),A=f(at,`
            Used to disable rasterization altogether. When this flag is set, the
            rasterizer will not run and no fragments will be produced.`),at.forEach(l),T=Y(Ke),y=g(Ke,"LI",{});var wt=E(y);B=g(wt,"CODE",{});var St=E(B);M=f(St,"polygonMode"),St.forEach(l),O=g(wt,"BR",{}),x=f(wt,`
            Can be used to have Vulkan automatically turn triangles into points or
            lines. This a member of the `),S(F.$$.fragment,wt),V=f(wt,"-enumeration."),wt.forEach(l),q=Y(Ke),k=g(Ke,"LI",{});var tt=E(k);N=g(tt,"CODE",{});var ot=E(N);Q=f(ot,"cullmode"),ot.forEach(l),X=g(tt,"BR",{}),Z=f(tt,`
            Controls what parts of the input will be discarded. This is a bitmask
            of `),S(K.$$.fragment,tt),W=f(tt,"."),tt.forEach(l),U=Y(Ke),G=g(Ke,"LI",{});var At=E(G);te=g(At,"CODE",{});var it=E(te);ee=f(it,"frontFace"),it.forEach(l),ne=g(At,"BR",{}),le=f(At,`
            Which direction a triangle faces is determined by the winding order of
            its vertice - whether they go clockwise or counterclockwise in the window
            space. This is a member of the `),S(ae.$$.fragment,At),J=f(At,"-enumerant."),At.forEach(l),ue=Y(Ke),De=g(Ke,"LI",{});var Xe=E(De);de=g(Xe,"CODE",{});var Dt=E(de);me=f(Dt,"depthBiasEnable"),Dt.forEach(l),Ce=g(Xe,"BR",{}),_e=f(Xe,`
            This feature allows fragments to be depth compensated for before the
            depth test. This can be used to avoid depth fights.`),Xe.forEach(l),se=Y(Ke),ie=g(Ke,"LI",{});var Ct=E(ie);ge=g(Ct,"CODE",{});var pt=E(ge);we=f(pt,"depthBiasConstantFactor"),pt.forEach(l),Re=g(Ct,"BR",{}),Be=f(Ct,`
            A scalar factor that determines the constant depth value added to each
            clip.`),Ct.forEach(l),Ie=Y(Ke),re=g(Ke,"LI",{});var yt=E(re);he=g(yt,"CODE",{});var mt=E(he);Ae=f(mt,"depthBiasClamp"),mt.forEach(l),Ve=g(yt,"BR",{}),oe=f(yt,`
            The maximum (or minimum) depth bias of a fragment.`),yt.forEach(l),ce=Y(Ke),Pe=g(Ke,"LI",{});var Ot=E(Pe);Fe=g(Ot,"CODE",{});var Pt=E(Fe);ke=f(Pt,"depthBiasSlopeFactor"),Pt.forEach(l),Te=g(Ot,"BR",{}),Me=f(Ot,`
            A scalar factor applied to the slope of a fragment in depth bias calculations.`),Ot.forEach(l),Ue=Y(Ke),qe=g(Ke,"LI",{});var Tt=E(qe);xe=g(Tt,"CODE",{});var vt=E(xe);Ge=f(vt,"lineWidth"),vt.forEach(l),ye=g(Tt,"BR",{}),We=f(Tt,`
            The width of line primitives, in pixels. This applies to all lines gridded
            with the pipeline.`),ze=g(Tt,"BR",{}),Ye=f(Tt,`
            Some Vulkan implementations do not support broad strokes and may ignore
            this field. Others can work very slowly if this field is not
            `),rt=g(Tt,"CODE",{});var gt=E(rt);Ne=f(gt,"1.0f"),gt.forEach(l),He=f(Tt,`; still others can fully respect this field and
            discard all lines if lineWidth is set to `),$t=g(Tt,"CODE",{});var kt=E($t);ut=f(kt,"0.0f"),kt.forEach(l),ht=f(Tt,`.
            Therefore, this field should always be set to `),Je=g(Tt,"CODE",{});var Ft=E(Je);dt=f(Ft,"1.0f"),Ft.forEach(l),et=f(Tt,`,
            unless it is certain that it should be otherwise.`),Tt.forEach(l),Ke.forEach(l),this.h()},h(){z(e,"slot","params")},m(nt,Ke){h(nt,e,Ke),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m),o(e,_),o(_,v),o(v,R),o(_,P),o(_,A),o(e,T),o(e,y),o(y,B),o(B,M),o(y,O),o(y,x),D(F,y,null),o(y,V),o(e,q),o(e,k),o(k,N),o(N,Q),o(k,X),o(k,Z),D(K,k,null),o(k,W),o(e,U),o(e,G),o(G,te),o(te,ee),o(G,ne),o(G,le),D(ae,G,null),o(G,J),o(e,ue),o(e,De),o(De,de),o(de,me),o(De,Ce),o(De,_e),o(e,se),o(e,ie),o(ie,ge),o(ge,we),o(ie,Re),o(ie,Be),o(e,Ie),o(e,re),o(re,he),o(he,Ae),o(re,Ve),o(re,oe),o(e,ce),o(e,Pe),o(Pe,Fe),o(Fe,ke),o(Pe,Te),o(Pe,Me),o(e,Ue),o(e,qe),o(qe,xe),o(xe,Ge),o(qe,ye),o(qe,We),o(qe,ze),o(qe,Ye),o(qe,rt),o(rt,Ne),o(qe,He),o(qe,$t),o($t,ut),o(qe,ht),o(qe,Je),o(Je,dt),o(qe,et),Ze=!0},p(nt,Ke){const ct={};Ke&1&&(ct.$$scope={dirty:Ke,ctx:nt}),F.$set(ct);const st={};Ke&1&&(st.$$scope={dirty:Ke,ctx:nt}),K.$set(st);const Qe={};Ke&1&&(Qe.$$scope={dirty:Ke,ctx:nt}),ae.$set(Qe)},i(nt){Ze||(b(F.$$.fragment,nt),b(K.$$.fragment,nt),b(ae.$$.fragment,nt),Ze=!0)},o(nt){w(F.$$.fragment,nt),w(K.$$.fragment,nt),w(ae.$$.fragment,nt),Ze=!1},d(nt){nt&&l(e),C(F),C(K),C(ae)}}}function Qj(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setRasterizationState(PipelineRasterizationState rasterizationState);"}}),r=new Se({props:{$$slots:{params:[Nj],details:[xj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineRasterizationState {
    VkBool32 depthClampEnable = VK_FALSE;
    VkBool32 rasterizerDiscardEnable = VK_FALSE;
    VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL;
    VkCullModeFlags cullmode = VK_CULL_MODE_NONE;
    VkFrontFace frontFace = VK_FRONT_FACE_CLOCKWISE;
    VkBool32 depthBiasEnable = VK_FALSE;
    float depthBiasConstantFactor = 0.0f;
    float depthBiasClamp = 0.0f;
    float depthBiasSlopeFactor = 0.0f;
    float lineWidth = 1.0f;
};`}}),u=new Se({props:{$$slots:{params:[Wj],details:[Uj]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Kj extends ve{constructor(e){super(),Ee(this,e,null,Qj,be,{})}}function zj(c){let e,t;return{c(){e=d("span"),t=i("Set the Multisample State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Multisample State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function jj(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("multisampleState"),n=d("br"),s=i(`
            The multisample state, this is a
            `),a=d("code"),u=i("PipelineMultisampleState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"multisampleState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The multisample state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineMultisampleState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function Yj(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the multisampling stage."),r=d("br"),$=i(`
        Multisampling is the process of generating multiple samples for each pixel
        in an image. It is used to counteract aliasing and can significantly improve
        image quality when used effectively.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the multisampling stage."),r=g(s,"BR",{}),$=f(s,`
        Multisampling is the process of generating multiple samples for each pixel
        in an image. It is used to counteract aliasing and can significantly improve
        image quality when used effectively.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function Xj(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zj(c){let e;return{c(){e=i("VkSampleMask")},l(t){e=f(t,"VkSampleMask")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jj(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De;return a=new Bt({props:{reference:"VkSampleCountFlagBits",version:1.3,$$slots:{default:[Xj]},$$scope:{ctx:c}}}),x=new Bt({props:{reference:"VkSampleMask",version:1.3,$$slots:{default:[Zj]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("rasterizationSamples"),n=d("br"),s=i(`
            Not yet researched. This is a member of `),I(a.$$.fragment),u=i("."),p=j(),m=d("li"),_=d("code"),v=i("sampleShadingEnable"),R=d("br"),P=i(`
            Not yet researched.`),A=j(),T=d("li"),y=d("code"),B=i("minSampleShading"),M=d("br"),O=i(`
            Not yet researched. This is a list of `),I(x.$$.fragment),F=i("-structure."),V=j(),q=d("li"),k=d("code"),N=i("sampleMask"),Q=d("br"),X=i(`
            Not yet researched.`),Z=j(),K=d("li"),W=d("code"),U=i("alphaToCoverageEnable"),G=d("br"),te=i(`
            Not yet researched.`),ee=j(),ne=d("li"),le=d("code"),ae=i("alphaToOneEnable"),J=d("br"),ue=i(`
            Not yet researched.`),this.h()},l(de){e=g(de,"DIV",{slot:!0});var me=E(e);t=g(me,"LI",{});var Ce=E(t);r=g(Ce,"CODE",{});var _e=E(r);$=f(_e,"rasterizationSamples"),_e.forEach(l),n=g(Ce,"BR",{}),s=f(Ce,`
            Not yet researched. This is a member of `),S(a.$$.fragment,Ce),u=f(Ce,"."),Ce.forEach(l),p=Y(me),m=g(me,"LI",{});var se=E(m);_=g(se,"CODE",{});var ie=E(_);v=f(ie,"sampleShadingEnable"),ie.forEach(l),R=g(se,"BR",{}),P=f(se,`
            Not yet researched.`),se.forEach(l),A=Y(me),T=g(me,"LI",{});var ge=E(T);y=g(ge,"CODE",{});var we=E(y);B=f(we,"minSampleShading"),we.forEach(l),M=g(ge,"BR",{}),O=f(ge,`
            Not yet researched. This is a list of `),S(x.$$.fragment,ge),F=f(ge,"-structure."),ge.forEach(l),V=Y(me),q=g(me,"LI",{});var Re=E(q);k=g(Re,"CODE",{});var Be=E(k);N=f(Be,"sampleMask"),Be.forEach(l),Q=g(Re,"BR",{}),X=f(Re,`
            Not yet researched.`),Re.forEach(l),Z=Y(me),K=g(me,"LI",{});var Ie=E(K);W=g(Ie,"CODE",{});var re=E(W);U=f(re,"alphaToCoverageEnable"),re.forEach(l),G=g(Ie,"BR",{}),te=f(Ie,`
            Not yet researched.`),Ie.forEach(l),ee=Y(me),ne=g(me,"LI",{});var he=E(ne);le=g(he,"CODE",{});var Ae=E(le);ae=f(Ae,"alphaToOneEnable"),Ae.forEach(l),J=g(he,"BR",{}),ue=f(he,`
            Not yet researched.`),he.forEach(l),me.forEach(l),this.h()},h(){z(e,"slot","params")},m(de,me){h(de,e,me),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,R),o(m,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),o(e,V),o(e,q),o(q,k),o(k,N),o(q,Q),o(q,X),o(e,Z),o(e,K),o(K,W),o(W,U),o(K,G),o(K,te),o(e,ee),o(e,ne),o(ne,le),o(le,ae),o(ne,J),o(ne,ue),De=!0},p(de,me){const Ce={};me&1&&(Ce.$$scope={dirty:me,ctx:de}),a.$set(Ce);const _e={};me&1&&(_e.$$scope={dirty:me,ctx:de}),x.$set(_e)},i(de){De||(b(a.$$.fragment,de),b(x.$$.fragment,de),De=!0)},o(de){w(a.$$.fragment,de),w(x.$$.fragment,de),De=!1},d(de){de&&l(e),C(a),C(x)}}}function e9(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setMultisampleState(PipelineMultisampleState multisampleState);"}}),r=new Se({props:{$$slots:{params:[jj],details:[zj]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineMultisampleState {
    VkSampleCountFlagBits rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    VkBool32 sampleShadingEnable = VK_FALSE;
    float minSampleShading = 1.0f;
    std::vector<VkSampleMask> sampleMask = {};
    VkBool32 alphaToCoverageEnable = VK_FALSE;
    VkBool32 alphaToOneEnable = VK_FALSE;
};`}}),u=new Se({props:{$$slots:{params:[Jj],details:[Yj]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class t9 extends ve{constructor(e){super(),Ee(this,e,null,e9,be,{})}}function r9(c){let e,t;return{c(){e=d("span"),t=i("Set the Depth Stencil State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Depth Stencil State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function n9(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthStencilState"),n=d("br"),s=i(`
            The multisample state, this is a
            `),a=d("code"),u=i("PipelineDepthStencilState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"depthStencilState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The multisample state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineDepthStencilState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function s9(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the depth- stencil state."),r=d("br"),$=i(`
        The depth stencil state determines how the depth and stencil tests are performed
        and what happens to a snippet if it passes or fails one of these tests. The
        depth and stencil tests can be performed before or after the fragment shader
        has been run. By default, the tests take place after the fragment shader.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the depth- stencil state."),r=g(s,"BR",{}),$=f(s,`
        The depth stencil state determines how the depth and stencil tests are performed
        and what happens to a snippet if it passes or fails one of these tests. The
        depth and stencil tests can be performed before or after the fragment shader
        has been run. By default, the tests take place after the fragment shader.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function a9(c){let e;return{c(){e=i("VkComareOp")},l(t){e=f(t,"VkComareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o9(c){let e;return{c(){e=i("VkStencilOpState")},l(t){e=f(t,"VkStencilOpState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l9(c){let e;return{c(){e=i("VkStencilOpState")},l(t){e=f(t,"VkStencilOpState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i9(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z,K,W,U,G,te,ee,ne,le,ae,J,ue,De,de,me,Ce,_e,se,ie,ge,we,Re,Be,Ie,re,he,Ae,Ve,oe,ce,Pe,Fe,ke,Te,Me,Ue,qe,xe,Ge,ye,We;return k=new Bt({props:{reference:"VkComareOp",version:1.3,$$slots:{default:[a9]},$$scope:{ctx:c}}}),ie=new Bt({props:{reference:"VkStencilOpState",version:1.3,$$slots:{default:[o9]},$$scope:{ctx:c}}}),Ae=new Bt({props:{reference:"VkStencilOpState",version:1.3,$$slots:{default:[l9]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthTestEnable"),n=d("br"),s=i(`
            Whether depth testing is enabled.`),a=j(),u=d("li"),p=d("code"),m=i("depthWriteEnable"),_=d("br"),v=i(`
            Whether depth writing is enabled. Depth writes are always disabled when
            `),R=d("code"),P=i("depthTestEnable"),A=i(`
            is `),T=d("code"),y=i("VK_FALSE"),B=i("."),M=j(),O=d("li"),x=d("code"),F=i("depthCompareOp"),V=d("br"),q=i(`
            The test to use. This is a member of the `),I(k.$$.fragment),N=i("-enumerant."),Q=j(),X=d("li"),Z=d("code"),K=i("depthBoundsTestEnable"),W=d("br"),U=i(`
            Whether depth limits tests are enabled.`),G=j(),te=d("li"),ee=d("code"),ne=i("stencilTestEnable"),le=d("br"),ae=i(`
            Whether stencil testing is enabled.`),J=d("br"),ue=i(`
            If the depth test passes (or if the depth test is disabled), the snippet
            advances to the stencil test.`),De=j(),de=d("li"),me=d("code"),Ce=i("front"),_e=d("br"),se=i(`
            Determines the parameters of the stencil test. This is a member of the
            `),I(ie.$$.fragment),ge=i("-enumerant."),we=j(),Re=d("li"),Be=d("code"),Ie=i("back"),re=d("br"),he=i(`
            Determines the parameters of the stencil test. This is a member of the
            `),I(Ae.$$.fragment),Ve=i("-enumerant."),oe=j(),ce=d("li"),Pe=d("code"),Fe=i("minDepthBounds"),ke=d("br"),Te=i(`
            The minimum depth limit used in the depth limit test.`),Me=j(),Ue=d("li"),qe=d("code"),xe=i("maxDepthBounds"),Ge=d("br"),ye=i(`
            The maximum depth limit used in the depth limit test.`),this.h()},l(ze){e=g(ze,"DIV",{slot:!0});var Ye=E(e);t=g(Ye,"LI",{});var rt=E(t);r=g(rt,"CODE",{});var Ne=E(r);$=f(Ne,"depthTestEnable"),Ne.forEach(l),n=g(rt,"BR",{}),s=f(rt,`
            Whether depth testing is enabled.`),rt.forEach(l),a=Y(Ye),u=g(Ye,"LI",{});var He=E(u);p=g(He,"CODE",{});var $t=E(p);m=f($t,"depthWriteEnable"),$t.forEach(l),_=g(He,"BR",{}),v=f(He,`
            Whether depth writing is enabled. Depth writes are always disabled when
            `),R=g(He,"CODE",{});var ut=E(R);P=f(ut,"depthTestEnable"),ut.forEach(l),A=f(He,`
            is `),T=g(He,"CODE",{});var ht=E(T);y=f(ht,"VK_FALSE"),ht.forEach(l),B=f(He,"."),He.forEach(l),M=Y(Ye),O=g(Ye,"LI",{});var Je=E(O);x=g(Je,"CODE",{});var dt=E(x);F=f(dt,"depthCompareOp"),dt.forEach(l),V=g(Je,"BR",{}),q=f(Je,`
            The test to use. This is a member of the `),S(k.$$.fragment,Je),N=f(Je,"-enumerant."),Je.forEach(l),Q=Y(Ye),X=g(Ye,"LI",{});var et=E(X);Z=g(et,"CODE",{});var Ze=E(Z);K=f(Ze,"depthBoundsTestEnable"),Ze.forEach(l),W=g(et,"BR",{}),U=f(et,`
            Whether depth limits tests are enabled.`),et.forEach(l),G=Y(Ye),te=g(Ye,"LI",{});var nt=E(te);ee=g(nt,"CODE",{});var Ke=E(ee);ne=f(Ke,"stencilTestEnable"),Ke.forEach(l),le=g(nt,"BR",{}),ae=f(nt,`
            Whether stencil testing is enabled.`),J=g(nt,"BR",{}),ue=f(nt,`
            If the depth test passes (or if the depth test is disabled), the snippet
            advances to the stencil test.`),nt.forEach(l),De=Y(Ye),de=g(Ye,"LI",{});var ct=E(de);me=g(ct,"CODE",{});var st=E(me);Ce=f(st,"front"),st.forEach(l),_e=g(ct,"BR",{}),se=f(ct,`
            Determines the parameters of the stencil test. This is a member of the
            `),S(ie.$$.fragment,ct),ge=f(ct,"-enumerant."),ct.forEach(l),we=Y(Ye),Re=g(Ye,"LI",{});var Qe=E(Re);Be=g(Qe,"CODE",{});var at=E(Be);Ie=f(at,"back"),at.forEach(l),re=g(Qe,"BR",{}),he=f(Qe,`
            Determines the parameters of the stencil test. This is a member of the
            `),S(Ae.$$.fragment,Qe),Ve=f(Qe,"-enumerant."),Qe.forEach(l),oe=Y(Ye),ce=g(Ye,"LI",{});var bt=E(ce);Pe=g(bt,"CODE",{});var wt=E(Pe);Fe=f(wt,"minDepthBounds"),wt.forEach(l),ke=g(bt,"BR",{}),Te=f(bt,`
            The minimum depth limit used in the depth limit test.`),bt.forEach(l),Me=Y(Ye),Ue=g(Ye,"LI",{});var St=E(Ue);qe=g(St,"CODE",{});var tt=E(qe);xe=f(tt,"maxDepthBounds"),tt.forEach(l),Ge=g(St,"BR",{}),ye=f(St,`
            The maximum depth limit used in the depth limit test.`),St.forEach(l),Ye.forEach(l),this.h()},h(){z(e,"slot","params")},m(ze,Ye){h(ze,e,Ye),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(u,R),o(R,P),o(u,A),o(u,T),o(T,y),o(u,B),o(e,M),o(e,O),o(O,x),o(x,F),o(O,V),o(O,q),D(k,O,null),o(O,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,U),o(e,G),o(e,te),o(te,ee),o(ee,ne),o(te,le),o(te,ae),o(te,J),o(te,ue),o(e,De),o(e,de),o(de,me),o(me,Ce),o(de,_e),o(de,se),D(ie,de,null),o(de,ge),o(e,we),o(e,Re),o(Re,Be),o(Be,Ie),o(Re,re),o(Re,he),D(Ae,Re,null),o(Re,Ve),o(e,oe),o(e,ce),o(ce,Pe),o(Pe,Fe),o(ce,ke),o(ce,Te),o(e,Me),o(e,Ue),o(Ue,qe),o(qe,xe),o(Ue,Ge),o(Ue,ye),We=!0},p(ze,Ye){const rt={};Ye&1&&(rt.$$scope={dirty:Ye,ctx:ze}),k.$set(rt);const Ne={};Ye&1&&(Ne.$$scope={dirty:Ye,ctx:ze}),ie.$set(Ne);const He={};Ye&1&&(He.$$scope={dirty:Ye,ctx:ze}),Ae.$set(He)},i(ze){We||(b(k.$$.fragment,ze),b(ie.$$.fragment,ze),b(Ae.$$.fragment,ze),We=!0)},o(ze){w(k.$$.fragment,ze),w(ie.$$.fragment,ze),w(Ae.$$.fragment,ze),We=!1},d(ze){ze&&l(e),C(k),C(ie),C(Ae)}}}function f9(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setDepthStencilState(PipelineDepthStencilState depthStencilState);"}}),r=new Se({props:{$$slots:{params:[n9],details:[r9]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineDepthStencilState {
    VkBool32 depthTestEnable = VK_TRUE;
    VkBool32 depthWriteEnable = VK_TRUE;
    VkCompareOp depthCompareOp = VK_COMPARE_OP_LESS;
    VkBool32 depthBoundsTestEnable = VK_FALSE;
    VkBool32 stencilTestEnable = VK_FALSE;
    VkStencilOpState front = {};
    VkStencilOpState back = {};
    float minDepthBounds = 0.0f;
    float maxDepthBounds = 1.0f;
};`}}),u=new Se({props:{$$slots:{params:[i9],details:[s9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class c9 extends ve{constructor(e){super(),Ee(this,e,null,f9,be,{})}}function $9(c){let e,t;return{c(){e=d("span"),t=i("Set the Color Blend State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Color Blend State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function u9(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("colorBlendState"),n=d("br"),s=i(`
            The color blend state, this is a
            `),a=d("code"),u=i("PipelineColorBlendState"),p=i("-structure."),m=j(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var R=E(t);r=g(R,"CODE",{});var P=E(r);$=f(P,"colorBlendState"),P.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The color blend state, this is a
            `),a=g(R,"CODE",{});var A=E(a);u=f(A,"PipelineColorBlendState"),A.forEach(l),p=f(R,"-structure."),R.forEach(l),m=Y(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:Oe,d(_){_&&l(e)}}}function p9(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m9(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[p9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Describe the color blend state."),r=d("br"),$=i(`
        The color operations take the final results of the fragment shader and postfragment
        operations and use them to update the `),I(n.$$.fragment),s=i(`. The color operations include blending and logic operations. This
        stage is responsible for writing fragments in the color attachments.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Describe the color blend state."),r=g(p,"BR",{}),$=f(p,`
        The color operations take the final results of the fragment shader and postfragment
        operations and use them to update the `),S(n.$$.fragment,p),s=f(p,`. The color operations include blending and logic operations. This
        stage is responsible for writing fragments in the color attachments.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function h9(c){let e;return{c(){e=i("VkLogicOp")},l(t){e=f(t,"VkLogicOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d9(c){let e;return{c(){e=i("VkPipelineColorBlendAttachmentState")},l(t){e=f(t,"VkPipelineColorBlendAttachmentState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g9(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T,y,B,M,O,x,F,V,q,k,N,Q,X,Z;return R=new Bt({props:{reference:"VkLogicOp",version:1.3,$$slots:{default:[h9]},$$scope:{ctx:c}}}),x=new Bt({props:{reference:"VkPipelineColorBlendAttachmentState",version:1.3,$$slots:{default:[d9]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("logicOpEnable"),n=d("br"),s=i(`
            Whether to perform logical operations between the fragment shader output
            and the contents of the color attachments.`),a=j(),u=d("li"),p=d("code"),m=i("logicOp"),_=d("br"),v=i(`
            The logical operation to apply. This is a member of the `),I(R.$$.fragment),P=i("-enumerant."),A=j(),T=d("li"),y=d("code"),B=i("attachments"),M=d("br"),O=i(`
            The color attachments to blend. This is a list of `),I(x.$$.fragment),F=i("-structures."),V=j(),q=d("li"),k=d("code"),N=i("blendConstants"),Q=d("br"),X=i(`
            A matrix of four values used as the R, G, B, and A components of the
            blending constant used in mixing, depending on the mixing factor.`),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var U=E(t);r=g(U,"CODE",{});var G=E(r);$=f(G,"logicOpEnable"),G.forEach(l),n=g(U,"BR",{}),s=f(U,`
            Whether to perform logical operations between the fragment shader output
            and the contents of the color attachments.`),U.forEach(l),a=Y(W),u=g(W,"LI",{});var te=E(u);p=g(te,"CODE",{});var ee=E(p);m=f(ee,"logicOp"),ee.forEach(l),_=g(te,"BR",{}),v=f(te,`
            The logical operation to apply. This is a member of the `),S(R.$$.fragment,te),P=f(te,"-enumerant."),te.forEach(l),A=Y(W),T=g(W,"LI",{});var ne=E(T);y=g(ne,"CODE",{});var le=E(y);B=f(le,"attachments"),le.forEach(l),M=g(ne,"BR",{}),O=f(ne,`
            The color attachments to blend. This is a list of `),S(x.$$.fragment,ne),F=f(ne,"-structures."),ne.forEach(l),V=Y(W),q=g(W,"LI",{});var ae=E(q);k=g(ae,"CODE",{});var J=E(k);N=f(J,"blendConstants"),J.forEach(l),Q=g(ae,"BR",{}),X=f(ae,`
            A matrix of four values used as the R, G, B, and A components of the
            blending constant used in mixing, depending on the mixing factor.`),ae.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(R,u,null),o(u,P),o(e,A),o(e,T),o(T,y),o(y,B),o(T,M),o(T,O),D(x,T,null),o(T,F),o(e,V),o(e,q),o(q,k),o(k,N),o(q,Q),o(q,X),Z=!0},p(K,W){const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),R.$set(U);const G={};W&1&&(G.$$scope={dirty:W,ctx:K}),x.$set(G)},i(K){Z||(b(R.$$.fragment,K),b(x.$$.fragment,K),Z=!0)},o(K){w(R.$$.fragment,K),w(x.$$.fragment,K),Z=!1},d(K){K&&l(e),C(R),C(x)}}}function _9(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setColorBlendState(PipelineColorBlendState colorBlendState);"}}),r=new Se({props:{$$slots:{params:[u9],details:[$9]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineColorBlendState {
    VkBool32 logicOpEnable = VK_FALSE;
    VkLogicOp logicOp = VK_LOGIC_OP_COPY;
    std::vector<VkPipelineColorBlendAttachmentState> attachments = {};
    std::array<float, 4> blendConstants = {};
};`}}),u=new Se({props:{$$slots:{params:[g9],details:[m9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class v9 extends ve{constructor(e){super(),Ee(this,e,null,_9,be,{})}}function E9(c){let e,t;return{c(){e=d("span"),t=i("Set the Dynamic State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Dynamic State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function b9(c){let e,t,r,$,n,s,a;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dynamicState"),n=d("br"),s=i(`
            The dynamic state, this is a PipelineDynamicState-structure.`),a=j(),this.h()},l(u){e=g(u,"DIV",{slot:!0});var p=E(e);t=g(p,"LI",{});var m=E(t);r=g(m,"CODE",{});var _=E(r);$=f(_,"dynamicState"),_.forEach(l),n=g(m,"BR",{}),s=f(m,`
            The dynamic state, this is a PipelineDynamicState-structure.`),m.forEach(l),a=Y(p),p.forEach(l),this.h()},h(){z(e,"slot","params")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a)},p:Oe,d(u){u&&l(e)}}}function w9(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the dynamic state."),r=d("br"),$=i(`
        To make fine-grained state changes more manageable, Vulkan provides the ability
        to mark certain parts of the graphics pipeline as dynamic, meaning they can
        be updated directly using commands directly in the command buffer rather
        than using an object. Since this reduces the chance for Vulkan to optimize
        or absorb parts of the state, it is necessary to specify exactly which state
        to make dynamically.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the dynamic state."),r=g(s,"BR",{}),$=f(s,`
        To make fine-grained state changes more manageable, Vulkan provides the ability
        to mark certain parts of the graphics pipeline as dynamic, meaning they can
        be updated directly using commands directly in the command buffer rather
        than using an object. Since this reduces the chance for Vulkan to optimize
        or absorb parts of the state, it is necessary to specify exactly which state
        to make dynamically.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:Oe,d(n){n&&l(e)}}}function I9(c){let e;return{c(){e=i("VkDynamicState")},l(t){e=f(t,"VkDynamicState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D9(c){let e,t,r,$,n,s,a,u,p;return a=new Bt({props:{reference:"VkDynamicState",version:1.3,$$slots:{default:[I9]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dynamicStates"),n=d("br"),s=i(`
            The states to make dynamic. This is a list of `),I(a.$$.fragment),u=i("-structures."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"dynamicStates"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The states to make dynamic. This is a list of `),S(a.$$.fragment,v),u=f(v,"-structures."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function C9(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:pe,code:"void setDynamicState(PipelineDynamicState dynamicState);"}}),r=new Se({props:{$$slots:{params:[b9],details:[E9]},$$scope:{ctx:c}}}),s=new $e({props:{language:pe,code:`struct PipelineDynamicState {
    std::vector<VkDynamicState> dynamicStates;
};`}}),u=new Se({props:{$$slots:{params:[D9],details:[w9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment),$=d("br"),n=j(),I(s.$$.fragment),a=j(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=Y(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=Y(m),S(s.$$.fragment,m),a=Y(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),u.$set(R)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class S9 extends ve{constructor(e){super(),Ee(this,e,null,C9,be,{})}}function R9(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A9(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[R9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" that describes the environment in which the pipeline will be used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," that describes the environment in which the pipeline will be used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function P9(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pRenderPass"),n=d("br"),s=i(`
            A pointer to a render pass that describes the environment in which the
            pipeline will be used.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"pRenderPass"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            A pointer to a render pass that describes the environment in which the
            pipeline will be used.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:Oe,d(a){a&&l(e)}}}function B9(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setRenderPass(RenderPass* pRenderPass);"}}),r=new Se({props:{$$slots:{params:[P9],details:[A9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class L9 extends ve{constructor(e){super(),Ee(this,e,null,B9,be,{})}}function k9(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T9(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[k9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the subpass in the "),I(r.$$.fragment),$=i(" where this pipeline will be used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the subpass in the "),S(r.$$.fragment,a),$=f(a," where this pipeline will be used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function O9(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V9(c){let e,t,r,$,n,s,a,u,p;return a=new H({props:{sectionID:L.RENDER_PASS,$$slots:{default:[O9]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("subpass"),n=d("br"),s=i(`
            The index of the subpass in the `),I(a.$$.fragment),u=i(" where this pipeline will be used."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var R=E(r);$=f(R,"subpass"),R.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index of the subpass in the `),S(a.$$.fragment,v),u=f(v," where this pipeline will be used."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function y9(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void setSubpass(unsigned int subpass);"}}),r=new Se({props:{$$slots:{params:[V9],details:[T9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class M9 extends ve{constructor(e){super(),Ee(this,e,null,y9,be,{})}}function F9(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x9(c){let e,t,r,$,n;return r=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[F9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function N9(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U9(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G9(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[N9]},$$scope:{ctx:c}}}),n=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[U9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function H9(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q9(c){let e,t,r,$,n,s,a;return n=new H({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[H9]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function W9(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"std::unique_ptr<GraphicsPipeline> getResult();"}}),r=new Se({props:{$$slots:{throws:[q9],return:[G9],details:[x9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Q9 extends ve{constructor(e){super(),Ee(this,e,null,W9,be,{})}}function K9(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z9(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:Oe,d(r){r&&l(e)}}}function j9(c){let e,t,r,$;return e=new $e({props:{language:pe,code:"void reset() override;"}}),r=new Se({props:{$$slots:{details:[z9],default:[K9]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=j(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=Y(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Y9 extends ve{constructor(e){super(),Ee(this,e,null,j9,be,{})}}function Ja(c,e,t){const r=c.slice();return r[7]=e[t],r[8]=e,r[9]=t,r}function eo(c){let e,t,r,$,n,s,a,u;return $=new To({}),{c(){e=d("div"),t=d("div"),r=d("button"),I($.$$.fragment),this.h()},l(p){e=g(p,"DIV",{class:!0});var m=E(e);t=g(m,"DIV",{class:!0});var _=E(t);r=g(_,"BUTTON",{class:!0});var v=E(r);S($.$$.fragment,v),v.forEach(l),_.forEach(l),m.forEach(l),this.h()},h(){z(r,"class",n="hamburger-menu-button "+(c[1]?"activated":"")+" svelte-1usu7je"),z(t,"class","documentation-pop-in-inner svelte-1usu7je"),z(e,"class","documentation-pop-in svelte-1usu7je")},m(p,m){h(p,e,m),o(e,t),o(t,r),D($,r,null),s=!0,a||(u=Vs(r,"click",c[3]),a=!0)},p(p,m){(!s||m&2&&n!==(n="hamburger-menu-button "+(p[1]?"activated":"")+" svelte-1usu7je"))&&z(r,"class",n)},i(p){s||(b($.$$.fragment,p),s=!0)},o(p){w($.$$.fragment,p),s=!1},d(p){p&&l(e),C($),a=!1,u()}}}function to(c){let e,t,r,$,n;return t=new Eo({props:{sections:c[0],onReferenceClick:c[4]}}),{c(){e=d("div"),I(t.$$.fragment),this.h()},l(s){e=g(s,"DIV",{class:!0});var a=E(e);S(t.$$.fragment,a),a.forEach(l),this.h()},h(){z(e,"class","documentation-pop-in-content svelte-1usu7je")},m(s,a){h(s,e,a),D(t,e,null),n=!0},p(s,a){const u={};a&1&&(u.sections=s[0]),t.$set(u)},i(s){n||(b(t.$$.fragment,s),Co(()=>{$&&$.end(1),r=Bo(e,La,{y:-10,duration:500,opacity:0}),r.start()}),n=!0)},o(s){w(t.$$.fragment,s),r&&r.invalidate(),$=So(e,La,{y:-20,duration:250,opacity:0}),n=!1},d(s){s&&l(e),C(t),s&&$&&$.end()}}}function X9(c){let e,t,r;const $=[c[7].props];var n=c[7].content;function s(a){let u={};for(let p=0;p<$.length;p+=1)u=ks(u,$[p]);return{props:u}}return n&&(e=new n(s())),{c(){e&&I(e.$$.fragment),t=dn()},l(a){e&&S(e.$$.fragment,a),t=dn()},m(a,u){e&&D(e,a,u),h(a,t,u),r=!0},p(a,u){const p=u&1?so($,[ko(a[7].props)]):{};if(n!==(n=a[7].content)){if(e){An();const m=e;w(m.$$.fragment,1,0,()=>{C(m,1)}),Pn()}n?(e=new n(s()),I(e.$$.fragment),b(e.$$.fragment,1),D(e,t.parentNode,t)):e=null}else n&&e.$set(p)},i(a){r||(e&&b(e.$$.fragment,a),r=!0)},o(a){e&&w(e.$$.fragment,a),r=!1},d(a){a&&l(t),e&&C(e,a)}}}function ro(c){let e;return{c(){e=d("hr"),this.h()},l(t){e=g(t,"HR",{class:!0}),this.h()},h(){z(e,"class","svelte-1usu7je")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function no(c){var v;let e,t,r,$,n,s=c[9]!==0&&c[9]<c[0].length-1&&((v=c[0].at(c[9]+1))==null?void 0:v.heading)===2,a,u;function p(R){c[5](R,c[7])}let m={id:c[7].id,label:c[7].label,heading:c[7].heading,$$slots:{default:[X9]},$$scope:{ctx:c}};c[7].visible!==void 0&&(m.visible=c[7].visible),e=new Jl({props:m}),Us.push(()=>Lo(e,"visible",p));let _=s&&ro();return{c(){I(e.$$.fragment),r=j(),$=d("br"),n=j(),_&&_.c(),a=dn()},l(R){S(e.$$.fragment,R),r=Y(R),$=g(R,"BR",{}),n=Y(R),_&&_.l(R),a=dn()},m(R,P){D(e,R,P),h(R,r,P),h(R,$,P),h(R,n,P),_&&_.m(R,P),h(R,a,P),u=!0},p(R,P){var T;c=R;const A={};P&1&&(A.id=c[7].id),P&1&&(A.label=c[7].label),P&1&&(A.heading=c[7].heading),P&1025&&(A.$$scope={dirty:P,ctx:c}),!t&&P&1&&(t=!0,A.visible=c[7].visible,Ro(()=>t=!1)),e.$set(A),P&1&&(s=c[9]!==0&&c[9]<c[0].length-1&&((T=c[0].at(c[9]+1))==null?void 0:T.heading)===2),s?_||(_=ro(),_.c(),_.m(a.parentNode,a)):_&&(_.d(1),_=null)},i(R){u||(b(e.$$.fragment,R),u=!0)},o(R){w(e.$$.fragment,R),u=!1},d(R){C(e,R),R&&l(r),R&&l($),R&&l(n),_&&_.d(R),R&&l(a)}}}function Z9(c){let e,t,r,$,n,s,a,u,p,m,_,v,R,P,A,T=je().Fillcan.version+"",y,B,M,O,x,F,V,q,k,N,Q,X,Z;s=new Eo({props:{sections:c[0],onReferenceClick:c[4]}});let K=c[2]&&eo(c),W=c[2]&&c[1]&&to(c),U=c[0],G=[];for(let ee=0;ee<U.length;ee+=1)G[ee]=no(Ja(c,U,ee));const te=ee=>w(G[ee],1,1,()=>{G[ee]=null});return{c(){e=new ao(!1),t=dn(),r=j(),$=d("div"),n=d("div"),I(s.$$.fragment),a=j(),K&&K.c(),u=j(),W&&W.c(),p=j(),m=d("div"),_=d("h1"),v=i("Documentation"),R=j(),P=d("p"),A=i("This page contains the documentation for Fillcan (v"),y=i(T),B=i(`). It's intended for people who are familiar
            with C++ and Vulkan. `),M=d("br"),O=i(`
            Some concepts within C++ and Vulkan will be elaborated upon if I think
            they are interesting.`),x=j(),F=d("br"),V=d("br"),q=j(),k=d("hr"),N=j();for(let ee=0;ee<G.length;ee+=1)G[ee].c();this.h()},l(ee){const ne=Ao('[data-svelte="svelte-1k4j43e"]',document.head);e=oo(ne,!1),t=dn(),ne.forEach(l),r=Y(ee),$=g(ee,"DIV",{class:!0,style:!0});var le=E($);n=g(le,"DIV",{class:!0});var ae=E(n);S(s.$$.fragment,ae),ae.forEach(l),a=Y(le),K&&K.l(le),u=Y(le),W&&W.l(le),p=Y(le),m=g(le,"DIV",{class:!0});var J=E(m);_=g(J,"H1",{class:!0});var ue=E(_);v=f(ue,"Documentation"),ue.forEach(l),R=Y(J),P=g(J,"P",{});var De=E(P);A=f(De,"This page contains the documentation for Fillcan (v"),y=f(De,T),B=f(De,`). It's intended for people who are familiar
            with C++ and Vulkan. `),M=g(De,"BR",{}),O=f(De,`
            Some concepts within C++ and Vulkan will be elaborated upon if I think
            they are interesting.`),De.forEach(l),x=Y(J),F=g(J,"BR",{}),V=g(J,"BR",{}),q=Y(J),k=g(J,"HR",{class:!0}),N=Y(J);for(let de=0;de<G.length;de+=1)G[de].l(J);J.forEach(l),le.forEach(l),this.h()},h(){e.a=t,z(n,"class","documentation-sidebar svelte-1usu7je"),z(_,"class","svelte-1usu7je"),z(k,"class","svelte-1usu7je"),z(m,"class",Q="documentation-container "+(c[2]?"mobile":"desktop")+" svelte-1usu7je"),z($,"class",X="documentation "+(c[2]?"mobile":"")+" svelte-1usu7je"),Po($,"--sidebar-width","22.5rem")},m(ee,ne){e.m(Hl,document.head),o(document.head,t),h(ee,r,ne),h(ee,$,ne),o($,n),D(s,n,null),o($,a),K&&K.m($,null),o($,u),W&&W.m($,null),o($,p),o($,m),o(m,_),o(_,v),o(m,R),o(m,P),o(P,A),o(P,y),o(P,B),o(P,M),o(P,O),o(m,x),o(m,F),o(m,V),o(m,q),o(m,k),o(m,N);for(let le=0;le<G.length;le+=1)G[le].m(m,null);Z=!0},p(ee,[ne]){const le={};if(ne&1&&(le.sections=ee[0]),s.$set(le),ee[2]?K?(K.p(ee,ne),ne&4&&b(K,1)):(K=eo(ee),K.c(),b(K,1),K.m($,u)):K&&(An(),w(K,1,1,()=>{K=null}),Pn()),ee[2]&&ee[1]?W?(W.p(ee,ne),ne&6&&b(W,1)):(W=to(ee),W.c(),b(W,1),W.m($,p)):W&&(An(),w(W,1,1,()=>{W=null}),Pn()),ne&1){U=ee[0];let ae;for(ae=0;ae<U.length;ae+=1){const J=Ja(ee,U,ae);G[ae]?(G[ae].p(J,ne),b(G[ae],1)):(G[ae]=no(J),G[ae].c(),b(G[ae],1),G[ae].m(m,null))}for(An(),ae=U.length;ae<G.length;ae+=1)te(ae);Pn()}(!Z||ne&4&&Q!==(Q="documentation-container "+(ee[2]?"mobile":"desktop")+" svelte-1usu7je"))&&z(m,"class",Q),(!Z||ne&4&&X!==(X="documentation "+(ee[2]?"mobile":"")+" svelte-1usu7je"))&&z($,"class",X)},i(ee){if(!Z){b(s.$$.fragment,ee),b(K),b(W);for(let ne=0;ne<U.length;ne+=1)b(G[ne]);Z=!0}},o(ee){w(s.$$.fragment,ee),w(K),w(W),G=G.filter(Boolean);for(let ne=0;ne<G.length;ne+=1)w(G[ne]);Z=!1},d(ee){l(t),ee&&e.d(),ee&&l(r),ee&&l($),C(s),K&&K.d(),W&&W.d(),io(G,ee)}}}function J9(c,e,t){const r=[{id:L.GETTING_STARTED,label:"Getting Started",heading:2,content:Wl,props:{},visible:!1},{id:L.CMAKE,label:"CMake",heading:3,content:ai,props:{},visible:!1},{id:L.FILLCAN,label:"Fillcan",heading:2,content:li,props:{},visible:!1},{id:L.FILLCAN_Constructor,label:"Constructor",heading:3,content:Si,props:{},visible:!1},{id:L.FILLCAN_getSupportedPhysicalDevices,label:"getSupportedPhysicalDevices",heading:3,content:ki,props:{},visible:!1},{id:L.FILLCAN_selectDevice,label:"selectDevice",heading:3,content:Ui,props:{},visible:!1},{id:L.FILLCAN_getCurrentDevice,label:"getCurrentDevice",heading:3,content:zi,props:{},visible:!1},{id:L.FILLCAN_createShaderModule,label:"createShaderModule",heading:3,content:Lf,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS,label:"Fillcan Graphics",heading:2,content:Of,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_Constructor,label:"Constructor",heading:3,content:zf,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getWindow,label:"getWindow",heading:3,content:ef,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_mainLoop,label:"mainLoop",heading:3,content:Zf,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_createSwapchain,label:"createSwapchain",heading:3,content:$c,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_recreateSwapchain,label:"recreateSwapchain",heading:3,content:Vc,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getSwapchain,label:"getSwapchain",heading:3,content:Wc,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getSwapchains,label:"getSwapchains",heading:3,content:Xc,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_destroySwapchain,label:"destroySwapchain",heading:3,content:a$,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getAssetManager,label:"getAssetManager",heading:3,content:$$,props:{},visible:!1},{id:L.WINDOW,label:"Window",heading:2,content:h$,props:{},visible:!1},{id:L.WINDOW_Constructor,label:"Constructor",heading:3,content:E$,props:{},visible:!1},{id:L.WINDOW_shouldClose,label:"shouldClose",heading:3,content:D$,props:{},visible:!1},{id:L.WINDOW_wasResized,label:"wasResized",heading:3,content:A$,props:{},visible:!1},{id:L.WINDOW_pollEvents,label:"pollEvents",heading:3,content:L$,props:{},visible:!1},{id:L.WINDOW_getRequiredExtensions,label:"getRequiredExtensions",heading:3,content:y$,props:{},visible:!1},{id:L.WINDOW_createSurface,label:"createSurface",heading:3,content:q$,props:{},visible:!1},{id:L.WINDOW_getSurface,label:"getSurface",heading:3,content:X$,props:{},visible:!1},{id:L.WINDOW_getExtent,label:"getExtent",heading:3,content:nu,props:{},visible:!1},{id:L.INSTANCE,label:"Instance",heading:2,content:lu,props:{},visible:!1},{id:L.INSTANCE_Constructor,label:"Constructor",heading:3,content:vu,props:{},visible:!1},{id:L.INSTANCE_getInstanceHandle,label:"getInstanceHandle",heading:3,content:Cu,props:{},visible:!1},{id:L.DEVICE_POOL,label:"Device Pool",heading:2,content:Ou,props:{},visible:!1},{id:L.DEVICE_POOL_Constructor,label:"Constructor",heading:3,content:ju,props:{},visible:!1},{id:L.DEVICE_POOL_getSupportedPhysicalDevices,label:"getSupportedPhysicalDevices",heading:3,content:rp,props:{},visible:!1},{id:L.DEVICE_POOL_selectDevice,label:"selectDevice",heading:3,content:$p,props:{},visible:!1},{id:L.DEVICE_POOL_getCurrentDevice,label:"getCurrentDevice",heading:3,content:_p,props:{},visible:!1},{id:L.PHYSICAL_DEVICE,label:"Physical Device",heading:2,content:Dp,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_Constructor,label:"Constructor",heading:3,content:Op,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getPhysicalDeviceHandle,label:"getPhysicalDeviceHandle",heading:3,content:Np,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getRequiredExtensions,label:"getRequiredExtensions",heading:3,content:Wp,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_areExtensionsSupported,label:"areExtensionsSupported",heading:3,content:Yp,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getRequiredFeatures,label:"getRequiredFeatures",heading:3,content:am,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_areFeaturesSupported,label:"areFeaturesSupported",heading:3,content:cm,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getFeatures,label:"getFeatures",heading:3,content:hm,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getProperties,label:"getProperties",heading:3,content:Em,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfaceCapabilitiesKHR,label:"getSurfaceCapabilitiesKHR",heading:3,content:Am,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfaceFormatsKHR,label:"getSurfaceFormatsKHR",heading:3,content:ym,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfacePresentModesKHR,label:"getSurfacePresentModesKHR",heading:3,content:qm,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getQueueFamilyProperties,label:"getQueueFamilyProperties",heading:3,content:Xm,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getFormatProperties,label:"getFormatProperties",heading:3,content:nh,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_findSupportedFormat,label:"findSupportedFormat",heading:3,content:ph,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getGraphicsQueueFamilyIndices,label:"getGraphicsQueueFamilyIndices",heading:3,content:_h,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getPresentQueueFamilyIndices,label:"getPresentQueueFamilyIndices",heading:3,content:Ih,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getComputeQueueFamilyIndices,label:"getComputeQueueFamilyIndices",heading:3,content:Ah,props:{},visible:!1},{id:L.LOGICAL_DEVICE,label:"Logical Device",heading:2,content:Mh,props:{},visible:!1},{id:L.LOGICAL_DEVICE_Constructor,label:"Constructor",heading:3,content:zh,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getLogicalDeviceHandle,label:"getLogicalDeviceHandle",heading:3,content:ed,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getPhysicalDevice,label:"getPhysicalDevice",heading:3,content:od,props:{},visible:!1},{id:L.LOGICAL_DEVICE_waitIdle,label:"waitIdle",heading:3,content:$d,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getGraphicsQueue,label:"getGraphicsQueue",heading:3,content:_d,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getPresentQueue,label:"getPresentQueue",heading:3,content:kd,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getComputeQueue,label:"getComputeQueue",heading:3,content:Cd,props:{},visible:!1},{id:L.LOGICAL_DEVICE_beginSingleTimeCommandRecording,label:"beginSingleTimeCommandRecording",heading:3,content:Kd,props:{},visible:!1},{id:L.LOGICAL_DEVICE_endSingleTimeCommandRecording,label:"endSingleTimeCommandRecording",heading:3,content:tg,props:{},visible:!1},{id:L.QUEUE,label:"Queue",heading:2,content:fg,props:{},visible:!1},{id:L.QUEUE_Constructor,label:"Constructor",heading:3,content:hg,props:{},visible:!1},{id:L.QUEUE_getQueueHandle,label:"getQueueHandle",heading:3,content:bg,props:{},visible:!1},{id:L.QUEUE_getQueueFamilyIndex,label:"getQueueFamilyIndex",heading:3,content:sP,props:{},visible:!1},{id:L.QUEUE_getQueueIndex,label:"getQueueIndex",heading:3,content:iP,props:{},visible:!1},{id:L.QUEUE_createCommandPool,label:"createCommandPool",heading:3,content:hE,props:{},visible:!1},{id:L.QUEUE_getCommandPools,label:"getCommandPools",heading:3,content:HE,props:{},visible:!1},{id:L.QUEUE_getCommandPool,label:"getCommandPool",heading:3,content:DE,props:{},visible:!1},{id:L.QUEUE_destroyCommandPool,label:"destroyCommandPool",heading:3,content:LE,props:{},visible:!1},{id:L.QUEUE_createRecording,label:"createRecording",heading:3,content:yg,props:{},visible:!1},{id:L.QUEUE_submitRecordings,label:"submitRecordings",heading:3,content:Wg,props:{},visible:!1},{id:L.QUEUE_resetRecording,label:"resetRecording",heading:3,content:a_,props:{},visible:!1},{id:L.QUEUE_freeRecording,label:"freeRecording",heading:3,content:h_,props:{},visible:!1},{id:L.QUEUE_waitIdle,label:"waitIdle",heading:3,content:E_,props:{},visible:!1},{id:L.COMMAND_POOL,label:"Command Pool",heading:2,content:B_,props:{},visible:!1},{id:L.COMMAND_POOL_Constructor,label:"Constructor",heading:3,content:H_,props:{},visible:!1},{id:L.COMMAND_POOL_getCommandPoolHandle,label:"getCommandPoolHandle",heading:3,content:dv,props:{},visible:!1},{id:L.COMMAND_POOL_allocateCommandBuffers,label:"allocateCommandBuffers",heading:3,content:X_,props:{},visible:!1},{id:L.COMMAND_POOL_freeCommandBuffers,label:"freeCommandBuffers",heading:3,content:nv,props:{},visible:!1},{id:L.COMMAND_POOL_reset,label:"reset",heading:3,content:cv,props:{},visible:!1},{id:L.COMMAND_BUFFER,label:"Command Buffer",heading:2,content:eE,props:{},visible:!1},{id:L.COMMAND_BUFFER_Constructor,label:"Constructor",heading:3,content:ME,props:{},visible:!1},{id:L.COMMAND_BUFFER_getCommandBufferHandle,label:"getCommandBufferHandle",heading:3,content:wv,props:{},visible:!1},{id:L.COMMAND_BUFFER_getLevel,label:"getLevel",heading:3,content:Rv,props:{},visible:!1},{id:L.COMMAND_BUFFER_begin,label:"begin",heading:3,content:Ov,props:{},visible:!1},{id:L.COMMAND_BUFFER_end,label:"end",heading:3,content:Uv,props:{},visible:!1},{id:L.COMMAND_BUFFER_reset,label:"reset",heading:3,content:jv,props:{},visible:!1},{id:L.COMMAND_RECORDING,label:"Command Recording",heading:2,content:fb,props:{},visible:!1},{id:L.COMMAND_RECORDING_endAll,label:"endAll",heading:3,content:_b,props:{},visible:!1},{id:L.COMMAND_RECORDING_submit,label:"submit",heading:3,content:Rb,props:{},visible:!1},{id:L.COMMAND_RECORDING_reset,label:"reset",heading:3,content:Vb,props:{},visible:!1},{id:L.COMMAND_RECORDING_free,label:"free",heading:3,content:xb,props:{},visible:!1},{id:L.COMMAND_RECORDING_createFence,label:"createFence",heading:3,content:jb,props:{},visible:!1},{id:L.COMMAND_RECORDING_waitForFence,label:"waitForFence",heading:3,content:n1,props:{},visible:!1},{id:L.SWAPCHAIN,label:"Swapchain",heading:2,content:m1,props:{},visible:!1},{id:L.SWAPCHAIN_Swapchain_Image,label:"Swapchain Image",heading:3,content:hI,props:{},visible:!1},{id:L.SWAPCHAIN_Constructor,label:"Constructor",heading:3,content:R1,props:{},visible:!1},{id:L.SWAPCHAIN_getSwapchainHandle,label:"getSwapchainHandle",heading:3,content:T1,props:{},visible:!1},{id:L.SWAPCHAIN_getNextImage,label:"getNextImage",heading:3,content:G1,props:{},visible:!1},{id:L.SWAPCHAIN_getSurfaceFormat,label:"getSurfaceFormat",heading:3,content:K1,props:{},visible:!1},{id:L.SWAPCHAIN_getImageCount,label:"getImageCount",heading:3,content:J1,props:{},visible:!1},{id:L.SWAPCHAIN_getImageArrayLayers,label:"getImageArrayLayers",heading:3,content:aw,props:{},visible:!1},{id:L.SWAPCHAIN_getImageUsage,label:"getImageUsage",heading:3,content:uw,props:{},visible:!1},{id:L.SWAPCHAIN_getImageSharingMode,label:"getImageSharingMode",heading:3,content:ww,props:{},visible:!1},{id:L.SWAPCHAIN_getImageExtent,label:"getImageExtent",heading:3,content:Ow,props:{},visible:!1},{id:L.SWAPCHAIN_getPresentMode,label:"getPresentMode",heading:3,content:Rw,props:{},visible:!1},{id:L.SWAPCHAIN_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:qw,props:{},visible:!1},{id:L.SWAPCHAIN_present,label:"present",heading:3,content:tI,props:{},visible:!1},{id:L.BUFFER_DIRECTOR,label:"Buffer Director",heading:2,content:kL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_Constructor,label:"Constructor",heading:3,content:VL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeVertexBuffer,label:"makeVertexBuffer",heading:3,content:YL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeVertexTransferDestinationBuffer,label:"makeVertexTransferDestinationBuffer",heading:3,content:$k,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeUniformBuffer,label:"makeUniformBuffer",heading:3,content:Sk,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStorageBuffer,label:"makeStorageBuffer",heading:3,content:Uk,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeUniformTexelBuffer,label:"makeUniformTexelBuffer",heading:3,content:rT,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStorageTexelBuffer,label:"makeStorageTexelBuffer",heading:3,content:gT,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndexBuffer,label:"makeIndexBuffer",heading:3,content:kT,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndexTransferDestinationBuffer,label:"makeIndexTransferDestinationBuffer",heading:3,content:KT,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndirectBuffer,label:"makeIndirectBuffer",heading:3,content:i0,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStagingBuffer,label:"makeStagingBuffer",heading:3,content:I0,props:{},visible:!1},{id:L.BUFFER_BUILDER,label:"Buffer Builder",heading:2,content:R0,props:{},visible:!1},{id:L.BUFFER_BUILDER_Constructor,label:"Constructor",heading:3,content:B0,props:{},visible:!1},{id:L.BUFFER_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:F0,props:{},visible:!1},{id:L.BUFFER_BUILDER_setFlags,label:"setFlags",heading:3,content:q0,props:{},visible:!1},{id:L.BUFFER_BUILDER_setSize,label:"setSize",heading:3,content:j0,props:{},visible:!1},{id:L.BUFFER_BUILDER_setUsage,label:"setUsage",heading:3,content:rO,props:{},visible:!1},{id:L.BUFFER_BUILDER_setSharingMode,label:"setSharingMode",heading:3,content:hO,props:{},visible:!1},{id:L.BUFFER_BUILDER_setQueueFamilyIndices,label:"setQueueFamilyIndices",heading:3,content:bO,props:{},visible:!1},{id:L.BUFFER_BUILDER_getResult,label:"getResult",heading:3,content:OO,props:{},visible:!1},{id:L.BUFFER_BUILDER_reset,label:"reset",heading:3,content:CO,props:{},visible:!1},{id:L.BUFFER,label:"Buffer",heading:2,content:II,props:{},visible:!1},{id:L.BUFFER_Constructor,label:"Constructor",heading:3,content:GI,props:{},visible:!1},{id:L.BUFFER_getBufferHandle,label:"getBufferHandle",heading:3,content:zI,props:{},visible:!1},{id:L.BUFFER_getFlags,label:"getFlags",heading:3,content:ZI,props:{},visible:!1},{id:L.BUFFER_getSize,label:"getSize",heading:3,content:sD,props:{},visible:!1},{id:L.BUFFER_getUsage,label:"getUsage",heading:3,content:iD,props:{},visible:!1},{id:L.BUFFER_getSharingMode,label:"getSharingMode",heading:3,content:uD,props:{},visible:!1},{id:L.BUFFER_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:dD,props:{},visible:!1},{id:L.BUFFER_bindMemory,label:"bindMemory",heading:3,content:DD,props:{},visible:!1},{id:L.BUFFER_getMemory,label:"getMemory",heading:3,content:LD,props:{},visible:!1},{id:L.BUFFER_createBufferView,label:"createBufferView",heading:3,content:KD,props:{},visible:!1},{id:L.BUFFER_getBufferViews,label:"getBufferViews",heading:3,content:aC,props:{},visible:!1},{id:L.BUFFER_getBufferView,label:"getBufferView",heading:3,content:JD,props:{},visible:!1},{id:L.BUFFER_destroyBufferViews,label:"destroyBufferViews",heading:3,content:hC,props:{},visible:!1},{id:L.BUFFER_destroyBufferView,label:"destroyBufferView",heading:3,content:$C,props:{},visible:!1},{id:L.BUFFER_copyTo,label:"copyTo",heading:3,content:PC,props:{},visible:!1},{id:L.BUFFER_VIEW,label:"Buffer View",heading:2,content:NP,props:{},visible:!1},{id:L.BUFFER_VIEW_Constructor,label:"Constructor",heading:3,content:TP,props:{},visible:!1},{id:L.BUFFER_VIEW_getBufferViewHandle,label:"getBufferViewHandle",heading:3,content:mP,props:{},visible:!1},{id:L.IMAGE_DIRECTOR,label:"Image Director",heading:2,content:zO,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_Constructor,label:"Constructor",heading:3,content:MO,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_make2DTexture,label:"make2DTexture",heading:3,content:$V,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_makeDepthImage,label:"makeDepthImage",heading:3,content:AV,props:{},visible:!1},{id:L.IMAGE_BUILDER,label:"Image Builder",heading:2,content:kV,props:{},visible:!1},{id:L.IMAGE_BUILDER_Constructor,label:"Constructor",heading:3,content:VV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:HV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setFlags,label:"setFlags",heading:3,content:jV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageType,label:"setImageType",heading:3,content:sy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setFormat,label:"setFormat",heading:3,content:fy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setExtent,label:"setExtent",heading:3,content:vy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setMipLevels,label:"setMipLevels",heading:3,content:Cy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setArrayLayers,label:"setArrayLayers",heading:3,content:ky,props:{},visible:!1},{id:L.IMAGE_BUILDER_setSamples,label:"setSamples",heading:3,content:xy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageTiling,label:"setImageTiling",heading:3,content:zy,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageUsage,label:"setImageUsage",heading:3,content:t3,props:{},visible:!1},{id:L.IMAGE_BUILDER_setSharingMode,label:"setSharingMode",heading:3,content:m3,props:{},visible:!1},{id:L.IMAGE_BUILDER_setQueueFamilyIndices,label:"setQueueFamilyIndices",heading:3,content:b3,props:{},visible:!1},{id:L.IMAGE_BUILDER_setInitialLayout,label:"setInitialLayout",heading:3,content:k3,props:{},visible:!1},{id:L.IMAGE_BUILDER_reset,label:"reset",heading:3,content:y3,props:{},visible:!1},{id:L.IMAGE_BUILDER_getResult,label:"getResult",heading:3,content:W3,props:{},visible:!1},{id:L.IMAGE,label:"Image",heading:2,content:MC,props:{},visible:!1},{id:L.IMAGE_Constructor,label:"Constructor",heading:3,content:mS,props:{},visible:!1},{id:L.IMAGE_getImageHandle,label:"getImageHandle",heading:3,content:ES,props:{},visible:!1},{id:L.IMAGE_getFlags,label:"getFlags",heading:3,content:DS,props:{},visible:!1},{id:L.IMAGE_getUsage,label:"getUsage",heading:3,content:AS,props:{},visible:!1},{id:L.IMAGE_getSharingMode,label:"getSharingMode",heading:3,content:kS,props:{},visible:!1},{id:L.IMAGE_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:yS,props:{},visible:!1},{id:L.IMAGE_getType,label:"getType",heading:3,content:eA,props:{},visible:!1},{id:L.IMAGE_getFormat,label:"getFormat",heading:3,content:sA,props:{},visible:!1},{id:L.IMAGE_getExtent,label:"getExtent",heading:3,content:iA,props:{},visible:!1},{id:L.IMAGE_getMipLevels,label:"getMipLevels",heading:3,content:uA,props:{},visible:!1},{id:L.IMAGE_getArrayLayers,label:"getArrayLayers",heading:3,content:dA,props:{},visible:!1},{id:L.IMAGE_getSamples,label:"getSamples",heading:3,content:EA,props:{},visible:!1},{id:L.IMAGE_getTiling,label:"getTiling",heading:3,content:DA,props:{},visible:!1},{id:L.IMAGE_getInitialLayout,label:"getInitialLayout",heading:3,content:AA,props:{},visible:!1},{id:L.IMAGE_bindMemory,label:"bindMemory",heading:3,content:qS,props:{},visible:!1},{id:L.IMAGE_getMemory,label:"getMemory",heading:3,content:XS,props:{},visible:!1},{id:L.IMAGE_createImageView,label:"createImageView",heading:3,content:hR,props:{},visible:!1},{id:L.IMAGE_getImageViews,label:"getImageViews",heading:3,content:eP,props:{},visible:!1},{id:L.IMAGE_getImageView,label:"getImageView",heading:3,content:IR,props:{},visible:!1},{id:L.IMAGE_destroyImageViews,label:"destroyImageViews",heading:3,content:RR,props:{},visible:!1},{id:L.IMAGE_destroyImageView,label:"destroyImageView",heading:3,content:TR,props:{},visible:!1},{id:L.IMAGE_copyTo,label:"copyTo",heading:3,content:YR,props:{},visible:!1},{id:L.IMAGE_transitionImageLayout,label:"transitionImageLayout",heading:3,content:zA,props:{},visible:!1},{id:L.IMAGE_VIEW,label:"Image View",heading:2,content:jP,props:{},visible:!1},{id:L.IMAGE_VIEW_Constructor,label:"Constructor",heading:3,content:uB,props:{},visible:!1},{id:L.IMAGE_VIEW_getImageViewHandle,label:"getImageViewHandle",heading:3,content:_B,props:{},visible:!1},{id:L.SAMPLER_BUILDER,label:"Sampler Builder",heading:2,content:PQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_Constructor,label:"Constructor",heading:3,content:kQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:NQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setFilters,label:"setFilters",heading:3,content:jQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMipmapMode,label:"setMipmapMode",heading:3,content:rK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setAddressModes,label:"setAddressModes",heading:3,content:iK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMipLodBias,label:"setMipLodBias",heading:3,content:uK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMaxAnisotropy,label:"setMaxAnisotropy",heading:3,content:_K,props:{},visible:!1},{id:L.SAMPLER_BUILDER_unsetMaxAnisotropy,label:"unsetMaxAnisotropy",heading:3,content:bK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setCompareOp,label:"setCompareOp",heading:3,content:RK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_unsetCompareOp,label:"unsetCompareOp",heading:3,content:BK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setLod,label:"setLod",heading:3,content:yK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setBorderColor,label:"setBorderColor",heading:3,content:HK,props:{},visible:!1},{id:L.SAMPLER_BUILDER_enableUnnormalizedCoordinates,label:"enableUnnormalizedCoordinates",heading:3,content:ez,props:{},visible:!1},{id:L.SAMPLER_BUILDER_disableUnnormalizedCoordinates,label:"disableUnnormalizedCoordinates",heading:3,content:nz,props:{},visible:!1},{id:L.SAMPLER_BUILDER_getResult,label:"getResult",heading:3,content:uz,props:{},visible:!1},{id:L.SAMPLER_BUILDER_reset,label:"reset",heading:3,content:dz,props:{},visible:!1},{id:L.SAMPLER,label:"Sampler",heading:2,content:XW,props:{},visible:!1},{id:L.SAMPLER_Constructor,label:"Constructor",heading:3,content:bQ,props:{},visible:!1},{id:L.SAMPLER_getSamplerHandle,label:"getSamplerHandle",heading:3,content:RQ,props:{},visible:!1},{id:L.MEMORY,label:"Memory",heading:2,content:AB,props:{},visible:!1},{id:L.MEMORY_Constructor,label:"Constructor",heading:3,content:QB,props:{},visible:!1},{id:L.MEMORY_getMemoryHandle,label:"getMemoryHandle",heading:3,content:ZB,props:{},visible:!1},{id:L.MEMORY_map,label:"map",heading:3,content:sL,props:{},visible:!1},{id:L.MEMORY_unmap,label:"unmap",heading:3,content:lL,props:{},visible:!1},{id:L.MEMORY_getData,label:"getData",heading:3,content:uL,props:{},visible:!1},{id:L.MEMORY_flush,label:"flush",heading:3,content:gL,props:{},visible:!1},{id:L.MEMORY_invalidate,label:"invalidate",heading:3,content:wL,props:{},visible:!1},{id:L.SEMAPHORE,label:"Semaphore",heading:2,content:F2,props:{},visible:!1},{id:L.SEMAPHORE_Constructor,label:"Constructor",heading:3,content:W2,props:{},visible:!1},{id:L.SEMAPHORE_getSemaphoreHandle,label:"getSemaphoreHandle",heading:3,content:X2,props:{},visible:!1},{id:L.FENCE,label:"Fence",heading:2,content:j3,props:{},visible:!1},{id:L.FENCE_Constructor,label:"Constructor",heading:3,content:n2,props:{},visible:!1},{id:L.FENCE_getFenceHandle,label:"getFenceHandle",heading:3,content:f2,props:{},visible:!1},{id:L.FENCE_waitFor,label:"waitFor",heading:3,content:m2,props:{},visible:!1},{id:L.FENCE_reset,label:"reset",heading:3,content:k2,props:{},visible:!1},{id:L.FENCE_s_waitForAll,label:"s_waitForAll",heading:3,content:b2,props:{},visible:!1},{id:L.FENCE_s_resetAll,label:"s_resetAll",heading:3,content:A2,props:{},visible:!1},{id:L.SHADER_MODULE,label:"Shader Module",heading:2,content:gM,props:{},visible:!1},{id:L.SHADER_MODULE_Constructor,label:"Constructor",heading:3,content:WM,props:{},visible:!1},{id:L.SHADER_MODULE_getShaderModuleHandle,label:"getShaderModuleHandle",heading:3,content:XM,props:{},visible:!1},{id:L.SHADER_MODULE_getDescriptorSetLayouts,label:"getDescriptorSetLayouts",heading:3,content:nF,props:{},visible:!1},{id:L.SHADER_MODULE_getDescriptorPool,label:"getDescriptorPool",heading:3,content:fF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER,label:"Descriptor Set Layout Builder",heading:2,content:GF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_Constructor,label:"Constructor",heading:3,content:WF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:JF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_addBinding,label:"addBinding",heading:3,content:hx,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_getResult,label:"getResult",heading:3,content:Dx,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_reset,label:"reset",heading:3,content:Ax,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT,label:"Descriptor Set Layout",heading:2,content:bF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_Constructor,label:"Constructor",heading:3,content:BF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_getDescriptorSetLayoutHandle,label:"getDescriptorSetLayoutHandle",heading:3,content:yF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_getBindings,label:"getBindings",heading:3,content:NF,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER,label:"Descriptor Pool Builder",heading:2,content:WN,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_Constructor,label:"Constructor",heading:3,content:zN,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:rU,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_setFlags,label:"setFlags",heading:3,content:fU,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_addSet,label:"addSet",heading:3,content:hU,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_getResult,label:"getResult",heading:3,content:RU,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_reset,label:"reset",heading:3,content:LU,props:{},visible:!1},{id:L.DESCRIPTOR_POOL,label:"Descriptor Pool",heading:2,content:Ox,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_Constructor,label:"Constructor",heading:3,content:Qx,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorPoolHandle,label:"getDescriptorPoolHandle",heading:3,content:Zx,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_allocateDescriptorSet,label:"allocateDescriptorSet",heading:3,content:uN,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorSets,label:"getDescriptorSets",heading:3,content:_N,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorSet,label:"getDescriptorSet",heading:3,content:RN,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_freeDescriptorSets,label:"freeDescriptorSets",heading:3,content:xN,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_reset,label:"reset",heading:3,content:HN,props:{},visible:!1},{id:L.DESCRIPTOR_SET,label:"Descriptor Set",heading:2,content:KU,props:{},visible:!1},{id:L.DESCRIPTOR_SET_Constructor,label:"Constructor",heading:3,content:nG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getDescriptorSetHandle,label:"getDescriptorSetHandle",heading:3,content:fG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getLayout,label:"getLayout",heading:3,content:hG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getName,label:"getName",heading:3,content:vG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeImage,label:"writeImage",heading:3,content:BG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeBuffer,label:"writeBuffer",heading:3,content:xG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeTexelBufferView,label:"writeTexelBufferView",heading:3,content:WG,props:{},visible:!1},{id:L.DESCRIPTOR_SET_copy,label:"copy",heading:3,content:jG,props:{},visible:!1},{id:L.PIPELINE_BUILDER,label:"Pipeline Builder",heading:2,content:o6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:c6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:_6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setFlags,label:"setFlags",heading:3,content:D6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_addPushConstant,label:"addPushConstant",heading:3,content:B6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setPipelineCache,label:"setPipelineCache",heading:3,content:H6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setBasePipeline,label:"setBasePipeline",heading:3,content:Z6,props:{},visible:!1},{id:L.PIPELINE_BUILDER_reset,label:"reset",heading:3,content:K6,props:{},visible:!1},{id:L.PIPELINE,label:"Pipeline",heading:2,content:Y4,props:{},visible:!1},{id:L.PIPELINE_PIPELINE_SHADER_STAGE,label:"Pipeline Shader Stage",heading:3,content:WH,props:{},visible:!1},{id:L.PIPELINE_Constructor,label:"Constructor",heading:3,content:l5,props:{},visible:!1},{id:L.PIPELINE_getPipelineHandle,label:"getPipelineHandle",heading:3,content:p5,props:{},visible:!1},{id:L.PIPELINE_getPipelineLayout,label:"getPipelineLayout",heading:3,content:v5,props:{},visible:!1},{id:L.PIPELINE_bindToCommandBuffer,label:"bindToCommandBuffer",heading:3,content:R5,props:{},visible:!1},{id:L.PIPELINE_getCommandBuffer,label:"getCommandBuffer",heading:3,content:O5,props:{},visible:!1},{id:L.PIPELINE_bindDescriptorSets,label:"bindDescriptorSets",heading:3,content:bH,props:{},visible:!1},{id:L.PIPELINE_getDescriptorSets,label:"getDescriptorSets",heading:3,content:AH,props:{},visible:!1},{id:L.PIPELINE_getDescriptorSet,label:"getDescriptorSet",heading:3,content:MH,props:{},visible:!1},{id:L.PIPELINE_pushConstantData,label:"pushConstantData",heading:3,content:s6,props:{},visible:!1},{id:L.PIPELINE_LAYOUT,label:"Pipeline Layout",heading:2,content:o4,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_PUSH_CONSTANT,label:"Push Constant",heading:3,content:G4,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_Constructor,label:"Constructor",heading:3,content:d4,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_getPipelineLayoutHandle,label:"getPipelineLayoutHandle",heading:3,content:w4,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_pushConstantData,label:"pushConstantData",heading:3,content:O4,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER,label:"Compute Pipeline Builder",heading:2,content:w7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:C7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_setShaderStage,label:"setShaderStage",heading:3,content:k7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_getResult,label:"getResult",heading:3,content:U7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_reset,label:"reset",heading:3,content:W7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE,label:"Compute Pipeline",heading:2,content:l7,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_Constructor,label:"Constructor",heading:3,content:E7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER,label:"Render Pass Builder",heading:2,content:Xq,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_Constructor,label:"Constructor",heading:3,content:e8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:i8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addAttachment,label:"addAttachment",heading:3,content:h8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addInputAttachment,label:"addInputAttachment",heading:3,content:E8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addColorAttachment,label:"addColorAttachment",heading:3,content:C8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_setDepthStencilAttachment,label:"setDepthStencilAttachment",heading:3,content:B8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_resolveCurrentAttachments,label:"resolveCurrentAttachments",heading:3,content:T8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_constructSubpass,label:"constructSubpass",heading:3,content:M8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addDependency,label:"addDependency",heading:3,content:H8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_getResult,label:"getResult",heading:3,content:Z8,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_reset,label:"reset",heading:3,content:rW,props:{},visible:!1},{id:L.RENDER_PASS,label:"Render Pass",heading:2,content:eq,props:{},visible:!1},{id:L.RENDER_PASS_Constructor,label:"Constructor",heading:3,content:uq,props:{},visible:!1},{id:L.RENDER_PASS_getRenderPassHandle,label:"getRenderPassHandle",heading:3,content:_q,props:{},visible:!1},{id:L.RENDER_PASS_getAttachments,label:"getAttachments",heading:3,content:Iq,props:{},visible:!1},{id:L.RENDER_PASS_getSubpasses,label:"getSubpasses",heading:3,content:Aq,props:{},visible:!1},{id:L.RENDER_PASS_getDependencies,label:"getDependencies",heading:3,content:Tq,props:{},visible:!1},{id:L.RENDER_PASS_begin,label:"begin",heading:3,content:Hq,props:{},visible:!1},{id:L.RENDER_PASS_end,label:"end",heading:3,content:jq,props:{},visible:!1},{id:L.FRAMEBUFFER,label:"Framebuffer",heading:2,content:gW,props:{},visible:!1},{id:L.FRAMEBUFFER_Constructor,label:"Constructor",heading:3,content:LW,props:{},visible:!1},{id:L.FRAMEBUFFER_getFramebufferHandle,label:"getFramebufferHandle",heading:3,content:MW,props:{},visible:!1},{id:L.FRAMEBUFFER_getExtent,label:"getExtent",heading:3,content:GW,props:{},visible:!1},{id:L.FRAMEBUFFER_getLayers,label:"getLayers",heading:3,content:QW,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER,label:"Graphics Pipeline Builder",heading:2,content:Jz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:rj,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_addShaderStage,label:"addShaderStage",heading:3,content:ij,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setInputAssemblyState,label:"setInputAssemblyState",heading:3,content:hj,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setVertexInputState,label:"setVertexInputState",heading:3,content:Ij,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setTessellationState,label:"setTessellationState",heading:3,content:Pj,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_addViewportState,label:"addViewportState",heading:3,content:Fj,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setRasterizationState,label:"setRasterizationState",heading:3,content:Kj,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setMultisampleState,label:"setMultisampleState",heading:3,content:t9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setDepthStencilState,label:"setDepthStencilState",heading:3,content:c9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setColorBlendState,label:"setColorBlendState",heading:3,content:v9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setDynamicState,label:"setDynamicState",heading:3,content:S9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setRenderPass,label:"setRenderPass",heading:3,content:L9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setSubpass,label:"setSubpass",heading:3,content:M9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_getResult,label:"getResult",heading:3,content:Q9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_reset,label:"reset",heading:3,content:Y9,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE,label:"Graphics Pipeline",heading:2,content:Ez,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_Constructor,label:"Constructor",heading:3,content:Wz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_getRenderPass,label:"getRenderPass",heading:3,content:Xz,props:{},visible:!1}];let $=!1;function n(p){t(1,$=!$)}function s(){t(1,$=!1)}let a=!1;Oo.subscribe(p=>{t(2,a=p.Screen.width<=1e3)});function u(p,m){c.$$.not_equal(m.visible,p)&&(m.visible=p,t(0,r))}return c.$$.update=()=>{if(c.$$.dirty&1){for(let p=0;p<r.length;p++)if(r[p].visible){r[p];break}}},[r,$,a,n,s,u]}class sY extends ve{constructor(e){super(),Ee(this,e,J9,Z9,be,{})}}export{sY as default};
