import{S as ve,i as Ee,s as be,e as d,c as g,a as E,d as l,g as h,E as ke,t as i,w as I,k as Y,h as f,x as S,m as j,b as z,y as D,G as o,q as b,o as w,B as C,O as Fn,P as yn,Q as Mn,l as On,n as In,p as Dn,a5 as Ba,N as xn,H as Sa,J as Ds,j as La,I as Pa,$ as ka,V as Aa,K as Ta,M as Va,_ as Oa,X as Fa,Y as ya,Z as Ma,f as xa,L as Na,W as Ua,z as Ga,A as Ha,C as qa}from"../chunks/index-974b575e.js";import{H as Wa,f as la}from"../chunks/HamburgerMenuIcon-525600aa.js";import{A as fe,H as $e,a as Is,c as ue,n as Qa,S as Ka}from"../chunks/nord-5eb09d97.js";import{g as Ye,s as Cs}from"../chunks/StateStore-20b0ac83.js";import"../chunks/index-4112df05.js";var L=(c=>(c.GETTING_STARTED="Getting-Started",c.CMAKE="CMake",c.FILLCAN="Fillcan",c.FILLCAN_Constructor="Fillcan-Constructor",c.FILLCAN_getSupportedPhysicalDevices="Fillcan-getSupportedPhysicalDevices",c.FILLCAN_selectDevice="Fillcan-selectDevice",c.FILLCAN_getCurrentDevice="Fillcan-getCurrentDevice",c.FILLCAN_createShaderModule="Fillcan-createShaderModule",c.FILLCAN_GRAPHICS="Fillcan-Graphics",c.FILLCAN_GRAPHICS_Constructor="Fillcan-Graphics-Constructor",c.FILLCAN_GRAPHICS_getWindow="Fillcan-Graphics-getWindow",c.FILLCAN_GRAPHICS_mainLoop="Fillcan-Graphics-mainLoop",c.FILLCAN_GRAPHICS_createSwapchain="Fillcan-Graphics-createSwapchain",c.FILLCAN_GRAPHICS_recreateSwapchain="Fillcan-Graphics-recreateSwapchain",c.FILLCAN_GRAPHICS_getSwapchain="Fillcan-Graphics-getSwapchain",c.FILLCAN_GRAPHICS_getSwapchains="Fillcan-Graphics-getSwapchains",c.FILLCAN_GRAPHICS_destroySwapchain="Fillcan-Graphics-destroySwapchain",c.FILLCAN_GRAPHICS_getAssetManager="Fillcan-Graphics-getAssetManager",c.WINDOW="Window",c.WINDOW_Constructor="Window-Constructor",c.WINDOW_shouldClose="Window-shouldClose",c.WINDOW_wasResized="Window-wasResized",c.WINDOW_pollEvents="Window-pollEvents",c.WINDOW_getRequiredExtensions="Window-getRequiredExtensions",c.WINDOW_createSurface="Window-createSurface",c.WINDOW_getSurface="Window-getSurface",c.WINDOW_getExtent="Window-getExtent",c.INSTANCE="Instance",c.INSTANCE_Constructor="Instance-Constructor",c.INSTANCE_getInstanceHandle="Instance-getInstanceHandle",c.DEVICE_POOL="Device-Pool",c.DEVICE_POOL_Constructor="Device-Pool-Constructor",c.DEVICE_POOL_getSupportedPhysicalDevices="Device-Pool-getSupportedPhysicalDevices",c.DEVICE_POOL_selectDevice="Device-Pool-selectDevice",c.DEVICE_POOL_getCurrentDevice="Device-Pool-getCurrentDevice",c.PHYSICAL_DEVICE="Physical-Device",c.PHYSICAL_DEVICE_Constructor="Physical-Device-Constructor",c.PHYSICAL_DEVICE_getPhysicalDeviceHandle="Physical-Device-getPhysicalDeviceHandle",c.PHYSICAL_DEVICE_getRequiredExtensions="Physical-Device-getRequiredExtensions",c.PHYSICAL_DEVICE_areExtensionsSupported="Physical-Device-areExtensionsSupported",c.PHYSICAL_DEVICE_getRequiredFeatures="Physical-Device-getRequiredFeatures",c.PHYSICAL_DEVICE_areFeaturesSupported="Physical-Device-areFeaturesSupported",c.PHYSICAL_DEVICE_getFeatures="Physical-Device-getFeatures",c.PHYSICAL_DEVICE_getProperties="Physical-Device-getProperties",c.PHYSICAL_DEVICE_getSurfaceCapabilitiesKHR="Physical-Device-getSurfaceCapabilitiesKHR",c.PHYSICAL_DEVICE_getSurfaceFormatsKHR="Physical-Device-getSurfaceFormatsKHR",c.PHYSICAL_DEVICE_getSurfacePresentModesKHR="Physical-Device-getSurfacePresentModesKHR",c.PHYSICAL_DEVICE_getQueueFamilyProperties="Physical-Device-getQueueFamilyProperties",c.PHYSICAL_DEVICE_getFormatProperties="Physical-Device-getFormatProperties",c.PHYSICAL_DEVICE_getMemoryProperties="Physical-Device-getMemoryProperties",c.PHYSICAL_DEVICE_findSupportedFormat="Physical-Device-findSupportedFormat",c.PHYSICAL_DEVICE_getGraphicsQueueFamilyIndices="Physical-Device-getGraphicsQueueFamilyIndices",c.PHYSICAL_DEVICE_getPresentQueueFamilyIndices="Physical-Device-getPresentQueueFamilyIndices",c.PHYSICAL_DEVICE_getComputeQueueFamilyIndices="Physical-Device-getComputeQueueFamilyIndices",c.LOGICAL_DEVICE="Logical-Device",c.LOGICAL_DEVICE_Constructor="Logical-Device-Constructor",c.LOGICAL_DEVICE_getLogicalDeviceHandle="Logical-Device-getLogicalDeviceHandle",c.LOGICAL_DEVICE_getPhysicalDevice="Logical-Device-getPhysicalDevice",c.LOGICAL_DEVICE_waitIdle="Logical-Device-waitIdle",c.LOGICAL_DEVICE_getGraphicsQueue="Logical-Device-getGraphicsQueue",c.LOGICAL_DEVICE_getPresentQueue="Logical-Device-getPresentQueue",c.LOGICAL_DEVICE_getComputeQueue="Logical-Device-getComputeQueue",c.LOGICAL_DEVICE_beginSingleTimeCommandRecording="Logical-Device-beginSingleTimeCommandRecording",c.LOGICAL_DEVICE_endSingleTimeCommandRecording="Logical-Device-endSingleTimeCommandRecording",c.QUEUE="Queue",c.QUEUE_Constructor="Queue-Constructor",c.QUEUE_getQueueHandle="Queue-getQueueHandle",c.QUEUE_getQueueFamilyIndex="Queue-getQueueFamilyIndex",c.QUEUE_getQueueIndex="Queue-getQueueIndex",c.QUEUE_createCommandPool="Queue-createCommandPool",c.QUEUE_getCommandPools="Queue-getCommandPools",c.QUEUE_getCommandPool="Queue-getCommandPool",c.QUEUE_destroyCommandPool="Queue-destroyCommandPool",c.QUEUE_createRecording="Queue-createRecording",c.QUEUE_submitRecordings="Queue-submitRecordings",c.QUEUE_resetRecording="Queue-resetRecording",c.QUEUE_freeRecording="Queue-freeRecording",c.QUEUE_waitIdle="Queue-waitIdle",c.COMMAND_POOL="Command-Pool",c.COMMAND_POOL_Constructor="Command-Pool-Constructor",c.COMMAND_POOL_getCommandPoolHandle="Command-Pool-getCommandPoolHandle",c.COMMAND_POOL_allocateCommandBuffers="Command-Pool-allocateCommandBuffers",c.COMMAND_POOL_freeCommandBuffers="Command-Pool-freeCommandBuffers",c.COMMAND_POOL_reset="Command-Pool-reset",c.COMMAND_BUFFER="Command-Buffer",c.COMMAND_BUFFER_Constructor="Command-Buffer-Constructor",c.COMMAND_BUFFER_getCommandBufferHandle="Command-Buffer-getCommandBufferHandle",c.COMMAND_BUFFER_getLevel="Command-Buffer-getLevel",c.COMMAND_BUFFER_begin="Command-Buffer-begin",c.COMMAND_BUFFER_end="Command-Buffer-end",c.COMMAND_BUFFER_reset="Command-Buffer-reset",c.COMMAND_RECORDING="Command-Recording",c.COMMAND_RECORDING_endAll="Command-Recording-endAll",c.COMMAND_RECORDING_submit="Command-Recording-submit",c.COMMAND_RECORDING_reset="Command-Recording-reset",c.COMMAND_RECORDING_free="Command-Recording-free",c.COMMAND_RECORDING_createFence="Command-Recording-createFence",c.COMMAND_RECORDING_waitForFence="Command-Recording-waitForFence",c.SWAPCHAIN="Swapchain",c.SWAPCHAIN_Swapchain_Image="Swapchain-Swapchain-Image",c.SWAPCHAIN_Constructor="Swapchain-Constructor",c.SWAPCHAIN_getSwapchainHandle="Swapchain-getSwapchainHandle",c.SWAPCHAIN_getNextImage="Swapchain-getNextImage",c.SWAPCHAIN_getSurfaceFormat="Swapchain-getSurfaceFormat",c.SWAPCHAIN_getImageCount="Swapchain-getImageCount",c.SWAPCHAIN_getImageArrayLayers="Swapchain-getImageArrayLayers",c.SWAPCHAIN_getImageUsage="Swapchain-getImageUsage",c.SWAPCHAIN_getImageSharingMode="Swapchain-getImageSharingMode",c.SWAPCHAIN_getImageExtent="Swapchain-getImageExtent",c.SWAPCHAIN_getPresentMode="Swapchain-getPresentMode",c.SWAPCHAIN_getQueueFamilyIndices="Swapchain-getQueueFamilyIndices",c.SWAPCHAIN_present="Swapchain-present",c.BUFFER="Buffer",c.BUFFER_Constructor="Buffer-Constructor",c.BUFFER_getBufferHandle="Buffer-getBufferHandle",c.BUFFER_getFlags="Buffer-getFlags",c.BUFFER_getSize="Buffer-getSize",c.BUFFER_getUsage="Buffer-getUsage",c.BUFFER_getSharingMode="Buffer-getSharingMode",c.BUFFER_getQueueFamilyIndices="Buffer-getQueueFamilyIndices",c.BUFFER_bindMemory="Buffer-bindMemory",c.BUFFER_getMemory="Buffer-getMemory",c.BUFFER_createBufferView="Buffer-createBufferView",c.BUFFER_getBufferViews="Buffer-getBufferViews",c.BUFFER_getBufferView="Buffer-getBufferView",c.BUFFER_destroyBufferViews="Buffer-destroyBufferViews",c.BUFFER_destroyBufferView="Buffer-destroyBufferView",c.BUFFER_copyTo="Buffer-copyTo",c.BUFFER_VIEW="Buffer-View",c.BUFFER_VIEW_Constructor="Buffer-View-Constructor",c.BUFFER_VIEW_getBufferViewHandle="Buffer-View-getBufferViewHandle",c.BUFFER_DIRECTOR="Buffer-Director",c.BUFFER_DIRECTOR_Constructor="Buffer-Director-Constructor",c.BUFFER_DIRECTOR_makeVertexBuffer="Buffer-Director-makeVertexBuffer",c.BUFFER_DIRECTOR_makeVertexTransferDestinationBuffer="Buffer-Director-makeVertexTransferDestinationBuffer",c.BUFFER_DIRECTOR_makeUniformBuffer="Buffer-Director-makeUniformBuffer",c.BUFFER_DIRECTOR_makeStorageBuffer="Buffer-Director-makeStorageBuffer",c.BUFFER_DIRECTOR_makeUniformTexelBuffer="Buffer-Director-makeUniformTexelBuffer",c.BUFFER_DIRECTOR_makeStorageTexelBuffer="Buffer-Director-makeStorageTexelBuffer",c.BUFFER_DIRECTOR_makeIndexBuffer="Buffer-Director-makeIndexBuffer",c.BUFFER_DIRECTOR_makeIndexTransferDestinationBuffer="Buffer-Director-makeIndexTransferDestinationBuffer",c.BUFFER_DIRECTOR_makeIndirectBuffer="Buffer-Director-makeIndirectBuffer",c.BUFFER_DIRECTOR_makeStagingBuffer="Buffer-Director-makeStagingBuffer",c.BUFFER_BUILDER="Buffer-Builder",c.BUFFER_BUILDER_Constructor="Buffer-Builder-Constructor",c.BUFFER_BUILDER_setLogicalDevice="Buffer-Builder-setLogicalDevice",c.BUFFER_BUILDER_setFlags="Buffer-Builder-setFlags",c.BUFFER_BUILDER_setSize="Buffer-Builder-setSize",c.BUFFER_BUILDER_setUsage="Buffer-Builder-setUsage",c.BUFFER_BUILDER_setSharingMode="Buffer-Builder-setSharingMode",c.BUFFER_BUILDER_setQueueFamilyIndices="Buffer-Builder-setQueueFamilyIndices",c.BUFFER_BUILDER_getResult="Buffer-Builder-getResult",c.BUFFER_BUILDER_reset="Buffer-Builder-reset",c.IMAGE="Image",c.IMAGE_Constructor="Image-Constructor",c.IMAGE_getImageHandle="Image-getImageHandle",c.IMAGE_getFlags="Image-getFlags",c.IMAGE_getUsage="Image-getUsage",c.IMAGE_getSharingMode="Image-getSharingMode",c.IMAGE_getQueueFamilyIndices="Image-getQueueFamilyIndices",c.IMAGE_getType="Image-getType",c.IMAGE_getFormat="Image-getFormat",c.IMAGE_getExtent="Image-getExtent",c.IMAGE_getMipLevels="Image-getMipLevels",c.IMAGE_getArrayLayers="Image-getArrayLayers",c.IMAGE_getSamples="Image-getSamples",c.IMAGE_getTiling="Image-getTiling",c.IMAGE_getInitialLayout="Image-getInitialLayout",c.IMAGE_bindMemory="Image-bindMemory",c.IMAGE_getMemory="Image-getMemory",c.IMAGE_createImageView="Image-createImageView",c.IMAGE_getImageViews="Image-getImageViews",c.IMAGE_getImageView="Image-getImageView",c.IMAGE_destroyImageViews="Image-destroyImageViews",c.IMAGE_destroyImageView="Image-destroyImageView",c.IMAGE_copyTo="Image-copyTo",c.IMAGE_transitionImageLayout="Image-transitionImageLayout",c.IMAGE_VIEW="Image-View",c.IMAGE_VIEW_Constructor="Image-View-Constructor",c.IMAGE_VIEW_getImageViewHandle="Image-View-getImageViewHandle",c.IMAGE_DIRECTOR="Image-Director",c.IMAGE_DIRECTOR_Constructor="Image-Director-Constructor",c.IMAGE_DIRECTOR_make2DTexture="Image-Director-make2DTexture",c.IMAGE_DIRECTOR_makeDepthImage="Image-Director-makeDepthImage",c.IMAGE_BUILDER="Image-Builder",c.IMAGE_BUILDER_Constructor="Image-Builder-Constructor",c.IMAGE_BUILDER_setLogicalDevice="Image-Builder-setLogicalDevice",c.IMAGE_BUILDER_setFlags="Image-Builder-setFlags",c.IMAGE_BUILDER_setImageType="Image-Builder-setImageType",c.IMAGE_BUILDER_setFormat="Image-Builder-setFormat",c.IMAGE_BUILDER_setExtent="Image-Builder-setExtent",c.IMAGE_BUILDER_setMipLevels="Image-Builder-setMipLevels",c.IMAGE_BUILDER_setArrayLayers="Image-Builder-setArrayLayers",c.IMAGE_BUILDER_setSamples="Image-Builder-setSamples",c.IMAGE_BUILDER_setImageTiling="Image-Builder-setImageTiling",c.IMAGE_BUILDER_setImageUsage="Image-Builder-setImageUsage",c.IMAGE_BUILDER_setSharingMode="Image-Builder-setSharingMode",c.IMAGE_BUILDER_setQueueFamilyIndices="Image-Builder-setQueueFamilyIndices",c.IMAGE_BUILDER_setInitialLayout="Image-Builder-setInitialLayout",c.IMAGE_BUILDER_reset="Image-Builder-reset",c.IMAGE_BUILDER_getResult="Image-Builder-getResult",c.SAMPLER_BUILDER="Sampler-Builder",c.SAMPLER_BUILDER_Constructor="Sampler-Builder-Constructor",c.SAMPLER_BUILDER_setLogicalDevice="Sampler-Builder-setLogicalDevice",c.SAMPLER_BUILDER_setFilters="Sampler-Builder-setFilters",c.SAMPLER_BUILDER_setMipmapMode="Sampler-Builder-setMipmapMode",c.SAMPLER_BUILDER_setAddressModes="Sampler-Builder-setAddressModes",c.SAMPLER_BUILDER_setMipLodBias="Sampler-Builder-setMipLodBias",c.SAMPLER_BUILDER_setMaxAnisotropy="Sampler-Builder-setMaxAnisotropy",c.SAMPLER_BUILDER_unsetMaxAnisotropy="Sampler-Builder-unsetMaxAnisotropy",c.SAMPLER_BUILDER_setCompareOp="Sampler-Builder-setCompareOp",c.SAMPLER_BUILDER_unsetCompareOp="Sampler-Builder-unsetCompareOp",c.SAMPLER_BUILDER_setLod="Sampler-Builder-setLod",c.SAMPLER_BUILDER_setBorderColor="Sampler-Builder-setBorderColor",c.SAMPLER_BUILDER_enableUnnormalizedCoordinates="Sampler-Builder-enableUnnormalizedCoordinates",c.SAMPLER_BUILDER_disableUnnormalizedCoordinates="Sampler-Builder-disableUnnormalizedCoordinates",c.SAMPLER_BUILDER_getResult="Sampler-Builder-getResult",c.SAMPLER_BUILDER_reset="Sampler-Builder-reset",c.SAMPLER="Sampler",c.SAMPLER_Constructor="Sampler-Constructor",c.SAMPLER_getSamplerHandle="Sampler-getSamplerHandle",c.MEMORY="Memory",c.MEMORY_Constructor="Memory-Constructor",c.MEMORY_getMemoryHandle="Memory-getMemoryHandle",c.MEMORY_map="Memory-map",c.MEMORY_unmap="Memory-unmap",c.MEMORY_getData="Memory-getData",c.MEMORY_flush="Memory-flush",c.MEMORY_invalidate="Memory-invalidate",c.SEMAPHORE="Semaphore",c.SEMAPHORE_Constructor="Semaphore-Constructor",c.SEMAPHORE_getSemaphoreHandle="Semaphore-getSemaphoreHandle",c.FENCE="Fence",c.FENCE_Constructor="Fence-Constructor",c.FENCE_getFenceHandle="Fence-getFenceHandle",c.FENCE_waitFor="Fence-waitFor",c.FENCE_reset="Fence-reset",c.FENCE_s_waitForAll="Fence-s_waitForAll",c.FENCE_s_resetAll="Fence-s_resetAll",c.SHADER_MODULE="Shader-Module",c.SHADER_MODULE_Constructor="Shader-Module-Constructor",c.SHADER_MODULE_getShaderModuleHandle="Shader-Module-getShaderModuleHandle",c.SHADER_MODULE_getDescriptorSetLayouts="Shader-Module-getDescriptorSetLayouts",c.SHADER_MODULE_getDescriptorPool="Shader-Module-getDescriptorPool",c.DESCRIPTOR_SET_LAYOUT_BUILDER="Descriptor-Set-Layout-Builder",c.DESCRIPTOR_SET_LAYOUT_BUILDER_Constructor="Descriptor-Set-Layout-Builder-Constructor",c.DESCRIPTOR_SET_LAYOUT_BUILDER_setLogicalDevice="Descriptor-Set-Layout-Builder-setLogicalDevice",c.DESCRIPTOR_SET_LAYOUT_BUILDER_addBinding="Descriptor-Set-Layout-Builder-addBinding",c.DESCRIPTOR_SET_LAYOUT_BUILDER_getResult="Descriptor-Set-Layout-Builder-getResult",c.DESCRIPTOR_SET_LAYOUT_BUILDER_reset="Descriptor-Set-Layout-Builder-reset",c.DESCRIPTOR_SET_LAYOUT="Descriptor-Set-Layout",c.DESCRIPTOR_SET_LAYOUT_Constructor="Descriptor-Set-Layout-Constructor",c.DESCRIPTOR_SET_LAYOUT_getDescriptorSetLayoutHandle="Descriptor-Set-Layout-getDescriptorSetLayoutHandle",c.DESCRIPTOR_SET_LAYOUT_getBindings="Descriptor-Set-Layout-getBindings",c.DESCRIPTOR_POOL_BUILDER="Descriptor-Pool-Builder",c.DESCRIPTOR_POOL_BUILDER_Constructor="Descriptor-Pool-Builder-Constructor",c.DESCRIPTOR_POOL_BUILDER_setLogicalDevice="Descriptor-Pool-Builder-setLogicalDevice",c.DESCRIPTOR_POOL_BUILDER_setFlags="Descriptor-Pool-Builder-setFlags",c.DESCRIPTOR_POOL_BUILDER_addSet="Descriptor-Pool-Builder-addSet",c.DESCRIPTOR_POOL_BUILDER_getResult="Descriptor-Pool-Builder-getResult",c.DESCRIPTOR_POOL_BUILDER_reset="Descriptor-Pool-Builder-reset",c.DESCRIPTOR_POOL="Descriptor-Pool",c.DESCRIPTOR_POOL_Constructor="Descriptor-Pool-Constructor",c.DESCRIPTOR_POOL_getDescriptorPoolHandle="Descriptor-Pool-getDescriptorPoolHandle",c.DESCRIPTOR_POOL_allocateDescriptorSet="Descriptor-Pool-allocateDescriptorSet",c.DESCRIPTOR_POOL_getDescriptorSets="Descriptor-Pool-getDescriptorSets",c.DESCRIPTOR_POOL_getDescriptorSet="Descriptor-Pool-getDescriptorSet",c.DESCRIPTOR_POOL_freeDescriptorSets="Descriptor-Pool-freeDescriptorSets",c.DESCRIPTOR_POOL_reset="Descriptor-Pool-reset",c.DESCRIPTOR_SET="Descriptor-Set",c.DESCRIPTOR_SET_Constructor="Descriptor-Set-Constructor",c.DESCRIPTOR_SET_getDescriptorSetHandle="Descriptor-Set-getDescriptorSetHandle",c.DESCRIPTOR_SET_getLayout="Descriptor-Set-getLayout",c.DESCRIPTOR_SET_getName="Descriptor-Set-getName",c.DESCRIPTOR_SET_writeImage="Descriptor-Set-writeImage",c.DESCRIPTOR_SET_writeBuffer="Descriptor-Set-writeBuffer",c.DESCRIPTOR_SET_writeTexelBufferView="Descriptor-Set-writeTexelBufferView",c.DESCRIPTOR_SET_copy="Descriptor-Set-copy",c.PIPELINE_BUILDER="Pipeline-Builder",c.PIPELINE_BUILDER_Constructor="Pipeline-Builder-Constructor",c.PIPELINE_BUILDER_setLogicalDevice="Pipeline-Builder-setLogicalDevice",c.PIPELINE_BUILDER_setFlags="Pipeline-Builder-setFlags",c.PIPELINE_BUILDER_addPushConstant="Pipeline-Builder-addPushConstant",c.PIPELINE_BUILDER_setPipelineCache="Pipeline-Builder-setPipelineCache",c.PIPELINE_BUILDER_setBasePipeline="Pipeline-Builder-setBasePipeline",c.PIPELINE_BUILDER_reset="Pipeline-Builder-reset",c.PIPELINE_LAYOUT="Pipeline-Layout",c.PIPELINE_LAYOUT_PUSH_CONSTANT="Pipeline-Layout-Push-Constant",c.PIPELINE_LAYOUT_Constructor="Pipeline-Layout-Constructor",c.PIPELINE_LAYOUT_getPipelineLayoutHandle="Pipeline-Layout-getPipelineLayoutHandle",c.PIPELINE_LAYOUT_pushConstantData="Pipeline-Layout-pushConstantData",c.PIPELINE="Pipeline",c.PIPELINE_PIPELINE_SHADER_STAGE="Pipeline-Pipeline-Shader-Stage",c.PIPELINE_Constructor="Pipeline-Constructor",c.PIPELINE_getPipelineHandle="Pipeline-getPipelineHandle",c.PIPELINE_getPipelineLayout="Pipeline-getPipelineLayout",c.PIPELINE_bindToCommandBuffer="Pipeline-bindToCommandBuffer",c.PIPELINE_getCommandBuffer="Pipeline-getCommandBuffer",c.PIPELINE_bindDescriptorSets="Pipeline-bindDescriptorSets",c.PIPELINE_getDescriptorSets="Pipeline-getDescriptorSets",c.PIPELINE_getDescriptorSet="Pipeline-getDescriptorSet",c.PIPELINE_pushConstantData="Pipeline-pushConstantData",c.COMPUTE_PIPELINE="Compute-Pipeline",c.COMPUTE_PIPELINE_Constructor="Compute Pipeline-Constructor",c.COMPUTE_PIPELINE_BUILDER="Compute-Pipeline-Builder",c.COMPUTE_PIPELINE_BUILDER_Constructor="Compute-Pipeline-Builder-Constructor",c.COMPUTE_PIPELINE_BUILDER_setShaderStage="Compute-Pipeline-Builder-setShaderStage",c.COMPUTE_PIPELINE_BUILDER_getResult="Compute-Pipeline-Builder-getResult",c.COMPUTE_PIPELINE_BUILDER_reset="Compute-Pipeline-Builder-reset",c.RENDER_PASS="Render-Pass",c.RENDER_PASS_Constructor="Render-Pass-Constructor",c.RENDER_PASS_getRenderPassHandle="Render-Pass-getRenderPassHandle",c.RENDER_PASS_getAttachments="Render-Pass-getAttachments",c.RENDER_PASS_getSubpasses="Render-Pass-getSubpasses",c.RENDER_PASS_getDependencies="Render-Pass-getDependencies",c.RENDER_PASS_begin="Render-Pass-begin",c.RENDER_PASS_end="Render-Pass-end",c.RENDER_PASS_BUILDER="Render-Pass-Builder",c.RENDER_PASS_BUILDER_Constructor="Render-Pass-Builder-Constructor",c.RENDER_PASS_BUILDER_setLogicalDevice="Render-Pass-Builder-setLogicalDevice",c.RENDER_PASS_BUILDER_addAttachment="Render-Pass-Builder-addAttachment",c.RENDER_PASS_BUILDER_addInputAttachment="Render-Pass-Builder-addInputAttachment",c.RENDER_PASS_BUILDER_addColorAttachment="Render-Pass-Builder-addColorAttachment",c.RENDER_PASS_BUILDER_setDepthStencilAttachment="Render-Pass-Builder-setDepthStencilAttachment",c.RENDER_PASS_BUILDER_resolveCurrentAttachments="Render-Pass-Builder-resolveCurrentAttachments",c.RENDER_PASS_BUILDER_constructSubpass="Render-Pass-Builder-constructSubpass",c.RENDER_PASS_BUILDER_addDependency="Render-Pass-Builder-addDependency",c.RENDER_PASS_BUILDER_getResult="Render-Pass-Builder-getResult",c.RENDER_PASS_BUILDER_reset="Render-Pass-Builder-reset",c.FRAMEBUFFER="Framebuffer",c.FRAMEBUFFER_Constructor="Framebuffer-Constructor",c.FRAMEBUFFER_getFramebufferHandle="Framebuffer-getFramebufferHandle",c.FRAMEBUFFER_getExtent="Framebuffer-getExtent",c.FRAMEBUFFER_getLayers="Framebuffer-getLayers",c.GRAPHICS_PIPELINE_BUILDER="Graphics-Pipeline-Builder",c.GRAPHICS_PIPELINE_BUILDER_Constructor="Graphics-Pipeline-Builder-Constructor",c.GRAPHICS_PIPELINE_BUILDER_addShaderStage="Graphics-Pipeline-Builder-addShaderStage",c.GRAPHICS_PIPELINE_BUILDER_setInputAssemblyState="Graphics-Pipeline-Builder-setInputAssemblyState",c.GRAPHICS_PIPELINE_BUILDER_setVertexInputState="Graphics-Pipeline-Builder-setVertexInputState",c.GRAPHICS_PIPELINE_BUILDER_setTessellationState="Graphics-Pipeline-Builder-setTessellationState",c.GRAPHICS_PIPELINE_BUILDER_addViewportState="Graphics-Pipeline-Builder-addViewportState",c.GRAPHICS_PIPELINE_BUILDER_setRasterizationState="Graphics-Pipeline-Builder-setRasterizationState",c.GRAPHICS_PIPELINE_BUILDER_setMultisampleState="Graphics-Pipeline-Builder-setMultisampleState",c.GRAPHICS_PIPELINE_BUILDER_setDepthStencilState="Graphics-Pipeline-Builder-setDepthStencilState",c.GRAPHICS_PIPELINE_BUILDER_setColorBlendState="Graphics-Pipeline-Builder-setColorBlendState",c.GRAPHICS_PIPELINE_BUILDER_setDynamicState="Graphics-Pipeline-Builder-setDynamicState",c.GRAPHICS_PIPELINE_BUILDER_setRenderPass="Graphics-Pipeline-Builder-setRenderPass",c.GRAPHICS_PIPELINE_BUILDER_setSubpass="Graphics-Pipeline-Builder-setSubpass",c.GRAPHICS_PIPELINE_BUILDER_getResult="Graphics-Pipeline-Builder-getResult",c.GRAPHICS_PIPELINE_BUILDER_reset="Graphics-Pipeline-Builder-reset",c.GRAPHICS_PIPELINE="Graphics-Pipeline",c.GRAPHICS_PIPELINE_Constructor="Graphics-Pipeline-Constructor",c.GRAPHICS_PIPELINE_getRenderPass="Graphics-Pipeline-getRenderPass",c.ASSET_MANAGER="Asset-Manager",c))(L||{});function za(c){let e;return{c(){e=d("p")},l(t){e=g(t,"P",{});var r=E(e);r.forEach(l)},m(t,r){h(t,e,r)},p:ke,i:ke,o:ke,d(t){t&&l(e)}}}class Ya extends ve{constructor(e){super(),Ee(this,e,null,za,be,{})}}function ja(c){let e;return{c(){e=i("CMake")},l(t){e=f(t,"CMake")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xa(c){let e;return{c(){e=i("GLFW")},l(t){e=f(t,"GLFW")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Za(c){let e;return{c(){e=i("GLM")},l(t){e=f(t,"GLM")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ja(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eo(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te;return t=new fe({props:{href:"https://cmake.org/",target:"_blank",$$slots:{default:[ja]},$$scope:{ctx:c}}}),a=new $e({props:{language:Is,code:'set(Fillcan_DIRECTORY "${CMAKE_SOURCE_DIR}/lib/fillcan")\ntarget_include_directories(${PROJECT_NAME} PUBLIC ${Fillcan_DIRECTORY} ${PROJECT_BINARY_DIR})'}}),m=new $e({props:{language:Is,code:"add_subdirectory(${Fillcan_DIRECTORY})"}}),P=new $e({props:{language:Is,code:"target_link_libraries(${PROJECT_NAME} Fillcan)"}}),M=new fe({props:{href:"https://www.glfw.org/",target:"_blank",$$slots:{default:[Xa]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://github.com/g-truc/glm",target:"_blank",$$slots:{default:[Za]},$$scope:{ctx:c}}}),q=new fe({props:{href:"https://github.com/google/shaderc",target:"_blank",$$slots:{default:[Ja]},$$scope:{ctx:c}}}),{c(){e=i("Fillcan makes use of "),I(t.$$.fragment),r=i(" and as such has a CMakeLists.txt file."),$=d("br"),n=d("br"),s=i(`
To add Fillcan to your project as a library you first have to add it's directory
to the compiler's search list for include files:
`),I(a.$$.fragment),u=d("br"),p=i(`
Next you need to add Fillcan as a subdirectory to the project. This indicates to
the compiler where the CMakeLists.txt and code files of Fillcan are located:
`),I(m.$$.fragment),_=d("br"),v=i(`
Finally you can link the Fillcan library to the project:
`),I(P.$$.fragment),R=d("br"),A=i(`
Within Fillcan's CMakeLists.txt several libraries are added. These libraries are
as follows:
`),T=d("h4"),F=i("1. Vulkan"),B=i(`
The Vulkan Library will be looked for on the system. And if it can not be found a
bundled version will be used instead.
`),y=d("h4"),V=i("2. GLFW"),x=Y(),I(M.$$.fragment),O=i(` is used for creating
windows, contexts and surfaces and receiving input and window events.
`),H=d("h4"),k=i("3. GLM"),N=Y(),I(Q.$$.fragment),X=i(` is a header
only C++ mathematics library for graphics software based on the OpenGL Shading Language
(GLSL) specifications.
`),Z=d("h4"),K=i("4. Shaderc"),W=Y(),I(q.$$.fragment),U=i(` is a collection of tools for shader compilation. It is used within Fillcan to validate
GLSL shader-code and to compile it to SPIR-V.`),this.h()},l(ee){e=f(ee,"Fillcan makes use of "),S(t.$$.fragment,ee),r=f(ee," and as such has a CMakeLists.txt file."),$=g(ee,"BR",{}),n=g(ee,"BR",{}),s=f(ee,`
To add Fillcan to your project as a library you first have to add it's directory
to the compiler's search list for include files:
`),S(a.$$.fragment,ee),u=g(ee,"BR",{}),p=f(ee,`
Next you need to add Fillcan as a subdirectory to the project. This indicates to
the compiler where the CMakeLists.txt and code files of Fillcan are located:
`),S(m.$$.fragment,ee),_=g(ee,"BR",{}),v=f(ee,`
Finally you can link the Fillcan library to the project:
`),S(P.$$.fragment,ee),R=g(ee,"BR",{}),A=f(ee,`
Within Fillcan's CMakeLists.txt several libraries are added. These libraries are
as follows:
`),T=g(ee,"H4",{id:!0,class:!0});var se=E(T);F=f(se,"1. Vulkan"),se.forEach(l),B=f(ee,`
The Vulkan Library will be looked for on the system. And if it can not be found a
bundled version will be used instead.
`),y=g(ee,"H4",{id:!0,class:!0});var ie=E(y);V=f(ie,"2. GLFW"),ie.forEach(l),x=j(ee),S(M.$$.fragment,ee),O=f(ee,` is used for creating
windows, contexts and surfaces and receiving input and window events.
`),H=g(ee,"H4",{id:!0,class:!0});var ae=E(H);k=f(ae,"3. GLM"),ae.forEach(l),N=j(ee),S(Q.$$.fragment,ee),X=f(ee,` is a header
only C++ mathematics library for graphics software based on the OpenGL Shading Language
(GLSL) specifications.
`),Z=g(ee,"H4",{id:!0,class:!0});var J=E(Z);K=f(J,"4. Shaderc"),J.forEach(l),W=j(ee),S(q.$$.fragment,ee),U=f(ee,` is a collection of tools for shader compilation. It is used within Fillcan to validate
GLSL shader-code and to compile it to SPIR-V.`),this.h()},h(){z(T,"id","cmake-vulkan"),z(T,"class","svelte-1tuq2yd"),z(y,"id","cmake-glfw"),z(y,"class","svelte-1tuq2yd"),z(H,"id","cmake-glm"),z(H,"class","svelte-1tuq2yd"),z(Z,"id","cmake-shaderc"),z(Z,"class","svelte-1tuq2yd")},m(ee,se){h(ee,e,se),D(t,ee,se),h(ee,r,se),h(ee,$,se),h(ee,n,se),h(ee,s,se),D(a,ee,se),h(ee,u,se),h(ee,p,se),D(m,ee,se),h(ee,_,se),h(ee,v,se),D(P,ee,se),h(ee,R,se),h(ee,A,se),h(ee,T,se),o(T,F),h(ee,B,se),h(ee,y,se),o(y,V),h(ee,x,se),D(M,ee,se),h(ee,O,se),h(ee,H,se),o(H,k),h(ee,N,se),D(Q,ee,se),h(ee,X,se),h(ee,Z,se),o(Z,K),h(ee,W,se),D(q,ee,se),h(ee,U,se),te=!0},p(ee,[se]){const ie={};se&1&&(ie.$$scope={dirty:se,ctx:ee}),t.$set(ie);const ae={};se&1&&(ae.$$scope={dirty:se,ctx:ee}),M.$set(ae);const J={};se&1&&(J.$$scope={dirty:se,ctx:ee}),Q.$set(J);const pe={};se&1&&(pe.$$scope={dirty:se,ctx:ee}),q.$set(pe)},i(ee){te||(b(t.$$.fragment,ee),b(a.$$.fragment,ee),b(m.$$.fragment,ee),b(P.$$.fragment,ee),b(M.$$.fragment,ee),b(Q.$$.fragment,ee),b(q.$$.fragment,ee),te=!0)},o(ee){w(t.$$.fragment,ee),w(a.$$.fragment,ee),w(m.$$.fragment,ee),w(P.$$.fragment,ee),w(M.$$.fragment,ee),w(Q.$$.fragment,ee),w(q.$$.fragment,ee),te=!1},d(ee){ee&&l(e),C(t,ee),ee&&l(r),ee&&l($),ee&&l(n),ee&&l(s),C(a,ee),ee&&l(u),ee&&l(p),C(m,ee),ee&&l(_),ee&&l(v),C(P,ee),ee&&l(R),ee&&l(A),ee&&l(T),ee&&l(B),ee&&l(y),ee&&l(x),C(M,ee),ee&&l(O),ee&&l(H),ee&&l(N),C(Q,ee),ee&&l(X),ee&&l(Z),ee&&l(W),C(q,ee),ee&&l(U)}}}class to extends ve{constructor(e){super(),Ee(this,e,null,eo,be,{})}}function ro(c){let e,t,r,$,n,s;return e=new $e({props:{language:ue,code:"#include <fillcan/fillcan.hpp>"}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Fillcan"),n=i(` class is the API through which the application can talk
with Vulkan.`)},l(a){S(e.$$.fragment,a),t=f(a,`
The `),r=g(a,"CODE",{});var u=E(r);$=f(u,"Fillcan"),u.forEach(l),n=f(a,` class is the API through which the application can talk
with Vulkan.`)},m(a,u){D(e,a,u),h(a,t,u),h(a,r,u),o(r,$),h(a,n,u),s=!0},p:ke,i(a){s||(b(e.$$.fragment,a),s=!0)},o(a){w(e.$$.fragment,a),s=!1},d(a){C(e,a),a&&l(t),a&&l(r),a&&l(n)}}}class no extends ve{constructor(e){super(),Ee(this,e,null,ro,be,{})}}const so=c=>({}),ia=c=>({}),ao=c=>({}),fa=c=>({}),oo=c=>({}),ca=c=>({}),lo=c=>({}),$a=c=>({}),io=c=>({}),ua=c=>({});function pa(c){let e,t;const r=c[2].details,$=xn(r,c,c[1],ua);return{c(){e=d("div"),$&&$.c(),this.h()},l(n){e=g(n,"DIV",{class:!0});var s=E(e);$&&$.l(s),s.forEach(l),this.h()},h(){z(e,"class","details svelte-3cp1as")},m(n,s){h(n,e,s),$&&$.m(e,null),t=!0},p(n,s){$&&$.p&&(!t||s&2)&&Fn($,r,n,n[1],t?Mn(r,n[1],s,io):yn(n[1]),ua)},i(n){t||(b($,n),t=!0)},o(n){w($,n),t=!1},d(n){n&&l(e),$&&$.d(n)}}}function ma(c){let e,t,r;const $=c[2].params,n=xn($,c,c[1],$a);return{c(){e=d("ul"),t=d("div"),n&&n.c(),this.h()},l(s){e=g(s,"UL",{class:!0});var a=E(e);t=g(a,"DIV",{class:!0});var u=E(t);n&&n.l(u),u.forEach(l),a.forEach(l),this.h()},h(){z(t,"class","params svelte-3cp1as"),z(e,"class","method-description svelte-3cp1as")},m(s,a){h(s,e,a),o(e,t),n&&n.m(t,null),r=!0},p(s,a){n&&n.p&&(!r||a&2)&&Fn(n,$,s,s[1],r?Mn($,s[1],a,lo):yn(s[1]),$a)},i(s){r||(b(n,s),r=!0)},o(s){w(n,s),r=!1},d(s){s&&l(e),n&&n.d(s)}}}function ha(c){let e,t,r,$,n;const s=c[2].return,a=xn(s,c,c[1],ca);return{c(){e=d("div"),t=d("code"),r=i("@return"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{class:!0});var m=E(t);r=f(m,"@return"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(t,"class","svelte-3cp1as"),z(e,"class","return svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&Fn(a,s,u,u[1],n?Mn(s,u[1],p,oo):yn(u[1]),ca)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function da(c){let e,t,r,$,n;const s=c[2].throws,a=xn(s,c,c[1],fa);return{c(){e=d("div"),t=d("code"),r=i("@throws"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{class:!0});var m=E(t);r=f(m,"@throws"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(t,"class","svelte-3cp1as"),z(e,"class","throws svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&Fn(a,s,u,u[1],n?Mn(s,u[1],p,ao):yn(u[1]),fa)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function ga(c){let e,t,r,$,n;const s=c[2].note,a=xn(s,c,c[1],ia);return{c(){e=d("div"),t=d("code"),r=i("@note"),$=i(": "),a&&a.c(),this.h()},l(u){e=g(u,"DIV",{class:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"@note"),m.forEach(l),$=f(p,": "),a&&a.l(p),p.forEach(l),this.h()},h(){z(e,"class","note svelte-3cp1as")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),a&&a.m(e,null),n=!0},p(u,p){a&&a.p&&(!n||p&2)&&Fn(a,s,u,u[1],n?Mn(s,u[1],p,so):yn(u[1]),ia)},i(u){n||(b(a,u),n=!0)},o(u){w(a,u),n=!1},d(u){u&&l(e),a&&a.d(u)}}}function fo(c){let e,t,r,$,n,s,a=c[0].details&&pa(c),u=c[0].params&&ma(c),p=c[0].return&&ha(c),m=c[0].throws&&da(c),_=c[0].note&&ga(c);return{c(){a&&a.c(),e=Y(),u&&u.c(),t=Y(),p&&p.c(),r=Y(),m&&m.c(),$=Y(),_&&_.c(),n=On()},l(v){a&&a.l(v),e=j(v),u&&u.l(v),t=j(v),p&&p.l(v),r=j(v),m&&m.l(v),$=j(v),_&&_.l(v),n=On()},m(v,P){a&&a.m(v,P),h(v,e,P),u&&u.m(v,P),h(v,t,P),p&&p.m(v,P),h(v,r,P),m&&m.m(v,P),h(v,$,P),_&&_.m(v,P),h(v,n,P),s=!0},p(v,[P]){v[0].details?a?(a.p(v,P),P&1&&b(a,1)):(a=pa(v),a.c(),b(a,1),a.m(e.parentNode,e)):a&&(In(),w(a,1,1,()=>{a=null}),Dn()),v[0].params?u?(u.p(v,P),P&1&&b(u,1)):(u=ma(v),u.c(),b(u,1),u.m(t.parentNode,t)):u&&(In(),w(u,1,1,()=>{u=null}),Dn()),v[0].return?p?(p.p(v,P),P&1&&b(p,1)):(p=ha(v),p.c(),b(p,1),p.m(r.parentNode,r)):p&&(In(),w(p,1,1,()=>{p=null}),Dn()),v[0].throws?m?(m.p(v,P),P&1&&b(m,1)):(m=da(v),m.c(),b(m,1),m.m($.parentNode,$)):m&&(In(),w(m,1,1,()=>{m=null}),Dn()),v[0].note?_?(_.p(v,P),P&1&&b(_,1)):(_=ga(v),_.c(),b(_,1),_.m(n.parentNode,n)):_&&(In(),w(_,1,1,()=>{_=null}),Dn())},i(v){s||(b(a),b(u),b(p),b(m),b(_),s=!0)},o(v){w(a),w(u),w(p),w(m),w(_),s=!1},d(v){a&&a.d(v),v&&l(e),u&&u.d(v),v&&l(t),p&&p.d(v),v&&l(r),m&&m.d(v),v&&l($),_&&_.d(v),v&&l(n)}}}function co(c,e,t){let{$$slots:r={},$$scope:$}=e;const n=Ba(r);return c.$$set=s=>{"$$scope"in s&&t(1,$=s.$$scope)},[n,$,r]}class Ce extends ve{constructor(e){super(),Ee(this,e,co,fo,be,{})}}function $o(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uo(c){let e;return{c(){e=i("Device Pool")},l(t){e=f(t,"Device Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function po(c){let e,t,r,$,n,s,a,u,p;return n=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[$o]},$$scope:{ctx:c}}}),a=new fe({props:{href:Ye().URL.documentation+"#"+L.DEVICE_POOL,$$slots:{default:[uo]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Intialize the Fillcan API."),r=d("br"),$=i(`
        Initializes `),I(n.$$.fragment),s=i(" and "),I(a.$$.fragment),u=i(`.
    `),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Intialize the Fillcan API."),r=g(_,"BR",{}),$=f(_,`
        Initializes `),S(n.$$.fragment,_),s=f(_," and "),S(a.$$.fragment,_),u=f(_,`.
    `),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function mo(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ho(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function go(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _o(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vo(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eo(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bo(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne;return y=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[mo]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[ho]},$$scope:{ctx:c}}}),W=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[go]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[_o]},$$scope:{ctx:c}}}),ie=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[vo]},$$scope:{ctx:c}}}),de=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[Eo]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=Y(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),P=Y(),R=d("li"),A=d("code"),T=i("requiredDeviceFeatures"),F=d("br"),B=i(`
            The features a `),I(y.$$.fragment),V=i(" should have for the purposes of the application."),x=d("br"),M=i(`
            This should be a `),I(O.$$.fragment),H=i("-structure where each required feature should be set to true."),k=Y(),N=d("li"),Q=d("code"),X=i("requiredDeviceExtensions"),Z=d("br"),K=i(`
            The extensions a `),I(W.$$.fragment),q=i(" should support for the purposes of the application."),U=d("br"),te=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(ee.$$.fragment),se=i(". To be able to use a "),I(ie.$$.fragment),ae=i(` this list should contain
            `),J=d("code"),pe=i("VK_KHR_SWAPCHAIN_EXTENSION_NAME"),Se=i(" ("),I(de.$$.fragment),me=i(" contains this by default)."),De=d("br"),_e=Y(),this.h()},l(le){e=g(le,"DIV",{slot:!0});var ge=E(e);t=g(ge,"LI",{});var we=E(t);r=g(we,"CODE",{});var Pe=E(r);$=f(Pe,"pApplicationName"),Pe.forEach(l),n=g(we,"BR",{}),s=f(we,`
            The name of the application.`),we.forEach(l),a=j(ge),u=g(ge,"LI",{});var Be=E(u);p=g(Be,"CODE",{});var Ie=E(p);m=f(Ie,"applicationVersion"),Ie.forEach(l),_=g(Be,"BR",{}),v=f(Be,`
            The version of the application.`),Be.forEach(l),P=j(ge),R=g(ge,"LI",{});var re=E(R);A=g(re,"CODE",{});var he=E(A);T=f(he,"requiredDeviceFeatures"),he.forEach(l),F=g(re,"BR",{}),B=f(re,`
            The features a `),S(y.$$.fragment,re),V=f(re," should have for the purposes of the application."),x=g(re,"BR",{}),M=f(re,`
            This should be a `),S(O.$$.fragment,re),H=f(re,"-structure where each required feature should be set to true."),re.forEach(l),k=j(ge),N=g(ge,"LI",{});var Le=E(N);Q=g(Le,"CODE",{});var Oe=E(Q);X=f(Oe,"requiredDeviceExtensions"),Oe.forEach(l),Z=g(Le,"BR",{}),K=f(Le,`
            The extensions a `),S(W.$$.fragment,Le),q=f(Le," should support for the purposes of the application."),U=g(Le,"BR",{}),te=f(Le,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(ee.$$.fragment,Le),se=f(Le,". To be able to use a "),S(ie.$$.fragment,Le),ae=f(Le,` this list should contain
            `),J=g(Le,"CODE",{});var oe=E(J);pe=f(oe,"VK_KHR_SWAPCHAIN_EXTENSION_NAME"),oe.forEach(l),Se=f(Le," ("),S(de.$$.fragment,Le),me=f(Le," contains this by default)."),De=g(Le,"BR",{}),Le.forEach(l),_e=j(ge),ge.forEach(l),this.h()},h(){z(e,"slot","params")},m(le,ge){h(le,e,ge),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B),D(y,R,null),o(R,V),o(R,x),o(R,M),D(O,R,null),o(R,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(N,U),o(N,te),D(ee,N,null),o(N,se),D(ie,N,null),o(N,ae),o(N,J),o(J,pe),o(N,Se),D(de,N,null),o(N,me),o(N,De),o(e,_e),ne=!0},p(le,ge){const we={};ge&1&&(we.$$scope={dirty:ge,ctx:le}),y.$set(we);const Pe={};ge&1&&(Pe.$$scope={dirty:ge,ctx:le}),O.$set(Pe);const Be={};ge&1&&(Be.$$scope={dirty:ge,ctx:le}),W.$set(Be);const Ie={};ge&1&&(Ie.$$scope={dirty:ge,ctx:le}),ee.$set(Ie);const re={};ge&1&&(re.$$scope={dirty:ge,ctx:le}),ie.$set(re);const he={};ge&1&&(he.$$scope={dirty:ge,ctx:le}),de.$set(he)},i(le){ne||(b(y.$$.fragment,le),b(O.$$.fragment,le),b(W.$$.fragment,le),b(ee.$$.fragment,le),b(ie.$$.fragment,le),b(de.$$.fragment,le),ne=!0)},o(le){w(y.$$.fragment,le),w(O.$$.fragment,le),w(W.$$.fragment,le),w(ee.$$.fragment,le),w(ie.$$.fragment,le),w(de.$$.fragment,le),ne=!1},d(le){le&&l(e),C(y),C(O),C(W),C(ee),C(ie),C(de)}}}function wo(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:`Fillcan(
        const char* pApplicationName, 
        uint32_t applicationVersion, 
        VkPhysicalDeviceFeatures requiredDeviceFeatures = {}, 
        std::vector<const char*> requiredDeviceExtensions = {}
);`}}),r=new Ce({props:{$$slots:{params:[bo],details:[po]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:'fillcan::Fillcan fillcan = fillcan::Fillcan("Example Application", 1.0);'}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class Io extends ve{constructor(e){super(),Ee(this,e,null,wo,be,{})}}function Do(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Co(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Do]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the supported "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the supported "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function So(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Po(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[So]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of all the "),I(r.$$.fragment),$=i(" that meet the requirements for the purposes of this implementation."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of all the "),S(r.$$.fragment,a),$=f(a," that meet the requirements for the purposes of this implementation."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ao(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<PhysicalDevice> getSupportedPhysicalDevices() const;"}}),r=new Ce({props:{$$slots:{return:[Po],details:[Co]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ro extends ve{constructor(e){super(),Ee(this,e,null,Ao,be,{})}}function Bo(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lo(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ko(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Bo]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Lo]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Select a "),I(r.$$.fragment),$=i(" by index to create a "),I(n.$$.fragment),s=i(` of.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Select a "),S(r.$$.fragment,p),$=f(p," by index to create a "),S(n.$$.fragment,p),s=f(p,` of.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function To(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vo(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[To]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i(`.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,`.
    `),a.forEach(l),this.h()},h(){z(e,"slot","returns")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Oo(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fo(c){let e;return{c(){e=i("getCurrentDevice")},l(t){e=f(t,"getCurrentDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yo(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:"LogicalDevice* selectDevice(unsigned int deviceIndex = 0);"}}),r=new Ce({props:{$$slots:{returns:[Vo],details:[ko]},$$scope:{ctx:c}}}),s=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Oo]},$$scope:{ctx:c}}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_getCurrentDevice,$$slots:{default:[Fo]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
If a device is selected, a pointer to the `),I(s.$$.fragment),a=i(` can also be retrieved using
`),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=j(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=f(_,`
If a device is selected, a pointer to the `),S(s.$$.fragment,_),a=f(_,` can also be retrieved using
`),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),s.$set(R);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),u.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class Mo extends ve{constructor(e){super(),Ee(this,e,null,yo,be,{})}}function xo(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function No(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uo(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[xo]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_selectDevice,$$slots:{default:[No]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the currently selected "),I(r.$$.fragment),$=i(" (selected with "),I(n.$$.fragment),s=i(")"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the currently selected "),S(r.$$.fragment,p),$=f(p," (selected with "),S(n.$$.fragment,p),s=f(p,")"),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Go(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ho(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Go]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the currently selected "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the currently selected "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qo(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"LogicalDevice* getCurrentDevice();"}}),r=new Ce({props:{$$slots:{return:[Ho],details:[Uo]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Wo extends ve{constructor(e){super(),Ee(this,e,null,qo,be,{})}}function Qo(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ko(c){let e,t,r,$;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Qo]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get the "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function zo(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yo(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[zo]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function jo(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Window* getWindow();"}}),r=new Ce({props:{$$slots:{return:[Yo],details:[Ko]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Xo extends ve{constructor(e){super(),Ee(this,e,null,jo,be,{})}}function Zo(c){let e;const t=c[2].default,r=xn(t,c,c[3],null);return{c(){r&&r.c()},l($){r&&r.l($)},m($,n){r&&r.m($,n),e=!0},p($,n){r&&r.p&&(!e||n&8)&&Fn(r,t,$,$[3],e?Mn(t,$[3],n,null):yn($[3]),null)},i($){e||(b(r,$),e=!0)},o($){w(r,$),e=!1},d($){r&&r.d($)}}}function Jo(c){let e,t;return e=new fe({props:{href:c[1].URL.documentation+"#"+c[0],$$slots:{default:[Zo]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment)},l(r){S(e.$$.fragment,r)},m(r,$){D(e,r,$),t=!0},p(r,[$]){const n={};$&3&&(n.href=r[1].URL.documentation+"#"+r[0]),$&8&&(n.$$scope={dirty:$,ctx:r}),e.$set(n)},i(r){t||(b(e.$$.fragment,r),t=!0)},o(r){w(e.$$.fragment,r),t=!1},d(r){C(e,r)}}}function el(c,e,t){let r;Sa(c,Cs,a=>t(1,r=a));let{$$slots:$={},$$scope:n}=e,{sectionID:s}=e;return c.$$set=a=>{"sectionID"in a&&t(0,s=a.sectionID),"$$scope"in a&&t(3,n=a.$$scope)},[s,r,$,n]}class G extends ve{constructor(e){super(),Ee(this,e,el,Jo,be,{sectionID:0})}}function tl(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rl(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nl(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sl(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function al(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ol(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return n=new fe({props:{href:"https://github.com/google/shaderc",$$slots:{default:[tl]},$$scope:{ctx:c}}}),P=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[rl]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[nl]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[sl]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[al]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a Shader Module object."),r=d("br"),$=i(`
        Uses `),I(n.$$.fragment),s=i(` to
        compile a file (defined by `),a=d("code"),u=i("shaderDirectory"),p=i(` and
        `),m=d("code"),_=i("shaderFileName"),v=i(") from "),I(P.$$.fragment),R=i(" to "),I(A.$$.fragment),T=i(`. Any resources the shader might need should be passed using the
        descriptor set layouts and the descriptor pool, both are `),I(F.$$.fragment),B=i(" which ownerships should be moved to the Shader Module using "),I(y.$$.fragment),V=i(`.
    `),this.h()},l(M){e=g(M,"SPAN",{slot:!0});var O=E(e);t=f(O,"Create a Shader Module object."),r=g(O,"BR",{}),$=f(O,`
        Uses `),S(n.$$.fragment,O),s=f(O,` to
        compile a file (defined by `),a=g(O,"CODE",{});var H=E(a);u=f(H,"shaderDirectory"),H.forEach(l),p=f(O,` and
        `),m=g(O,"CODE",{});var k=E(m);_=f(k,"shaderFileName"),k.forEach(l),v=f(O,") from "),S(P.$$.fragment,O),R=f(O," to "),S(A.$$.fragment,O),T=f(O,`. Any resources the shader might need should be passed using the
        descriptor set layouts and the descriptor pool, both are `),S(F.$$.fragment,O),B=f(O," which ownerships should be moved to the Shader Module using "),S(y.$$.fragment,O),V=f(O,`.
    `),O.forEach(l),this.h()},h(){z(e,"slot","details")},m(M,O){h(M,e,O),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(P,e,null),o(e,R),D(A,e,null),o(e,T),D(F,e,null),o(e,B),D(y,e,null),o(e,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),n.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),P.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),A.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),F.$set(Q);const X={};O&1&&(X.$$scope={dirty:O,ctx:M}),y.$set(X)},i(M){x||(b(n.$$.fragment,M),b(P.$$.fragment,M),b(A.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(n.$$.fragment,M),w(P.$$.fragment,M),w(A.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(n),C(P),C(A),C(F),C(y)}}}function ll(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function il(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fl(c){let e;return{c(){e=i("shaderc.h line 36 - 90")},l(t){e=f(t,"shaderc.h line 36 - 90")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cl(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $l(c){let e;return{c(){e=i("Descriptor Set Layouts")},l(t){e=f(t,"Descriptor Set Layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ul(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pl(c){let e;return{c(){e=i("DescriptorSetLayoutBuilder")},l(t){e=f(t,"DescriptorSetLayoutBuilder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ml(c){let e;return{c(){e=i("Descriptor Set Layouts")},l(t){e=f(t,"Descriptor Set Layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hl(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dl(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gl(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _l(c){let e;return{c(){e=i("DescriptorPoolBuilder")},l(t){e=f(t,"DescriptorPoolBuilder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vl(c){let e;return{c(){e=i("Descriptor Pools")},l(t){e=f(t,"Descriptor Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function El(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bl(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt;return a=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[ll]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[il]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://github.com/google/shaderc/blob/1bbf43f210941ba69a2cd05cf3529063f1ff5bb9/libshaderc/include/shaderc/shaderc.h#L36",target:"_blank",$$slots:{default:[fl]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[cl]},$$scope:{ctx:c}}}),U=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[$l]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[ul]},$$scope:{ctx:c}}}),ie=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[pl]},$$scope:{ctx:c}}}),J=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[ml]},$$scope:{ctx:c}}}),le=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_POOL,$$slots:{default:[hl]},$$scope:{ctx:c}}}),we=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_SET,$$slots:{default:[dl]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",$$slots:{default:[gl]},$$scope:{ctx:c}}}),re=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_POOL_BUILDER,$$slots:{default:[_l]},$$scope:{ctx:c}}}),Le=new fe({props:{href:Ye().URL.documentation+"#"+L.DESCRIPTOR_POOL,$$slots:{default:[vl]},$$scope:{ctx:c}}}),Ge=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[El]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("shaderDirectory"),n=d("br"),s=i(`
            The directory where the `),I(a.$$.fragment),u=i(" shader file is located."),p=Y(),m=d("li"),_=d("code"),v=i("shaderFileName"),P=d("br"),R=i(`
            The name of the `),I(A.$$.fragment),T=i(" shader file."),F=Y(),B=d("li"),y=d("code"),V=i("shaderKind"),x=d("br"),M=i(`
            The kind of shader (see `),I(O.$$.fragment),H=i(")"),k=Y(),N=d("li"),Q=d("code"),X=i("upDescriptorSetLayouts"),Z=d("br"),K=i(`
            A `),I(W.$$.fragment),q=i(" to a list of the "),I(U.$$.fragment),te=i(` describing the resources the shader should have access to. Please use
            `),I(ee.$$.fragment),se=i(" to transfer ownership. See "),I(ie.$$.fragment),ae=i(" for creating "),I(J.$$.fragment),pe=i("."),Se=Y(),de=d("li"),me=d("code"),De=i("upDescriptorPool"),_e=d("br"),ne=i(`
            A unique pointer to the `),I(le.$$.fragment),ge=i(" where the "),I(we.$$.fragment),Pe=i(` can be retrieved from. Please use
            `),I(Be.$$.fragment),Ie=i(" to transfer ownership. See "),I(re.$$.fragment),he=i(" for creating "),I(Le.$$.fragment),Oe=i("."),oe=Y(),ce=d("li"),Ae=d("code"),ye=i("preprocess"),Fe=d("br"),Ve=i(`
            Whether to preprocess the shader to validate the `),I(Ge.$$.fragment),He=i(" code. This will throw an exception if the shader failed to compile."),ze=Y(),xe=d("li"),Ne=d("code"),Te=i("optimize"),qe=d("br"),Ke=i(`
            Whether the optimize the shader.`),je=Y(),this.h()},l(Me){e=g(Me,"DIV",{slot:!0});var Ue=E(e);t=g(Ue,"LI",{});var $t=E(t);r=g($t,"CODE",{});var ut=E(r);$=f(ut,"shaderDirectory"),ut.forEach(l),n=g($t,"BR",{}),s=f($t,`
            The directory where the `),S(a.$$.fragment,$t),u=f($t," shader file is located."),$t.forEach(l),p=j(Ue),m=g(Ue,"LI",{});var ht=E(m);_=g(ht,"CODE",{});var Je=E(_);v=f(Je,"shaderFileName"),Je.forEach(l),P=g(ht,"BR",{}),R=f(ht,`
            The name of the `),S(A.$$.fragment,ht),T=f(ht," shader file."),ht.forEach(l),F=j(Ue),B=g(Ue,"LI",{});var dt=E(B);y=g(dt,"CODE",{});var et=E(y);V=f(et,"shaderKind"),et.forEach(l),x=g(dt,"BR",{}),M=f(dt,`
            The kind of shader (see `),S(O.$$.fragment,dt),H=f(dt,")"),dt.forEach(l),k=j(Ue),N=g(Ue,"LI",{});var Ze=E(N);Q=g(Ze,"CODE",{});var nt=E(Q);X=f(nt,"upDescriptorSetLayouts"),nt.forEach(l),Z=g(Ze,"BR",{}),K=f(Ze,`
            A `),S(W.$$.fragment,Ze),q=f(Ze," to a list of the "),S(U.$$.fragment,Ze),te=f(Ze,` describing the resources the shader should have access to. Please use
            `),S(ee.$$.fragment,Ze),se=f(Ze," to transfer ownership. See "),S(ie.$$.fragment,Ze),ae=f(Ze," for creating "),S(J.$$.fragment,Ze),pe=f(Ze,"."),Ze.forEach(l),Se=j(Ue),de=g(Ue,"LI",{});var Qe=E(de);me=g(Qe,"CODE",{});var ct=E(me);De=f(ct,"upDescriptorPool"),ct.forEach(l),_e=g(Qe,"BR",{}),ne=f(Qe,`
            A unique pointer to the `),S(le.$$.fragment,Qe),ge=f(Qe," where the "),S(we.$$.fragment,Qe),Pe=f(Qe,` can be retrieved from. Please use
            `),S(Be.$$.fragment,Qe),Ie=f(Qe," to transfer ownership. See "),S(re.$$.fragment,Qe),he=f(Qe," for creating "),S(Le.$$.fragment,Qe),Oe=f(Qe,"."),Qe.forEach(l),oe=j(Ue),ce=g(Ue,"LI",{});var st=E(ce);Ae=g(st,"CODE",{});var We=E(Ae);ye=f(We,"preprocess"),We.forEach(l),Fe=g(st,"BR",{}),Ve=f(st,`
            Whether to preprocess the shader to validate the `),S(Ge.$$.fragment,st),He=f(st," code. This will throw an exception if the shader failed to compile."),st.forEach(l),ze=j(Ue),xe=g(Ue,"LI",{});var at=E(xe);Ne=g(at,"CODE",{});var bt=E(Ne);Te=f(bt,"optimize"),bt.forEach(l),qe=g(at,"BR",{}),Ke=f(at,`
            Whether the optimize the shader.`),at.forEach(l),je=j(Ue),Ue.forEach(l),this.h()},h(){z(e,"slot","params")},m(Me,Ue){h(Me,e,Ue),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),D(U,N,null),o(N,te),D(ee,N,null),o(N,se),D(ie,N,null),o(N,ae),D(J,N,null),o(N,pe),o(e,Se),o(e,de),o(de,me),o(me,De),o(de,_e),o(de,ne),D(le,de,null),o(de,ge),D(we,de,null),o(de,Pe),D(Be,de,null),o(de,Ie),D(re,de,null),o(de,he),D(Le,de,null),o(de,Oe),o(e,oe),o(e,ce),o(ce,Ae),o(Ae,ye),o(ce,Fe),o(ce,Ve),D(Ge,ce,null),o(ce,He),o(e,ze),o(e,xe),o(xe,Ne),o(Ne,Te),o(xe,qe),o(xe,Ke),o(e,je),rt=!0},p(Me,Ue){const $t={};Ue&1&&($t.$$scope={dirty:Ue,ctx:Me}),a.$set($t);const ut={};Ue&1&&(ut.$$scope={dirty:Ue,ctx:Me}),A.$set(ut);const ht={};Ue&1&&(ht.$$scope={dirty:Ue,ctx:Me}),O.$set(ht);const Je={};Ue&1&&(Je.$$scope={dirty:Ue,ctx:Me}),W.$set(Je);const dt={};Ue&1&&(dt.$$scope={dirty:Ue,ctx:Me}),U.$set(dt);const et={};Ue&1&&(et.$$scope={dirty:Ue,ctx:Me}),ee.$set(et);const Ze={};Ue&1&&(Ze.$$scope={dirty:Ue,ctx:Me}),ie.$set(Ze);const nt={};Ue&1&&(nt.$$scope={dirty:Ue,ctx:Me}),J.$set(nt);const Qe={};Ue&1&&(Qe.$$scope={dirty:Ue,ctx:Me}),le.$set(Qe);const ct={};Ue&1&&(ct.$$scope={dirty:Ue,ctx:Me}),we.$set(ct);const st={};Ue&1&&(st.$$scope={dirty:Ue,ctx:Me}),Be.$set(st);const We={};Ue&1&&(We.$$scope={dirty:Ue,ctx:Me}),re.$set(We);const at={};Ue&1&&(at.$$scope={dirty:Ue,ctx:Me}),Le.$set(at);const bt={};Ue&1&&(bt.$$scope={dirty:Ue,ctx:Me}),Ge.$set(bt)},i(Me){rt||(b(a.$$.fragment,Me),b(A.$$.fragment,Me),b(O.$$.fragment,Me),b(W.$$.fragment,Me),b(U.$$.fragment,Me),b(ee.$$.fragment,Me),b(ie.$$.fragment,Me),b(J.$$.fragment,Me),b(le.$$.fragment,Me),b(we.$$.fragment,Me),b(Be.$$.fragment,Me),b(re.$$.fragment,Me),b(Le.$$.fragment,Me),b(Ge.$$.fragment,Me),rt=!0)},o(Me){w(a.$$.fragment,Me),w(A.$$.fragment,Me),w(O.$$.fragment,Me),w(W.$$.fragment,Me),w(U.$$.fragment,Me),w(ee.$$.fragment,Me),w(ie.$$.fragment,Me),w(J.$$.fragment,Me),w(le.$$.fragment,Me),w(we.$$.fragment,Me),w(Be.$$.fragment,Me),w(re.$$.fragment,Me),w(Le.$$.fragment,Me),w(Ge.$$.fragment,Me),rt=!1},d(Me){Me&&l(e),C(a),C(A),C(O),C(W),C(U),C(ee),C(ie),C(J),C(le),C(we),C(Be),C(re),C(Le),C(Ge)}}}function wl(c){let e;return{c(){e=i("Shader Module")},l(t){e=f(t,"Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Il(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[wl]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A unique pointer to the created "),I(r.$$.fragment),$=i(` (ownership will be transferred to the implementation).
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A unique pointer to the created "),S(r.$$.fragment,a),$=f(a,` (ownership will be transferred to the implementation).
    `),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Dl(c){let e;return{c(){e=i("Shader Module")},l(t){e=f(t,"Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cl(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[Dl]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Sl(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:`std::unique_ptr<ShaderModule> createShaderModule(
        const std::string shaderDirectory, 
        const std::string shaderFileName,
        shaderc_shader_kind shaderKind,
        std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
        std::unique_ptr<DescriptorPool> upDescriptorPool, 
        bool preprocess = true,
        bool optimize = false
);`}}),r=new Ce({props:{$$slots:{throws:[Cl],return:[Il],params:[bl],details:[ol]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`std::vector<std::unique_ptr<fillcan::DescriptorSetLayout>> upFragmentDescriptorSetLayouts = ...;
std::unique_ptr<fillcan::DescriptorPool> upFragmentDescriptorPool = ...;

std::unique_ptr<fillcan::ShaderModule> upVertexShaderModule =
    fillcan.createShaderModule(
        this->APP_DIR + "/shaders", 
        "shader.vert", 
        shaderc_vertex_shader, 
        {}, 
        nullptr, 
        true, 
        false
);

std::unique_ptr<fillcan::ShaderModule> upFragmentShaderModule =
    fillcan.createShaderModule(
        this->APP_DIR + "/shaders", 
        "shader.frag", 
        shaderc_fragment_shader,
        std::move(upFragmentDescriptorSetLayouts), 
        std::move(upFragmentDescriptorPool), 
        true, 
        false
);`}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class Pl extends ve{constructor(e){super(),Ee(this,e,null,Sl,be,{})}}function Al(c){let e,t;return{c(){e=d("code"),t=i("Fillcan")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"Fillcan"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Rl(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:"#include <fillcan/fillcan_graphics.hpp>"}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[Al]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
Vulkan is primarily a graphics API in the sense that most of Vulkan's functionality
is devoted to image generation and processing. Most Vulkan applications are designed
to display their results to the user. This is a process known as presentation. Because
the variety of platforms that Vulkan runs on is large and because not all applications
need to present the output to the user visually, the presentation is not a core part
of the API, but is handled by a series of extensions. `),r=d("br"),$=i(`
The `),n=d("code"),s=i("FillcanGraphics"),a=i(" class extends the "),I(u.$$.fragment),p=i(` class to enable these extensions and offer functionality exclusive to the graphics
portion of Vulkan.`)},l(_){S(e.$$.fragment,_),t=f(_,`
Vulkan is primarily a graphics API in the sense that most of Vulkan's functionality
is devoted to image generation and processing. Most Vulkan applications are designed
to display their results to the user. This is a process known as presentation. Because
the variety of platforms that Vulkan runs on is large and because not all applications
need to present the output to the user visually, the presentation is not a core part
of the API, but is handled by a series of extensions. `),r=g(_,"BR",{}),$=f(_,`
The `),n=g(_,"CODE",{});var v=E(n);s=f(v,"FillcanGraphics"),v.forEach(l),a=f(_," class extends the "),S(u.$$.fragment,_),p=f(_,` class to enable these extensions and offer functionality exclusive to the graphics
portion of Vulkan.`)},m(_,v){D(e,_,v),h(_,t,v),h(_,r,v),h(_,$,v),h(_,n,v),o(n,s),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(e.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),_&&l(r),_&&l($),_&&l(n),_&&l(a),C(u,_),_&&l(p)}}}class Bl extends ve{constructor(e){super(),Ee(this,e,null,Rl,be,{})}}function Ll(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kl(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tl(c){let e;return{c(){e=i("Device Pool")},l(t){e=f(t,"Device Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vl(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Ll]},$$scope:{ctx:c}}}),a=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[kl]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.DEVICE_POOL,$$slots:{default:[Tl]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Intialize the Fillcan Graphics API."),r=d("br"),$=i(`
        Initializes the `),I(n.$$.fragment),s=i(", "),I(a.$$.fragment),u=i(", and "),I(p.$$.fragment),m=i(`.
    `),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=f(P,"Intialize the Fillcan Graphics API."),r=g(P,"BR",{}),$=f(P,`
        Initializes the `),S(n.$$.fragment,P),s=f(P,", "),S(a.$$.fragment,P),u=f(P,", and "),S(p.$$.fragment,P),m=f(P,`.
    `),P.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,P){h(v,e,P),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),n.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),a.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:v}),p.$set(T)},i(v){_||(b(n.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(a),C(p)}}}function Ol(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fl(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yl(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ml(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xl(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nl(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ul(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gl(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye;return y=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Ol]},$$scope:{ctx:c}}}),Q=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Fl]},$$scope:{ctx:c}}}),ee=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[yl]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[Ml]},$$scope:{ctx:c}}}),le=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[xl]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[Nl]},$$scope:{ctx:c}}}),re=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Ul]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=Y(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),P=Y(),R=d("li"),A=d("code"),T=i("windowWidth"),F=d("br"),B=i(`
            The initial width the `),I(y.$$.fragment),V=i("."),x=Y(),M=d("li"),O=d("code"),H=i("windowHeight"),k=d("br"),N=i(`
            The initial height the `),I(Q.$$.fragment),X=i("."),Z=Y(),K=d("li"),W=d("code"),q=i("requiredDeviceFeatures"),U=d("br"),te=i(`
            The features a `),I(ee.$$.fragment),se=i(" should have for the purposes of the application."),ie=d("br"),ae=i(`
            This should be a `),I(J.$$.fragment),pe=i("-structure where each required feature should be set to true."),Se=Y(),de=d("li"),me=d("code"),De=i("requiredDeviceExtensions"),_e=d("br"),ne=i(`
            The extensions a `),I(le.$$.fragment),ge=i(" should enable for the purposes of the application."),we=d("br"),Pe=i(`
            This should be a list of strings containing the names of the extensions
            to enable. The available extensions can be retrieved using `),I(Be.$$.fragment),Ie=i(". To be able to use a "),I(re.$$.fragment),he=i(` this list should contain
            `),Le=d("code"),Oe=i("VK_KHR_SWAPCHAIN_EXTENSION_NAME"),oe=i(`, this is included by
            default.`),ce=d("br"),Ae=Y(),this.h()},l(Fe){e=g(Fe,"DIV",{slot:!0});var Ve=E(e);t=g(Ve,"LI",{});var Ge=E(t);r=g(Ge,"CODE",{});var He=E(r);$=f(He,"pApplicationName"),He.forEach(l),n=g(Ge,"BR",{}),s=f(Ge,`
            The name of the application.`),Ge.forEach(l),a=j(Ve),u=g(Ve,"LI",{});var ze=E(u);p=g(ze,"CODE",{});var xe=E(p);m=f(xe,"applicationVersion"),xe.forEach(l),_=g(ze,"BR",{}),v=f(ze,`
            The version of the application.`),ze.forEach(l),P=j(Ve),R=g(Ve,"LI",{});var Ne=E(R);A=g(Ne,"CODE",{});var Te=E(A);T=f(Te,"windowWidth"),Te.forEach(l),F=g(Ne,"BR",{}),B=f(Ne,`
            The initial width the `),S(y.$$.fragment,Ne),V=f(Ne,"."),Ne.forEach(l),x=j(Ve),M=g(Ve,"LI",{});var qe=E(M);O=g(qe,"CODE",{});var Ke=E(O);H=f(Ke,"windowHeight"),Ke.forEach(l),k=g(qe,"BR",{}),N=f(qe,`
            The initial height the `),S(Q.$$.fragment,qe),X=f(qe,"."),qe.forEach(l),Z=j(Ve),K=g(Ve,"LI",{});var je=E(K);W=g(je,"CODE",{});var rt=E(W);q=f(rt,"requiredDeviceFeatures"),rt.forEach(l),U=g(je,"BR",{}),te=f(je,`
            The features a `),S(ee.$$.fragment,je),se=f(je," should have for the purposes of the application."),ie=g(je,"BR",{}),ae=f(je,`
            This should be a `),S(J.$$.fragment,je),pe=f(je,"-structure where each required feature should be set to true."),je.forEach(l),Se=j(Ve),de=g(Ve,"LI",{});var Me=E(de);me=g(Me,"CODE",{});var Ue=E(me);De=f(Ue,"requiredDeviceExtensions"),Ue.forEach(l),_e=g(Me,"BR",{}),ne=f(Me,`
            The extensions a `),S(le.$$.fragment,Me),ge=f(Me," should enable for the purposes of the application."),we=g(Me,"BR",{}),Pe=f(Me,`
            This should be a list of strings containing the names of the extensions
            to enable. The available extensions can be retrieved using `),S(Be.$$.fragment,Me),Ie=f(Me,". To be able to use a "),S(re.$$.fragment,Me),he=f(Me,` this list should contain
            `),Le=g(Me,"CODE",{});var $t=E(Le);Oe=f($t,"VK_KHR_SWAPCHAIN_EXTENSION_NAME"),$t.forEach(l),oe=f(Me,`, this is included by
            default.`),ce=g(Me,"BR",{}),Me.forEach(l),Ae=j(Ve),Ve.forEach(l),this.h()},h(){z(e,"slot","params")},m(Fe,Ve){h(Fe,e,Ve),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B),D(y,R,null),o(R,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),D(ee,K,null),o(K,se),o(K,ie),o(K,ae),D(J,K,null),o(K,pe),o(e,Se),o(e,de),o(de,me),o(me,De),o(de,_e),o(de,ne),D(le,de,null),o(de,ge),o(de,we),o(de,Pe),D(Be,de,null),o(de,Ie),D(re,de,null),o(de,he),o(de,Le),o(Le,Oe),o(de,oe),o(de,ce),o(e,Ae),ye=!0},p(Fe,Ve){const Ge={};Ve&1&&(Ge.$$scope={dirty:Ve,ctx:Fe}),y.$set(Ge);const He={};Ve&1&&(He.$$scope={dirty:Ve,ctx:Fe}),Q.$set(He);const ze={};Ve&1&&(ze.$$scope={dirty:Ve,ctx:Fe}),ee.$set(ze);const xe={};Ve&1&&(xe.$$scope={dirty:Ve,ctx:Fe}),J.$set(xe);const Ne={};Ve&1&&(Ne.$$scope={dirty:Ve,ctx:Fe}),le.$set(Ne);const Te={};Ve&1&&(Te.$$scope={dirty:Ve,ctx:Fe}),Be.$set(Te);const qe={};Ve&1&&(qe.$$scope={dirty:Ve,ctx:Fe}),re.$set(qe)},i(Fe){ye||(b(y.$$.fragment,Fe),b(Q.$$.fragment,Fe),b(ee.$$.fragment,Fe),b(J.$$.fragment,Fe),b(le.$$.fragment,Fe),b(Be.$$.fragment,Fe),b(re.$$.fragment,Fe),ye=!0)},o(Fe){w(y.$$.fragment,Fe),w(Q.$$.fragment,Fe),w(ee.$$.fragment,Fe),w(J.$$.fragment,Fe),w(le.$$.fragment,Fe),w(Be.$$.fragment,Fe),w(re.$$.fragment,Fe),ye=!1},d(Fe){Fe&&l(e),C(y),C(Q),C(ee),C(J),C(le),C(Be),C(re)}}}function Hl(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:`FillcanGraphics(
        const char* pApplicationName, 
        uint32_t applicationVersion, 
        unsigned int windowWidth, 
        unsigned int windowHeight,
        VkPhysicalDeviceFeatures requiredDeviceFeatures = {},
        std::vector<const char*> requiredDeviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME}
);`}}),r=new Ce({props:{$$slots:{params:[Gl],details:[Vl]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`VkPhysicalDeviceFeatures requiredDeviceFeatures = {};
requiredDeviceFeatures.samplerAnisotropy = true;
fillcan::FillcanGraphics fillcan = fillcan::FillcanGraphics("Example Application", 800, 600, 1.0, requiredDeviceFeatures);`}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class ql extends ve{constructor(e){super(),Ee(this,e,null,Hl,be,{})}}function Wl(c){let e,t;return{c(){e=d("span"),t=i(`The main loop of the Fillcan Graphics API. The main loop of the Fillcan
        Graphics API gives access to a callback function with the deltaTime. The
        main loop calls this callback every frame.
    `),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`The main loop of the Fillcan Graphics API. The main loop of the Fillcan
        Graphics API gives access to a callback function with the deltaTime. The
        main loop calls this callback every frame.
    `),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Ql(c){let e,t,r,$,n,s,a;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("callback"),n=d("br"),s=i(`
            The callback with the deltaTime which will be called every frame.`),a=Y(),this.h()},l(u){e=g(u,"DIV",{slot:!0});var p=E(e);t=g(p,"LI",{});var m=E(t);r=g(m,"CODE",{});var _=E(r);$=f(_,"callback"),_.forEach(l),n=g(m,"BR",{}),s=f(m,`
            The callback with the deltaTime which will be called every frame.`),m.forEach(l),a=j(p),p.forEach(l),this.h()},h(){z(e,"slot","params")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Kl(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:"void mainLoop(std::function<void(double)> callback);"}}),r=new Ce({props:{$$slots:{params:[Ql],details:[Wl]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`{
    ...
    fillcan.mainLoop(std::bind(&App::update, this, std::placeholders::_1));
}

void App::update(double deltaTime) {
    // Called every frame
}`}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class zl extends ve{constructor(e){super(),Ee(this,e,null,Kl,be,{})}}function Yl(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jl(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Yl]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Xl(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zl(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jl(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ei(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ti(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Xl]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Zl]},$$scope:{ctx:c}}}),F=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Jl]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[ei]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("imageCount"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should have."),_=Y(),v=d("li"),P=d("code"),R=i("presentMode"),A=d("br"),T=i(`
            The present mode of the `),I(F.$$.fragment),B=i(". This should be member of the "),I(y.$$.fragment),V=i("-struct."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"imageCount"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            The amount of `),S(a.$$.fragment,H),u=f(H," the "),S(p.$$.fragment,H),m=f(H," should have."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"presentMode"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The present mode of the `),S(F.$$.fragment,N),B=f(N,". This should be member of the "),S(y.$$.fragment,N),V=f(N,"-struct."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function ri(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ni(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[ri]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function si(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ai(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[si]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function oi(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int createSwapchain(uint32_t imageCount = 3, VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR);"}}),r=new Ce({props:{$$slots:{throws:[ai],return:[ni],params:[ti],details:[jl]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class li extends ve{constructor(e){super(),Ee(this,e,null,oi,be,{})}}function ii(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[ii]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Recreate a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Recreate a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ci(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $i(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ui(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pi(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mi(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hi(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function di(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[ci]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[$i]},$$scope:{ctx:c}}}),F=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[ui]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[pi]},$$scope:{ctx:c}}}),Q=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[mi]},$$scope:{ctx:c}}}),Z=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[hi]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("imageCount"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" the recreated "),I(p.$$.fragment),m=i(" should have."),_=Y(),v=d("li"),P=d("code"),R=i("presentMode"),A=d("br"),T=i(`
            The present mode of the recreated `),I(F.$$.fragment),B=i(". This should be member of the "),I(y.$$.fragment),V=i("-struct"),x=Y(),M=d("li"),O=d("code"),H=i("index"),k=d("br"),N=i(`
            The index of the Swapchain returned by `),I(Q.$$.fragment),X=i(" or "),I(Z.$$.fragment),K=i(" to be recreated."),W=Y(),this.h()},l(U){e=g(U,"DIV",{slot:!0});var te=E(e);t=g(te,"LI",{});var ee=E(t);r=g(ee,"CODE",{});var se=E(r);$=f(se,"imageCount"),se.forEach(l),n=g(ee,"BR",{}),s=f(ee,`
            The amount of `),S(a.$$.fragment,ee),u=f(ee," the recreated "),S(p.$$.fragment,ee),m=f(ee," should have."),ee.forEach(l),_=j(te),v=g(te,"LI",{});var ie=E(v);P=g(ie,"CODE",{});var ae=E(P);R=f(ae,"presentMode"),ae.forEach(l),A=g(ie,"BR",{}),T=f(ie,`
            The present mode of the recreated `),S(F.$$.fragment,ie),B=f(ie,". This should be member of the "),S(y.$$.fragment,ie),V=f(ie,"-struct"),ie.forEach(l),x=j(te),M=g(te,"LI",{});var J=E(M);O=g(J,"CODE",{});var pe=E(O);H=f(pe,"index"),pe.forEach(l),k=g(J,"BR",{}),N=f(J,`
            The index of the Swapchain returned by `),S(Q.$$.fragment,J),X=f(J," or "),S(Z.$$.fragment,J),K=f(J," to be recreated."),J.forEach(l),W=j(te),te.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,te){h(U,e,te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),D(Z,M,null),o(M,K),o(e,W),q=!0},p(U,te){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:U}),a.$set(ee);const se={};te&1&&(se.$$scope={dirty:te,ctx:U}),p.$set(se);const ie={};te&1&&(ie.$$scope={dirty:te,ctx:U}),F.$set(ie);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:U}),y.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:U}),Q.$set(J);const pe={};te&1&&(pe.$$scope={dirty:te,ctx:U}),Z.$set(pe)},i(U){q||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(F.$$.fragment,U),b(y.$$.fragment,U),b(Q.$$.fragment,U),b(Z.$$.fragment,U),q=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(F.$$.fragment,U),w(y.$$.fragment,U),w(Q.$$.fragment,U),w(Z.$$.fragment,U),q=!1},d(U){U&&l(e),C(a),C(p),C(F),C(y),C(Q),C(Z)}}}function gi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _i(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[gi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the recreated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the recreated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ei(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[vi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be recreated.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be recreated.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function bi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[bi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Recreate a "),I(r.$$.fragment),$=i(" using it's original values."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Recreate a "),S(r.$$.fragment,a),$=f(a," using it's original values."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ii(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Di(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ci(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[Ii]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[Di]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the Swapchain returned by `),I(a.$$.fragment),u=i(" or "),I(p.$$.fragment),m=i(" to be recreated."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The index of the Swapchain returned by `),S(a.$$.fragment,R),u=f(R," or "),S(p.$$.fragment,R),m=f(R," to be recreated."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Si(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Si]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the recreated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The index of the recreated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ai(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ri(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Ai]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be recreated."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be recreated."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Bi(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"unsigned int recreateSwapchain(uint32_t imageCount, VkPresentModeKHR presentMode, unsigned int index = 0);"}}),r=new Ce({props:{$$slots:{throws:[Ei],return:[_i],params:[di],details:[fi]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:"unsigned int recreateSwapchain(unsigned int index = 0);"}}),u=new Ce({props:{$$slots:{throws:[Ri],return:[Pi],params:[Ci],details:[wi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Li extends ve{constructor(e){super(),Ee(this,e,null,Bi,be,{})}}function ki(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ti(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[ki]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a "),I(r.$$.fragment),$=i(" at a given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a "),S(r.$$.fragment,a),$=f(a," at a given index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Vi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oi(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fi(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yi(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Vi]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[Oi]},$$scope:{ctx:c}}}),_=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[Fi]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" returned by "),I(p.$$.fragment),m=i(" or "),I(_.$$.fragment),v=i(" to retrieve."),this.h()},l(R){e=g(R,"DIV",{slot:!0});var A=E(e);t=g(A,"LI",{});var T=E(t);r=g(T,"CODE",{});var F=E(r);$=f(F,"index"),F.forEach(l),n=g(T,"BR",{}),s=f(T,`
            The index of the `),S(a.$$.fragment,T),u=f(T," returned by "),S(p.$$.fragment,T),m=f(T," or "),S(_.$$.fragment,T),v=f(T," to retrieve."),T.forEach(l),A.forEach(l),this.h()},h(){z(e,"slot","params")},m(R,A){h(R,e,A),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),a.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),p.$set(F);const B={};A&1&&(B.$$scope={dirty:A,ctx:R}),_.$set(B)},i(R){P||(b(a.$$.fragment,R),b(p.$$.fragment,R),b(_.$$.fragment,R),P=!0)},o(R){w(a.$$.fragment,R),w(p.$$.fragment,R),w(_.$$.fragment,R),P=!1},d(R){R&&l(e),C(a),C(p),C(_)}}}function Mi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Mi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" at the given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," at the given index."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ni(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Swapchain* getSwapchain(unsigned int index = 0);"}}),r=new Ce({props:{$$slots:{return:[xi],params:[yi],details:[Ti]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ui extends ve{constructor(e){super(),Ee(this,e,null,Ni,be,{})}}function Gi(c){let e;return{c(){e=i("Swapchains")},l(t){e=f(t,"Swapchains")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hi(c){let e,t,r,$;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[Gi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get all the created "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function qi(c){let e;return{c(){e=i("Swapchains")},l(t){e=f(t,"Swapchains")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[qi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Qi(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<Swapchain*> getSwapchains();"}}),r=new Ce({props:{$$slots:{return:[Wi],details:[Hi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ki extends ve{constructor(e){super(),Ee(this,e,null,Qi,be,{})}}function zi(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yi(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[zi]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" at a given index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," at a given index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ji(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xi(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zi(c){let e;return{c(){e=i("recreateSwapchain")},l(t){e=f(t,"recreateSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ji(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.SWAPCHAIN,$$slots:{default:[ji]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[Xi]},$$scope:{ctx:c}}}),_=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS_recreateSwapchain,$$slots:{default:[Zi]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" returned by "),I(p.$$.fragment),m=i(" or "),I(_.$$.fragment),v=i(" to destroy."),this.h()},l(R){e=g(R,"DIV",{slot:!0});var A=E(e);t=g(A,"LI",{});var T=E(t);r=g(T,"CODE",{});var F=E(r);$=f(F,"index"),F.forEach(l),n=g(T,"BR",{}),s=f(T,`
            The index of the `),S(a.$$.fragment,T),u=f(T," returned by "),S(p.$$.fragment,T),m=f(T," or "),S(_.$$.fragment,T),v=f(T," to destroy."),T.forEach(l),A.forEach(l),this.h()},h(){z(e,"slot","params")},m(R,A){h(R,e,A),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),a.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),p.$set(F);const B={};A&1&&(B.$$scope={dirty:A,ctx:R}),_.$set(B)},i(R){P||(b(a.$$.fragment,R),b(p.$$.fragment,R),b(_.$$.fragment,R),P=!0)},o(R){w(a.$$.fragment,R),w(p.$$.fragment,R),w(_.$$.fragment,R),P=!1},d(R){R&&l(e),C(a),C(p),C(_)}}}function ef(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroySwapchain(unsigned int index = 0);"}}),r=new Ce({props:{$$slots:{params:[Ji],details:[Yi]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tf extends ve{constructor(e){super(),Ee(this,e,null,ef,be,{})}}function rf(c){let e;return{c(){e=i("Asset Manager")},l(t){e=f(t,"Asset Manager")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nf(c){let e,t,r,$;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.ASSET_MANAGER,$$slots:{default:[rf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Get the "),S(r.$$.fragment,s),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),D(r,e,null),$=!0},p(n,s){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(r.$$.fragment,n),$=!0)},o(n){w(r.$$.fragment,n),$=!1},d(n){n&&l(e),C(r)}}}function sf(c){let e;return{c(){e=i("Asset Manager")},l(t){e=f(t,"Asset Manager")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function af(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.ASSET_MANAGER,$$slots:{default:[sf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function of(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"AssetManager* getAssetManager();"}}),r=new Ce({props:{$$slots:{return:[af],details:[nf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class lf extends ve{constructor(e){super(),Ee(this,e,null,of,be,{})}}function ff(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cf(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $f(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:"#include <fillcan/window.hpp>"}}),s=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[ff]},$$scope:{ctx:c}}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[cf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Window"),n=i(" class is used by "),I(s.$$.fragment),a=i(" for presentation. The Window is instantiated automatically by "),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=f(_,`
The `),r=g(_,"CODE",{});var v=E(r);$=f(v,"Window"),v.forEach(l),n=f(_," class is used by "),S(s.$$.fragment,_),a=f(_," for presentation. The Window is instantiated automatically by "),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),h(_,r,v),o(r,$),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),s.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(e.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),_&&l(r),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class uf extends ve{constructor(e){super(),Ee(this,e,null,$f,be,{})}}function pf(c){let e;return{c(){e=i("GLFW")},l(t){e=f(t,"GLFW")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mf(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://www.glfw.org/",target:"_blank",$$slots:{default:[pf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Window."),r=d("br"),$=i(`
        Creates a new `),I(n.$$.fragment),s=i(" Window."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Window."),r=g(p,"BR",{}),$=f(p,`
        Creates a new `),S(n.$$.fragment,p),s=f(p," Window."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function hf(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("width"),n=d("br"),s=i(`
            The initial width of the Window.`),a=Y(),u=d("li"),p=d("code"),m=i("height"),_=d("br"),v=i(`
            The initial height of the Window.`),P=Y(),R=d("li"),A=d("code"),T=i("name"),F=d("br"),B=i(`
            The name of the Window.`),this.h()},l(y){e=g(y,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var x=E(t);r=g(x,"CODE",{});var M=E(r);$=f(M,"width"),M.forEach(l),n=g(x,"BR",{}),s=f(x,`
            The initial width of the Window.`),x.forEach(l),a=j(V),u=g(V,"LI",{});var O=E(u);p=g(O,"CODE",{});var H=E(p);m=f(H,"height"),H.forEach(l),_=g(O,"BR",{}),v=f(O,`
            The initial height of the Window.`),O.forEach(l),P=j(V),R=g(V,"LI",{});var k=E(R);A=g(k,"CODE",{});var N=E(A);T=f(N,"name"),N.forEach(l),F=g(k,"BR",{}),B=f(k,`
            The name of the Window.`),k.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(y,V){h(y,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B)},p:ke,d(y){y&&l(e)}}}function df(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Window(unsigned int width, unsigned int height, std::string name);"}}),r=new Ce({props:{$$slots:{params:[hf],details:[mf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gf extends ve{constructor(e){super(),Ee(this,e,null,df,be,{})}}function _f(c){let e,t;return{c(){e=d("span"),t=i("Whether the Window should close, e.g. the user attempts to close it."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Whether the Window should close, e.g. the user attempts to close it."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function vf(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the Window should close. "),n=d("code"),s=i("false"),a=i(" if the Window shouldn't close."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the Window should close. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Window shouldn't close."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Ef(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool shouldClose();"}}),r=new Ce({props:{$$slots:{return:[vf],details:[_f]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bf extends ve{constructor(e){super(),Ee(this,e,null,Ef,be,{})}}function wf(c){let e,t;return{c(){e=d("span"),t=i("Whether the Window was resized."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Whether the Window was resized."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function If(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the Window was resized. "),n=d("code"),s=i("false"),a=i(" if the Window wasn't resized."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the Window was resized. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Window wasn't resized."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Df(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool wasResized();"}}),r=new Ce({props:{$$slots:{return:[If],details:[wf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cf extends ve{constructor(e){super(),Ee(this,e,null,Df,be,{})}}function Sf(c){let e,t;return{c(){e=d("span"),t=i(`Poll for events, e.g. close button pressed, window resized or other user
        interaction.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Poll for events, e.g. close button pressed, window resized or other user
        interaction.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Pf(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void pollEvents();"}}),r=new Ce({props:{$$slots:{details:[Sf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Af extends ve{constructor(e){super(),Ee(this,e,null,Pf,be,{})}}function Rf(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bf(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[Rf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Get a list of required extensions that should be enabled by Vulkan. The
        available extensions can be retrieved using `),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`Get a list of required extensions that should be enabled by Vulkan. The
        available extensions can be retrieved using `),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Lf(c){let e,t;return{c(){e=d("span"),t=i("A list of the required extensions."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required extensions."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function kf(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<const char*> getRequiredExtensions();"}}),r=new Ce({props:{$$slots:{return:[Lf],details:[Bf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Tf extends ve{constructor(e){super(),Ee(this,e,null,kf,be,{})}}function Vf(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Of(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ff(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[Vf]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[Of]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i(" using the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a "),S(r.$$.fragment,p),$=f(p," using the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function yf(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mf(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[yf]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pInstance"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to create a surface in."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pInstance"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to create a surface in."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function xf(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the surface failed to be created."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the surface failed to be created."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function Nf(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void createSurface(Instance* pInstance);"}}),r=new Ce({props:{$$slots:{throws:[xf],params:[Mf],details:[Ff]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Uf extends ve{constructor(e){super(),Ee(this,e,null,Nf,be,{})}}function Gf(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hf(c){let e;return{c(){e=i("createSurface")},l(t){e=f(t,"createSurface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qf(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[Gf]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW_createSurface,$$slots:{default:[Hf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" created with "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the "),S(r.$$.fragment,p),$=f(p," created with "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Wf(c){let e;return{c(){e=i("Vulkan Surface")},l(t){e=f(t,"Vulkan Surface")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qf(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html",target:"_blank",$$slots:{default:[Wf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A handle to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A handle to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Kf(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSurfaceKHR getSurface();"}}),r=new Ce({props:{$$slots:{return:[Qf],details:[qf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zf extends ve{constructor(e){super(),Ee(this,e,null,Kf,be,{})}}function Yf(c){let e;return{c(){e=i("Extent")},l(t){e=f(t,"Extent")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jf(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[Yf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" of the Window."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," of the Window."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Xf(c){let e;return{c(){e=i("Extent")},l(t){e=f(t,"Extent")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zf(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[Xf]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(" of the Window."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The "),S(r.$$.fragment,a),$=f(a," of the Window."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Jf(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkExtent2D getExtent();"}}),r=new Ce({props:{$$slots:{return:[Zf],details:[jf]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ec extends ve{constructor(e){super(),Ee(this,e,null,Jf,be,{})}}function tc(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rc(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nc(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return e=new $e({props:{language:ue,code:"#include <fillcan/instance/instance.hpp>"}}),A=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[tc]},$$scope:{ctx:c}}}),F=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[rc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Instance"),n=i(` class is the connection between the application and
the Vulkan library and to create it some details of the application need to be
specified to the driver.`),s=d("br"),a=i(`
The instance contains information such as an application name, name and version of
the engine used to create the application, and enabled instance-level extensions
and layers.`),u=d("br"),p=i(`
Vulkan can be seen as a subsystem of the application. Once the application is linked
to the Vulkan libraries and initialized, a certain state is tracked. Vulkan does
not introduce a global state in the application, so all tracked state must be stored
in an object that the application provides, the `),m=d("code"),_=i("Instance"),v=i(" class."),P=d("br"),R=i(`
The Instance is instantiated automatically by `),I(A.$$.fragment),T=i(" and "),I(F.$$.fragment),B=i(".")},l(V){S(e.$$.fragment,V),t=f(V,`
The `),r=g(V,"CODE",{});var x=E(r);$=f(x,"Instance"),x.forEach(l),n=f(V,` class is the connection between the application and
the Vulkan library and to create it some details of the application need to be
specified to the driver.`),s=g(V,"BR",{}),a=f(V,`
The instance contains information such as an application name, name and version of
the engine used to create the application, and enabled instance-level extensions
and layers.`),u=g(V,"BR",{}),p=f(V,`
Vulkan can be seen as a subsystem of the application. Once the application is linked
to the Vulkan libraries and initialized, a certain state is tracked. Vulkan does
not introduce a global state in the application, so all tracked state must be stored
in an object that the application provides, the `),m=g(V,"CODE",{});var M=E(m);_=f(M,"Instance"),M.forEach(l),v=f(V," class."),P=g(V,"BR",{}),R=f(V,`
The Instance is instantiated automatically by `),S(A.$$.fragment,V),T=f(V," and "),S(F.$$.fragment,V),B=f(V,".")},m(V,x){D(e,V,x),h(V,t,x),h(V,r,x),o(r,$),h(V,n,x),h(V,s,x),h(V,a,x),h(V,u,x),h(V,p,x),h(V,m,x),o(m,_),h(V,v,x),h(V,P,x),h(V,R,x),D(A,V,x),h(V,T,x),D(F,V,x),h(V,B,x),y=!0},p(V,[x]){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),A.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),F.$set(O)},i(V){y||(b(e.$$.fragment,V),b(A.$$.fragment,V),b(F.$$.fragment,V),y=!0)},o(V){w(e.$$.fragment,V),w(A.$$.fragment,V),w(F.$$.fragment,V),y=!1},d(V){C(e,V),V&&l(t),V&&l(r),V&&l(n),V&&l(s),V&&l(a),V&&l(u),V&&l(p),V&&l(m),V&&l(v),V&&l(P),V&&l(R),C(A,V),V&&l(T),C(F,V),V&&l(B)}}}class sc extends ve{constructor(e){super(),Ee(this,e,null,nc,be,{})}}function ac(c){let e,t;return{c(){e=d("span"),t=i("Create a new Instance."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Instance."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function oc(c){let e;return{c(){e=i("vkEnumerateInstanceLayerProperties")},l(t){e=f(t,"vkEnumerateInstanceLayerProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lc(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ic(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fc(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cc(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $c(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uc(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be;return y=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html",target:"_blank",$$slots:{default:[oc]},$$scope:{ctx:c}}}),k=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[lc]},$$scope:{ctx:c}}}),Q=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[ic]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[fc]},$$scope:{ctx:c}}}),De=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[cc]},$$scope:{ctx:c}}}),ne=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[$c]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pApplicationName"),n=d("br"),s=i(`
            The name of the application.`),a=Y(),u=d("li"),p=d("code"),m=i("applicationVersion"),_=d("br"),v=i(`
            The version of the application.`),P=Y(),R=d("li"),A=d("code"),T=i("requiredLayers"),F=d("br"),B=i(`
            The Instance layers that should be enabled. To get a list of supported
            layers the function `),I(y.$$.fragment),V=i(" can be called."),x=d("br"),M=i(`
            Layers are used to intercept the Vulkan API and provide logging, profiling,
            debugging, and other additional features.`),O=d("br"),H=Y(),I(k.$$.fragment),N=i(" and "),I(Q.$$.fragment),X=i(" will enable the layer "),Z=d("code"),K=i("VK_LAYER_KHRONOS_validation"),W=i(` when
            the application is running in Debug mode.`),q=Y(),U=d("li"),te=d("code"),ee=i("requiredExtensions"),se=d("br"),ie=i(`
            The Instance extensions that should be enabled. To get a list of supported
            extensions the function `),I(ae.$$.fragment),J=i(" can be called."),pe=d("br"),Se=i(`
            Vulkan requires applications to sign up for extensions and enable them
            explicitly. This allows drivers to disable extensions that are not in
            use and makes it more difficult for applications to accidentally use
            functionality that is part of an extension that they had no intention
            of enabling.
            `),de=d("br"),me=Y(),I(De.$$.fragment),_e=i(" and "),I(ne.$$.fragment),le=i(` will enable the extension
            `),ge=d("code"),we=i("VK_EXT_DEBUG_UTILS_EXTENSION_NAME"),Pe=i(` when the application is
            running in Debug mode.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Le=E(r);$=f(Le,"pApplicationName"),Le.forEach(l),n=g(he,"BR",{}),s=f(he,`
            The name of the application.`),he.forEach(l),a=j(re),u=g(re,"LI",{});var Oe=E(u);p=g(Oe,"CODE",{});var oe=E(p);m=f(oe,"applicationVersion"),oe.forEach(l),_=g(Oe,"BR",{}),v=f(Oe,`
            The version of the application.`),Oe.forEach(l),P=j(re),R=g(re,"LI",{});var ce=E(R);A=g(ce,"CODE",{});var Ae=E(A);T=f(Ae,"requiredLayers"),Ae.forEach(l),F=g(ce,"BR",{}),B=f(ce,`
            The Instance layers that should be enabled. To get a list of supported
            layers the function `),S(y.$$.fragment,ce),V=f(ce," can be called."),x=g(ce,"BR",{}),M=f(ce,`
            Layers are used to intercept the Vulkan API and provide logging, profiling,
            debugging, and other additional features.`),O=g(ce,"BR",{}),H=j(ce),S(k.$$.fragment,ce),N=f(ce," and "),S(Q.$$.fragment,ce),X=f(ce," will enable the layer "),Z=g(ce,"CODE",{});var ye=E(Z);K=f(ye,"VK_LAYER_KHRONOS_validation"),ye.forEach(l),W=f(ce,` when
            the application is running in Debug mode.`),ce.forEach(l),q=j(re),U=g(re,"LI",{});var Fe=E(U);te=g(Fe,"CODE",{});var Ve=E(te);ee=f(Ve,"requiredExtensions"),Ve.forEach(l),se=g(Fe,"BR",{}),ie=f(Fe,`
            The Instance extensions that should be enabled. To get a list of supported
            extensions the function `),S(ae.$$.fragment,Fe),J=f(Fe," can be called."),pe=g(Fe,"BR",{}),Se=f(Fe,`
            Vulkan requires applications to sign up for extensions and enable them
            explicitly. This allows drivers to disable extensions that are not in
            use and makes it more difficult for applications to accidentally use
            functionality that is part of an extension that they had no intention
            of enabling.
            `),de=g(Fe,"BR",{}),me=j(Fe),S(De.$$.fragment,Fe),_e=f(Fe," and "),S(ne.$$.fragment,Fe),le=f(Fe,` will enable the extension
            `),ge=g(Fe,"CODE",{});var Ge=E(ge);we=f(Ge,"VK_EXT_DEBUG_UTILS_EXTENSION_NAME"),Ge.forEach(l),Pe=f(Fe,` when the application is
            running in Debug mode.`),Fe.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B),D(y,R,null),o(R,V),o(R,x),o(R,M),o(R,O),o(R,H),D(k,R,null),o(R,N),D(Q,R,null),o(R,X),o(R,Z),o(Z,K),o(R,W),o(e,q),o(e,U),o(U,te),o(te,ee),o(U,se),o(U,ie),D(ae,U,null),o(U,J),o(U,pe),o(U,Se),o(U,de),o(U,me),D(De,U,null),o(U,_e),D(ne,U,null),o(U,le),o(U,ge),o(ge,we),o(U,Pe),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),y.$set(he);const Le={};re&1&&(Le.$$scope={dirty:re,ctx:Ie}),k.$set(Le);const Oe={};re&1&&(Oe.$$scope={dirty:re,ctx:Ie}),Q.$set(Oe);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),ae.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),De.$set(ce);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),ne.$set(Ae)},i(Ie){Be||(b(y.$$.fragment,Ie),b(k.$$.fragment,Ie),b(Q.$$.fragment,Ie),b(ae.$$.fragment,Ie),b(De.$$.fragment,Ie),b(ne.$$.fragment,Ie),Be=!0)},o(Ie){w(y.$$.fragment,Ie),w(k.$$.fragment,Ie),w(Q.$$.fragment,Ie),w(ae.$$.fragment,Ie),w(De.$$.fragment,Ie),w(ne.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(y),C(k),C(Q),C(ae),C(De),C(ne)}}}function pc(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mc(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[pc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        throws `),p=d("code"),m=i("std::runtime_error"),_=i(` aswell when running in DEBUG mode
        and the debug messenger couldn't be created.`),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R," couldn't be created."),a=g(R,"BR",{}),u=f(R,`
        throws `),p=g(R,"CODE",{});var T=E(p);m=f(T,"std::runtime_error"),T.forEach(l),_=f(R,` aswell when running in DEBUG mode
        and the debug messenger couldn't be created.`),R.forEach(l),this.h()},h(){z(e,"slot","throws")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),o(p,m),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A)},i(P){v||(b(n.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),v=!1},d(P){P&&l(e),C(n)}}}function hc(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Instance(
        std::string pApplicationName, 
        unsigned int applicationVersion, 
        std::vector<const char*> requiredLayers,
        std::vector<const char*> requiredExtensions
);`}}),r=new Ce({props:{$$slots:{throws:[mc],params:[uc],details:[ac]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dc extends ve{constructor(e){super(),Ee(this,e,null,hc,be,{})}}function gc(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _c(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[gc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vc(c){let e;return{c(){e=i("Vulkan Instance")},l(t){e=f(t,"Vulkan Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ec(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html",target:"_blank",$$slots:{default:[vc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bc(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkInstance getInstanceHandle() const;"}}),r=new Ce({props:{$$slots:{return:[Ec],details:[_c]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wc extends ve{constructor(e){super(),Ee(this,e,null,bc,be,{})}}function Ic(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dc(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pc(c){let e;return{c(){e=i("Logical Devices")},l(t){e=f(t,"Logical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ac(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rc(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bc(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return e=new $e({props:{language:ue,code:"#include <fillcan/instance/device_pool.hpp>"}}),s=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[Ic]},$$scope:{ctx:c}}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Dc]},$$scope:{ctx:c}}}),m=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Cc]},$$scope:{ctx:c}}}),R=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Sc]},$$scope:{ctx:c}}}),T=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[Pc]},$$scope:{ctx:c}}}),V=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN,$$slots:{default:[Ac]},$$scope:{ctx:c}}}),M=new fe({props:{href:Ye().URL.documentation+"#"+L.FILLCAN_GRAPHICS,$$slots:{default:[Rc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("DevicePool"),n=i(" class takes in information about the "),I(s.$$.fragment),a=i(", "),I(u.$$.fragment),p=i(`, required device extensions and required device features and uses that
information to prepare a list of `),I(m.$$.fragment),_=i(" that meet the stated requirements."),v=d("br"),P=i(`
These `),I(R.$$.fragment),A=i(" can be then be turned into "),I(T.$$.fragment),F=i(" at the request of the application."),B=d("br"),y=i(`
The Device Pool is instantiated automatically by `),I(V.$$.fragment),x=i(" and "),I(M.$$.fragment),O=i(".")},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"DevicePool"),N.forEach(l),n=f(k," class takes in information about the "),S(s.$$.fragment,k),a=f(k,", "),S(u.$$.fragment,k),p=f(k,`, required device extensions and required device features and uses that
information to prepare a list of `),S(m.$$.fragment,k),_=f(k," that meet the stated requirements."),v=g(k,"BR",{}),P=f(k,`
These `),S(R.$$.fragment,k),A=f(k," can be then be turned into "),S(T.$$.fragment,k),F=f(k," at the request of the application."),B=g(k,"BR",{}),y=f(k,`
The Device Pool is instantiated automatically by `),S(V.$$.fragment,k),x=f(k," and "),S(M.$$.fragment,k),O=f(k,".")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),D(m,k,N),h(k,_,N),h(k,v,N),h(k,P,N),D(R,k,N),h(k,A,N),D(T,k,N),h(k,F,N),h(k,B,N),h(k,y,N),D(V,k,N),h(k,x,N),D(M,k,N),h(k,O,N),H=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),m.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),R.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),T.$set(W);const q={};N&1&&(q.$$scope={dirty:N,ctx:k}),V.$set(q);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),M.$set(U)},i(k){H||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(m.$$.fragment,k),b(R.$$.fragment,k),b(T.$$.fragment,k),b(V.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(m.$$.fragment,k),w(R.$$.fragment,k),w(T.$$.fragment,k),w(V.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),C(m,k),k&&l(_),k&&l(v),k&&l(P),C(R,k),k&&l(A),C(T,k),k&&l(F),k&&l(B),k&&l(y),C(V,k),k&&l(x),C(M,k),k&&l(O)}}}class Lc extends ve{constructor(e){super(),Ee(this,e,null,Bc,be,{})}}function kc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tc(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[kc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Device Pool."),r=d("br"),$=i(`
        Initializes a list of `),I(n.$$.fragment),s=i(" that are supported for the purposes of the implementation."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Device Pool."),r=g(p,"BR",{}),$=f(p,`
        Initializes a list of `),S(n.$$.fragment,p),s=f(p," that are supported for the purposes of the implementation."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Vc(c){let e;return{c(){e=i("Instance")},l(t){e=f(t,"Instance")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fc(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yc(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mc(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xc(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nc(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uc(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gc(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hc(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.INSTANCE,$$slots:{default:[Vc]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Oc]},$$scope:{ctx:c}}}),V=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[Fc]},$$scope:{ctx:c}}}),M=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[yc]},$$scope:{ctx:c}}}),N=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Mc]},$$scope:{ctx:c}}}),te=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[xc]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[Nc]},$$scope:{ctx:c}}}),ne=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Uc]},$$scope:{ctx:c}}}),Pe=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[Gc]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pInstance"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" with which the "),I(p.$$.fragment),m=i(" should be enumerated."),_=Y(),v=d("li"),P=d("code"),R=i("pWindow"),A=d("br"),T=i(`
            If not `),F=d("code"),B=i("nullptr"),y=i(", a pointer to the "),I(V.$$.fragment),x=i(` with which the support for presentation will be determined for the
            `),I(M.$$.fragment),O=i("."),H=d("br"),k=i(`
            Support for presentation- and graphics operations for the `),I(N.$$.fragment),Q=i(" will be ensured as well."),X=Y(),Z=d("li"),K=d("code"),W=i("requiredDeviceFeatures"),q=d("br"),U=i(`
            The features a `),I(te.$$.fragment),ee=i(" should have for the purposes of the application."),se=d("br"),ie=i(`
            This should be a `),I(ae.$$.fragment),J=i("-structure where each required feature should be set to true."),pe=Y(),Se=d("li"),de=d("code"),me=i("requiredDeviceExtensions"),De=d("br"),_e=i(`
            The extensions a `),I(ne.$$.fragment),le=i(" should support for the purposes of the application."),ge=d("br"),we=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(Pe.$$.fragment),Be=i("."),this.h()},l(re){e=g(re,"DIV",{slot:!0});var he=E(e);t=g(he,"LI",{});var Le=E(t);r=g(Le,"CODE",{});var Oe=E(r);$=f(Oe,"pInstance"),Oe.forEach(l),n=g(Le,"BR",{}),s=f(Le,`
            A pointer to the `),S(a.$$.fragment,Le),u=f(Le," with which the "),S(p.$$.fragment,Le),m=f(Le," should be enumerated."),Le.forEach(l),_=j(he),v=g(he,"LI",{});var oe=E(v);P=g(oe,"CODE",{});var ce=E(P);R=f(ce,"pWindow"),ce.forEach(l),A=g(oe,"BR",{}),T=f(oe,`
            If not `),F=g(oe,"CODE",{});var Ae=E(F);B=f(Ae,"nullptr"),Ae.forEach(l),y=f(oe,", a pointer to the "),S(V.$$.fragment,oe),x=f(oe,` with which the support for presentation will be determined for the
            `),S(M.$$.fragment,oe),O=f(oe,"."),H=g(oe,"BR",{}),k=f(oe,`
            Support for presentation- and graphics operations for the `),S(N.$$.fragment,oe),Q=f(oe," will be ensured as well."),oe.forEach(l),X=j(he),Z=g(he,"LI",{});var ye=E(Z);K=g(ye,"CODE",{});var Fe=E(K);W=f(Fe,"requiredDeviceFeatures"),Fe.forEach(l),q=g(ye,"BR",{}),U=f(ye,`
            The features a `),S(te.$$.fragment,ye),ee=f(ye," should have for the purposes of the application."),se=g(ye,"BR",{}),ie=f(ye,`
            This should be a `),S(ae.$$.fragment,ye),J=f(ye,"-structure where each required feature should be set to true."),ye.forEach(l),pe=j(he),Se=g(he,"LI",{});var Ve=E(Se);de=g(Ve,"CODE",{});var Ge=E(de);me=f(Ge,"requiredDeviceExtensions"),Ge.forEach(l),De=g(Ve,"BR",{}),_e=f(Ve,`
            The extensions a `),S(ne.$$.fragment,Ve),le=f(Ve," should support for the purposes of the application."),ge=g(Ve,"BR",{}),we=f(Ve,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(Pe.$$.fragment,Ve),Be=f(Ve,"."),Ve.forEach(l),he.forEach(l),this.h()},h(){z(e,"slot","params")},m(re,he){h(re,e,he),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),o(v,F),o(F,B),o(v,y),D(V,v,null),o(v,x),D(M,v,null),o(v,O),o(v,H),o(v,k),D(N,v,null),o(v,Q),o(e,X),o(e,Z),o(Z,K),o(K,W),o(Z,q),o(Z,U),D(te,Z,null),o(Z,ee),o(Z,se),o(Z,ie),D(ae,Z,null),o(Z,J),o(e,pe),o(e,Se),o(Se,de),o(de,me),o(Se,De),o(Se,_e),D(ne,Se,null),o(Se,le),o(Se,ge),o(Se,we),D(Pe,Se,null),o(Se,Be),Ie=!0},p(re,he){const Le={};he&1&&(Le.$$scope={dirty:he,ctx:re}),a.$set(Le);const Oe={};he&1&&(Oe.$$scope={dirty:he,ctx:re}),p.$set(Oe);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),V.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),M.$set(ce);const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),N.$set(Ae);const ye={};he&1&&(ye.$$scope={dirty:he,ctx:re}),te.$set(ye);const Fe={};he&1&&(Fe.$$scope={dirty:he,ctx:re}),ae.$set(Fe);const Ve={};he&1&&(Ve.$$scope={dirty:he,ctx:re}),ne.$set(Ve);const Ge={};he&1&&(Ge.$$scope={dirty:he,ctx:re}),Pe.$set(Ge)},i(re){Ie||(b(a.$$.fragment,re),b(p.$$.fragment,re),b(V.$$.fragment,re),b(M.$$.fragment,re),b(N.$$.fragment,re),b(te.$$.fragment,re),b(ae.$$.fragment,re),b(ne.$$.fragment,re),b(Pe.$$.fragment,re),Ie=!0)},o(re){w(a.$$.fragment,re),w(p.$$.fragment,re),w(V.$$.fragment,re),w(M.$$.fragment,re),w(N.$$.fragment,re),w(te.$$.fragment,re),w(ae.$$.fragment,re),w(ne.$$.fragment,re),w(Pe.$$.fragment,re),Ie=!1},d(re){re&&l(e),C(a),C(p),C(V),C(M),C(N),C(te),C(ae),C(ne),C(Pe)}}}function qc(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no devices with Vulkan support were found."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if no devices with Vulkan support were found."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function Wc(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`DevicePool(
        Instance* pInstance, 
        Window* pWindow, 
        std::vector<const char*> requiredDeviceExtensions,
        VkPhysicalDeviceFeatures requiredDeviceFeatures
);`}}),r=new Ce({props:{$$slots:{throws:[qc],params:[Hc],details:[Tc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Qc extends ve{constructor(e){super(),Ee(this,e,null,Wc,be,{})}}function Kc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zc(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yc(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[Kc]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.DEVICE_POOL_Constructor,$$slots:{default:[zc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" that support the requirements given in the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the "),S(r.$$.fragment,p),$=f(p," that support the requirements given in the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function jc(c){let e;return{c(){e=i("Physical Devices")},l(t){e=f(t,"Physical Devices")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xc(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[jc]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of all the "),I(r.$$.fragment),$=i(" that meet the requirements for the purposes of this implementation."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of all the "),S(r.$$.fragment,a),$=f(a," that meet the requirements for the purposes of this implementation."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Zc(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<PhysicalDevice> getSupportedPhysicalDevices();"}}),r=new Ce({props:{$$slots:{return:[Xc],details:[Yc]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Jc extends ve{constructor(e){super(),Ee(this,e,null,Zc,be,{})}}function e$(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t$(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r$(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.PHYSICAL_DEVICE,$$slots:{default:[e$]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[t$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Select a "),I(r.$$.fragment),$=i(" by index to create a "),I(n.$$.fragment),s=i(` of.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Select a "),S(r.$$.fragment,p),$=f(p," by index to create a "),S(n.$$.fragment,p),s=f(p,` of.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function n$(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s$(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[n$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i(`.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,`.
    `),a.forEach(l),this.h()},h(){z(e,"slot","returns")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function a$(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o$(c){let e;return{c(){e=i("getCurrentDevice")},l(t){e=f(t,"getCurrentDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l$(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:"LogicalDevice* selectDevice(unsigned int deviceIndex = 0);"}}),r=new Ce({props:{$$slots:{returns:[s$],details:[r$]},$$scope:{ctx:c}}}),s=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[a$]},$$scope:{ctx:c}}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.DEVICE_POOL_getCurrentDevice,$$slots:{default:[o$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
If a device is selected, a pointer to the `),I(s.$$.fragment),a=i(` can also be retrieved using
`),I(u.$$.fragment),p=i(".")},l(_){S(e.$$.fragment,_),t=j(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=f(_,`
If a device is selected, a pointer to the `),S(s.$$.fragment,_),a=f(_,` can also be retrieved using
`),S(u.$$.fragment,_),p=f(_,".")},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),s.$set(R);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),u.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class i$ extends ve{constructor(e){super(),Ee(this,e,null,l$,be,{})}}function f$(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c$(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $$(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[f$]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.DEVICE_POOL_selectDevice,$$slots:{default:[c$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the currently selected "),I(r.$$.fragment),$=i(" (selected with "),I(n.$$.fragment),s=i(")"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the currently selected "),S(r.$$.fragment,p),$=f(p," (selected with "),S(n.$$.fragment,p),s=f(p,")"),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function u$(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p$(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE,$$slots:{default:[u$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the currently selected "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the currently selected "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function m$(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"LogicalDevice* getCurrentDevice();"}}),r=new Ce({props:{$$slots:{return:[p$],details:[$$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class h$ extends ve{constructor(e){super(),Ee(this,e,null,m$,be,{})}}function d$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g$(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E$(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return e=new $e({props:{language:ue,code:"#include <fillcan/instance/physical_device.hpp>"}}),s=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[d$]},$$scope:{ctx:c}}}),u=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[g$]},$$scope:{ctx:c}}}),B=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[_$]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[v$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Physical Device"),n=i(" class takes in a handle to a "),I(s.$$.fragment),a=i(", a pointer to the "),I(u.$$.fragment),p=i(" (or "),m=d("code"),_=i("nullptr"),v=i(`) and the required device features and extensions.
`),P=d("br"),R=i(`
With this information the `),A=d("code"),T=i("Physical Device"),F=i(` class acts as a wrapper
around the `),I(B.$$.fragment),y=i(" for requesting information about the Physical Device and it's capabilities."),V=d("br"),x=i(`
A `),I(M.$$.fragment),O=i(` usually represents a single piece of hardware or a collection of hardware that
is interconnected. There is a fixed, finite number of physical devices in any system,
unless that system supports reconfiguration, such as hot-plugging. Hot plugging is
the addition of a part to a running computer system without significant interruption
of system operation.`)},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Physical Device"),N.forEach(l),n=f(k," class takes in a handle to a "),S(s.$$.fragment,k),a=f(k,", a pointer to the "),S(u.$$.fragment,k),p=f(k," (or "),m=g(k,"CODE",{});var Q=E(m);_=f(Q,"nullptr"),Q.forEach(l),v=f(k,`) and the required device features and extensions.
`),P=g(k,"BR",{}),R=f(k,`
With this information the `),A=g(k,"CODE",{});var X=E(A);T=f(X,"Physical Device"),X.forEach(l),F=f(k,` class acts as a wrapper
around the `),S(B.$$.fragment,k),y=f(k," for requesting information about the Physical Device and it's capabilities."),V=g(k,"BR",{}),x=f(k,`
A `),S(M.$$.fragment,k),O=f(k,` usually represents a single piece of hardware or a collection of hardware that
is interconnected. There is a fixed, finite number of physical devices in any system,
unless that system supports reconfiguration, such as hot-plugging. Hot plugging is
the addition of a part to a running computer system without significant interruption
of system operation.`)},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),o(m,_),h(k,v,N),h(k,P,N),h(k,R,N),h(k,A,N),o(A,T),h(k,F,N),D(B,k,N),h(k,y,N),h(k,V,N),h(k,x,N),D(M,k,N),h(k,O,N),H=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),B.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),M.$set(K)},i(k){H||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(B.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(B.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(v),k&&l(P),k&&l(R),k&&l(A),k&&l(F),C(B,k),k&&l(y),k&&l(V),k&&l(x),C(M,k),k&&l(O)}}}class b$ extends ve{constructor(e){super(),Ee(this,e,null,E$,be,{})}}function w$(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I$(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[w$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Physical Device."),r=d("br"),$=i(`
        Finds the queue family indices of the applicable `),I(n.$$.fragment),s=i(" (graphics, presentation and computation)."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Physical Device."),r=g(p,"BR",{}),$=f(p,`
        Finds the queue family indices of the applicable `),S(n.$$.fragment,p),s=f(p," (graphics, presentation and computation)."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function D$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C$(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S$(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P$(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A$(c){let e;return{c(){e=i("vkEnumerateInstanceExtensionProperties()")},l(t){e=f(t,"vkEnumerateInstanceExtensionProperties()")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R$(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[D$]},$$scope:{ctx:c}}}),B=new fe({props:{href:Ye().URL.documentation+"#"+L.WINDOW,$$slots:{default:[C$]},$$scope:{ctx:c}}}),M=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[S$]},$$scope:{ctx:c}}}),q=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[P$]},$$scope:{ctx:c}}}),de=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html",target:"_blank",$$slots:{default:[A$]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("hPhysicalDevice"),n=d("br"),s=i(`
            A handle to the `),I(a.$$.fragment),u=i(" to wrap."),p=Y(),m=d("li"),_=d("code"),v=i("pWindow"),P=d("br"),R=i(`
            If not `),A=d("code"),T=i("nullptr"),F=i(", a pointer to the "),I(B.$$.fragment),y=i(` with which the support for presentation can be determined and other
            surface related capabilities.`),V=d("br"),x=i(`
            The queue family index for the graphics- and presentation `),I(M.$$.fragment),O=i(" will be looked for aswell."),H=Y(),k=d("li"),N=d("code"),Q=i("requiredDeviceFeatures"),X=d("br"),Z=i(`
            The features the Physical Device should have for the purposes of the
            application.`),K=d("br"),W=i(`
            This should be a `),I(q.$$.fragment),U=i("-structure where each required feature should be set to true."),te=Y(),ee=d("li"),se=d("code"),ie=i("requiredDeviceExtensions"),ae=d("br"),J=i(`
            The extensions the Physical Device should support for the purposes of
            the application.`),pe=d("br"),Se=i(`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),I(de.$$.fragment),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var ne=E(e);t=g(ne,"LI",{});var le=E(t);r=g(le,"CODE",{});var ge=E(r);$=f(ge,"hPhysicalDevice"),ge.forEach(l),n=g(le,"BR",{}),s=f(le,`
            A handle to the `),S(a.$$.fragment,le),u=f(le," to wrap."),le.forEach(l),p=j(ne),m=g(ne,"LI",{});var we=E(m);_=g(we,"CODE",{});var Pe=E(_);v=f(Pe,"pWindow"),Pe.forEach(l),P=g(we,"BR",{}),R=f(we,`
            If not `),A=g(we,"CODE",{});var Be=E(A);T=f(Be,"nullptr"),Be.forEach(l),F=f(we,", a pointer to the "),S(B.$$.fragment,we),y=f(we,` with which the support for presentation can be determined and other
            surface related capabilities.`),V=g(we,"BR",{}),x=f(we,`
            The queue family index for the graphics- and presentation `),S(M.$$.fragment,we),O=f(we," will be looked for aswell."),we.forEach(l),H=j(ne),k=g(ne,"LI",{});var Ie=E(k);N=g(Ie,"CODE",{});var re=E(N);Q=f(re,"requiredDeviceFeatures"),re.forEach(l),X=g(Ie,"BR",{}),Z=f(Ie,`
            The features the Physical Device should have for the purposes of the
            application.`),K=g(Ie,"BR",{}),W=f(Ie,`
            This should be a `),S(q.$$.fragment,Ie),U=f(Ie,"-structure where each required feature should be set to true."),Ie.forEach(l),te=j(ne),ee=g(ne,"LI",{});var he=E(ee);se=g(he,"CODE",{});var Le=E(se);ie=f(Le,"requiredDeviceExtensions"),Le.forEach(l),ae=g(he,"BR",{}),J=f(he,`
            The extensions the Physical Device should support for the purposes of
            the application.`),pe=g(he,"BR",{}),Se=f(he,`
            This should be a list of strings containing the names of the extensions
            to support. The available extensions can be retrieved using `),S(de.$$.fragment,he),me=f(he,"."),he.forEach(l),ne.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,ne){h(_e,e,ne),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(m,A),o(A,T),o(m,F),D(B,m,null),o(m,y),o(m,V),o(m,x),D(M,m,null),o(m,O),o(e,H),o(e,k),o(k,N),o(N,Q),o(k,X),o(k,Z),o(k,K),o(k,W),D(q,k,null),o(k,U),o(e,te),o(e,ee),o(ee,se),o(se,ie),o(ee,ae),o(ee,J),o(ee,pe),o(ee,Se),D(de,ee,null),o(ee,me),De=!0},p(_e,ne){const le={};ne&1&&(le.$$scope={dirty:ne,ctx:_e}),a.$set(le);const ge={};ne&1&&(ge.$$scope={dirty:ne,ctx:_e}),B.$set(ge);const we={};ne&1&&(we.$$scope={dirty:ne,ctx:_e}),M.$set(we);const Pe={};ne&1&&(Pe.$$scope={dirty:ne,ctx:_e}),q.$set(Pe);const Be={};ne&1&&(Be.$$scope={dirty:ne,ctx:_e}),de.$set(Be)},i(_e){De||(b(a.$$.fragment,_e),b(B.$$.fragment,_e),b(M.$$.fragment,_e),b(q.$$.fragment,_e),b(de.$$.fragment,_e),De=!0)},o(_e){w(a.$$.fragment,_e),w(B.$$.fragment,_e),w(M.$$.fragment,_e),w(q.$$.fragment,_e),w(de.$$.fragment,_e),De=!1},d(_e){_e&&l(e),C(a),C(B),C(M),C(q),C(de)}}}function B$(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`PhysicalDevice(
        VkPhysicalDevice hPhysicalDevice, 
        Window* pWindow, 
        std::vector<const char*> requiredExtensions,
        VkPhysicalDeviceFeatures requiredFeatures = {}
);`}}),r=new Ce({props:{$$slots:{params:[R$],details:[I$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class L$ extends ve{constructor(e){super(),Ee(this,e,null,B$,be,{})}}function k$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T$(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[k$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function V$(c){let e;return{c(){e=i("Vulkan Physical Device")},l(t){e=f(t,"Vulkan Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O$(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html",target:"_blank",$$slots:{default:[V$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function F$(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPhysicalDevice getPhysicalDeviceHandle() const;"}}),r=new Ce({props:{$$slots:{return:[O$],details:[T$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class y$ extends ve{constructor(e){super(),Ee(this,e,null,F$,be,{})}}function M$(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x$(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[M$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the device extensions (given in the "),I(r.$$.fragment),$=i(") this Physical Device should support."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the device extensions (given in the "),S(r.$$.fragment,a),$=f(a,") this Physical Device should support."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function N$(c){let e,t;return{c(){e=d("span"),t=i("A list of the required device extensions."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required device extensions."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function U$(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<const char*>& getRequiredExtensions() const;"}}),r=new Ce({props:{$$slots:{return:[N$],details:[x$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class G$ extends ve{constructor(e){super(),Ee(this,e,null,U$,be,{})}}function H$(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q$(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[H$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Whether the device extensions given in the "),I(r.$$.fragment),$=i(" are supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Whether the device extensions given in the "),S(r.$$.fragment,a),$=f(a," are supported."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function W$(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the device extensions are supported.
        `),n=d("code"),s=i("false"),a=i(" if the device extensions aren't supported."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the device extensions are supported.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the device extensions aren't supported."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Q$(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool areExtensionsSupported();"}}),r=new Ce({props:{$$slots:{return:[W$],details:[q$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class K$ extends ve{constructor(e){super(),Ee(this,e,null,Q$,be,{})}}const{window:z$}=ka;function _a(c,e,t){const r=c.slice();return r[9]=e[t],r[10]=e,r[11]=t,r}function va(c){let e,t="<",r;return{c(){e=d("span"),r=i(t),this.h()},l($){e=g($,"SPAN",{class:!0});var n=E(e);r=f(n,t),n.forEach(l),this.h()},h(){z(e,"class","visible-reference-indicator svelte-1vakv9t")},m($,n){h($,e,n),o(e,r)},d($){$&&l(e)}}}function Ea(c){let e,t,r=c[9].label+"",$,n,s,a=c[11],u,p,m,_,v=c[2]!==null&&c[9].id===c[2].id&&va();const P=()=>c[7](t,a),R=()=>c[7](null,a);return{c(){e=d("li"),t=d("a"),$=i(r),n=Y(),v&&v.c(),u=Y(),this.h()},l(A){e=g(A,"LI",{class:!0});var T=E(e);t=g(T,"A",{href:!0,class:!0});var F=E(t);$=f(F,r),n=j(F),v&&v.l(F),F.forEach(l),u=j(T),T.forEach(l),this.h()},h(){z(t,"href",s=c[3].URL.root+"/documentation#"+c[9].id),z(t,"class","svelte-1vakv9t"),z(e,"class",p="reference-item h"+c[9].heading+" "+(c[2]!==null&&c[9].id===c[2].id?"active":"")+" svelte-1vakv9t")},m(A,T){h(A,e,T),o(e,t),o(t,$),o(t,n),v&&v.m(t,null),P(),o(e,u),m||(_=Ds(t,"click",c[5]),m=!0)},p(A,T){c=A,T&1&&r!==(r=c[9].label+"")&&La($,r),c[2]!==null&&c[9].id===c[2].id?v||(v=va(),v.c(),v.m(t,null)):v&&(v.d(1),v=null),T&9&&s!==(s=c[3].URL.root+"/documentation#"+c[9].id)&&z(t,"href",s),a!==c[11]&&(R(),a=c[11],P()),T&5&&p!==(p="reference-item h"+c[9].heading+" "+(c[2]!==null&&c[9].id===c[2].id?"active":"")+" svelte-1vakv9t")&&z(e,"class",p)},d(A){A&&l(e),v&&v.d(),R(),m=!1,_()}}}function Y$(c){let e,t,r,$=c[0],n=[];for(let s=0;s<$.length;s+=1)n[s]=Ea(_a(c,$,s));return{c(){e=d("ul");for(let s=0;s<n.length;s+=1)n[s].c();this.h()},l(s){e=g(s,"UL",{class:!0});var a=E(e);for(let u=0;u<n.length;u+=1)n[u].l(a);a.forEach(l),this.h()},h(){z(e,"class","references-list svelte-1vakv9t")},m(s,a){h(s,e,a);for(let u=0;u<n.length;u+=1)n[u].m(e,null);t||(r=Ds(z$,"scroll",c[4]),t=!0)},p(s,[a]){if(a&47){$=s[0];let u;for(u=0;u<$.length;u+=1){const p=_a(s,$,u);n[u]?n[u].p(p,a):(n[u]=Ea(p),n[u].c(),n[u].m(e,null))}for(;u<n.length;u+=1)n[u].d(1);n.length=$.length}},i:ke,o:ke,d(s){s&&l(e),Pa(n,s),t=!1,r()}}}function j$(c){c.getBoundingClientRect().bottom>window.innerHeight&&c.scrollIntoView(!1),c.getBoundingClientRect().top<100&&c.scrollIntoView()}function X$(c,e,t){let r;Sa(c,Cs,v=>t(3,r=v));let{sections:$}=e,{onReferenceClick:n=()=>{}}=e,s=null,a=[],u=null;function p(){u!==null&&j$(u)}function m(v){n()}function _(v,P){Aa[v?"unshift":"push"](()=>{a[P]=v,t(1,a)})}return c.$$set=v=>{"sections"in v&&t(0,$=v.sections),"onReferenceClick"in v&&t(6,n=v.onReferenceClick)},c.$$.update=()=>{if(c.$$.dirty&3){for(let v=0;v<$.length;v++)if($[v].visible){t(2,s=$[v]),u=a[v];break}}},[$,a,s,r,p,m,n,_]}class Ra extends ve{constructor(e){super(),Ee(this,e,X$,Y$,be,{sections:0,onReferenceClick:6})}}function Z$(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J$(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[Z$]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the device features (given in the "),I(r.$$.fragment),$=i(") this Physical Device should support."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the device features (given in the "),S(r.$$.fragment,a),$=f(a,") this Physical Device should support."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function eu(c){let e,t;return{c(){e=d("span"),t=i("A list of the required device features."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the required device features."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function tu(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPhysicalDeviceFeatures& getRequiredFeatures() const;"}}),r=new Ce({props:{$$slots:{return:[eu],details:[J$]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ru extends ve{constructor(e){super(),Ee(this,e,null,tu,be,{})}}function nu(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function su(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE_Constructor,$$slots:{default:[nu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Whether the device features given in the "),I(r.$$.fragment),$=i(" are supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Whether the device features given in the "),S(r.$$.fragment,a),$=f(a," are supported."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function au(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the device features are supported.
        `),n=d("code"),s=i("false"),a=i(" if the device features aren't supported."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the device features are supported.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the device features aren't supported."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function ou(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool areFeaturesSupported();"}}),r=new Ce({props:{$$slots:{return:[au],details:[su]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class lu extends ve{constructor(e){super(),Ee(this,e,null,ou,be,{})}}function iu(c){let e,t;return{c(){e=d("span"),t=i("Query all supported and unsupported features for this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query all supported and unsupported features for this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function fu(c){let e;return{c(){e=i("VkPhysicalDeviceFeatures")},l(t){e=f(t,"VkPhysicalDeviceFeatures")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html",target:"_blank",$$slots:{default:[fu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying which features are and aren't supported."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,"-structure specifying which features are and aren't supported."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function $u(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPhysicalDeviceFeatures getFeatures() const;"}}),r=new Ce({props:{$$slots:{return:[cu],details:[iu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uu extends ve{constructor(e){super(),Ee(this,e,null,$u,be,{})}}function pu(c){let e,t;return{c(){e=d("span"),t=i("Query all properties of this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query all properties of this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function mu(c){let e;return{c(){e=i("VkPhysicalDeviceProperties")},l(t){e=f(t,"VkPhysicalDeviceProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html",target:"_blank",$$slots:{default:[mu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying the properties of this Physical Device."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,"-structure specifying the properties of this Physical Device."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function du(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPhysicalDeviceProperties getProperties() const;"}}),r=new Ce({props:{$$slots:{return:[hu],details:[pu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gu extends ve{constructor(e){super(),Ee(this,e,null,du,be,{})}}function _u(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vu(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eu(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.WINDOW,$$slots:{default:[_u]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[vu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the basic capabilities of the "),I(r.$$.fragment),$=i(" surface, needed in order to create a "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the basic capabilities of the "),S(r.$$.fragment,p),$=f(p," surface, needed in order to create a "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function bu(c){let e;return{c(){e=i("VkSurfaceCapabilitiesKHR")},l(t){e=f(t,"VkSurfaceCapabilitiesKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wu(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iu(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html",target:"_blank",$$slots:{default:[bu]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[wu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i("-structure specifying the basic capabilities of the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p,"-structure specifying the basic capabilities of the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Du(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkSurfaceCapabilitiesKHR getSurfaceCapabilitiesKHR() const;"}}),r=new Ce({props:{$$slots:{return:[Iu],details:[Eu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cu extends ve{constructor(e){super(),Ee(this,e,null,Du,be,{})}}function Su(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pu(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Au(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Su]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[Pu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the supported "),I(r.$$.fragment),$=i(" format with colorspace pairs for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the supported "),S(r.$$.fragment,p),$=f(p," format with colorspace pairs for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ru(c){let e;return{c(){e=i("VkSurfaceFormatKHR")},l(t){e=f(t,"VkSurfaceFormatKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bu(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lu(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html",target:"_blank",$$slots:{default:[Ru]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[Bu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i(`-structures specifying the supported format with colorspace pairs for
        the `),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,`-structures specifying the supported format with colorspace pairs for
        the `),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function ku(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkSurfaceFormatKHR> getSurfaceFormatsKHR() const;"}}),r=new Ce({props:{$$slots:{return:[Lu],details:[Au]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Tu extends ve{constructor(e){super(),Ee(this,e,null,ku,be,{})}}function Vu(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ou(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fu(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[Vu]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[Ou]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the supported "),I(r.$$.fragment),$=i(" presentation modes for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Query the supported "),S(r.$$.fragment,p),$=f(p," presentation modes for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function yu(c){let e;return{c(){e=i("VkPresentMode")},l(t){e=f(t,"VkPresentMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mu(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xu(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[yu]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[Mu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures specifying the supported presentation modes for the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,"-structures specifying the supported presentation modes for the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Nu(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkPresentModeKHR> getSurfacePresentModesKHR() const;"}}),r=new Ce({props:{$$slots:{return:[xu],details:[Fu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Uu extends ve{constructor(e){super(),Ee(this,e,null,Nu,be,{})}}function Gu(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hu(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Gu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Query the properties of the "),I(r.$$.fragment),$=i(" available on this Physical Device. >."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Query the properties of the "),S(r.$$.fragment,a),$=f(a," available on this Physical Device. >."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qu(c){let e;return{c(){e=i("VkQueueFamilyProperties")},l(t){e=f(t,"VkQueueFamilyProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wu(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qu(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html",target:"_blank",$$slots:{default:[qu]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Wu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures specifying the properties of the "),I(n.$$.fragment),s=i(" available on this Physical Device."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,"-structures specifying the properties of the "),S(n.$$.fragment,p),s=f(p," available on this Physical Device."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ku(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkQueueFamilyProperties> getQueueFamilyProperties() const;"}}),r=new Ce({props:{$$slots:{return:[Qu],details:[Hu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zu extends ve{constructor(e){super(),Ee(this,e,null,Ku,be,{})}}function Yu(c){let e,t;return{c(){e=d("span"),t=i("Query the properties of a given format for this Physical Device."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Query the properties of a given format for this Physical Device."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ju(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            The format of which to query it's properties for this Physical Device.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"format"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The format of which to query it's properties for this Physical Device.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function Xu(c){let e;return{c(){e=i("VkFormatProperties")},l(t){e=f(t,"VkFormatProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zu(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html",target:"_blank",$$slots:{default:[Xu]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure specifying the properties of the given format for this
        Physical Device.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-structure specifying the properties of the given format for this
        Physical Device.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ju(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkFormatProperties getFormatProperties(VkFormat format) const;"}}),r=new Ce({props:{$$slots:{return:[Zu],params:[ju],details:[Yu]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ep extends ve{constructor(e){super(),Ee(this,e,null,Ju,be,{})}}function tp(c){let e,t;return{c(){e=d("span"),t=i(`Find a format from a list of given formats which supports the given
        tiling and features.
    `),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Find a format from a list of given formats which supports the given
        tiling and features.
    `),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function rp(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function np(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sp(c){let e;return{c(){e=i("VkFormatFeatureFlagBits")},l(t){e=f(t,"VkFormatFeatureFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ap(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function op(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X;return P=new G({props:{sectionID:L.IMAGE,$$slots:{default:[rp]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[np]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html",target:"_blank",$$slots:{default:[sp]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.BUFFER,$$slots:{default:[ap]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("formats"),n=d("br"),s=i(`
            The formats to query support for.`),a=Y(),u=d("li"),p=d("code"),m=i("tiling"),_=d("br"),v=i(`
            The tiling arrangement of data in an `),I(P.$$.fragment),R=i(" which the format should support. This should be a member of the "),I(A.$$.fragment),T=i(" enumeration."),F=Y(),B=d("li"),y=d("code"),V=i("features"),x=d("br"),M=i(`
            A bitmask of `),I(O.$$.fragment),H=i(" specifying the features supported by a "),I(k.$$.fragment),N=i(" this format should support."),Q=Y(),this.h()},l(Z){e=g(Z,"DIV",{slot:!0});var K=E(e);t=g(K,"LI",{});var W=E(t);r=g(W,"CODE",{});var q=E(r);$=f(q,"formats"),q.forEach(l),n=g(W,"BR",{}),s=f(W,`
            The formats to query support for.`),W.forEach(l),a=j(K),u=g(K,"LI",{});var U=E(u);p=g(U,"CODE",{});var te=E(p);m=f(te,"tiling"),te.forEach(l),_=g(U,"BR",{}),v=f(U,`
            The tiling arrangement of data in an `),S(P.$$.fragment,U),R=f(U," which the format should support. This should be a member of the "),S(A.$$.fragment,U),T=f(U," enumeration."),U.forEach(l),F=j(K),B=g(K,"LI",{});var ee=E(B);y=g(ee,"CODE",{});var se=E(y);V=f(se,"features"),se.forEach(l),x=g(ee,"BR",{}),M=f(ee,`
            A bitmask of `),S(O.$$.fragment,ee),H=f(ee," specifying the features supported by a "),S(k.$$.fragment,ee),N=f(ee," this format should support."),ee.forEach(l),Q=j(K),K.forEach(l),this.h()},h(){z(e,"slot","params")},m(Z,K){h(Z,e,K),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),D(A,u,null),o(u,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),o(e,Q),X=!0},p(Z,K){const W={};K&1&&(W.$$scope={dirty:K,ctx:Z}),P.$set(W);const q={};K&1&&(q.$$scope={dirty:K,ctx:Z}),A.$set(q);const U={};K&1&&(U.$$scope={dirty:K,ctx:Z}),O.$set(U);const te={};K&1&&(te.$$scope={dirty:K,ctx:Z}),k.$set(te)},i(Z){X||(b(P.$$.fragment,Z),b(A.$$.fragment,Z),b(O.$$.fragment,Z),b(k.$$.fragment,Z),X=!0)},o(Z){w(P.$$.fragment,Z),w(A.$$.fragment,Z),w(O.$$.fragment,Z),w(k.$$.fragment,Z),X=!1},d(Z){Z&&l(e),C(P),C(A),C(O),C(k)}}}function lp(c){let e;return{c(){e=i("std::nullopt")},l(t){e=f(t,"std::nullopt")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ip(c){let e,t,r,$,n;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/optional/nullopt",target:"_blank",$$slots:{default:[lp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`An optional value of the first format in the list of given formats that
        supports the given tiling and features or `),I(r.$$.fragment),$=i(` if none of the given formats supports the given tiling and features.
    `),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`An optional value of the first format in the list of given formats that
        supports the given tiling and features or `),S(r.$$.fragment,a),$=f(a,` if none of the given formats supports the given tiling and features.
    `),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function fp(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:`const std::optional<VkFormat> findSupportedFormat(
        std::vector<VkFormat> formats, 
        VkImageTiling tiling, 
        VkFormatFeatureFlags features
) const;`}}),r=new Ce({props:{$$slots:{return:[ip],params:[op],details:[tp]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`std::vector<VkFormat> formats = { VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT };
VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
VkFormatFeatureFlags features = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;

std::optional<VkFormat> optFormat = fillcan.getCurrentDevice()->getPhysicalDevice()->findSupportedFormat(
    formats, tiling, features
);

if (!optFormat.has_value()) {
    throw std::runtime_error("Failed to find a supported format");
}

VkFormat supportedFormat = optFormat.value();`}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class cp extends ve{constructor(e){super(),Ee(this,e,null,fp,be,{})}}function $p(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function up(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[$p]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the graphics "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the graphics "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function pp(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the graphics Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the graphics Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function mp(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<unsigned int>& getGraphicsQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[pp],details:[up]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hp extends ve{constructor(e){super(),Ee(this,e,null,mp,be,{})}}function dp(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gp(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[dp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the present "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the present "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _p(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the present Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the present Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function vp(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<unsigned int>& getPresentQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[_p],details:[gp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ep extends ve{constructor(e){super(),Ee(this,e,null,vp,be,{})}}function bp(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wp(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[bp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the queue family indices for the compute "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the queue family indices for the compute "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ip(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices for the compute Queues."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices for the compute Queues."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Dp(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<unsigned int>& getComputeQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[Ip],details:[wp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cp extends ve{constructor(e){super(),Ee(this,e,null,Dp,be,{})}}function Sp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ap(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lp(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tp(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return e=new $e({props:{language:ue,code:"#include <fillcan/instance/logical_device.hpp>"}}),s=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Sp]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Pp]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Ap]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Rp]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Bp]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Lp]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[kp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Logical Device"),n=i(" class takes in a pointer to the "),I(s.$$.fragment),a=i(" to construct around. It uses the "),I(u.$$.fragment),p=i(" to construct the graphics, presentation and computation "),I(m.$$.fragment),_=i(" if available."),v=d("br"),P=i(`
The Logical Device is the software construction around a `),I(R.$$.fragment),A=i(`. A Logical Device represents a reservation of resources associated with a
particular `),I(T.$$.fragment),F=i(". This includes a possible subset of the available "),I(B.$$.fragment),y=i(" on the "),I(V.$$.fragment),x=i(`, and it is the Logical Device that the application will communicate with most
of the time.`)},l(O){S(e.$$.fragment,O),t=f(O,`
The `),r=g(O,"CODE",{});var H=E(r);$=f(H,"Logical Device"),H.forEach(l),n=f(O," class takes in a pointer to the "),S(s.$$.fragment,O),a=f(O," to construct around. It uses the "),S(u.$$.fragment,O),p=f(O," to construct the graphics, presentation and computation "),S(m.$$.fragment,O),_=f(O," if available."),v=g(O,"BR",{}),P=f(O,`
The Logical Device is the software construction around a `),S(R.$$.fragment,O),A=f(O,`. A Logical Device represents a reservation of resources associated with a
particular `),S(T.$$.fragment,O),F=f(O,". This includes a possible subset of the available "),S(B.$$.fragment,O),y=f(O," on the "),S(V.$$.fragment,O),x=f(O,`, and it is the Logical Device that the application will communicate with most
of the time.`)},m(O,H){D(e,O,H),h(O,t,H),h(O,r,H),o(r,$),h(O,n,H),D(s,O,H),h(O,a,H),D(u,O,H),h(O,p,H),D(m,O,H),h(O,_,H),h(O,v,H),h(O,P,H),D(R,O,H),h(O,A,H),D(T,O,H),h(O,F,H),D(B,O,H),h(O,y,H),D(V,O,H),h(O,x,H),M=!0},p(O,[H]){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),s.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),u.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),m.$set(Q);const X={};H&1&&(X.$$scope={dirty:H,ctx:O}),R.$set(X);const Z={};H&1&&(Z.$$scope={dirty:H,ctx:O}),T.$set(Z);const K={};H&1&&(K.$$scope={dirty:H,ctx:O}),B.$set(K);const W={};H&1&&(W.$$scope={dirty:H,ctx:O}),V.$set(W)},i(O){M||(b(e.$$.fragment,O),b(s.$$.fragment,O),b(u.$$.fragment,O),b(m.$$.fragment,O),b(R.$$.fragment,O),b(T.$$.fragment,O),b(B.$$.fragment,O),b(V.$$.fragment,O),M=!0)},o(O){w(e.$$.fragment,O),w(s.$$.fragment,O),w(u.$$.fragment,O),w(m.$$.fragment,O),w(R.$$.fragment,O),w(T.$$.fragment,O),w(B.$$.fragment,O),w(V.$$.fragment,O),M=!1},d(O){C(e,O),O&&l(t),O&&l(r),O&&l(n),C(s,O),O&&l(a),C(u,O),O&&l(p),C(m,O),O&&l(_),O&&l(v),O&&l(P),C(R,O),O&&l(A),C(T,O),O&&l(F),C(B,O),O&&l(y),C(V,O),O&&l(x)}}}class Vp extends ve{constructor(e){super(),Ee(this,e,null,Tp,be,{})}}function Op(c){let e,t;return{c(){e=d("span"),t=i("Create a new Logical Device. "),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Logical Device. "),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Fp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yp(c){let e,t,r,$,n,s,a,u,p,m;return a=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Fp]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pPhysicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to create a Logical Device from."),p=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"pPhysicalDevice"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            A pointer to the `),S(a.$$.fragment,P),u=f(P," to create a Logical Device from."),P.forEach(l),p=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),a.$set(P)},i(_){m||(b(a.$$.fragment,_),m=!0)},o(_){w(a.$$.fragment,_),m=!1},d(_){_&&l(e),C(a)}}}function Mp(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xp(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Np(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[Mp]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.QUEUE,$$slots:{default:[xp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        throws `),p=d("code"),m=i("std::runtime_error"),_=i(" aswell if no "),I(v.$$.fragment),P=i(` were found.
    `),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=g(T,"CODE",{});var F=E(t);r=f(F,"std::runtime_error"),F.forEach(l),$=f(T," if the "),S(n.$$.fragment,T),s=f(T," couldn't be created."),a=g(T,"BR",{}),u=f(T,`
        throws `),p=g(T,"CODE",{});var B=E(p);m=f(B,"std::runtime_error"),B.forEach(l),_=f(T," aswell if no "),S(v.$$.fragment,T),P=f(T,` were found.
    `),T.forEach(l),this.h()},h(){z(e,"slot","throws")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,P),R=!0},p(A,T){const F={};T&1&&(F.$$scope={dirty:T,ctx:A}),n.$set(F);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),v.$set(B)},i(A){R||(b(n.$$.fragment,A),b(v.$$.fragment,A),R=!0)},o(A){w(n.$$.fragment,A),w(v.$$.fragment,A),R=!1},d(A){A&&l(e),C(n),C(v)}}}function Up(c){let e;return{c(){e=i("Fillcan")},l(t){e=f(t,"Fillcan")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gp(c){let e;return{c(){e=i("Fillcan Graphics")},l(t){e=f(t,"Fillcan Graphics")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hp(c){let e;return{c(){e=i("selectDevice")},l(t){e=f(t,"selectDevice")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qp(c){let e,t,r,$,n,s,a,u,p,m,_,v;return e=new $e({props:{language:ue,code:"LogicalDevice(PhysicalDevice* pPhysicalDevice);"}}),r=new Ce({props:{$$slots:{throws:[Np],params:[yp],details:[Op]},$$scope:{ctx:c}}}),s=new G({props:{sectionID:L.FILLCAN,$$slots:{default:[Up]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.FILLCAN_GRAPHICS,$$slots:{default:[Gp]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.FILLCAN_selectDevice,$$slots:{default:[Hp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
The Logical Device can be retrieved using the `),I(s.$$.fragment),a=i(" or "),I(u.$$.fragment),p=i(` API by calling
`),I(m.$$.fragment),_=i(` instead
of manually calling this Constructor.`)},l(P){S(e.$$.fragment,P),t=j(P),S(r.$$.fragment,P),$=g(P,"BR",{}),n=f(P,`
The Logical Device can be retrieved using the `),S(s.$$.fragment,P),a=f(P," or "),S(u.$$.fragment,P),p=f(P,` API by calling
`),S(m.$$.fragment,P),_=f(P,` instead
of manually calling this Constructor.`)},m(P,R){D(e,P,R),h(P,t,R),D(r,P,R),h(P,$,R),h(P,n,R),D(s,P,R),h(P,a,R),D(u,P,R),h(P,p,R),D(m,P,R),h(P,_,R),v=!0},p(P,[R]){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),r.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),s.$set(T);const F={};R&1&&(F.$$scope={dirty:R,ctx:P}),u.$set(F);const B={};R&1&&(B.$$scope={dirty:R,ctx:P}),m.$set(B)},i(P){v||(b(e.$$.fragment,P),b(r.$$.fragment,P),b(s.$$.fragment,P),b(u.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(e.$$.fragment,P),w(r.$$.fragment,P),w(s.$$.fragment,P),w(u.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){C(e,P),P&&l(t),C(r,P),P&&l($),P&&l(n),C(s,P),P&&l(a),C(u,P),P&&l(p),C(m,P),P&&l(_)}}}class Wp extends ve{constructor(e){super(),Ee(this,e,null,qp,be,{})}}function Qp(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kp(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[Qp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zp(c){let e;return{c(){e=i("Vulkan Device")},l(t){e=f(t,"Vulkan Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yp(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html",target:"_blank",$$slots:{default:[zp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function jp(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkDevice getLogicalDeviceHandle() const;"}}),r=new Ce({props:{$$slots:{return:[Yp],details:[Kp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Xp extends ve{constructor(e){super(),Ee(this,e,null,jp,be,{})}}function Zp(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jp(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[Zp]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the "),I(r.$$.fragment),$=i(" this Logical Device is constructed around."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the "),S(r.$$.fragment,a),$=f(a," this Logical Device is constructed around."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function em(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tm(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[em]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" this Logical Device is constructed around."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," this Logical Device is constructed around."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const PhysicalDevice* getPhysicalDevice() const;"}}),r=new Ce({props:{$$slots:{return:[tm],details:[Jp]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class nm extends ve{constructor(e){super(),Ee(this,e,null,rm,be,{})}}function sm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function am(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function om(c){let e,t,r,$,n,s,a,u,p;return n=new G({props:{sectionID:L.QUEUE,$$slots:{default:[sm]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.QUEUE,$$slots:{default:[am]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the Logical Device to become idle."),r=d("br"),$=i(`
        Waits on the host for the completion of ongoing `),I(n.$$.fragment),s=i(` operations for all
        `),I(a.$$.fragment),u=i(` on this Logical
        Device.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Wait for the Logical Device to become idle."),r=g(_,"BR",{}),$=f(_,`
        Waits on the host for the completion of ongoing `),S(n.$$.fragment,_),s=f(_,` operations for all
        `),S(a.$$.fragment,_),u=f(_,` on this Logical
        Device.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function lm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void waitIdle();"}}),r=new Ce({props:{$$slots:{details:[om]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class im extends ve{constructor(e){super(),Ee(this,e,null,lm,be,{})}}function fm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cm(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[fm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the graphics "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the graphics "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function $m(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function um(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pm(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[$m]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.QUEUE,$$slots:{default:[um]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the graphics "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the graphics "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function mm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Queue* getGraphicsQueue();"}}),r=new Ce({props:{$$slots:{return:[pm],details:[cm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hm extends ve{constructor(e){super(),Ee(this,e,null,mm,be,{})}}function dm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gm(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[dm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the compute "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the compute "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _m(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Em(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[_m]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.QUEUE,$$slots:{default:[vm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the compute "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the compute "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function bm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Queue* getComputeQueue();"}}),r=new Ce({props:{$$slots:{return:[Em],details:[gm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wm extends ve{constructor(e){super(),Ee(this,e,null,bm,be,{})}}function Im(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dm(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Im]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to the present "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to the present "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Cm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pm(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Cm]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Sm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the present "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the present "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function Am(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Queue* getPresentQueue();"}}),r=new Ce({props:{$$slots:{return:[Pm],details:[Dm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Rm extends ve{constructor(e){super(),Ee(this,e,null,Am,be,{})}}function Bm(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function km(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tm(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vm(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Om(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fm(c){let e;return{c(){e=i("endSingleTimeRecording")},l(t){e=f(t,"endSingleTimeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ym(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Bm]},$$scope:{ctx:c}}}),n=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Lm]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[km]},$$scope:{ctx:c}}}),_=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Tm]},$$scope:{ctx:c}}}),P=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_BUFFER,$$slots:{default:[Vm]},$$scope:{ctx:c}}}),A=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_BUFFER,$$slots:{default:[Om]},$$scope:{ctx:c}}}),F=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE_endSingleTimeCommandRecording,$$slots:{default:[Fm]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Start a "),I(r.$$.fragment),$=i(" with a given "),I(n.$$.fragment),s=i("."),a=d("br"),u=i(`
        Creates a `),I(p.$$.fragment),m=i(" using the given Queue pointer. This "),I(_.$$.fragment),v=i(" will contain 1 (one) Primary "),I(P.$$.fragment),R=i(" and 0 (zero) Secondary "),I(A.$$.fragment),T=i(". To end the recording, call "),I(F.$$.fragment),B=i("."),this.h()},l(V){e=g(V,"SPAN",{slot:!0});var x=E(e);t=f(x,"Start a "),S(r.$$.fragment,x),$=f(x," with a given "),S(n.$$.fragment,x),s=f(x,"."),a=g(x,"BR",{}),u=f(x,`
        Creates a `),S(p.$$.fragment,x),m=f(x," using the given Queue pointer. This "),S(_.$$.fragment,x),v=f(x," will contain 1 (one) Primary "),S(P.$$.fragment,x),R=f(x," and 0 (zero) Secondary "),S(A.$$.fragment,x),T=f(x,". To end the recording, call "),S(F.$$.fragment,x),B=f(x,"."),x.forEach(l),this.h()},h(){z(e,"slot","details")},m(V,x){h(V,e,x),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),D(P,e,null),o(e,R),D(A,e,null),o(e,T),D(F,e,null),o(e,B),y=!0},p(V,x){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),r.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),n.$set(O);const H={};x&1&&(H.$$scope={dirty:x,ctx:V}),p.$set(H);const k={};x&1&&(k.$$scope={dirty:x,ctx:V}),_.$set(k);const N={};x&1&&(N.$$scope={dirty:x,ctx:V}),P.$set(N);const Q={};x&1&&(Q.$$scope={dirty:x,ctx:V}),A.$set(Q);const X={};x&1&&(X.$$scope={dirty:x,ctx:V}),F.$set(X)},i(V){y||(b(r.$$.fragment,V),b(n.$$.fragment,V),b(p.$$.fragment,V),b(_.$$.fragment,V),b(P.$$.fragment,V),b(A.$$.fragment,V),b(F.$$.fragment,V),y=!0)},o(V){w(r.$$.fragment,V),w(n.$$.fragment,V),w(p.$$.fragment,V),w(_.$$.fragment,V),w(P.$$.fragment,V),w(A.$$.fragment,V),w(F.$$.fragment,V),y=!1},d(V){V&&l(e),C(r),C(n),C(p),C(_),C(P),C(A),C(F)}}}function Mm(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xm(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nm(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Mm]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[xm]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pQueue"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" from which a "),I(p.$$.fragment),m=i(" will be created from."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pQueue"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," from which a "),S(p.$$.fragment,R),m=f(R," will be created from."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Um(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gm(c){let e,t,r,$,n;return r=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Um]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Hm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"CommandRecording* Fillcan::beginSingleTimeCommandRecording(Queue* pQueue);"}}),r=new Ce({props:{$$slots:{return:[Gm],params:[Nm],details:[ym]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qm extends ve{constructor(e){super(),Ee(this,e,null,Hm,be,{})}}function Wm(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qm(c){let e;return{c(){e=i("beginSingleTimeRecording")},l(t){e=f(t,"beginSingleTimeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Km(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zm(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Wm]},$$scope:{ctx:c}}}),a=new fe({props:{href:Ye().URL.documentation+"#"+L.LOGICAL_DEVICE_beginSingleTimeCommandRecording,$$slots:{default:[Qm]},$$scope:{ctx:c}}}),p=new fe({props:{href:Ye().URL.documentation+"#"+L.QUEUE,$$slots:{default:[Km]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("End a Command Recording."),r=d("br"),$=i(`
        Ends a `),I(n.$$.fragment),s=i(" (preferably created using "),I(a.$$.fragment),u=i("), submits the recording and waits for the "),I(p.$$.fragment),m=i(" to idle before returning."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=f(P,"End a Command Recording."),r=g(P,"BR",{}),$=f(P,`
        Ends a `),S(n.$$.fragment,P),s=f(P," (preferably created using "),S(a.$$.fragment,P),u=f(P,"), submits the recording and waits for the "),S(p.$$.fragment,P),m=f(P," to idle before returning."),P.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,P){h(v,e,P),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),n.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),a.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:v}),p.$set(T)},i(v){_||(b(n.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(a),C(p)}}}function Ym(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jm(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:Ye().URL.documentation+"#"+L.COMMAND_RECORDING,$$slots:{default:[Ym]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecording"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to end."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pCommandRecording"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to end."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function Xm(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void endSingleTimeCommandRecording(CommandRecording* pCommandRecording);"}}),r=new Ce({props:{$$slots:{params:[jm],details:[zm]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Zm extends ve{constructor(e){super(),Ee(this,e,null,Xm,be,{})}}function Jm(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eh(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function th(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rh(c){let e;return{c(){e=i("getGraphicsQueue")},l(t){e=f(t,"getGraphicsQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nh(c){let e;return{c(){e=i("getPresentQueue")},l(t){e=f(t,"getPresentQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sh(c){let e;return{c(){e=i("getComputeQueue")},l(t){e=f(t,"getComputeQueue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ah(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return e=new $e({props:{language:ue,code:"#include <fillcan/commands/queue.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Jm]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[eh]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[th]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.LOGICAL_DEVICE_getGraphicsQueue,$$slots:{default:[rh]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.LOGICAL_DEVICE_getPresentQueue,$$slots:{default:[nh]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.LOGICAL_DEVICE_getComputeQueue,$$slots:{default:[sh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Queue"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with the queue family index and queue index and uses this information to
construct one `),I(u.$$.fragment),p=i("."),m=d("br"),_=i(`
Each device in Vulkan has one or more Queues. The Queue is the part of the device
that does the actual work. It can be thought of as a sub-device that exposes a subset
of the functionality of the device.`),v=d("br"),P=i(`
Queues are grouped into one or more queue families, each containing one or more Queues.
Queues within a single family are essentially identical. Their capabilities are the
same, their performance level and access to system resources is the same, and there
is no cost (other than synchronization) for transferring work between each other.`),R=d("br"),A=i(`
The `),I(T.$$.fragment),F=i(` will
automatically attempt to create one graphics, presentation and computation Queue
which can be retrieved with `),I(B.$$.fragment),y=i(", "),I(V.$$.fragment),x=i(" and "),I(M.$$.fragment),O=i(", respectively.")},l(k){S(e.$$.fragment,k),t=f(k,`

The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Queue"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k,` along with the queue family index and queue index and uses this information to
construct one `),S(u.$$.fragment,k),p=f(k,"."),m=g(k,"BR",{}),_=f(k,`
Each device in Vulkan has one or more Queues. The Queue is the part of the device
that does the actual work. It can be thought of as a sub-device that exposes a subset
of the functionality of the device.`),v=g(k,"BR",{}),P=f(k,`
Queues are grouped into one or more queue families, each containing one or more Queues.
Queues within a single family are essentially identical. Their capabilities are the
same, their performance level and access to system resources is the same, and there
is no cost (other than synchronization) for transferring work between each other.`),R=g(k,"BR",{}),A=f(k,`
The `),S(T.$$.fragment,k),F=f(k,` will
automatically attempt to create one graphics, presentation and computation Queue
which can be retrieved with `),S(B.$$.fragment,k),y=f(k,", "),S(V.$$.fragment,k),x=f(k," and "),S(M.$$.fragment,k),O=f(k,", respectively.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),h(k,_,N),h(k,v,N),h(k,P,N),h(k,R,N),h(k,A,N),D(T,k,N),h(k,F,N),D(B,k,N),h(k,y,N),D(V,k,N),h(k,x,N),D(M,k,N),h(k,O,N),H=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),T.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),B.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),V.$set(W);const q={};N&1&&(q.$$scope={dirty:N,ctx:k}),M.$set(q)},i(k){H||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(T.$$.fragment,k),b(B.$$.fragment,k),b(V.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(T.$$.fragment,k),w(B.$$.fragment,k),w(V.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(_),k&&l(v),k&&l(P),k&&l(R),k&&l(A),C(T,k),k&&l(F),C(B,k),k&&l(y),C(V,k),k&&l(x),C(M,k),k&&l(O)}}}class oh extends ve{constructor(e){super(),Ee(this,e,null,ah,be,{})}}function lh(c){let e,t;return{c(){e=d("span"),t=i("Create a new Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Queue."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ih(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fh(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[ih]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Queue."),p=Y(),m=d("li"),_=d("code"),v=i("queueFamilyIndex"),P=d("br"),R=i(`
            The index of the chosen queue family.`),A=Y(),T=d("li"),F=d("code"),B=i("queueIndex"),y=d("br"),V=i(`
            The index of the chosen queue from the queue family.`),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"pLogicalDevice"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            A pointer to the `),S(a.$$.fragment,H),u=f(H," that owns the Queue."),H.forEach(l),p=j(O),m=g(O,"LI",{});var N=E(m);_=g(N,"CODE",{});var Q=E(_);v=f(Q,"queueFamilyIndex"),Q.forEach(l),P=g(N,"BR",{}),R=f(N,`
            The index of the chosen queue family.`),N.forEach(l),A=j(O),T=g(O,"LI",{});var X=E(T);F=g(X,"CODE",{});var Z=E(F);B=f(Z,"queueIndex"),Z.forEach(l),y=g(X,"BR",{}),V=f(X,`
            The index of the chosen queue from the queue family.`),X.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H)},i(M){x||(b(a.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),x=!1},d(M){M&&l(e),C(a)}}}function ch(c){let e,t,r,$,n,s,a,u;return{c(){e=d("span"),t=i("When either "),r=d("code"),$=i("queueFamilyIndex"),n=i(" or "),s=d("code"),a=i("queueIndex"),u=i(` is out
        of range.`),this.h()},l(p){e=g(p,"SPAN",{slot:!0});var m=E(e);t=f(m,"When either "),r=g(m,"CODE",{});var _=E(r);$=f(_,"queueFamilyIndex"),_.forEach(l),n=f(m," or "),s=g(m,"CODE",{});var v=E(s);a=f(v,"queueIndex"),v.forEach(l),u=f(m,` is out
        of range.`),m.forEach(l),this.h()},h(){z(e,"slot","throws")},m(p,m){h(p,e,m),o(e,t),o(e,r),o(r,$),o(e,n),o(e,s),o(s,a),o(e,u)},p:ke,d(p){p&&l(e)}}}function $h(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Queue(LogicalDevice* pLogicalDevice, unsigned int queueFamilyIndex, unsigned int queueIndex);"}}),r=new Ce({props:{$$slots:{throws:[ch],params:[fh],details:[lh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uh extends ve{constructor(e){super(),Ee(this,e,null,$h,be,{})}}function ph(c){let e;return{c(){e=i("Vulkan Queue")},l(t){e=f(t,"Vulkan Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mh(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html",target:"_blank",$$slots:{default:[ph]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hh(c){let e;return{c(){e=i("Vulkan Queue")},l(t){e=f(t,"Vulkan Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dh(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html",target:"_blank",$$slots:{default:[hh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function gh(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkQueue getQueueHandle(); const"}}),r=new Ce({props:{$$slots:{return:[dh],details:[mh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _h extends ve{constructor(e){super(),Ee(this,e,null,gh,be,{})}}function vh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eh(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[vh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bh(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ih(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ch(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sh(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ph(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[bh]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[wh]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Ih]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Dh]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Ch]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Sh]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("primaryCommandBufferCount"),n=d("br"),s=i(`
            The amount of Primary `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should allocate."),_=Y(),v=d("li"),P=d("code"),R=i("secondaryCommandBufferCount"),A=d("br"),T=i(`
            The amount of Secondary `),I(F.$$.fragment),B=i(" the "),I(y.$$.fragment),V=i(" should allocate."),x=Y(),M=d("li"),O=d("code"),H=i("commandPoolIndex"),k=d("br"),N=i(`
            The index of the `),I(Q.$$.fragment),X=i(" to allocate the "),I(Z.$$.fragment),K=i(" from."),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"primaryCommandBufferCount"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The amount of Primary `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te," should allocate."),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"secondaryCommandBufferCount"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The amount of Secondary `),S(F.$$.fragment,se),B=f(se," the "),S(y.$$.fragment,se),V=f(se," should allocate."),se.forEach(l),x=j(U),M=g(U,"LI",{});var ae=E(M);O=g(ae,"CODE",{});var J=E(O);H=f(J,"commandPoolIndex"),J.forEach(l),k=g(ae,"BR",{}),N=f(ae,`
            The index of the `),S(Q.$$.fragment,ae),X=f(ae," to allocate the "),S(Z.$$.fragment,ae),K=f(ae," from."),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),D(Z,M,null),o(M,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),y.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(y.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(y.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(y),C(Q),C(Z)}}}function Ah(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rh(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Ah]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Bh(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lh(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Bh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the given index exceeds the max
        possible index of a `),I(n.$$.fragment),s=i(" for this Queue."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if the given index exceeds the max
        possible index of a `),S(n.$$.fragment,p),s=f(p," for this Queue."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function kh(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`CommandRecording* createRecording(
        unsigned int primaryCommandBufferCount, 
        unsigned int secondaryCommandBufferCount,
        unsigned int commandPoolIndex = 0
);`}}),r=new Ce({props:{$$slots:{throws:[Lh],return:[Rh],params:[Ph],details:[Eh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Th extends ve{constructor(e){super(),Ee(this,e,null,kh,be,{})}}function Vh(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oh(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Vh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Submit one or more "),I(r.$$.fragment),$=i(" to be executed by the Queue."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Submit one or more "),S(r.$$.fragment,a),$=f(a," to be executed by the Queue."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Fh(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yh(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mh(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xh(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return a=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Fh]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.FENCE,$$slots:{default:[yh]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Mh]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecordings"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to submit."),p=Y(),m=d("li"),_=d("code"),v=i("pFence"),P=d("br"),R=i(`
            A pointer to a `),I(A.$$.fragment),T=i(" to signal once all submitted "),I(F.$$.fragment),B=i(" have completed execution."),this.h()},l(V){e=g(V,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var M=E(t);r=g(M,"CODE",{});var O=E(r);$=f(O,"pCommandRecordings"),O.forEach(l),n=g(M,"BR",{}),s=f(M,`
            The `),S(a.$$.fragment,M),u=f(M," to submit."),M.forEach(l),p=j(x),m=g(x,"LI",{});var H=E(m);_=g(H,"CODE",{});var k=E(_);v=f(k,"pFence"),k.forEach(l),P=g(H,"BR",{}),R=f(H,`
            A pointer to a `),S(A.$$.fragment,H),T=f(H," to signal once all submitted "),S(F.$$.fragment,H),B=f(H," have completed execution."),H.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,x){h(V,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),y=!0},p(V,x){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),a.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),A.$set(O);const H={};x&1&&(H.$$scope={dirty:x,ctx:V}),F.$set(H)},i(V){y||(b(a.$$.fragment,V),b(A.$$.fragment,V),b(F.$$.fragment,V),y=!0)},o(V){w(a.$$.fragment,V),w(A.$$.fragment,V),w(F.$$.fragment,V),y=!1},d(V){V&&l(e),C(a),C(A),C(F)}}}function Nh(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all Command Recordings were succesfully submitted
        to the Queue. `),n=d("code"),s=i("false"),a=i(` if not all Command Recordings were succesfully
        submitted to the Queue.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all Command Recordings were succesfully submitted
        to the Queue. `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if not all Command Recordings were succesfully
        submitted to the Queue.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Uh(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool submitRecordings(std::vector<CommandRecording*> pCommandRecordings, Fence* pFence = nullptr);"}}),r=new Ce({props:{$$slots:{return:[Nh],params:[xh],details:[Oh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Gh extends ve{constructor(e){super(),Ee(this,e,null,Uh,be,{})}}function Hh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qh(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wh(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kh(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return r=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Hh]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[qh]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Wh]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Qh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Reset a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        This will call `),I(a.$$.fragment),u=i(" on every "),I(p.$$.fragment),m=i(" in the given "),I(_.$$.fragment),v=i("."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var A=E(e);t=f(A,"Reset a "),S(r.$$.fragment,A),$=f(A,"."),n=g(A,"BR",{}),s=f(A,`
        This will call `),S(a.$$.fragment,A),u=f(A," on every "),S(p.$$.fragment,A),m=f(A," in the given "),S(_.$$.fragment,A),v=f(A,"."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(R,A){h(R,e,A),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),r.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),a.$set(F);const B={};A&1&&(B.$$scope={dirty:A,ctx:R}),p.$set(B);const y={};A&1&&(y.$$scope={dirty:A,ctx:R}),_.$set(y)},i(R){P||(b(r.$$.fragment,R),b(a.$$.fragment,R),b(p.$$.fragment,R),b(_.$$.fragment,R),P=!0)},o(R){w(r.$$.fragment,R),w(a.$$.fragment,R),w(p.$$.fragment,R),w(_.$$.fragment,R),P=!1},d(R){R&&l(e),C(r),C(a),C(p),C(_)}}}function zh(c){let e;return{c(){e=i("Command Recordings")},l(t){e=f(t,"Command Recordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yh(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jh(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xh(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return a=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[zh]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Yh]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[jh]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecordings"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to reset."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            Additional actions to perform while resetting the `),I(A.$$.fragment),T=i(". This is a bitmask of "),I(F.$$.fragment),this.h()},l(y){e=g(y,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var x=E(t);r=g(x,"CODE",{});var M=E(r);$=f(M,"pCommandRecordings"),M.forEach(l),n=g(x,"BR",{}),s=f(x,`
            The `),S(a.$$.fragment,x),u=f(x," to reset."),x.forEach(l),p=j(V),m=g(V,"LI",{});var O=E(m);_=g(O,"CODE",{});var H=E(_);v=f(H,"flags"),H.forEach(l),P=g(O,"BR",{}),R=f(O,`
            Additional actions to perform while resetting the `),S(A.$$.fragment,O),T=f(O,". This is a bitmask of "),S(F.$$.fragment,O),O.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(y,V){h(y,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),B=!0},p(y,V){const x={};V&1&&(x.$$scope={dirty:V,ctx:y}),a.$set(x);const M={};V&1&&(M.$$scope={dirty:V,ctx:y}),A.$set(M);const O={};V&1&&(O.$$scope={dirty:V,ctx:y}),F.$set(O)},i(y){B||(b(a.$$.fragment,y),b(A.$$.fragment,y),b(F.$$.fragment,y),B=!0)},o(y){w(a.$$.fragment,y),w(A.$$.fragment,y),w(F.$$.fragment,y),B=!1},d(y){y&&l(e),C(a),C(A),C(F)}}}function Zh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jh(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ed(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Zh]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[Jh]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the "),I(n.$$.fragment),s=i(` was succesfully reset.
        `),a=d("code"),u=i("false"),p=i(" if the "),I(m.$$.fragment),_=i(" failed to reset."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R,` was succesfully reset.
        `),a=g(R,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(R," if the "),S(m.$$.fragment,R),_=f(R," failed to reset."),R.forEach(l),this.h()},h(){z(e,"slot","return")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),m.$set(T)},i(P){v||(b(n.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){P&&l(e),C(n),C(m)}}}function td(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool resetRecording(CommandRecording* pCommandRecording, VkCommandBufferResetFlags flags);"}}),r=new Ce({props:{$$slots:{return:[ed],params:[Xh],details:[Kh]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rd extends ve{constructor(e){super(),Ee(this,e,null,td,be,{})}}function nd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sd(c){let e;return{c(){e=i("freeCommandBuffers")},l(t){e=f(t,"freeCommandBuffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ad(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function od(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ld(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function id(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return r=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[nd]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.COMMAND_POOL_freeCommandBuffers,$$slots:{default:[sd]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[ad]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[od]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[ld]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        This will call `),I(a.$$.fragment),u=i(" on the "),I(p.$$.fragment),m=i(" for all the "),I(_.$$.fragment),v=i(" in the given "),I(P.$$.fragment),R=i("."),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var F=E(e);t=f(F,"Free a "),S(r.$$.fragment,F),$=f(F,"."),n=g(F,"BR",{}),s=f(F,`
        This will call `),S(a.$$.fragment,F),u=f(F," on the "),S(p.$$.fragment,F),m=f(F," for all the "),S(_.$$.fragment,F),v=f(F," in the given "),S(P.$$.fragment,F),R=f(F,"."),F.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,F){h(T,e,F),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),D(P,e,null),o(e,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),r.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),a.$set(y);const V={};F&1&&(V.$$scope={dirty:F,ctx:T}),p.$set(V);const x={};F&1&&(x.$$scope={dirty:F,ctx:T}),_.$set(x);const M={};F&1&&(M.$$scope={dirty:F,ctx:T}),P.$set(M)},i(T){A||(b(r.$$.fragment,T),b(a.$$.fragment,T),b(p.$$.fragment,T),b(_.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(a.$$.fragment,T),w(p.$$.fragment,T),w(_.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(a),C(p),C(_),C(P)}}}function fd(c){let e;return{c(){e=i("Command Recording")},l(t){e=f(t,"Command Recording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cd(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_RECORDING,$$slots:{default:[fd]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandRecording"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to free."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pCommandRecording"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to free."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function $d(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void freeRecording(CommandRecording* pCommandRecording);"}}),r=new Ce({props:{$$slots:{params:[cd],details:[id]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ud extends ve{constructor(e){super(),Ee(this,e,null,$d,be,{})}}function pd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function md(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return _=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[pd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the Queue to become idle."),r=d("br"),$=i(`
        When `),n=d("code"),s=i("waitIdle"),a=i(" returns "),u=d("code"),p=i("true"),m=i(", all "),I(_.$$.fragment),v=i(" sent to the Queue are guaranteed to be completed."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var A=E(e);t=f(A,"Wait for the Queue to become idle."),r=g(A,"BR",{}),$=f(A,`
        When `),n=g(A,"CODE",{});var T=E(n);s=f(T,"waitIdle"),T.forEach(l),a=f(A," returns "),u=g(A,"CODE",{});var F=E(u);p=f(F,"true"),F.forEach(l),m=f(A,", all "),S(_.$$.fragment,A),v=f(A," sent to the Queue are guaranteed to be completed."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(R,A){h(R,e,A),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(u,p),o(e,m),D(_,e,null),o(e,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),_.$set(T)},i(R){P||(b(_.$$.fragment,R),P=!0)},o(R){w(_.$$.fragment,R),P=!1},d(R){R&&l(e),C(_)}}}function hd(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Queue was sucessfully waited on.
        `),n=d("code"),s=i("false"),a=i(` if something went wrong while waiting for the Queue to
        idle.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Queue was sucessfully waited on.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if something went wrong while waiting for the Queue to
        idle.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function dd(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool waitIdle();"}}),r=new Ce({props:{$$slots:{return:[hd],details:[md]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gd extends ve{constructor(e){super(),Ee(this,e,null,dd,be,{})}}function _d(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ed(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Id(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dd(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sd(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return e=new $e({props:{language:ue,code:"#include <fillcan/commands/command_pool.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[_d]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[vd]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Ed]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[bd]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[wd]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Id]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Dd]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Cd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Command Pool"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with the queue family index uses this information to allocate, free and reset
`),I(u.$$.fragment),p=i("."),m=d("br"),_=i(`
The primary purpose of a `),I(v.$$.fragment),P=i(` is to process work on behalf of the application. Work is represented as a series
of commands that are committed to `),I(R.$$.fragment),A=i(". The application will create "),I(T.$$.fragment),F=i(" with the work to be done and send them to one of the "),I(B.$$.fragment),y=i(" for execution. Before commands can be recorded, a "),I(V.$$.fragment),x=i(" must be created. "),I(M.$$.fragment),O=i(" themselves are not created directly, but allocated from Command Pools.")},l(k){S(e.$$.fragment,k),t=f(k,`

The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Command Pool"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k,` along with the queue family index uses this information to allocate, free and reset
`),S(u.$$.fragment,k),p=f(k,"."),m=g(k,"BR",{}),_=f(k,`
The primary purpose of a `),S(v.$$.fragment,k),P=f(k,` is to process work on behalf of the application. Work is represented as a series
of commands that are committed to `),S(R.$$.fragment,k),A=f(k,". The application will create "),S(T.$$.fragment,k),F=f(k," with the work to be done and send them to one of the "),S(B.$$.fragment,k),y=f(k," for execution. Before commands can be recorded, a "),S(V.$$.fragment,k),x=f(k," must be created. "),S(M.$$.fragment,k),O=f(k," themselves are not created directly, but allocated from Command Pools.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),h(k,m,N),h(k,_,N),D(v,k,N),h(k,P,N),D(R,k,N),h(k,A,N),D(T,k,N),h(k,F,N),D(B,k,N),h(k,y,N),D(V,k,N),h(k,x,N),D(M,k,N),h(k,O,N),H=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),v.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),R.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),T.$set(W);const q={};N&1&&(q.$$scope={dirty:N,ctx:k}),B.$set(q);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),V.$set(U);const te={};N&1&&(te.$$scope={dirty:N,ctx:k}),M.$set(te)},i(k){H||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(v.$$.fragment,k),b(R.$$.fragment,k),b(T.$$.fragment,k),b(B.$$.fragment,k),b(V.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(v.$$.fragment,k),w(R.$$.fragment,k),w(T.$$.fragment,k),w(B.$$.fragment,k),w(V.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),k&&l(m),k&&l(_),C(v,k),k&&l(P),C(R,k),k&&l(A),C(T,k),k&&l(F),C(B,k),k&&l(y),C(V,k),k&&l(x),C(M,k),k&&l(O)}}}class Pd extends ve{constructor(e){super(),Ee(this,e,null,Sd,be,{})}}function Ad(c){let e,t;return{c(){e=d("span"),t=i("Create a new Command Pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Command Pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Rd(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bd(c){let e;return{c(){e=i("VkCommandPoolCreateFlagBits")},l(t){e=f(t,"VkCommandPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ld(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kd(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Td(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vd(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Od(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fd(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Rd]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[Bd]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Ld]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[kd]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Td]},$$scope:{ctx:c}}}),te=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Vd]},$$scope:{ctx:c}}}),se=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Od]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Command Pool."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" that specifies usage behavior for the pool and the "),I(F.$$.fragment),B=i(`
            assigned to it.`),y=d("br"),V=i(`
            In order to be able to call `),I(x.$$.fragment),M=i(" on the "),I(O.$$.fragment),H=i(` allocated from this Command Pool the flag
            `),k=d("code"),N=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),Q=i(`
            should be set.`),X=Y(),Z=d("li"),K=d("code"),W=i("queueFamilyIndex"),q=d("br"),U=i(`
            The family index of `),I(te.$$.fragment),ee=i(" where "),I(se.$$.fragment),ie=i(" allocated from this pool are sent."),this.h()},l(J){e=g(J,"DIV",{slot:!0});var pe=E(e);t=g(pe,"LI",{});var Se=E(t);r=g(Se,"CODE",{});var de=E(r);$=f(de,"pLogicalDevice"),de.forEach(l),n=g(Se,"BR",{}),s=f(Se,`
            A pointer to the `),S(a.$$.fragment,Se),u=f(Se," that owns the Command Pool."),Se.forEach(l),p=j(pe),m=g(pe,"LI",{});var me=E(m);_=g(me,"CODE",{});var De=E(_);v=f(De,"flags"),De.forEach(l),P=g(me,"BR",{}),R=f(me,`
            A bitmask of `),S(A.$$.fragment,me),T=f(me," that specifies usage behavior for the pool and the "),S(F.$$.fragment,me),B=f(me,`
            assigned to it.`),y=g(me,"BR",{}),V=f(me,`
            In order to be able to call `),S(x.$$.fragment,me),M=f(me," on the "),S(O.$$.fragment,me),H=f(me,` allocated from this Command Pool the flag
            `),k=g(me,"CODE",{});var _e=E(k);N=f(_e,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),_e.forEach(l),Q=f(me,`
            should be set.`),me.forEach(l),X=j(pe),Z=g(pe,"LI",{});var ne=E(Z);K=g(ne,"CODE",{});var le=E(K);W=f(le,"queueFamilyIndex"),le.forEach(l),q=g(ne,"BR",{}),U=f(ne,`
            The family index of `),S(te.$$.fragment,ne),ee=f(ne," where "),S(se.$$.fragment,ne),ie=f(ne," allocated from this pool are sent."),ne.forEach(l),pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(J,pe){h(J,e,pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),o(m,y),o(m,V),D(x,m,null),o(m,M),D(O,m,null),o(m,H),o(m,k),o(k,N),o(m,Q),o(e,X),o(e,Z),o(Z,K),o(K,W),o(Z,q),o(Z,U),D(te,Z,null),o(Z,ee),D(se,Z,null),o(Z,ie),ae=!0},p(J,pe){const Se={};pe&1&&(Se.$$scope={dirty:pe,ctx:J}),a.$set(Se);const de={};pe&1&&(de.$$scope={dirty:pe,ctx:J}),A.$set(de);const me={};pe&1&&(me.$$scope={dirty:pe,ctx:J}),F.$set(me);const De={};pe&1&&(De.$$scope={dirty:pe,ctx:J}),x.$set(De);const _e={};pe&1&&(_e.$$scope={dirty:pe,ctx:J}),O.$set(_e);const ne={};pe&1&&(ne.$$scope={dirty:pe,ctx:J}),te.$set(ne);const le={};pe&1&&(le.$$scope={dirty:pe,ctx:J}),se.$set(le)},i(J){ae||(b(a.$$.fragment,J),b(A.$$.fragment,J),b(F.$$.fragment,J),b(x.$$.fragment,J),b(O.$$.fragment,J),b(te.$$.fragment,J),b(se.$$.fragment,J),ae=!0)},o(J){w(a.$$.fragment,J),w(A.$$.fragment,J),w(F.$$.fragment,J),w(x.$$.fragment,J),w(O.$$.fragment,J),w(te.$$.fragment,J),w(se.$$.fragment,J),ae=!1},d(J){J&&l(e),C(a),C(A),C(F),C(x),C(O),C(te),C(se)}}}function yd(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Md(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[yd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function xd(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"CommandPool(LogicalDevice* pLogicalDevice, VkCommandPoolCreateFlags flags, unsigned int queueFamilyIndex);"}}),r=new Ce({props:{$$slots:{throws:[Md],params:[Fd],details:[Ad]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Nd extends ve{constructor(e){super(),Ee(this,e,null,xd,be,{})}}function Ud(c){let e,t;return{c(){e=d("span"),t=i("Allocate Command Buffers from the pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Allocate Command Buffers from the pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Gd(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qd(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",$$slots:{default:[Gd]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Hd]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("level"),n=d("br"),s=i(`
            The level at which the allocated Command Buffers operate. This should
            be a member of the `),I(a.$$.fragment),u=i("-enumerant."),p=Y(),m=d("li"),_=d("code"),v=i("commandBufferCount"),P=d("br"),R=i(`
            The amount of `),I(A.$$.fragment),T=i(" to allocate."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"level"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The level at which the allocated Command Buffers operate. This should
            be a member of the `),S(a.$$.fragment,V),u=f(V,"-enumerant."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"commandBufferCount"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            The amount of `),S(A.$$.fragment,M),T=f(M," to allocate."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function Wd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qd(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Wd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Kd(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<CommandBuffer*> allocateCommandBuffers(VkCommandBufferLevel level, unsigned int commandBufferCount);"}}),r=new Ce({props:{$$slots:{return:[Qd],params:[qd],details:[Ud]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zd extends ve{constructor(e){super(),Ee(this,e,null,Kd,be,{})}}function Yd(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jd(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Yd]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free the given Command Buffers."),r=d("br"),$=i(`
        Freeing a `),I(n.$$.fragment),s=i(` does not necessarily free all its resources, but returns them to the Command
        Pool from which they were allocated.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Free the given Command Buffers."),r=g(p,"BR",{}),$=f(p,`
        Freeing a `),S(n.$$.fragment,p),s=f(p,` does not necessarily free all its resources, but returns them to the Command
        Pool from which they were allocated.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Xd(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zd(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Xd]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffers"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to free."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pCommandBuffers"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to free."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function Jd(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void freeCommandBuffers(std::vector<CommandBuffer*> pCommandBuffers);"}}),r=new Ce({props:{$$slots:{params:[Zd],details:[jd]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eg extends ve{constructor(e){super(),Ee(this,e,null,Jd,be,{})}}function tg(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rg(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[tg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Reset the Command Pool."),r=d("br"),$=i(`
        Resets all the `),I(n.$$.fragment),s=i(" allocated from this Command Pool."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Reset the Command Pool."),r=g(p,"BR",{}),$=f(p,`
        Resets all the `),S(n.$$.fragment,p),s=f(p," allocated from this Command Pool."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ng(c){let e;return{c(){e=i("VkCommandPoolResetFlagBits")},l(t){e=f(t,"VkCommandPoolResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sg(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html",target:"_blank",$$slots:{default:[ng]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the command pool. This
            is a bitmask of `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"flags"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            Additional actions to perform while resetting the command pool. This
            is a bitmask of `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function ag(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Pool was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Command Pool failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Pool was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Pool failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function og(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool reset(VkCommandPoolResetFlags flags);"}}),r=new Ce({props:{$$slots:{return:[ag],params:[sg],details:[rg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class lg extends ve{constructor(e){super(),Ee(this,e,null,og,be,{})}}function ig(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[ig]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function cg(c){let e;return{c(){e=i("Vulkan Command Pool")},l(t){e=f(t,"Vulkan Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $g(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html",target:"_blank",$$slots:{default:[cg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ug(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkCommandPool getCommandPoolHandle() const;"}}),r=new Ce({props:{$$slots:{return:[$g],details:[fg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class pg extends ve{constructor(e){super(),Ee(this,e,null,ug,be,{})}}function mg(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[mg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function dg(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[dg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _g(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkCommandBuffer getCommandBufferHandle() const;"}}),r=new Ce({props:{$$slots:{return:[gg],details:[hg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vg extends ve{constructor(e){super(),Ee(this,e,null,_g,be,{})}}function Eg(c){let e,t;return{c(){e=d("span"),t=i("Get the level at which the Command Buffer operates."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the level at which the Command Buffer operates."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function bg(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wg(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",target:"_blank",$$slots:{default:[bg]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`The level at which the Command Buffer operates. This is a member of the
        `),I(r.$$.fragment),$=i("-enumerant."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`The level at which the Command Buffer operates. This is a member of the
        `),S(r.$$.fragment,a),$=f(a,"-enumerant."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ig(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkCommandBufferLevel getLevel() const;"}}),r=new Ce({props:{$$slots:{return:[wg],details:[Eg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Dg extends ve{constructor(e){super(),Ee(this,e,null,Ig,be,{})}}function Cg(c){let e,t;return{c(){e=d("span"),t=i("Start the Command Buffer, which resets it to an initial state."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Start the Command Buffer, which resets it to an initial state."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Sg(c){let e;return{c(){e=i("VkCommandBufferUsageFlagBits")},l(t){e=f(t,"VkCommandBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Pg(c){let e;return{c(){e=i("VkCommandBufferInheritanceInfo")},l(t){e=f(t,"VkCommandBufferInheritanceInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ag(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[Sg]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html",target:"_blank",$$slots:{default:[Pg]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" telling Vulkan how the Command Buffer will be used."),p=Y(),m=d("li"),_=d("code"),v=i("pSecondaryCommandBufferInheritanceInfo"),P=d("br"),R=i(`
            A `),I(A.$$.fragment),T=i(`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"flags"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            A bitmask of `),S(a.$$.fragment,V),u=f(V," telling Vulkan how the Command Buffer will be used."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"pSecondaryCommandBufferInheritanceInfo"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            A `),S(A.$$.fragment,M),T=f(M,`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function Rg(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully started.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to start."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully started.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to start."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Bg(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`bool begin(
        VkCommandBufferUsageFlags flags = 0, 
        VkCommandBufferInheritanceInfo* pSecondaryCommandBufferInheritanceInfo = nullptr
);`}}),r=new Ce({props:{$$slots:{return:[Rg],params:[Ag],details:[Cg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Lg extends ve{constructor(e){super(),Ee(this,e,null,Bg,be,{})}}function kg(c){let e,t,r,$;return{c(){e=d("span"),t=i("End the Command Buffer."),r=d("br"),$=i(`
        Before the Command Buffer is ready to be sent to the device for execution,
        we need to tell Vulkan that we're done recording commands in it.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"End the Command Buffer."),r=g(s,"BR",{}),$=f(s,`
        Before the Command Buffer is ready to be sent to the device for execution,
        we need to tell Vulkan that we're done recording commands in it.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function Tg(c){let e;return{c(){e=i("VkCommandBufferUsageFlagBits")},l(t){e=f(t,"VkCommandBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vg(c){let e;return{c(){e=i("VkCommandBufferInheritanceInfo")},l(t){e=f(t,"VkCommandBufferInheritanceInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Og(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[Tg]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html",target:"_blank",$$slots:{default:[Vg]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" telling Vulkan how the Command Buffer will be used."),p=Y(),m=d("li"),_=d("code"),v=i("pSecondaryCommandBufferInheritanceInfo"),P=d("br"),R=i(`
            A `),I(A.$$.fragment),T=i(`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"flags"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            A bitmask of `),S(a.$$.fragment,V),u=f(V," telling Vulkan how the Command Buffer will be used."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"pSecondaryCommandBufferInheritanceInfo"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            A `),S(A.$$.fragment,M),T=f(M,`-structure used when starting a secondary Command Buffer to define
            which states are inherited from the primary Command Buffer that
            calls it. For primary Command Buffers, this pointer is ignored.`),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function Fg(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully ended.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to end."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully ended.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to end."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function yg(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool end();"}}),r=new Ce({props:{$$slots:{return:[Fg],params:[Og],details:[kg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Mg extends ve{constructor(e){super(),Ee(this,e,null,yg,be,{})}}function xg(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ng(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ug(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return p=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[xg]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Ng]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Start the Command Buffer, which resets it to an initial state."),r=d("br"),$=i(`

        Many applications use a similar set of commands to render all or part of
        each frame. Therefore, it is likely that similar Command Buffers are
        included in the application over and over again.`),n=d("br"),s=i(`
        Allocating and freeing Command Buffers every frame is a relatively heavy
        operation. If the application reuses a Command Buffer many times in a row
        for similar work, it may be more efficient to reset the Command Buffer.`),a=d("br"),u=i(`
        This effectively restores the Command Buffer to its original state, but does
        not necessarily interact with the `),I(p.$$.fragment),m=i(` to do so. Therefore, if the Command Buffer dynamically allocates resources
        from the `),I(_.$$.fragment),v=i(` as the Command Buffer grows, the Command Buffer can hold onto those resources
        and avoid the cost of reallocation the next time it is rebuilt.`),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var A=E(e);t=f(A,"Start the Command Buffer, which resets it to an initial state."),r=g(A,"BR",{}),$=f(A,`

        Many applications use a similar set of commands to render all or part of
        each frame. Therefore, it is likely that similar Command Buffers are
        included in the application over and over again.`),n=g(A,"BR",{}),s=f(A,`
        Allocating and freeing Command Buffers every frame is a relatively heavy
        operation. If the application reuses a Command Buffer many times in a row
        for similar work, it may be more efficient to reset the Command Buffer.`),a=g(A,"BR",{}),u=f(A,`
        This effectively restores the Command Buffer to its original state, but does
        not necessarily interact with the `),S(p.$$.fragment,A),m=f(A,` to do so. Therefore, if the Command Buffer dynamically allocates resources
        from the `),S(_.$$.fragment,A),v=f(A,` as the Command Buffer grows, the Command Buffer can hold onto those resources
        and avoid the cost of reallocation the next time it is rebuilt.`),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(R,A){h(R,e,A),o(e,t),o(e,r),o(e,$),o(e,n),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),D(_,e,null),o(e,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),p.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),_.$set(F)},i(R){P||(b(p.$$.fragment,R),b(_.$$.fragment,R),P=!0)},o(R){w(p.$$.fragment,R),w(_.$$.fragment,R),P=!1},d(R){R&&l(e),C(p),C(_)}}}function Gg(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hg(c){let e,t,r,$,n,s,a,u,p,m,_;return p=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[Gg]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the command buffer.`),a=d("br"),u=i(`
            This is a bitmask of `),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"flags"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            Additional actions to perform while resetting the command buffer.`),a=g(R,"BR",{}),u=f(R,`
            This is a bitmask of `),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),p.$set(R)},i(v){_||(b(p.$$.fragment,v),_=!0)},o(v){w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(p)}}}function qg(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Command Buffer was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Command Buffer failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Command Buffer was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Command Buffer failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Wg(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool reset(VkCommandBufferResetFlags flags = 0);"}}),r=new Ce({props:{$$slots:{return:[qg],params:[Hg],details:[Ug]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Qg extends ve{constructor(e){super(),Ee(this,e,null,Wg,be,{})}}function Kg(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zg(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yg(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jg(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K;return e=new $e({props:{language:ue,code:"#include <fillcan/commands/command_buffer.hpp>"}}),s=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[Kg]},$$scope:{ctx:c}}}),P=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[zg]},$$scope:{ctx:c}}}),X=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Yg]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Command Buffer"),n=i(" class takes in a handle to a "),I(s.$$.fragment),a=i(" and the level of the Command Buffer."),u=d("br"),p=i(`
With this information the `),m=d("code"),_=i("Command Buffer"),v=i(` class acts as a wrapper
around the `),I(P.$$.fragment),R=i(" for beginning, ending and resetting the Command Buffer."),A=d("br"),T=i(`
All commands for the GPU are stored in a Command Buffer. All functions that perform
GPU work do nothing until the Command Buffer is sent to the GPU.`),F=d("br"),B=i(`
Access to the Command Buffer must be synchronized externally, which means that it
is the responsibility of the application to ensure that no two threads simultaneously
try to insert commands into the same Command Buffer at the same time.`),y=d("br"),V=i(`
However, the following is perfectly acceptable:
`),x=d("ul"),M=d("li"),O=i(`One thread can record commands in multiple Command Buffers by simply
        calling Command Buffer functions sequentially on different Command
        Buffers.`),H=Y(),k=d("li"),N=i(`Two or more threads can participate in building a single Command Buffer,
        as long as the application can guarantee that no two of the threads ever
        run a Command Buffer build function simultaneously.`),Q=i(`
One of Vulkan's key design principles is to enable efficient multithreading. To achieve
this, it is important that the application threads do not block each other's execution.
For this reason, it is good practice to have one or more Command Buffers for each
thread rather than sharing one. Furthermore, since Command Buffers are allocated
from pools, one can go further by creating a `),I(X.$$.fragment),Z=i(` for each thread, so that Command Buffers can be allocated by the worker threads
from their respective pools without these worker threads interacting with each other.`)},l(W){S(e.$$.fragment,W),t=f(W,`

The `),r=g(W,"CODE",{});var q=E(r);$=f(q,"Command Buffer"),q.forEach(l),n=f(W," class takes in a handle to a "),S(s.$$.fragment,W),a=f(W," and the level of the Command Buffer."),u=g(W,"BR",{}),p=f(W,`
With this information the `),m=g(W,"CODE",{});var U=E(m);_=f(U,"Command Buffer"),U.forEach(l),v=f(W,` class acts as a wrapper
around the `),S(P.$$.fragment,W),R=f(W," for beginning, ending and resetting the Command Buffer."),A=g(W,"BR",{}),T=f(W,`
All commands for the GPU are stored in a Command Buffer. All functions that perform
GPU work do nothing until the Command Buffer is sent to the GPU.`),F=g(W,"BR",{}),B=f(W,`
Access to the Command Buffer must be synchronized externally, which means that it
is the responsibility of the application to ensure that no two threads simultaneously
try to insert commands into the same Command Buffer at the same time.`),y=g(W,"BR",{}),V=f(W,`
However, the following is perfectly acceptable:
`),x=g(W,"UL",{});var te=E(x);M=g(te,"LI",{});var ee=E(M);O=f(ee,`One thread can record commands in multiple Command Buffers by simply
        calling Command Buffer functions sequentially on different Command
        Buffers.`),ee.forEach(l),H=j(te),k=g(te,"LI",{});var se=E(k);N=f(se,`Two or more threads can participate in building a single Command Buffer,
        as long as the application can guarantee that no two of the threads ever
        run a Command Buffer build function simultaneously.`),se.forEach(l),te.forEach(l),Q=f(W,`
One of Vulkan's key design principles is to enable efficient multithreading. To achieve
this, it is important that the application threads do not block each other's execution.
For this reason, it is good practice to have one or more Command Buffers for each
thread rather than sharing one. Furthermore, since Command Buffers are allocated
from pools, one can go further by creating a `),S(X.$$.fragment,W),Z=f(W,` for each thread, so that Command Buffers can be allocated by the worker threads
from their respective pools without these worker threads interacting with each other.`)},m(W,q){D(e,W,q),h(W,t,q),h(W,r,q),o(r,$),h(W,n,q),D(s,W,q),h(W,a,q),h(W,u,q),h(W,p,q),h(W,m,q),o(m,_),h(W,v,q),D(P,W,q),h(W,R,q),h(W,A,q),h(W,T,q),h(W,F,q),h(W,B,q),h(W,y,q),h(W,V,q),h(W,x,q),o(x,M),o(M,O),o(x,H),o(x,k),o(k,N),h(W,Q,q),D(X,W,q),h(W,Z,q),K=!0},p(W,[q]){const U={};q&1&&(U.$$scope={dirty:q,ctx:W}),s.$set(U);const te={};q&1&&(te.$$scope={dirty:q,ctx:W}),P.$set(te);const ee={};q&1&&(ee.$$scope={dirty:q,ctx:W}),X.$set(ee)},i(W){K||(b(e.$$.fragment,W),b(s.$$.fragment,W),b(P.$$.fragment,W),b(X.$$.fragment,W),K=!0)},o(W){w(e.$$.fragment,W),w(s.$$.fragment,W),w(P.$$.fragment,W),w(X.$$.fragment,W),K=!1},d(W){C(e,W),W&&l(t),W&&l(r),W&&l(n),C(s,W),W&&l(a),W&&l(u),W&&l(p),W&&l(m),W&&l(v),C(P,W),W&&l(R),W&&l(A),W&&l(T),W&&l(F),W&&l(B),W&&l(y),W&&l(V),W&&l(x),W&&l(Q),C(X,W),W&&l(Z)}}}class Xg extends ve{constructor(e){super(),Ee(this,e,null,jg,be,{})}}function Zg(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jg(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t_(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Zg]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[Jg]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[e_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        The Queue automatically creates one `),I(a.$$.fragment),u=i(" on construction, this "),I(p.$$.fragment),m=i(" has both the "),_=d("code"),v=i("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),P=i(`-flag
        and `),R=d("code"),A=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),T=i(`-flag
        set.`),this.h()},l(B){e=g(B,"SPAN",{slot:!0});var y=E(e);t=f(y,"Create a "),S(r.$$.fragment,y),$=f(y,"."),n=g(y,"BR",{}),s=f(y,`
        The Queue automatically creates one `),S(a.$$.fragment,y),u=f(y," on construction, this "),S(p.$$.fragment,y),m=f(y," has both the "),_=g(y,"CODE",{});var V=E(_);v=f(V,"VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),V.forEach(l),P=f(y,`-flag
        and `),R=g(y,"CODE",{});var x=E(R);A=f(x,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),x.forEach(l),T=f(y,`-flag
        set.`),y.forEach(l),this.h()},h(){z(e,"slot","details")},m(B,y){h(B,e,y),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),o(e,_),o(_,v),o(e,P),o(e,R),o(R,A),o(e,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),r.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),a.$set(x);const M={};y&1&&(M.$$scope={dirty:y,ctx:B}),p.$set(M)},i(B){F||(b(r.$$.fragment,B),b(a.$$.fragment,B),b(p.$$.fragment,B),F=!0)},o(B){w(r.$$.fragment,B),w(a.$$.fragment,B),w(p.$$.fragment,B),F=!1},d(B){B&&l(e),C(r),C(a),C(p)}}}function r_(c){let e;return{c(){e=i("VkCommandPoolCreateFlagBits")},l(t){e=f(t,"VkCommandPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s_(c){let e;return{c(){e=i("reset")},l(t){e=f(t,"reset")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o_(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[r_]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[n_]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.COMMAND_BUFFER_reset,$$slots:{default:[s_]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[a_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that specifies usage behavior for the pool and the "),I(p.$$.fragment),m=i(`
            assigned to it.`),_=d("br"),v=i(`
            In order to be able to call `),I(P.$$.fragment),R=i(" on the "),I(A.$$.fragment),T=i(` allocated from this Command Pool the flag
            `),F=d("code"),B=i("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),y=i(`
            should be set.`),this.h()},l(x){e=g(x,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var H=E(r);$=f(H,"flags"),H.forEach(l),n=g(O,"BR",{}),s=f(O,`
            A bitmask of `),S(a.$$.fragment,O),u=f(O," that specifies usage behavior for the pool and the "),S(p.$$.fragment,O),m=f(O,`
            assigned to it.`),_=g(O,"BR",{}),v=f(O,`
            In order to be able to call `),S(P.$$.fragment,O),R=f(O," on the "),S(A.$$.fragment,O),T=f(O,` allocated from this Command Pool the flag
            `),F=g(O,"CODE",{});var k=E(F);B=f(k,"VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),k.forEach(l),y=f(O,`
            should be set.`),O.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(x,M){h(x,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(t,v),D(P,t,null),o(t,R),D(A,t,null),o(t,T),o(t,F),o(F,B),o(t,y),V=!0},p(x,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:x}),a.$set(O);const H={};M&1&&(H.$$scope={dirty:M,ctx:x}),p.$set(H);const k={};M&1&&(k.$$scope={dirty:M,ctx:x}),P.$set(k);const N={};M&1&&(N.$$scope={dirty:M,ctx:x}),A.$set(N)},i(x){V||(b(a.$$.fragment,x),b(p.$$.fragment,x),b(P.$$.fragment,x),b(A.$$.fragment,x),V=!0)},o(x){w(a.$$.fragment,x),w(p.$$.fragment,x),w(P.$$.fragment,x),w(A.$$.fragment,x),V=!1},d(x){x&&l(e),C(a),C(p),C(P),C(A)}}}function l_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f_(c){let e;return{c(){e=i("getCommandPool")},l(t){e=f(t,"getCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c_(c){let e,t,r,$,n,s,a,u,p;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[l_]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[i_]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.QUEUE_getCommandPool,$$slots:{default:[f_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to request the "),I(n.$$.fragment),s=i(" with "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to request the "),S(n.$$.fragment,_),s=f(_," with "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),n.$set(P);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function $_(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int createCommandPool(VkCommandPoolCreateFlags flags);"}}),r=new Ce({props:{$$slots:{return:[c_],params:[o_],details:[t_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class u_ extends ve{constructor(e){super(),Ee(this,e,null,$_,be,{})}}function p_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m_(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[p_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function h_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d_(c){let e;return{c(){e=i("createCommandPool")},l(t){e=f(t,"createCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g_(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[h_]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.QUEUE_createCommandPool,$$slots:{default:[d_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" to get. This index was returned by "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The index of the `),S(a.$$.fragment,R),u=f(R," to get. This index was returned by "),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function __(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v_(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[__]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function E_(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"CommandPool* getCommandPool(unsigned int index = 0);"}}),r=new Ce({props:{$$slots:{return:[v_],params:[g_],details:[m_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class b_ extends ve{constructor(e){super(),Ee(this,e,null,E_,be,{})}}function w_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I_(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[w_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function D_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C_(c){let e;return{c(){e=i("createCommandPool")},l(t){e=f(t,"createCommandPool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S_(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[D_]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.QUEUE_createCommandPool,$$slots:{default:[C_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index of the `),I(a.$$.fragment),u=i(" to destroy. This index was returned by "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"index"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The index of the `),S(a.$$.fragment,R),u=f(R," to destroy. This index was returned by "),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function P_(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroyCommandPool(unsigned int index);"}}),r=new Ce({props:{$$slots:{params:[S_],details:[I_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class A_ extends ve{constructor(e){super(),Ee(this,e,null,P_,be,{})}}function R_(c){let e,t;return{c(){e=d("span"),t=i("Create a new Command Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Command Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function B_(c){let e;return{c(){e=i("Vulkan Command Buffer")},l(t){e=f(t,"Vulkan Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L_(c){let e;return{c(){e=i("VkCommandBufferLevel")},l(t){e=f(t,"VkCommandBufferLevel")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k_(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html",target:"_blank",$$slots:{default:[B_]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html",target:"_blank",$$slots:{default:[L_]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("hCommandBuffer"),n=d("br"),s=i(`
            A handle to the `),I(a.$$.fragment),u=i(" to wrap."),p=Y(),m=d("li"),_=d("code"),v=i("level"),P=d("br"),R=i(`
            The level at which the Command Buffer operates. This should be a member
            of the `),I(A.$$.fragment),T=i("-enumerant."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"hCommandBuffer"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            A handle to the `),S(a.$$.fragment,V),u=f(V," to wrap."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"level"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            The level at which the Command Buffer operates. This should be a member
            of the `),S(A.$$.fragment,M),T=f(M,"-enumerant."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function T_(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"CommandBuffer(VkCommandBuffer hCommandBuffer, VkCommandBufferLevel level);"}}),r=new Ce({props:{$$slots:{params:[k_],details:[R_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class V_ extends ve{constructor(e){super(),Ee(this,e,null,T_,be,{})}}function O_(c){let e;return{c(){e=i("Command Pools")},l(t){e=f(t,"Command Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F_(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[O_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function y_(c){let e;return{c(){e=i("Command Pools")},l(t){e=f(t,"Command Pools")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M_(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[y_]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function x_(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<CommandPool*> getCommandPools();"}}),r=new Ce({props:{$$slots:{return:[M_],details:[F_]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class N_ extends ve{constructor(e){super(),Ee(this,e,null,x_,be,{})}}function U_(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G_(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H_(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q_(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W_(c){let e;return{c(){e=i("Command Pool")},l(t){e=f(t,"Command Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y_(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X_(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z_(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J_(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ev(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nv(c){let e;return{c(){e=i("createFence")},l(t){e=f(t,"createFence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sv(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St,tt,ot,At;return a=new G({props:{sectionID:L.QUEUE,$$slots:{default:[q_]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.COMMAND_POOL,$$slots:{default:[W_]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Q_]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[K_]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[z_]},$$scope:{ctx:c}}}),Se=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[Y_]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[j_]},$$scope:{ctx:c}}}),Be=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[X_]},$$scope:{ctx:c}}}),Me=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[Z_]},$$scope:{ctx:c}}}),$t=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[J_]},$$scope:{ctx:c}}}),Qe=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[ev]},$$scope:{ctx:c}}}),st=new G({props:{sectionID:L.FENCE,$$slots:{default:[tv]},$$scope:{ctx:c}}}),at=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[rv]},$$scope:{ctx:c}}}),tt=new G({props:{sectionID:L.COMMAND_RECORDING_createFence,$$slots:{default:[nv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("pQueue"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(` that owns
            this recording.`),p=Y(),m=d("li"),_=d("code"),v=i("pCommandPool"),P=d("br"),R=i(`
            The `),I(A.$$.fragment),T=i(" the "),I(F.$$.fragment),B=i(" were allocated from."),y=Y(),V=d("li"),x=d("code"),M=i("pPrimaryCommandBuffers"),O=d("br"),H=i(`
            The allocated primary `),I(k.$$.fragment),N=i(" that can be recorded to."),Q=Y(),X=d("li"),Z=d("code"),K=i("pSecondaryCommandBuffers"),W=d("br"),q=i(`
            The allocated secondary `),I(U.$$.fragment),te=i(" that can be recorded to."),ee=Y(),se=d("li"),ie=d("code"),ae=i("pWaitSemaphores"),J=d("br"),pe=i(`
            A list of pointers to `),I(Se.$$.fragment),de=i(" to wait for before executing the "),I(me.$$.fragment),De=i("."),_e=Y(),ne=d("li"),le=d("code"),ge=i("waitDstStageMask"),we=d("br"),Pe=i(`
            An array of pipeline stages, which is a bitmask of `),I(Be.$$.fragment),Ie=i(", at which each corresponding semaphore wait will occur."),re=d("br"),he=i(`
            So the semaphore at index `),Le=d("code"),Oe=i("0"),oe=i(` will wait at the pipeline
            stage at index
            `),ce=d("code"),Ae=i("0"),ye=i(", the semaphore at index "),Fe=d("code"),Ve=i("1"),Ge=i(` will wait at
            the pipeline stage at index
            `),He=d("code"),ze=i("1"),xe=i(", etc."),Ne=Y(),Te=d("li"),qe=d("code"),Ke=i("pSignalSemaphores"),je=d("br"),rt=i(`
            A list of pointers to `),I(Me.$$.fragment),Ue=i(" that are signaled when the "),I($t.$$.fragment),ut=i(" have finished execution."),ht=Y(),Je=d("li"),dt=d("code"),et=i("upFenceWorkCompleted"),Ze=d("br"),nt=i(`
            A `),I(Qe.$$.fragment),ct=i(" to a "),I(st.$$.fragment),We=i(` that
            will be signaled once the `),I(at.$$.fragment),bt=i(" have finished execution."),wt=d("br"),St=i(`
            To initialize this Fence, call `),I(tt.$$.fragment),ot=i("."),this.h()},l(it){e=g(it,"SPAN",{slot:!0});var Xe=E(e);t=g(Xe,"LI",{});var Dt=E(t);r=g(Dt,"CODE",{});var Ct=E(r);$=f(Ct,"pQueue"),Ct.forEach(l),n=g(Dt,"BR",{}),s=f(Dt,`
            The `),S(a.$$.fragment,Dt),u=f(Dt,` that owns
            this recording.`),Dt.forEach(l),p=j(Xe),m=g(Xe,"LI",{});var pt=E(m);_=g(pt,"CODE",{});var Ft=E(_);v=f(Ft,"pCommandPool"),Ft.forEach(l),P=g(pt,"BR",{}),R=f(pt,`
            The `),S(A.$$.fragment,pt),T=f(pt," the "),S(F.$$.fragment,pt),B=f(pt," were allocated from."),pt.forEach(l),y=j(Xe),V=g(Xe,"LI",{});var mt=E(V);x=g(mt,"CODE",{});var Vt=E(x);M=f(Vt,"pPrimaryCommandBuffers"),Vt.forEach(l),O=g(mt,"BR",{}),H=f(mt,`
            The allocated primary `),S(k.$$.fragment,mt),N=f(mt," that can be recorded to."),mt.forEach(l),Q=j(Xe),X=g(Xe,"LI",{});var Rt=E(X);Z=g(Rt,"CODE",{});var Tt=E(Z);K=f(Tt,"pSecondaryCommandBuffers"),Tt.forEach(l),W=g(Rt,"BR",{}),q=f(Rt,`
            The allocated secondary `),S(U.$$.fragment,Rt),te=f(Rt," that can be recorded to."),Rt.forEach(l),ee=j(Xe),se=g(Xe,"LI",{});var vt=E(se);ie=g(vt,"CODE",{});var gt=E(ie);ae=f(gt,"pWaitSemaphores"),gt.forEach(l),J=g(vt,"BR",{}),pe=f(vt,`
            A list of pointers to `),S(Se.$$.fragment,vt),de=f(vt," to wait for before executing the "),S(me.$$.fragment,vt),De=f(vt,"."),vt.forEach(l),_e=j(Xe),ne=g(Xe,"LI",{});var kt=E(ne);le=g(kt,"CODE",{});var Mt=E(le);ge=f(Mt,"waitDstStageMask"),Mt.forEach(l),we=g(kt,"BR",{}),Pe=f(kt,`
            An array of pipeline stages, which is a bitmask of `),S(Be.$$.fragment,kt),Ie=f(kt,", at which each corresponding semaphore wait will occur."),re=g(kt,"BR",{}),he=f(kt,`
            So the semaphore at index `),Le=g(kt,"CODE",{});var yt=E(Le);Oe=f(yt,"0"),yt.forEach(l),oe=f(kt,` will wait at the pipeline
            stage at index
            `),ce=g(kt,"CODE",{});var Ht=E(ce);Ae=f(Ht,"0"),Ht.forEach(l),ye=f(kt,", the semaphore at index "),Fe=g(kt,"CODE",{});var $r=E(Fe);Ve=f($r,"1"),$r.forEach(l),Ge=f(kt,` will wait at
            the pipeline stage at index
            `),He=g(kt,"CODE",{});var Ut=E(He);ze=f(Ut,"1"),Ut.forEach(l),xe=f(kt,", etc."),kt.forEach(l),Ne=j(Xe),Te=g(Xe,"LI",{});var or=E(Te);qe=g(or,"CODE",{});var Xt=E(qe);Ke=f(Xt,"pSignalSemaphores"),Xt.forEach(l),je=g(or,"BR",{}),rt=f(or,`
            A list of pointers to `),S(Me.$$.fragment,or),Ue=f(or," that are signaled when the "),S($t.$$.fragment,or),ut=f(or," have finished execution."),or.forEach(l),ht=j(Xe),Je=g(Xe,"LI",{});var Ot=E(Je);dt=g(Ot,"CODE",{});var Zt=E(dt);et=f(Zt,"upFenceWorkCompleted"),Zt.forEach(l),Ze=g(Ot,"BR",{}),nt=f(Ot,`
            A `),S(Qe.$$.fragment,Ot),ct=f(Ot," to a "),S(st.$$.fragment,Ot),We=f(Ot,` that
            will be signaled once the `),S(at.$$.fragment,Ot),bt=f(Ot," have finished execution."),wt=g(Ot,"BR",{}),St=f(Ot,`
            To initialize this Fence, call `),S(tt.$$.fragment,Ot),ot=f(Ot,"."),Ot.forEach(l),Xe.forEach(l),this.h()},h(){z(e,"slot","params")},m(it,Xe){h(it,e,Xe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),D(U,X,null),o(X,te),o(e,ee),o(e,se),o(se,ie),o(ie,ae),o(se,J),o(se,pe),D(Se,se,null),o(se,de),D(me,se,null),o(se,De),o(e,_e),o(e,ne),o(ne,le),o(le,ge),o(ne,we),o(ne,Pe),D(Be,ne,null),o(ne,Ie),o(ne,re),o(ne,he),o(ne,Le),o(Le,Oe),o(ne,oe),o(ne,ce),o(ce,Ae),o(ne,ye),o(ne,Fe),o(Fe,Ve),o(ne,Ge),o(ne,He),o(He,ze),o(ne,xe),o(e,Ne),o(e,Te),o(Te,qe),o(qe,Ke),o(Te,je),o(Te,rt),D(Me,Te,null),o(Te,Ue),D($t,Te,null),o(Te,ut),o(e,ht),o(e,Je),o(Je,dt),o(dt,et),o(Je,Ze),o(Je,nt),D(Qe,Je,null),o(Je,ct),D(st,Je,null),o(Je,We),D(at,Je,null),o(Je,bt),o(Je,wt),o(Je,St),D(tt,Je,null),o(Je,ot),At=!0},p(it,Xe){const Dt={};Xe&1&&(Dt.$$scope={dirty:Xe,ctx:it}),a.$set(Dt);const Ct={};Xe&1&&(Ct.$$scope={dirty:Xe,ctx:it}),A.$set(Ct);const pt={};Xe&1&&(pt.$$scope={dirty:Xe,ctx:it}),F.$set(pt);const Ft={};Xe&1&&(Ft.$$scope={dirty:Xe,ctx:it}),k.$set(Ft);const mt={};Xe&1&&(mt.$$scope={dirty:Xe,ctx:it}),U.$set(mt);const Vt={};Xe&1&&(Vt.$$scope={dirty:Xe,ctx:it}),Se.$set(Vt);const Rt={};Xe&1&&(Rt.$$scope={dirty:Xe,ctx:it}),me.$set(Rt);const Tt={};Xe&1&&(Tt.$$scope={dirty:Xe,ctx:it}),Be.$set(Tt);const vt={};Xe&1&&(vt.$$scope={dirty:Xe,ctx:it}),Me.$set(vt);const gt={};Xe&1&&(gt.$$scope={dirty:Xe,ctx:it}),$t.$set(gt);const kt={};Xe&1&&(kt.$$scope={dirty:Xe,ctx:it}),Qe.$set(kt);const Mt={};Xe&1&&(Mt.$$scope={dirty:Xe,ctx:it}),st.$set(Mt);const yt={};Xe&1&&(yt.$$scope={dirty:Xe,ctx:it}),at.$set(yt);const Ht={};Xe&1&&(Ht.$$scope={dirty:Xe,ctx:it}),tt.$set(Ht)},i(it){At||(b(a.$$.fragment,it),b(A.$$.fragment,it),b(F.$$.fragment,it),b(k.$$.fragment,it),b(U.$$.fragment,it),b(Se.$$.fragment,it),b(me.$$.fragment,it),b(Be.$$.fragment,it),b(Me.$$.fragment,it),b($t.$$.fragment,it),b(Qe.$$.fragment,it),b(st.$$.fragment,it),b(at.$$.fragment,it),b(tt.$$.fragment,it),At=!0)},o(it){w(a.$$.fragment,it),w(A.$$.fragment,it),w(F.$$.fragment,it),w(k.$$.fragment,it),w(U.$$.fragment,it),w(Se.$$.fragment,it),w(me.$$.fragment,it),w(Be.$$.fragment,it),w(Me.$$.fragment,it),w($t.$$.fragment,it),w(Qe.$$.fragment,it),w(st.$$.fragment,it),w(at.$$.fragment,it),w(tt.$$.fragment,it),At=!1},d(it){it&&l(e),C(a),C(A),C(F),C(k),C(U),C(Se),C(me),C(Be),C(Me),C($t),C(Qe),C(st),C(at),C(tt)}}}function av(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return e=new $e({props:{language:ue,code:"#include <fillcan/commands/command_recording.hpp>"}}),r=new $e({props:{language:ue,code:`struct CommandRecording {
    Queue* pQueue;
    CommandPool* pCommandPool;
    std::vector<CommandBuffer*> pPrimaryCommandBuffers = {};
    std::vector<CommandBuffer*> pSecondaryCommandBuffers = {};
    std::vector<Semaphore*> pWaitSemaphores = {};
    VkPipelineStageFlags waitDstStageMask = 0;
    std::vector<Semaphore*> pSignalSemaphores = {};
    std::unique_ptr<Fence> upFenceWorkCompleted = nullptr;
};`}}),u=new G({props:{sectionID:L.QUEUE,$$slots:{default:[U_]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[G_]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.FENCE,$$slots:{default:[H_]},$$scope:{ctx:c}}}),T=new Ce({props:{$$slots:{params:[sv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=i(`

The `),n=d("code"),s=i("Command Recording"),a=i(" structure is used by the "),I(u.$$.fragment),p=i(` to keep track of the information needed for recording commands and can be supplemented
with `),I(m.$$.fragment),_=i(" and a "),I(v.$$.fragment),P=i(" for synchronization purposes."),R=d("br"),A=Y(),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=j(B),S(r.$$.fragment,B),$=f(B,`

The `),n=g(B,"CODE",{});var y=E(n);s=f(y,"Command Recording"),y.forEach(l),a=f(B," structure is used by the "),S(u.$$.fragment,B),p=f(B,` to keep track of the information needed for recording commands and can be supplemented
with `),S(m.$$.fragment,B),_=f(B," and a "),S(v.$$.fragment,B),P=f(B," for synchronization purposes."),R=g(B,"BR",{}),A=j(B),S(T.$$.fragment,B)},m(B,y){D(e,B,y),h(B,t,y),D(r,B,y),h(B,$,y),h(B,n,y),o(n,s),h(B,a,y),D(u,B,y),h(B,p,y),D(m,B,y),h(B,_,y),D(v,B,y),h(B,P,y),h(B,R,y),h(B,A,y),D(T,B,y),F=!0},p(B,[y]){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),u.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),m.$set(x);const M={};y&1&&(M.$$scope={dirty:y,ctx:B}),v.$set(M);const O={};y&1&&(O.$$scope={dirty:y,ctx:B}),T.$set(O)},i(B){F||(b(e.$$.fragment,B),b(r.$$.fragment,B),b(u.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),F=!0)},o(B){w(e.$$.fragment,B),w(r.$$.fragment,B),w(u.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),F=!1},d(B){C(e,B),B&&l(t),C(r,B),B&&l($),B&&l(n),B&&l(a),C(u,B),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(P),B&&l(R),B&&l(A),C(T,B)}}}class ov extends ve{constructor(e){super(),Ee(this,e,null,av,be,{})}}function lv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iv(c){let e;return{c(){e=i("end")},l(t){e=f(t,"end")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cv(c){let e,t,r,$,n,s,a,u,p,m,_;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[lv]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.COMMAND_BUFFER_end,$$slots:{default:[iv]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[fv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Ends all "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Calls `),I(a.$$.fragment),u=i(" on all "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=f(P,"Ends all "),S(r.$$.fragment,P),$=f(P,"."),n=g(P,"BR",{}),s=f(P,`
        Calls `),S(a.$$.fragment,P),u=f(P," on all "),S(p.$$.fragment,P),m=f(P,"."),P.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,P){h(v,e,P),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),r.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),a.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:v}),p.$set(T)},i(v){_||(b(r.$$.fragment,v),b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(r.$$.fragment,v),w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(r),C(a),C(p)}}}function $v(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pv(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[$v]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[uv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if all "),I(n.$$.fragment),s=i(` were succesfully ended.
        `),a=d("code"),u=i("false"),p=i(" if not all "),I(m.$$.fragment),_=i(" could be ended."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(R," if all "),S(n.$$.fragment,R),s=f(R,` were succesfully ended.
        `),a=g(R,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(R," if not all "),S(m.$$.fragment,R),_=f(R," could be ended."),R.forEach(l),this.h()},h(){z(e,"slot","return")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),m.$set(T)},i(P){v||(b(n.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){P&&l(e),C(n),C(m)}}}function mv(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool endAll();"}}),r=new Ce({props:{$$slots:{return:[pv],details:[cv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hv extends ve{constructor(e){super(),Ee(this,e,null,mv,be,{})}}function dv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gv(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _v(c){let e;return{c(){e=i("submitRecordings")},l(t){e=f(t,"submitRecordings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vv(c){let e,t,r,$,n,s,a,u,p,m,_;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[dv]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.QUEUE,$$slots:{default:[gv]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.QUEUE_submitRecordings,$$slots:{default:[_v]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Submit "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i("."),a=d("br"),u=i(`
        alls `),I(p.$$.fragment),m=i(" for this recording."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=f(P,"Submit "),S(r.$$.fragment,P),$=f(P," to the "),S(n.$$.fragment,P),s=f(P,"."),a=g(P,"BR",{}),u=f(P,`
        alls `),S(p.$$.fragment,P),m=f(P," for this recording."),P.forEach(l),this.h()},h(){z(e,"slot","details")},m(v,P){h(v,e,P),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),r.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),n.$set(A);const T={};P&1&&(T.$$scope={dirty:P,ctx:v}),p.$set(T)},i(v){_||(b(r.$$.fragment,v),b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(r.$$.fragment,v),w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(r),C(n),C(p)}}}function Ev(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bv(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wv(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Ev]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.QUEUE,$$slots:{default:[bv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the recording was succesfully submitted to the "),I(n.$$.fragment),s=i(`.
        `),a=d("code"),u=i("false"),p=i(" if the recording failed to submit to the "),I(m.$$.fragment),_=i("."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"true"),A.forEach(l),$=f(R," if the recording was succesfully submitted to the "),S(n.$$.fragment,R),s=f(R,`.
        `),a=g(R,"CODE",{});var T=E(a);u=f(T,"false"),T.forEach(l),p=f(R," if the recording failed to submit to the "),S(m.$$.fragment,R),_=f(R,"."),R.forEach(l),this.h()},h(){z(e,"slot","return")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),m.$set(T)},i(P){v||(b(n.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){P&&l(e),C(n),C(m)}}}function Iv(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool submit();"}}),r=new Ce({props:{$$slots:{return:[wv],details:[vv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Dv extends ve{constructor(e){super(),Ee(this,e,null,Iv,be,{})}}function Cv(c){let e;return{c(){e=i("resetRecording")},l(t){e=f(t,"resetRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sv(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.QUEUE_resetRecording,$$slots:{default:[Cv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Resets the recording and resets all structure variables to their default
        values.`),r=d("br"),$=i(`
        Calls `),I(n.$$.fragment),s=i(` for this recording before resetting all structure variables to their default
        values.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,`Resets the recording and resets all structure variables to their default
        values.`),r=g(p,"BR",{}),$=f(p,`
        Calls `),S(n.$$.fragment,p),s=f(p,` for this recording before resetting all structure variables to their default
        values.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Pv(c){let e;return{c(){e=i("Command Buffers")},l(t){e=f(t,"Command Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Av(c){let e;return{c(){e=i("VkCommandBufferResetFlagBits")},l(t){e=f(t,"VkCommandBufferResetFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rv(c){let e,t,r,$,n,s,a,u,p,m;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Pv]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html",target:"_blank",$$slots:{default:[Av]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            Additional actions to perform while resetting the `),I(a.$$.fragment),u=i(". This is a bitmask of "),I(p.$$.fragment),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"flags"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            Additional actions to perform while resetting the `),S(a.$$.fragment,P),u=f(P,". This is a bitmask of "),S(p.$$.fragment,P),P.forEach(l),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),a.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),p.$set(R)},i(_){m||(b(a.$$.fragment,_),b(p.$$.fragment,_),m=!0)},o(_){w(a.$$.fragment,_),w(p.$$.fragment,_),m=!1},d(_){_&&l(e),C(a),C(p)}}}function Bv(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the recording was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the recording failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the recording was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the recording failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Lv(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool reset(VkCommandBufferResetFlags flags = 0);"}}),r=new Ce({props:{$$slots:{return:[Bv],params:[Rv],details:[Sv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kv extends ve{constructor(e){super(),Ee(this,e,null,Lv,be,{})}}function Tv(c){let e;return{c(){e=i("freeRecording")},l(t){e=f(t,"freeRecording")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vv(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.QUEUE_freeRecording,$$slots:{default:[Tv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free this recording."),r=d("br"),$=i(`
        Calls `),I(n.$$.fragment),s=i(" for this recording."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Free this recording."),r=g(p,"BR",{}),$=f(p,`
        Calls `),S(n.$$.fragment,p),s=f(p," for this recording."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Ov(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void free();"}}),r=new Ce({props:{$$slots:{details:[Vv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Fv extends ve{constructor(e){super(),Ee(this,e,null,Ov,be,{})}}function yv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mv(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xv(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.FENCE,$$slots:{default:[yv]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Mv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i(` which will
        be signaled once this recording has been submitted to the `),I(n.$$.fragment),s=i(" and all work has finished execution."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a "),S(r.$$.fragment,p),$=f(p,` which will
        be signaled once this recording has been submitted to the `),S(n.$$.fragment,p),s=f(p," and all work has finished execution."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Nv(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gv(c){let e;return{c(){e=i("VkFenceCreateFlagBits")},l(t){e=f(t,"VkFenceCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qv(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Nv]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.FENCE,$$slots:{default:[Uv]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html",target:"_blank",$$slots:{default:[Gv]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.FENCE,$$slots:{default:[Hv]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" that should own the "),I(p.$$.fragment),m=i("."),_=Y(),v=d("li"),P=d("code"),R=i("flags"),A=d("br"),T=i(`
            A bitmask of `),I(F.$$.fragment),B=i(" specifying the initial state and behavior of the "),I(y.$$.fragment),V=i("."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"pLogicalDevice"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            The `),S(a.$$.fragment,H),u=f(H," that should own the "),S(p.$$.fragment,H),m=f(H,"."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"flags"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            A bitmask of `),S(F.$$.fragment,N),B=f(N," specifying the initial state and behavior of the "),S(y.$$.fragment,N),V=f(N,"."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function Wv(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void createFence(LogicalDevice* pLogicalDevice, VkFenceCreateFlags flags = 0);"}}),r=new Ce({props:{$$slots:{params:[qv],details:[xv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Qv extends ve{constructor(e){super(),Ee(this,e,null,Wv,be,{})}}function Kv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zv(c){let e;return{c(){e=i("createFence")},l(t){e=f(t,"createFence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yv(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.FENCE,$$slots:{default:[Kv]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMMAND_RECORDING_createFence,$$slots:{default:[zv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wait for the "),I(r.$$.fragment),$=i(` defined
        with `),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Wait for the "),S(r.$$.fragment,p),$=f(p,` defined
        with `),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function jv(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("timeout"),n=d("br"),s=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"timeout"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The timeout period in units of nanoseconds to wait before returning.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function Xv(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zv(c){let e,t,r,$,n,s,a,u,p,m;return n=new G({props:{sectionID:L.FENCE,$$slots:{default:[Xv]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the "),I(n.$$.fragment),s=i(" was succesfully waited for. "),a=d("code"),u=i("false"),p=i(" if the timeout expired."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=g(v,"CODE",{});var P=E(t);r=f(P,"true"),P.forEach(l),$=f(v," if the "),S(n.$$.fragment,v),s=f(v," was succesfully waited for. "),a=g(v,"CODE",{});var R=E(a);u=f(R,"false"),R.forEach(l),p=f(v," if the timeout expired."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),n.$set(P)},i(_){m||(b(n.$$.fragment,_),m=!0)},o(_){w(n.$$.fragment,_),m=!1},d(_){_&&l(e),C(n)}}}function Jv(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool waitForFence(uint64_t timeout = UINT64_MAX);"}}),r=new Ce({props:{$$slots:{return:[Zv],params:[jv],details:[Yv]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eE extends ve{constructor(e){super(),Ee(this,e,null,Jv,be,{})}}function tE(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rE(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nE(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sE(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fE(c){let e;return{c(){e=i("createSwapchain")},l(t){e=f(t,"createSwapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cE(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/swapchain.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[tE]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.WINDOW,$$slots:{default:[rE]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.QUEUE,$$slots:{default:[nE]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.WINDOW,$$slots:{default:[sE]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.IMAGE,$$slots:{default:[aE]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.IMAGE,$$slots:{default:[oE]},$$scope:{ctx:c}}}),H=new G({props:{sectionID:L.IMAGE,$$slots:{default:[lE]},$$scope:{ctx:c}}}),N=new G({props:{sectionID:L.IMAGE,$$slots:{default:[iE]},$$scope:{ctx:c}}}),K=new G({props:{sectionID:L.FILLCAN_GRAPHICS_createSwapchain,$$slots:{default:[fE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Swapchain"),n=i(" class takes in a pointer to the "),I(s.$$.fragment),a=i(", the "),I(u.$$.fragment),p=i(` and the present
`),I(m.$$.fragment),_=i(`. It uses this
information to prepare special image objects we can use to present to the `),I(v.$$.fragment),P=i(" surface."),R=d("br"),A=d("br"),T=i(`
Swapchain objects are used to ask the window system to create one or more images
that can be used to present on a Vulkan surface (this is visible with the
`),F=d("code"),B=i("VK_KHR_surface"),y=i(`
extension). Each Swapchain object manages a series of `),I(V.$$.fragment),x=i(`, usually in some form of a ring buffer. The application can ask the Swapchain
for the next available `),I(M.$$.fragment),O=i(`,
render to it, and then return the `),I(H.$$.fragment),k=i(` to the swapchain ready for display. By managing presentable images in a ring or
queue, one `),I(N.$$.fragment),Q=i(` can be displayed
on the screen while another is drawn to by the application, overlapping the operation
of the window system and the application.`),X=d("br"),Z=i(`
It is recommended to create Swapchains using `),I(K.$$.fragment),W=i(".")},l(U){S(e.$$.fragment,U),t=f(U,`
The `),r=g(U,"CODE",{});var te=E(r);$=f(te,"Swapchain"),te.forEach(l),n=f(U," class takes in a pointer to the "),S(s.$$.fragment,U),a=f(U,", the "),S(u.$$.fragment,U),p=f(U,` and the present
`),S(m.$$.fragment,U),_=f(U,`. It uses this
information to prepare special image objects we can use to present to the `),S(v.$$.fragment,U),P=f(U," surface."),R=g(U,"BR",{}),A=g(U,"BR",{}),T=f(U,`
Swapchain objects are used to ask the window system to create one or more images
that can be used to present on a Vulkan surface (this is visible with the
`),F=g(U,"CODE",{});var ee=E(F);B=f(ee,"VK_KHR_surface"),ee.forEach(l),y=f(U,`
extension). Each Swapchain object manages a series of `),S(V.$$.fragment,U),x=f(U,`, usually in some form of a ring buffer. The application can ask the Swapchain
for the next available `),S(M.$$.fragment,U),O=f(U,`,
render to it, and then return the `),S(H.$$.fragment,U),k=f(U,` to the swapchain ready for display. By managing presentable images in a ring or
queue, one `),S(N.$$.fragment,U),Q=f(U,` can be displayed
on the screen while another is drawn to by the application, overlapping the operation
of the window system and the application.`),X=g(U,"BR",{}),Z=f(U,`
It is recommended to create Swapchains using `),S(K.$$.fragment,U),W=f(U,".")},m(U,te){D(e,U,te),h(U,t,te),h(U,r,te),o(r,$),h(U,n,te),D(s,U,te),h(U,a,te),D(u,U,te),h(U,p,te),D(m,U,te),h(U,_,te),D(v,U,te),h(U,P,te),h(U,R,te),h(U,A,te),h(U,T,te),h(U,F,te),o(F,B),h(U,y,te),D(V,U,te),h(U,x,te),D(M,U,te),h(U,O,te),D(H,U,te),h(U,k,te),D(N,U,te),h(U,Q,te),h(U,X,te),h(U,Z,te),D(K,U,te),h(U,W,te),q=!0},p(U,[te]){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:U}),s.$set(ee);const se={};te&1&&(se.$$scope={dirty:te,ctx:U}),u.$set(se);const ie={};te&1&&(ie.$$scope={dirty:te,ctx:U}),m.$set(ie);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:U}),v.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:U}),V.$set(J);const pe={};te&1&&(pe.$$scope={dirty:te,ctx:U}),M.$set(pe);const Se={};te&1&&(Se.$$scope={dirty:te,ctx:U}),H.$set(Se);const de={};te&1&&(de.$$scope={dirty:te,ctx:U}),N.$set(de);const me={};te&1&&(me.$$scope={dirty:te,ctx:U}),K.$set(me)},i(U){q||(b(e.$$.fragment,U),b(s.$$.fragment,U),b(u.$$.fragment,U),b(m.$$.fragment,U),b(v.$$.fragment,U),b(V.$$.fragment,U),b(M.$$.fragment,U),b(H.$$.fragment,U),b(N.$$.fragment,U),b(K.$$.fragment,U),q=!0)},o(U){w(e.$$.fragment,U),w(s.$$.fragment,U),w(u.$$.fragment,U),w(m.$$.fragment,U),w(v.$$.fragment,U),w(V.$$.fragment,U),w(M.$$.fragment,U),w(H.$$.fragment,U),w(N.$$.fragment,U),w(K.$$.fragment,U),q=!1},d(U){C(e,U),U&&l(t),U&&l(r),U&&l(n),C(s,U),U&&l(a),C(u,U),U&&l(p),C(m,U),U&&l(_),C(v,U),U&&l(P),U&&l(R),U&&l(A),U&&l(T),U&&l(F),U&&l(y),C(V,U),U&&l(x),C(M,U),U&&l(O),C(H,U),U&&l(k),C(N,U),U&&l(Q),U&&l(X),U&&l(Z),C(K,U),U&&l(W)}}}class $E extends ve{constructor(e){super(),Ee(this,e,null,cE,be,{})}}function uE(c){let e,t;return{c(){e=d("span"),t=i("Create a new Swapchain."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Swapchain."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function pE(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mE(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dE(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _E(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vE(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[pE]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.WINDOW,$$slots:{default:[mE]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[hE]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.QUEUE,$$slots:{default:[dE]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.IMAGE,$$slots:{default:[gE]},$$scope:{ctx:c}}}),oe=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[_E]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to associate the Swapchain with."),p=Y(),m=d("li"),_=d("code"),v=i("pWindow"),P=d("br"),R=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" whose surface the Swapchain should make presentable "),I(F.$$.fragment),B=i(" for."),y=Y(),V=d("li"),x=d("code"),M=i("pPresentQueue"),O=d("br"),H=i(`
            The `),I(k.$$.fragment),N=i(` which the
            Swapchain should use for presentation.`),Q=Y(),X=d("li"),Z=d("code"),K=i("imageCount"),W=d("br"),q=i(`
            The amount of `),I(U.$$.fragment),te=i(" the Swapchain should prepare."),ee=d("br"),se=i(`
            Setting `),ie=d("code"),ae=i("imageCount"),J=i(` to 2 enables double buffering.
            Setting `),pe=d("code"),Se=i("imageCount"),de=i(`
            to 3 enables triple buffering. Setting `),me=d("code"),De=i("imageCount"),_e=i(` to 1
            represents a request to render directly to the frontbuffer or to the
            screen.`),ne=d("br"),le=i(`
            Setting `),ge=d("code"),we=i("imageCount"),Pe=i(` to 2 means that one frontbuffer and one
            backbuffer will be created. After the presentation of a completed backbuffer
            is activated, rendering to the frontbuffer cannot begin until the presentation
            of the frontbuffer has completed.`),Be=Y(),Ie=d("li"),re=d("code"),he=i("presentMode"),Le=d("br"),Oe=i(`
            The presentation mode for the surface. This should be a member of the
            `),I(oe.$$.fragment),ce=i("-enumerant."),Ae=Y(),ye=d("li"),Fe=d("code"),Ve=i("pOldSwapchain"),Ge=d("br"),He=i(`
            A pointer to the old Swapchain which can be used to return an existing
            Swapchain associated with the surface to Vulkan for recycling. This will
            be used when one Swapchain is replaced by another, such as when a Window
            is resized and the Swapchain needs to be remapped with larger images.`),this.h()},l(xe){e=g(xe,"DIV",{slot:!0});var Ne=E(e);t=g(Ne,"LI",{});var Te=E(t);r=g(Te,"CODE",{});var qe=E(r);$=f(qe,"pLogicalDevice"),qe.forEach(l),n=g(Te,"BR",{}),s=f(Te,`
            A pointer to the `),S(a.$$.fragment,Te),u=f(Te," to associate the Swapchain with."),Te.forEach(l),p=j(Ne),m=g(Ne,"LI",{});var Ke=E(m);_=g(Ke,"CODE",{});var je=E(_);v=f(je,"pWindow"),je.forEach(l),P=g(Ke,"BR",{}),R=f(Ke,`
            A pointer to the `),S(A.$$.fragment,Ke),T=f(Ke," whose surface the Swapchain should make presentable "),S(F.$$.fragment,Ke),B=f(Ke," for."),Ke.forEach(l),y=j(Ne),V=g(Ne,"LI",{});var rt=E(V);x=g(rt,"CODE",{});var Me=E(x);M=f(Me,"pPresentQueue"),Me.forEach(l),O=g(rt,"BR",{}),H=f(rt,`
            The `),S(k.$$.fragment,rt),N=f(rt,` which the
            Swapchain should use for presentation.`),rt.forEach(l),Q=j(Ne),X=g(Ne,"LI",{});var Ue=E(X);Z=g(Ue,"CODE",{});var $t=E(Z);K=f($t,"imageCount"),$t.forEach(l),W=g(Ue,"BR",{}),q=f(Ue,`
            The amount of `),S(U.$$.fragment,Ue),te=f(Ue," the Swapchain should prepare."),ee=g(Ue,"BR",{}),se=f(Ue,`
            Setting `),ie=g(Ue,"CODE",{});var ut=E(ie);ae=f(ut,"imageCount"),ut.forEach(l),J=f(Ue,` to 2 enables double buffering.
            Setting `),pe=g(Ue,"CODE",{});var ht=E(pe);Se=f(ht,"imageCount"),ht.forEach(l),de=f(Ue,`
            to 3 enables triple buffering. Setting `),me=g(Ue,"CODE",{});var Je=E(me);De=f(Je,"imageCount"),Je.forEach(l),_e=f(Ue,` to 1
            represents a request to render directly to the frontbuffer or to the
            screen.`),ne=g(Ue,"BR",{}),le=f(Ue,`
            Setting `),ge=g(Ue,"CODE",{});var dt=E(ge);we=f(dt,"imageCount"),dt.forEach(l),Pe=f(Ue,` to 2 means that one frontbuffer and one
            backbuffer will be created. After the presentation of a completed backbuffer
            is activated, rendering to the frontbuffer cannot begin until the presentation
            of the frontbuffer has completed.`),Ue.forEach(l),Be=j(Ne),Ie=g(Ne,"LI",{});var et=E(Ie);re=g(et,"CODE",{});var Ze=E(re);he=f(Ze,"presentMode"),Ze.forEach(l),Le=g(et,"BR",{}),Oe=f(et,`
            The presentation mode for the surface. This should be a member of the
            `),S(oe.$$.fragment,et),ce=f(et,"-enumerant."),et.forEach(l),Ae=j(Ne),ye=g(Ne,"LI",{});var nt=E(ye);Fe=g(nt,"CODE",{});var Qe=E(Fe);Ve=f(Qe,"pOldSwapchain"),Qe.forEach(l),Ge=g(nt,"BR",{}),He=f(nt,`
            A pointer to the old Swapchain which can be used to return an existing
            Swapchain associated with the surface to Vulkan for recycling. This will
            be used when one Swapchain is replaced by another, such as when a Window
            is resized and the Swapchain needs to be remapped with larger images.`),nt.forEach(l),Ne.forEach(l),this.h()},h(){z(e,"slot","params")},m(xe,Ne){h(xe,e,Ne),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),D(U,X,null),o(X,te),o(X,ee),o(X,se),o(X,ie),o(ie,ae),o(X,J),o(X,pe),o(pe,Se),o(X,de),o(X,me),o(me,De),o(X,_e),o(X,ne),o(X,le),o(X,ge),o(ge,we),o(X,Pe),o(e,Be),o(e,Ie),o(Ie,re),o(re,he),o(Ie,Le),o(Ie,Oe),D(oe,Ie,null),o(Ie,ce),o(e,Ae),o(e,ye),o(ye,Fe),o(Fe,Ve),o(ye,Ge),o(ye,He),ze=!0},p(xe,Ne){const Te={};Ne&1&&(Te.$$scope={dirty:Ne,ctx:xe}),a.$set(Te);const qe={};Ne&1&&(qe.$$scope={dirty:Ne,ctx:xe}),A.$set(qe);const Ke={};Ne&1&&(Ke.$$scope={dirty:Ne,ctx:xe}),F.$set(Ke);const je={};Ne&1&&(je.$$scope={dirty:Ne,ctx:xe}),k.$set(je);const rt={};Ne&1&&(rt.$$scope={dirty:Ne,ctx:xe}),U.$set(rt);const Me={};Ne&1&&(Me.$$scope={dirty:Ne,ctx:xe}),oe.$set(Me)},i(xe){ze||(b(a.$$.fragment,xe),b(A.$$.fragment,xe),b(F.$$.fragment,xe),b(k.$$.fragment,xe),b(U.$$.fragment,xe),b(oe.$$.fragment,xe),ze=!0)},o(xe){w(a.$$.fragment,xe),w(A.$$.fragment,xe),w(F.$$.fragment,xe),w(k.$$.fragment,xe),w(U.$$.fragment,xe),w(oe.$$.fragment,xe),ze=!1},d(xe){xe&&l(e),C(a),C(A),C(F),C(k),C(U),C(oe)}}}function EE(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wE(c){let e,t,r,$,n,s,a,u,p;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[EE]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[bE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created or the Swapchain "),I(a.$$.fragment),u=i(" failed to query."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_," if the "),S(n.$$.fragment,_),s=f(_," couldn't be created or the Swapchain "),S(a.$$.fragment,_),u=f(_," failed to query."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function IE(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Swapchain(
        LogicalDevice* pLogicalDevice, 
        Window* pWindow, 
        Queue* pPresentQueue, 
        uint32_t imageCount = 3,
        VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR, 
        Swapchain* pOldSwapchain = nullptr
);`}}),r=new Ce({props:{$$slots:{throws:[wE],params:[vE],details:[uE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DE extends ve{constructor(e){super(),Ee(this,e,null,IE,be,{})}}function CE(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SE(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[CE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function PE(c){let e;return{c(){e=i("Vulkan Swapchain")},l(t){e=f(t,"Vulkan Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AE(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html",target:"_blank",$$slots:{default:[PE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function RE(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkSwapchainKHR getSwapchainHandle() const;"}}),r=new Ce({props:{$$slots:{return:[AE],details:[SE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BE extends ve{constructor(e){super(),Ee(this,e,null,RE,be,{})}}function LE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kE(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[LE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the next available Swapchain "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        The images of the Swapchain are not immediately usable. Before data can be
        written into it, the next available image must be obtained.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Get the next available Swapchain "),S(r.$$.fragment,p),$=f(p,"."),n=g(p,"BR",{}),s=f(p,`
        The images of the Swapchain are not immediately usable. Before data can be
        written into it, the next available image must be obtained.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(r.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),a=!1},d(u){u&&l(e),C(r)}}}function TE(c){let e;return{c(){e=i("Fence")},l(t){e=f(t,"Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OE(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.FENCE,$$slots:{default:[TE]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[VE]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pFence"),n=d("br"),s=i(`
            A pointer to a `),I(a.$$.fragment),u=i(" which will be signaled once it's safe to render to the acquired "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pFence"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to a `),S(a.$$.fragment,R),u=f(R," which will be signaled once it's safe to render to the acquired "),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function FE(c){let e;return{c(){e=i("SwapchainImage")},l(t){e=f(t,"SwapchainImage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yE(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.SWAPCHAIN_Swapchain_Image,$$slots:{default:[FE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-struct containing the necessary information for
        rendering to the Swapchain Image.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-struct containing the necessary information for
        rendering to the Swapchain Image.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ME(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"SwapchainImage getNextImage(Fence* pFence = nullptr);"}}),r=new Ce({props:{$$slots:{return:[yE],params:[OE],details:[kE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class xE extends ve{constructor(e){super(),Ee(this,e,null,ME,be,{})}}function NE(c){let e,t;return{c(){e=d("span"),t=i("Get the intended Swapchain format and colorspace pair."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended Swapchain format and colorspace pair."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function UE(c){let e;return{c(){e=i("VkSurfaceFormatKHR")},l(t){e=f(t,"VkSurfaceFormatKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GE(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html",target:"_blank",$$slots:{default:[UE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure describing the intended Swapchain format and colorspace
        pair.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A "),S(r.$$.fragment,a),$=f(a,`-structure describing the intended Swapchain format and colorspace
        pair.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function HE(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSurfaceFormatKHR getSurfaceFormat();"}}),r=new Ce({props:{$$slots:{return:[GE],details:[NE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qE extends ve{constructor(e){super(),Ee(this,e,null,HE,be,{})}}function WE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QE(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[WE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the amount of Swapchain "),I(r.$$.fragment),$=i(" supported by this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the amount of Swapchain "),S(r.$$.fragment,a),$=f(a," supported by this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function KE(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zE(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[KE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The amount of Swapchain "),I(r.$$.fragment),$=i(" supported by this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The amount of Swapchain "),S(r.$$.fragment,a),$=f(a," supported by this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function YE(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"uint32_t getImageCount();"}}),r=new Ce({props:{$$slots:{return:[zE],details:[QE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jE extends ve{constructor(e){super(),Ee(this,e,null,YE,be,{})}}function XE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZE(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[XE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the amount of array layers a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain supports."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the amount of array layers a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain supports."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function JE(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eb(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[JE]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The amount of array layers a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain supports."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The amount of array layers a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain supports."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tb(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getImageArrayLayers();"}}),r=new Ce({props:{$$slots:{return:[eb],details:[ZE]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rb extends ve{constructor(e){super(),Ee(this,e,null,tb,be,{})}}function nb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sb(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[nb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the supported usage for a Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the supported usage for a Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ab(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ob(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lb(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[ab]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[ob]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A bitmap of "),I(r.$$.fragment),$=i(" describing the supported usage for a Swapchain "),I(n.$$.fragment),s=i(" of this Swapchain."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A bitmap of "),S(r.$$.fragment,p),$=f(p," describing the supported usage for a Swapchain "),S(n.$$.fragment,p),s=f(p," of this Swapchain."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function ib(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageUsageFlags getImageUsage();"}}),r=new Ce({props:{$$slots:{return:[lb],details:[sb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fb extends ve{constructor(e){super(),Ee(this,e,null,ib,be,{})}}function cb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $b(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ub(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pb(c){let e,t,r,$,n,s,a,u,p;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[cb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[$b]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.QUEUE,$$slots:{default:[ub]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(` sharing
        mode describing how the Swapchain `),I(n.$$.fragment),s=i(" of this Swapchain can be accessed from "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Get the "),S(r.$$.fragment,_),$=f(_,` sharing
        mode describing how the Swapchain `),S(n.$$.fragment,_),s=f(_," of this Swapchain can be accessed from "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),n.$set(P);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function mb(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function db(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gb(c){let e,t,r,$,n,s,a,u,p;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[mb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[hb]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[db]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A member of the "),I(r.$$.fragment),$=i("-enumerant describing the "),I(n.$$.fragment),s=i(" sharing mode for the Swapchain "),I(a.$$.fragment),u=i(" of this Swapchain."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"A member of the "),S(r.$$.fragment,_),$=f(_,"-enumerant describing the "),S(n.$$.fragment,_),s=f(_," sharing mode for the Swapchain "),S(a.$$.fragment,_),u=f(_," of this Swapchain."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),n.$set(P);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function _b(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSharingMode getImageSharingMode();"}}),r=new Ce({props:{$$slots:{return:[gb],details:[pb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vb extends ve{constructor(e){super(),Ee(this,e,null,_b,be,{})}}function Eb(c){let e,t;return{c(){e=d("span"),t=i("Get the current presentation mode for the surface of this Swapchain."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the current presentation mode for the surface of this Swapchain."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function bb(c){let e;return{c(){e=i("VkPresentModeKHR")},l(t){e=f(t,"VkPresentModeKHR")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wb(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html",target:"_blank",$$slots:{default:[bb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A member of the "),I(r.$$.fragment),$=i("-enumerant describing the current presentation mode of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A member of the "),S(r.$$.fragment,a),$=f(a,"-enumerant describing the current presentation mode of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Ib(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkPresentModeKHR getPresentMode();"}}),r=new Ce({props:{$$slots:{return:[wb],details:[Eb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Db extends ve{constructor(e){super(),Ee(this,e,null,Ib,be,{})}}function Cb(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sb(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Cb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the extent (the width and height) of the Swapchain "),I(r.$$.fragment),$=i(" of this Swapchain."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the extent (the width and height) of the Swapchain "),S(r.$$.fragment,a),$=f(a," of this Swapchain."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Pb(c){let e;return{c(){e=i("VkExtent2D")},l(t){e=f(t,"VkExtent2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ab(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rb(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html",target:"_blank",$$slots:{default:[Pb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Ab]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(`-structure describing the width and height of the Swapchain
        `),I(n.$$.fragment),s=i(" of this Swapchain."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p,`-structure describing the width and height of the Swapchain
        `),S(n.$$.fragment,p),s=f(p," of this Swapchain."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Bb(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkExtent2D getImageExtent();"}}),r=new Ce({props:{$$slots:{return:[Rb],details:[Sb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Lb extends ve{constructor(e){super(),Ee(this,e,null,Bb,be,{})}}function kb(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vb(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ob(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fb(c){let e,t,r,$,n,s,a,u,p=Ye().Fillcan.version+"",m,_,v,P,R,A,T;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[kb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Tb]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.QUEUE,$$slots:{default:[Vb]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Ob]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(` families between
        which an `),I(n.$$.fragment),s=i(" is shared."),a=d("br"),u=i(`
        For Fillcan version `),m=i(p),_=i(` this list will always be
        empty, as shared `),I(v.$$.fragment),P=i(" are not yet supported for Swapchain "),I(R.$$.fragment),A=i("."),this.h()},l(F){e=g(F,"SPAN",{slot:!0});var B=E(e);t=f(B,"The "),S(r.$$.fragment,B),$=f(B,` families between
        which an `),S(n.$$.fragment,B),s=f(B," is shared."),a=g(B,"BR",{}),u=f(B,`
        For Fillcan version `),m=f(B,p),_=f(B,` this list will always be
        empty, as shared `),S(v.$$.fragment,B),P=f(B," are not yet supported for Swapchain "),S(R.$$.fragment,B),A=f(B,"."),B.forEach(l),this.h()},h(){z(e,"slot","details")},m(F,B){h(F,e,B),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,m),o(e,_),D(v,e,null),o(e,P),D(R,e,null),o(e,A),T=!0},p(F,B){const y={};B&1&&(y.$$scope={dirty:B,ctx:F}),r.$set(y);const V={};B&1&&(V.$$scope={dirty:B,ctx:F}),n.$set(V);const x={};B&1&&(x.$$scope={dirty:B,ctx:F}),v.$set(x);const M={};B&1&&(M.$$scope={dirty:B,ctx:F}),R.$set(M)},i(F){T||(b(r.$$.fragment,F),b(n.$$.fragment,F),b(v.$$.fragment,F),b(R.$$.fragment,F),T=!0)},o(F){w(r.$$.fragment,F),w(n.$$.fragment,F),w(v.$$.fragment,F),w(R.$$.fragment,F),T=!1},d(F){F&&l(e),C(r),C(n),C(v),C(R)}}}function yb(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xb(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.QUEUE,$$slots:{default:[yb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Mb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i(` family
        indices between which an `),I(n.$$.fragment),s=i(" is shared."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of "),S(r.$$.fragment,p),$=f(p,` family
        indices between which an `),S(n.$$.fragment,p),s=f(p," is shared."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Nb(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[xb],details:[Fb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ub extends ve{constructor(e){super(),Ee(this,e,null,Nb,be,{})}}function Gb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hb(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qb(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Gb]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.WINDOW,$$slots:{default:[Hb]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Present a Swapchain "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(" surface."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Present a Swapchain "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p," surface."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Wb(c){let e;return{c(){e=i("SwapchainImage")},l(t){e=f(t,"SwapchainImage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kb(c){let e;return{c(){e=i("Semaphores")},l(t){e=f(t,"Semaphores")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zb(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yb(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.SWAPCHAIN_Swapchain_Image,$$slots:{default:[Wb]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Qb]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[Kb]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.IMAGE,$$slots:{default:[zb]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pSwapchainImage"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i("-structure containing the "),I(p.$$.fragment),m=i(" that should be presented."),_=Y(),v=d("li"),P=d("code"),R=i("waitSemaphores"),A=d("br"),T=i(`
            The `),I(F.$$.fragment),B=i(" to wait for before presenting the "),I(y.$$.fragment),V=i("."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"pSwapchainImage"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            A pointer to the `),S(a.$$.fragment,H),u=f(H,"-structure containing the "),S(p.$$.fragment,H),m=f(H," that should be presented."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"waitSemaphores"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The `),S(F.$$.fragment,N),B=f(N," to wait for before presenting the "),S(y.$$.fragment,N),V=f(N,"."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function jb(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(" if the presentation was succesful. "),n=d("code"),s=i("false"),a=i(` if
        the presentation failed.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p," if the presentation was succesful. "),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p,` if
        the presentation failed.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function Xb(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool present(SwapchainImage* pSwapchainImage, std::vector<VkSemaphore> waitSemaphores);"}}),r=new Ce({props:{$$slots:{return:[jb],params:[Yb],details:[qb]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Zb extends ve{constructor(e){super(),Ee(this,e,null,Xb,be,{})}}function Jb(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e1(c){let e;return{c(){e=i("Window")},l(t){e=f(t,"Window")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r1(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s1(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o1(c){let e;return{c(){e=i("Semaphore")},l(t){e=f(t,"Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i1(c){let e;return{c(){e=i("Semaphore")},l(t){e=f(t,"Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f1(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c1(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe;return a=new G({props:{sectionID:L.WINDOW,$$slots:{default:[e1]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[t1]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[r1]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.IMAGE,$$slots:{default:[n1]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[s1]},$$scope:{ctx:c}}}),ee=new G({props:{sectionID:L.IMAGE,$$slots:{default:[a1]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[o1]},$$scope:{ctx:c}}}),_e=new G({props:{sectionID:L.IMAGE,$$slots:{default:[l1]},$$scope:{ctx:c}}}),re=new G({props:{sectionID:L.SEMAPHORE,$$slots:{default:[i1]},$$scope:{ctx:c}}}),Le=new G({props:{sectionID:L.IMAGE,$$slots:{default:[f1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("outOfDate"),n=d("br"),s=i(`
            Whether the Swapchain has become incompatible with the surface and can
            no longer be used for rendering. Usually happens after a `),I(a.$$.fragment),u=i(" resize."),p=Y(),m=d("li"),_=d("code"),v=i("index"),P=d("br"),R=i(`
            The index of the Swapchain `),I(A.$$.fragment),T=i("."),F=Y(),B=d("li"),y=d("code"),V=i("pSwapchainImageView"),x=d("br"),M=i(`
            A pointer to the `),I(O.$$.fragment),H=i(" of the Swapchain "),I(k.$$.fragment),N=i("."),Q=Y(),X=d("li"),Z=d("code"),K=i("pDepthImageView"),W=d("br"),q=i(`
            A pointer to the Depth `),I(U.$$.fragment),te=i(" for the Swapchain "),I(ee.$$.fragment),se=i("."),ie=Y(),ae=d("li"),J=d("code"),pe=i("pSemaphoreImageReady"),Se=d("br"),de=i(`
            A pointer to a `),I(me.$$.fragment),De=i(" which will be signaled once the "),I(_e.$$.fragment),ne=i(" can be rendered to."),le=Y(),ge=d("li"),we=d("code"),Pe=i("pSemaphorePresentReady"),Be=d("br"),Ie=i(`
            A pointer to a `),I(re.$$.fragment),he=i(" which will be signaled once the "),I(Le.$$.fragment),Oe=i(" can be presented."),this.h()},l(ce){e=g(ce,"SPAN",{slot:!0});var Ae=E(e);t=g(Ae,"LI",{});var ye=E(t);r=g(ye,"CODE",{});var Fe=E(r);$=f(Fe,"outOfDate"),Fe.forEach(l),n=g(ye,"BR",{}),s=f(ye,`
            Whether the Swapchain has become incompatible with the surface and can
            no longer be used for rendering. Usually happens after a `),S(a.$$.fragment,ye),u=f(ye," resize."),ye.forEach(l),p=j(Ae),m=g(Ae,"LI",{});var Ve=E(m);_=g(Ve,"CODE",{});var Ge=E(_);v=f(Ge,"index"),Ge.forEach(l),P=g(Ve,"BR",{}),R=f(Ve,`
            The index of the Swapchain `),S(A.$$.fragment,Ve),T=f(Ve,"."),Ve.forEach(l),F=j(Ae),B=g(Ae,"LI",{});var He=E(B);y=g(He,"CODE",{});var ze=E(y);V=f(ze,"pSwapchainImageView"),ze.forEach(l),x=g(He,"BR",{}),M=f(He,`
            A pointer to the `),S(O.$$.fragment,He),H=f(He," of the Swapchain "),S(k.$$.fragment,He),N=f(He,"."),He.forEach(l),Q=j(Ae),X=g(Ae,"LI",{});var xe=E(X);Z=g(xe,"CODE",{});var Ne=E(Z);K=f(Ne,"pDepthImageView"),Ne.forEach(l),W=g(xe,"BR",{}),q=f(xe,`
            A pointer to the Depth `),S(U.$$.fragment,xe),te=f(xe," for the Swapchain "),S(ee.$$.fragment,xe),se=f(xe,"."),xe.forEach(l),ie=j(Ae),ae=g(Ae,"LI",{});var Te=E(ae);J=g(Te,"CODE",{});var qe=E(J);pe=f(qe,"pSemaphoreImageReady"),qe.forEach(l),Se=g(Te,"BR",{}),de=f(Te,`
            A pointer to a `),S(me.$$.fragment,Te),De=f(Te," which will be signaled once the "),S(_e.$$.fragment,Te),ne=f(Te," can be rendered to."),Te.forEach(l),le=j(Ae),ge=g(Ae,"LI",{});var Ke=E(ge);we=g(Ke,"CODE",{});var je=E(we);Pe=f(je,"pSemaphorePresentReady"),je.forEach(l),Be=g(Ke,"BR",{}),Ie=f(Ke,`
            A pointer to a `),S(re.$$.fragment,Ke),he=f(Ke," which will be signaled once the "),S(Le.$$.fragment,Ke),Oe=f(Ke," can be presented."),Ke.forEach(l),Ae.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Ae){h(ce,e,Ae),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),D(U,X,null),o(X,te),D(ee,X,null),o(X,se),o(e,ie),o(e,ae),o(ae,J),o(J,pe),o(ae,Se),o(ae,de),D(me,ae,null),o(ae,De),D(_e,ae,null),o(ae,ne),o(e,le),o(e,ge),o(ge,we),o(we,Pe),o(ge,Be),o(ge,Ie),D(re,ge,null),o(ge,he),D(Le,ge,null),o(ge,Oe),oe=!0},p(ce,Ae){const ye={};Ae&1&&(ye.$$scope={dirty:Ae,ctx:ce}),a.$set(ye);const Fe={};Ae&1&&(Fe.$$scope={dirty:Ae,ctx:ce}),A.$set(Fe);const Ve={};Ae&1&&(Ve.$$scope={dirty:Ae,ctx:ce}),O.$set(Ve);const Ge={};Ae&1&&(Ge.$$scope={dirty:Ae,ctx:ce}),k.$set(Ge);const He={};Ae&1&&(He.$$scope={dirty:Ae,ctx:ce}),U.$set(He);const ze={};Ae&1&&(ze.$$scope={dirty:Ae,ctx:ce}),ee.$set(ze);const xe={};Ae&1&&(xe.$$scope={dirty:Ae,ctx:ce}),me.$set(xe);const Ne={};Ae&1&&(Ne.$$scope={dirty:Ae,ctx:ce}),_e.$set(Ne);const Te={};Ae&1&&(Te.$$scope={dirty:Ae,ctx:ce}),re.$set(Te);const qe={};Ae&1&&(qe.$$scope={dirty:Ae,ctx:ce}),Le.$set(qe)},i(ce){oe||(b(a.$$.fragment,ce),b(A.$$.fragment,ce),b(O.$$.fragment,ce),b(k.$$.fragment,ce),b(U.$$.fragment,ce),b(ee.$$.fragment,ce),b(me.$$.fragment,ce),b(_e.$$.fragment,ce),b(re.$$.fragment,ce),b(Le.$$.fragment,ce),oe=!0)},o(ce){w(a.$$.fragment,ce),w(A.$$.fragment,ce),w(O.$$.fragment,ce),w(k.$$.fragment,ce),w(U.$$.fragment,ce),w(ee.$$.fragment,ce),w(me.$$.fragment,ce),w(_e.$$.fragment,ce),w(re.$$.fragment,ce),w(Le.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(a),C(A),C(O),C(k),C(U),C(ee),C(me),C(_e),C(re),C(Le)}}}function $1(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:`struct SwapchainImage {
    bool outOfDate;
    unsigned int index;
    ImageView* pSwapchainImageView;
    ImageView* pDepthImageView;
    Semaphore* pSemaphoreImageReady = nullptr;
    Semaphore* pSemaphorePresentReady = nullptr;
};`}}),s=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Jb]},$$scope:{ctx:c}}}),u=new Ce({props:{$$slots:{params:[c1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Swapchain Image"),n=i(` structure is used by the Swapchain to keep
track of the information needed for rendering to and presenting of Swapchain
`),I(s.$$.fragment),a=i(`.
`),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=f(m,`

The `),r=g(m,"CODE",{});var _=E(r);$=f(_,"Swapchain Image"),_.forEach(l),n=f(m,` structure is used by the Swapchain to keep
track of the information needed for rendering to and presenting of Swapchain
`),S(s.$$.fragment,m),a=f(m,`.
`),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),h(m,r,_),o(r,$),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),s.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),m&&l(r),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class u1 extends ve{constructor(e){super(),Ee(this,e,null,$1,be,{})}}function p1(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m1(c){let e;return{c(){e=i("Vulkan Buffer Object")},l(t){e=f(t,"Vulkan Buffer Object")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h1(c){let e;return{c(){e=i("Vulkan Buffers")},l(t){e=f(t,"Vulkan Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d1(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g1(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _1(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v1(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/buffer.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[p1]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[m1]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[h1]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[d1]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[g1]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[_1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a size and usage and uses this information to create a "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=d("br"),_=Y(),I(v.$$.fragment),P=i(` represent linear arrays of data that are used for different purposes by binding
them to a `),I(R.$$.fragment),A=i(" or "),I(T.$$.fragment),F=i(" via "),I(B.$$.fragment),y=i(` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},l(x){S(e.$$.fragment,x),t=f(x,`
The `),r=g(x,"CODE",{});var M=E(r);$=f(M,"Buffer"),M.forEach(l),n=f(x," class takes a pointer to a "),S(s.$$.fragment,x),a=f(x," along with a size and usage and uses this information to create a "),S(u.$$.fragment,x),p=f(x,` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=g(x,"BR",{}),_=j(x),S(v.$$.fragment,x),P=f(x,` represent linear arrays of data that are used for different purposes by binding
them to a `),S(R.$$.fragment,x),A=f(x," or "),S(T.$$.fragment,x),F=f(x," via "),S(B.$$.fragment,x),y=f(x,` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},m(x,M){D(e,x,M),h(x,t,M),h(x,r,M),o(r,$),h(x,n,M),D(s,x,M),h(x,a,M),D(u,x,M),h(x,p,M),h(x,m,M),h(x,_,M),D(v,x,M),h(x,P,M),D(R,x,M),h(x,A,M),D(T,x,M),h(x,F,M),D(B,x,M),h(x,y,M),V=!0},p(x,[M]){const O={};M&1&&(O.$$scope={dirty:M,ctx:x}),s.$set(O);const H={};M&1&&(H.$$scope={dirty:M,ctx:x}),u.$set(H);const k={};M&1&&(k.$$scope={dirty:M,ctx:x}),v.$set(k);const N={};M&1&&(N.$$scope={dirty:M,ctx:x}),R.$set(N);const Q={};M&1&&(Q.$$scope={dirty:M,ctx:x}),T.$set(Q);const X={};M&1&&(X.$$scope={dirty:M,ctx:x}),B.$set(X)},i(x){V||(b(e.$$.fragment,x),b(s.$$.fragment,x),b(u.$$.fragment,x),b(v.$$.fragment,x),b(R.$$.fragment,x),b(T.$$.fragment,x),b(B.$$.fragment,x),V=!0)},o(x){w(e.$$.fragment,x),w(s.$$.fragment,x),w(u.$$.fragment,x),w(v.$$.fragment,x),w(R.$$.fragment,x),w(T.$$.fragment,x),w(B.$$.fragment,x),V=!1},d(x){C(e,x),x&&l(t),x&&l(r),x&&l(n),C(s,x),x&&l(a),C(u,x),x&&l(p),x&&l(m),x&&l(_),C(v,x),x&&l(P),C(R,x),x&&l(A),C(T,x),x&&l(F),C(B,x),x&&l(y)}}}class E1 extends ve{constructor(e){super(),Ee(this,e,null,v1,be,{})}}function b1(c){let e;const t=c[2].default,r=xn(t,c,c[3],null);return{c(){r&&r.c()},l($){r&&r.l($)},m($,n){r&&r.m($,n),e=!0},p($,n){r&&r.p&&(!e||n&8)&&Fn(r,t,$,$[3],e?Mn(t,$[3],n,null):yn($[3]),null)},i($){e||(b(r,$),e=!0)},o($){w(r,$),e=!1},d($){r&&r.d($)}}}function w1(c){let e,t;return e=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/"+c[1]+"-extensions/man/html/"+c[0]+".html",target:"_blank",$$slots:{default:[b1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment)},l(r){S(e.$$.fragment,r)},m(r,$){D(e,r,$),t=!0},p(r,[$]){const n={};$&3&&(n.href="https://registry.khronos.org/vulkan/specs/"+r[1]+"-extensions/man/html/"+r[0]+".html"),$&8&&(n.$$scope={dirty:$,ctx:r}),e.$set(n)},i(r){t||(b(e.$$.fragment,r),t=!0)},o(r){w(e.$$.fragment,r),t=!1},d(r){C(e,r)}}}function I1(c,e,t){let{$$slots:r={},$$scope:$}=e,{reference:n}=e,{version:s}=e;return c.$$set=a=>{"reference"in a&&t(0,n=a.reference),"version"in a&&t(1,s=a.version),"$$scope"in a&&t(3,$=a.$$scope)},[n,s,r,$]}class Bt extends ve{constructor(e){super(),Ee(this,e,I1,w1,be,{reference:0,version:1})}}function D1(c){let e;return{c(){e=i("Buffer Director")},l(t){e=f(t,"Buffer Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C1(c){let e;return{c(){e=i("Buffer Builder")},l(t){e=f(t,"Buffer Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S1(c){let e,t,r,$,n,s,a,u,p;return n=new G({props:{sectionID:L.BUFFER_DIRECTOR,$$slots:{default:[D1]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[C1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Buffer."),r=d("br"),$=i(`
        It is recommended to not create a Buffer by it's Constructor, but to use
        a `),I(n.$$.fragment),s=i(" or "),I(a.$$.fragment),u=i(" instead."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Create a new Buffer."),r=g(_,"BR",{}),$=f(_,`
        It is recommended to not create a Buffer by it's Constructor, but to use
        a `),S(n.$$.fragment,_),s=f(_," or "),S(a.$$.fragment,_),u=f(_," instead."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function P1(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A1(c){let e;return{c(){e=i("VkBufferCreateFlagBits")},l(t){e=f(t,"VkBufferCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R1(c){let e;return{c(){e=i("VkBufferUsageFlagBits")},l(t){e=f(t,"VkBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function B1(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L1(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k1(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T1(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V1(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O1(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y=Ye().Fillcan.version+"",V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[P1]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html",target:"_blank",$$slots:{default:[A1]},$$scope:{ctx:c}}}),pe=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[R1]},$$scope:{ctx:c}}}),ge=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[B1]},$$scope:{ctx:c}}}),Pe=new G({props:{sectionID:L.QUEUE,$$slots:{default:[L1]},$$scope:{ctx:c}}}),ce=new G({props:{sectionID:L.QUEUE,$$slots:{default:[k1]},$$scope:{ctx:c}}}),xe=new G({props:{sectionID:L.QUEUE,$$slots:{default:[T1]},$$scope:{ctx:c}}}),Qe=new G({props:{sectionID:L.QUEUE,$$slots:{default:[V1]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Buffer should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" which are all related to sparse buffers."),F=d("br"),B=i(`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),V=i(y),x=i("."),M=Y(),O=d("li"),H=d("code"),k=i("size"),N=d("br"),Q=i(`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),X=d("code"),Z=i("1024"),K=i(`
            * `),W=d("code"),q=i("1024"),U=i(")."),te=Y(),ee=d("li"),se=d("code"),ie=i("usage"),ae=d("br"),J=i(`
            A bitmask of members of the `),I(pe.$$.fragment),Se=i("-enumerant telling Vulkan how the Buffer will be used."),de=Y(),me=d("li"),De=d("code"),_e=i("sharingMode"),ne=d("br"),le=i(`
            A member of the `),I(ge.$$.fragment),we=i(`-enumerant indicating how the Buffer will be used in the multiple
            device `),I(Pe.$$.fragment),Be=i(` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Buffer will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Ie=d("code"),re=i("sharingMode"),he=i(`
            to `),Le=d("code"),Oe=i("VK_SHARING_MODE_EXCLUSIVE"),oe=i(` tells Vulkan that the
            Buffer will only be used for a single `),I(ce.$$.fragment),Ae=i(`, while setting
            `),ye=d("code"),Fe=i("sharingMode"),Ve=i(`
            to
            `),Ge=d("code"),He=i("VK_SHARING_MODE_CONCURRENT"),ze=i(` specifies that the
            application will use the Buffer on multiple `),I(xe.$$.fragment),Ne=i(` at once. Using
            `),Te=d("code"),qe=i("VK_SHARING_MODE_CONCURRENT"),Ke=i(` may result in lower
            performance on some systems, so unless necessary,
            `),je=d("code"),rt=i("sharingMode"),Me=i(`
            should be set to `),Ue=d("code"),$t=i("VK_SHARING_MODE_EXCLUSIVE"),ut=i("."),ht=Y(),Je=d("li"),dt=d("code"),et=i("queueFamilyIndices"),Ze=d("br"),nt=i(`
            An array of `),I(Qe.$$.fragment),ct=i(`
            family indices on which the buffer will be used.`),this.h()},l(We){e=g(We,"DIV",{slot:!0});var at=E(e);t=g(at,"LI",{});var bt=E(t);r=g(bt,"CODE",{});var wt=E(r);$=f(wt,"pLogicalDevice"),wt.forEach(l),n=g(bt,"BR",{}),s=f(bt,`
            A pointer to the `),S(a.$$.fragment,bt),u=f(bt," the Buffer should be associated with."),bt.forEach(l),p=j(at),m=g(at,"LI",{});var St=E(m);_=g(St,"CODE",{});var tt=E(_);v=f(tt,"flags"),tt.forEach(l),P=g(St,"BR",{}),R=f(St,`
            A bitmask of `),S(A.$$.fragment,St),T=f(St," which are all related to sparse buffers."),F=g(St,"BR",{}),B=f(St,`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),V=f(St,y),x=f(St,"."),St.forEach(l),M=j(at),O=g(at,"LI",{});var ot=E(O);H=g(ot,"CODE",{});var At=E(H);k=f(At,"size"),At.forEach(l),N=g(ot,"BR",{}),Q=f(ot,`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),X=g(ot,"CODE",{});var it=E(X);Z=f(it,"1024"),it.forEach(l),K=f(ot,`
            * `),W=g(ot,"CODE",{});var Xe=E(W);q=f(Xe,"1024"),Xe.forEach(l),U=f(ot,")."),ot.forEach(l),te=j(at),ee=g(at,"LI",{});var Dt=E(ee);se=g(Dt,"CODE",{});var Ct=E(se);ie=f(Ct,"usage"),Ct.forEach(l),ae=g(Dt,"BR",{}),J=f(Dt,`
            A bitmask of members of the `),S(pe.$$.fragment,Dt),Se=f(Dt,"-enumerant telling Vulkan how the Buffer will be used."),Dt.forEach(l),de=j(at),me=g(at,"LI",{});var pt=E(me);De=g(pt,"CODE",{});var Ft=E(De);_e=f(Ft,"sharingMode"),Ft.forEach(l),ne=g(pt,"BR",{}),le=f(pt,`
            A member of the `),S(ge.$$.fragment,pt),we=f(pt,`-enumerant indicating how the Buffer will be used in the multiple
            device `),S(Pe.$$.fragment,pt),Be=f(pt,` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Buffer will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Ie=g(pt,"CODE",{});var mt=E(Ie);re=f(mt,"sharingMode"),mt.forEach(l),he=f(pt,`
            to `),Le=g(pt,"CODE",{});var Vt=E(Le);Oe=f(Vt,"VK_SHARING_MODE_EXCLUSIVE"),Vt.forEach(l),oe=f(pt,` tells Vulkan that the
            Buffer will only be used for a single `),S(ce.$$.fragment,pt),Ae=f(pt,`, while setting
            `),ye=g(pt,"CODE",{});var Rt=E(ye);Fe=f(Rt,"sharingMode"),Rt.forEach(l),Ve=f(pt,`
            to
            `),Ge=g(pt,"CODE",{});var Tt=E(Ge);He=f(Tt,"VK_SHARING_MODE_CONCURRENT"),Tt.forEach(l),ze=f(pt,` specifies that the
            application will use the Buffer on multiple `),S(xe.$$.fragment,pt),Ne=f(pt,` at once. Using
            `),Te=g(pt,"CODE",{});var vt=E(Te);qe=f(vt,"VK_SHARING_MODE_CONCURRENT"),vt.forEach(l),Ke=f(pt,` may result in lower
            performance on some systems, so unless necessary,
            `),je=g(pt,"CODE",{});var gt=E(je);rt=f(gt,"sharingMode"),gt.forEach(l),Me=f(pt,`
            should be set to `),Ue=g(pt,"CODE",{});var kt=E(Ue);$t=f(kt,"VK_SHARING_MODE_EXCLUSIVE"),kt.forEach(l),ut=f(pt,"."),pt.forEach(l),ht=j(at),Je=g(at,"LI",{});var Mt=E(Je);dt=g(Mt,"CODE",{});var yt=E(dt);et=f(yt,"queueFamilyIndices"),yt.forEach(l),Ze=g(Mt,"BR",{}),nt=f(Mt,`
            An array of `),S(Qe.$$.fragment,Mt),ct=f(Mt,`
            family indices on which the buffer will be used.`),Mt.forEach(l),at.forEach(l),this.h()},h(){z(e,"slot","params")},m(We,at){h(We,e,at),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(m,F),o(m,B),o(m,V),o(m,x),o(e,M),o(e,O),o(O,H),o(H,k),o(O,N),o(O,Q),o(O,X),o(X,Z),o(O,K),o(O,W),o(W,q),o(O,U),o(e,te),o(e,ee),o(ee,se),o(se,ie),o(ee,ae),o(ee,J),D(pe,ee,null),o(ee,Se),o(e,de),o(e,me),o(me,De),o(De,_e),o(me,ne),o(me,le),D(ge,me,null),o(me,we),D(Pe,me,null),o(me,Be),o(me,Ie),o(Ie,re),o(me,he),o(me,Le),o(Le,Oe),o(me,oe),D(ce,me,null),o(me,Ae),o(me,ye),o(ye,Fe),o(me,Ve),o(me,Ge),o(Ge,He),o(me,ze),D(xe,me,null),o(me,Ne),o(me,Te),o(Te,qe),o(me,Ke),o(me,je),o(je,rt),o(me,Me),o(me,Ue),o(Ue,$t),o(me,ut),o(e,ht),o(e,Je),o(Je,dt),o(dt,et),o(Je,Ze),o(Je,nt),D(Qe,Je,null),o(Je,ct),st=!0},p(We,at){const bt={};at&1&&(bt.$$scope={dirty:at,ctx:We}),a.$set(bt);const wt={};at&1&&(wt.$$scope={dirty:at,ctx:We}),A.$set(wt);const St={};at&1&&(St.$$scope={dirty:at,ctx:We}),pe.$set(St);const tt={};at&1&&(tt.$$scope={dirty:at,ctx:We}),ge.$set(tt);const ot={};at&1&&(ot.$$scope={dirty:at,ctx:We}),Pe.$set(ot);const At={};at&1&&(At.$$scope={dirty:at,ctx:We}),ce.$set(At);const it={};at&1&&(it.$$scope={dirty:at,ctx:We}),xe.$set(it);const Xe={};at&1&&(Xe.$$scope={dirty:at,ctx:We}),Qe.$set(Xe)},i(We){st||(b(a.$$.fragment,We),b(A.$$.fragment,We),b(pe.$$.fragment,We),b(ge.$$.fragment,We),b(Pe.$$.fragment,We),b(ce.$$.fragment,We),b(xe.$$.fragment,We),b(Qe.$$.fragment,We),st=!0)},o(We){w(a.$$.fragment,We),w(A.$$.fragment,We),w(pe.$$.fragment,We),w(ge.$$.fragment,We),w(Pe.$$.fragment,We),w(ce.$$.fragment,We),w(xe.$$.fragment,We),w(Qe.$$.fragment,We),st=!1},d(We){We&&l(e),C(a),C(A),C(pe),C(ge),C(Pe),C(ce),C(xe),C(Qe)}}}function F1(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y1(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkBuffer",version:1.3,$$slots:{default:[F1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function M1(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Buffer(
    LogicalDevice* pLogicalDevice, 
    VkBufferCreateFlags& flags, 
    VkDeviceSize& size, 
    VkBufferUsageFlags& usage, 
    VkSharingMode& sharingMode,
    std::vector<uint32_t> queueFamilyIndices = {}
);`}}),r=new Ce({props:{$$slots:{throws:[y1],params:[O1],details:[S1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class x1 extends ve{constructor(e){super(),Ee(this,e,null,M1,be,{})}}function N1(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U1(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[N1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function G1(c){let e;return{c(){e=i("Vulkan Buffer")},l(t){e=f(t,"Vulkan Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H1(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html",target:"_blank",$$slots:{default:[G1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function q1(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkBuffer getBufferHandle() const;"}}),r=new Ce({props:{$$slots:{return:[H1],details:[U1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class W1 extends ve{constructor(e){super(),Ee(this,e,null,q1,be,{})}}function Q1(c){let e,t;return{c(){e=d("span"),t=i("Get the flags used for creating the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the flags used for creating the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function K1(c){let e,t;return{c(){e=d("span"),t=i("The flags set when creating of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The flags set when creating of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function z1(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkBufferCreateFlags getFlags();"}}),r=new Ce({props:{$$slots:{return:[K1],details:[Q1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Y1 extends ve{constructor(e){super(),Ee(this,e,null,z1,be,{})}}function j1(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X1(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_Constructor,$$slots:{default:[j1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the size given in the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the size given in the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Z1(c){let e;return{c(){e=i("Constructor")},l(t){e=f(t,"Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J1(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_Constructor,$$slots:{default:[Z1]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The size given in the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The size given in the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function ew(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkDeviceSize getSize();"}}),r=new Ce({props:{$$slots:{return:[J1],details:[X1]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tw extends ve{constructor(e){super(),Ee(this,e,null,ew,be,{})}}function rw(c){let e,t;return{c(){e=d("span"),t=i("Get the intended usage of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended usage of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function nw(c){let e,t;return{c(){e=d("span"),t=i("The intended usage of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The intended usage of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function sw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkBufferUsageFlags getUsage();"}}),r=new Ce({props:{$$slots:{return:[nw],details:[rw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aw extends ve{constructor(e){super(),Ee(this,e,null,sw,be,{})}}function ow(c){let e,t;return{c(){e=d("span"),t=i("Get the sharing mode of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sharing mode of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function lw(c){let e,t;return{c(){e=d("span"),t=i("The sharing mode of the Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sharing mode of the Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function iw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSharingMode getSharingMode();"}}),r=new Ce({props:{$$slots:{return:[lw],details:[ow]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fw extends ve{constructor(e){super(),Ee(this,e,null,iw,be,{})}}function cw(c){let e,t;return{c(){e=d("span"),t=i("Get the queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function $w(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function uw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[$w],details:[cw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class pw extends ve{constructor(e){super(),Ee(this,e,null,uw,be,{})}}function mw(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.MEMORY,$$slots:{default:[mw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind "),I(r.$$.fragment),$=i(" to the Buffer."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind "),S(r.$$.fragment,a),$=f(a," to the Buffer."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function dw(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gw(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _w(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vw(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return a=new G({props:{sectionID:L.MEMORY,$$slots:{default:[dw]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.MEMORY,$$slots:{default:[gw]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.MEMORY,$$slots:{default:[_w]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pMemory"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to the Buffer."),p=Y(),m=d("li"),_=d("code"),v=i("memoryOffset"),P=d("br"),R=i(`
            Specifies the offset in the `),I(A.$$.fragment),T=i(` object the Buffer will live. If only one resource will be bound to
            the `),I(F.$$.fragment),B=i(` object,
            this can be set to
            `),y=d("code"),V=i("0"),x=i("."),this.h()},l(O){e=g(O,"DIV",{slot:!0});var H=E(e);t=g(H,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"pMemory"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            A pointer to the `),S(a.$$.fragment,k),u=f(k," to bind to the Buffer."),k.forEach(l),p=j(H),m=g(H,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"memoryOffset"),X.forEach(l),P=g(Q,"BR",{}),R=f(Q,`
            Specifies the offset in the `),S(A.$$.fragment,Q),T=f(Q,` object the Buffer will live. If only one resource will be bound to
            the `),S(F.$$.fragment,Q),B=f(Q,` object,
            this can be set to
            `),y=g(Q,"CODE",{});var Z=E(y);V=f(Z,"0"),Z.forEach(l),x=f(Q,"."),Q.forEach(l),H.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,H){h(O,e,H),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),o(m,y),o(y,V),o(m,x),M=!0},p(O,H){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),a.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),A.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),F.$set(Q)},i(O){M||(b(a.$$.fragment,O),b(A.$$.fragment,O),b(F.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(A.$$.fragment,O),w(F.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(A),C(F)}}}function Ew(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void bindMemory(Memory* pMemory, VkDeviceSize memoryOffset = 0);"}}),r=new Ce({props:{$$slots:{params:[vw],details:[hw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bw extends ve{constructor(e){super(),Ee(this,e,null,Ew,be,{})}}function ww(c){let e;return{c(){e=i("bindMemory")},l(t){e=f(t,"bindMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_bindMemory,$$slots:{default:[ww]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the Memory bound with "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the Memory bound with "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Dw(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cw(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sw(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.MEMORY,$$slots:{default:[Dw]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.MEMORY,$$slots:{default:[Cw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function Pw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Memory* getMemory() const;"}}),r=new Ce({props:{$$slots:{return:[Sw],details:[Iw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Aw extends ve{constructor(e){super(),Ee(this,e,null,Pw,be,{})}}function Rw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Rw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Lw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ow(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fw(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae;return P=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Lw]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[kw]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Tw]},$$scope:{ctx:c}}}),X=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Vw]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Ow]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            The format in which to interpret the Buffer.`),a=Y(),u=d("li"),p=d("code"),m=i("offset"),_=d("br"),v=i(`
            The `),I(P.$$.fragment),R=i(' will be a "window" into the parent buffer. The '),A=d("code"),T=i("offset"),F=i(`
            is the number of bytes within the Buffer where the `),I(B.$$.fragment),y=i(" should start. To create a "),I(V.$$.fragment),x=i(" of the entire Buffer, this must be 0."),M=Y(),O=d("li"),H=d("code"),k=i("range"),N=d("br"),Q=i(`
            The number of bytes the `),I(X.$$.fragment),Z=i(" will contain from "),K=d("code"),W=i("offset"),q=i(". To create a "),I(U.$$.fragment),te=i(` of the entire Buffer, this must be
            `),ee=d("code"),se=i("VK_WHOLE_SIZE"),ie=i("."),this.h()},l(J){e=g(J,"DIV",{slot:!0});var pe=E(e);t=g(pe,"LI",{});var Se=E(t);r=g(Se,"CODE",{});var de=E(r);$=f(de,"format"),de.forEach(l),n=g(Se,"BR",{}),s=f(Se,`
            The format in which to interpret the Buffer.`),Se.forEach(l),a=j(pe),u=g(pe,"LI",{});var me=E(u);p=g(me,"CODE",{});var De=E(p);m=f(De,"offset"),De.forEach(l),_=g(me,"BR",{}),v=f(me,`
            The `),S(P.$$.fragment,me),R=f(me,' will be a "window" into the parent buffer. The '),A=g(me,"CODE",{});var _e=E(A);T=f(_e,"offset"),_e.forEach(l),F=f(me,`
            is the number of bytes within the Buffer where the `),S(B.$$.fragment,me),y=f(me," should start. To create a "),S(V.$$.fragment,me),x=f(me," of the entire Buffer, this must be 0."),me.forEach(l),M=j(pe),O=g(pe,"LI",{});var ne=E(O);H=g(ne,"CODE",{});var le=E(H);k=f(le,"range"),le.forEach(l),N=g(ne,"BR",{}),Q=f(ne,`
            The number of bytes the `),S(X.$$.fragment,ne),Z=f(ne," will contain from "),K=g(ne,"CODE",{});var ge=E(K);W=f(ge,"offset"),ge.forEach(l),q=f(ne,". To create a "),S(U.$$.fragment,ne),te=f(ne,` of the entire Buffer, this must be
            `),ee=g(ne,"CODE",{});var we=E(ee);se=f(we,"VK_WHOLE_SIZE"),we.forEach(l),ie=f(ne,"."),ne.forEach(l),pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(J,pe){h(J,e,pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(u,A),o(A,T),o(u,F),D(B,u,null),o(u,y),D(V,u,null),o(u,x),o(e,M),o(e,O),o(O,H),o(H,k),o(O,N),o(O,Q),D(X,O,null),o(O,Z),o(O,K),o(K,W),o(O,q),D(U,O,null),o(O,te),o(O,ee),o(ee,se),o(O,ie),ae=!0},p(J,pe){const Se={};pe&1&&(Se.$$scope={dirty:pe,ctx:J}),P.$set(Se);const de={};pe&1&&(de.$$scope={dirty:pe,ctx:J}),B.$set(de);const me={};pe&1&&(me.$$scope={dirty:pe,ctx:J}),V.$set(me);const De={};pe&1&&(De.$$scope={dirty:pe,ctx:J}),X.$set(De);const _e={};pe&1&&(_e.$$scope={dirty:pe,ctx:J}),U.$set(_e)},i(J){ae||(b(P.$$.fragment,J),b(B.$$.fragment,J),b(V.$$.fragment,J),b(X.$$.fragment,J),b(U.$$.fragment,J),ae=!0)},o(J){w(P.$$.fragment,J),w(B.$$.fragment,J),w(V.$$.fragment,J),w(X.$$.fragment,J),w(U.$$.fragment,J),ae=!1},d(J){J&&l(e),C(P),C(B),C(V),C(X),C(U)}}}function yw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xw(c){let e;return{c(){e=i("getBufferView")},l(t){e=f(t,"getBufferView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nw(c){let e,t,r,$,n,s,a,u,p;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[yw]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Mw]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.BUFFER_getBufferView,$$slots:{default:[xw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to get the created "),I(n.$$.fragment),s=i(" using "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to get the created "),S(n.$$.fragment,_),s=f(_," using "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),n.$set(P);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function Uw(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gw(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Uw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Hw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int createBufferView(VkFormat format, VkDeviceSize offset = 0, VkDeviceSize range = VK_WHOLE_SIZE);"}}),r=new Ce({props:{$$slots:{throws:[Gw],return:[Nw],params:[Fw],details:[Bw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qw extends ve{constructor(e){super(),Ee(this,e,null,Hw,be,{})}}function Ww(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Ww]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Kw(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Kw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Yw(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<BufferView*> getBufferViews();"}}),r=new Ce({props:{$$slots:{return:[zw],details:[Qw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jw extends ve{constructor(e){super(),Ee(this,e,null,Yw,be,{})}}function Xw(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zw(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Xw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Jw(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eI(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[Jw]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tI(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<BufferView*> getBufferViews();"}}),r=new Ce({props:{$$slots:{return:[eI],details:[Zw]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class rI extends ve{constructor(e){super(),Ee(this,e,null,tI,be,{})}}function nI(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sI(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[nI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy a "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy a "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aI(c){let e;return{c(){e=i("Buffer View")},l(t){e=f(t,"Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oI(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[aI]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to destroy."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"index"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to destroy."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function lI(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroyBufferView(unsigned int index);"}}),r=new Ce({props:{$$slots:{params:[oI],details:[sI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iI extends ve{constructor(e){super(),Ee(this,e,null,lI,be,{})}}function fI(c){let e;return{c(){e=i("Buffer Views")},l(t){e=f(t,"Buffer Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cI(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[fI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy all created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy all created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function $I(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroyBufferViews();"}}),r=new Ce({props:{$$slots:{details:[cI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uI extends ve{constructor(e){super(),Ee(this,e,null,$I,be,{})}}function pI(c){let e,t;return{c(){e=d("span"),t=i("Copy this Buffer's data to a given Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Buffer's data to a given Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function mI(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hI(c){let e;return{c(){e=i("VkBufferCopy")},l(t){e=f(t,"VkBufferCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dI(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[mI]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html",target:"_blank",$$slots:{default:[hI]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=Y(),m=d("li"),_=d("code"),v=i("pBuffer"),P=d("br"),R=i(`
            A pointer to the Buffer to copy this Buffer's data to.`),A=Y(),T=d("li"),F=d("code"),B=i("regions"),y=d("br"),V=i(`
            An array of `),I(x.$$.fragment),M=i("-structures, each of which describes a region of data to copy."),O=Y(),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"pCommandBuffer"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The `),S(a.$$.fragment,Q),u=f(Q," to use to execute the copy."),Q.forEach(l),p=j(N),m=g(N,"LI",{});var Z=E(m);_=g(Z,"CODE",{});var K=E(_);v=f(K,"pBuffer"),K.forEach(l),P=g(Z,"BR",{}),R=f(Z,`
            A pointer to the Buffer to copy this Buffer's data to.`),Z.forEach(l),A=j(N),T=g(N,"LI",{});var W=E(T);F=g(W,"CODE",{});var q=E(F);B=f(q,"regions"),q.forEach(l),y=g(W,"BR",{}),V=f(W,`
            An array of `),S(x.$$.fragment,W),M=f(W,"-structures, each of which describes a region of data to copy."),W.forEach(l),O=j(N),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),o(e,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),a.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),x.$set(X)},i(k){H||(b(a.$$.fragment,k),b(x.$$.fragment,k),H=!0)},o(k){w(a.$$.fragment,k),w(x.$$.fragment,k),H=!1},d(k){k&&l(e),C(a),C(x)}}}function gI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _I(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[gI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Copy this Buffer's data to a given "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Copy this Buffer's data to a given "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vI(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bI(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wI(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function II(c){let e;return{c(){e=i("VkBufferCopy")},l(t){e=f(t,"VkBufferCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DI(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[vI]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[EI]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.IMAGE,$$slots:{default:[bI]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[wI]},$$scope:{ctx:c}}}),Pe=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html",target:"_blank",$$slots:{default:[II]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=Y(),m=d("li"),_=d("code"),v=i("pImage"),P=d("br"),R=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to copy this Buffer's data to."),F=Y(),B=d("li"),y=d("code"),V=i("dstLayout"),x=d("br"),M=i(`
            The layout of the destination `),I(O.$$.fragment),H=i(" subresources for the copy. This should be a member of the "),I(k.$$.fragment),N=i("-enumerant."),Q=d("br"),X=i(`
            This is most likely either
            `),Z=d("code"),K=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),W=i(`,
            `),q=d("code"),U=i("VK_IMAGE_LAYOUT_GENERAL"),te=i(`
            or `),ee=d("code"),se=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ie=i("."),ae=Y(),J=d("li"),pe=d("code"),Se=i("pBuffer"),de=d("br"),me=i(`
            A pointer to the Buffer to copy this Buffer's data to.`),De=Y(),_e=d("li"),ne=d("code"),le=i("regions"),ge=d("br"),we=i(`
            An array of `),I(Pe.$$.fragment),Be=i("-structures, each of which describes a region of data to copy."),this.h()},l(re){e=g(re,"DIV",{slot:!0});var he=E(e);t=g(he,"LI",{});var Le=E(t);r=g(Le,"CODE",{});var Oe=E(r);$=f(Oe,"pCommandBuffer"),Oe.forEach(l),n=g(Le,"BR",{}),s=f(Le,`
            The `),S(a.$$.fragment,Le),u=f(Le," to use to execute the copy."),Le.forEach(l),p=j(he),m=g(he,"LI",{});var oe=E(m);_=g(oe,"CODE",{});var ce=E(_);v=f(ce,"pImage"),ce.forEach(l),P=g(oe,"BR",{}),R=f(oe,`
            A pointer to the `),S(A.$$.fragment,oe),T=f(oe," to copy this Buffer's data to."),oe.forEach(l),F=j(he),B=g(he,"LI",{});var Ae=E(B);y=g(Ae,"CODE",{});var ye=E(y);V=f(ye,"dstLayout"),ye.forEach(l),x=g(Ae,"BR",{}),M=f(Ae,`
            The layout of the destination `),S(O.$$.fragment,Ae),H=f(Ae," subresources for the copy. This should be a member of the "),S(k.$$.fragment,Ae),N=f(Ae,"-enumerant."),Q=g(Ae,"BR",{}),X=f(Ae,`
            This is most likely either
            `),Z=g(Ae,"CODE",{});var Fe=E(Z);K=f(Fe,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Fe.forEach(l),W=f(Ae,`,
            `),q=g(Ae,"CODE",{});var Ve=E(q);U=f(Ve,"VK_IMAGE_LAYOUT_GENERAL"),Ve.forEach(l),te=f(Ae,`
            or `),ee=g(Ae,"CODE",{});var Ge=E(ee);se=f(Ge,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),Ge.forEach(l),ie=f(Ae,"."),Ae.forEach(l),ae=j(he),J=g(he,"LI",{});var He=E(J);pe=g(He,"CODE",{});var ze=E(pe);Se=f(ze,"pBuffer"),ze.forEach(l),de=g(He,"BR",{}),me=f(He,`
            A pointer to the Buffer to copy this Buffer's data to.`),He.forEach(l),De=j(he),_e=g(he,"LI",{});var xe=E(_e);ne=g(xe,"CODE",{});var Ne=E(ne);le=f(Ne,"regions"),Ne.forEach(l),ge=g(xe,"BR",{}),we=f(xe,`
            An array of `),S(Pe.$$.fragment,xe),Be=f(xe,"-structures, each of which describes a region of data to copy."),xe.forEach(l),he.forEach(l),this.h()},h(){z(e,"slot","params")},m(re,he){h(re,e,he),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),o(B,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,q),o(q,U),o(B,te),o(B,ee),o(ee,se),o(B,ie),o(e,ae),o(e,J),o(J,pe),o(pe,Se),o(J,de),o(J,me),o(e,De),o(e,_e),o(_e,ne),o(ne,le),o(_e,ge),o(_e,we),D(Pe,_e,null),o(_e,Be),Ie=!0},p(re,he){const Le={};he&1&&(Le.$$scope={dirty:he,ctx:re}),a.$set(Le);const Oe={};he&1&&(Oe.$$scope={dirty:he,ctx:re}),A.$set(Oe);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),O.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),k.$set(ce);const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),Pe.$set(Ae)},i(re){Ie||(b(a.$$.fragment,re),b(A.$$.fragment,re),b(O.$$.fragment,re),b(k.$$.fragment,re),b(Pe.$$.fragment,re),Ie=!0)},o(re){w(a.$$.fragment,re),w(A.$$.fragment,re),w(O.$$.fragment,re),w(k.$$.fragment,re),w(Pe.$$.fragment,re),Ie=!1},d(re){re&&l(e),C(a),C(A),C(O),C(k),C(Pe)}}}function CI(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void copyTo(CommandBuffer* pCommandBuffer, Buffer* pBuffer, std::vector<VkBufferCopy>& regions);"}}),r=new Ce({props:{$$slots:{params:[dI],details:[pI]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:"void copyTo(CommandBuffer* pCommandBuffer, Image* pImage, VkImageLayout dstLayout, std::vector<VkBufferImageCopy>& regions);"}}),u=new Ce({props:{$$slots:{params:[DI],details:[_I]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class SI extends ve{constructor(e){super(),Ee(this,e,null,CI,be,{})}}function PI(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AI(c){let e;return{c(){e=i("Vulkan Image Object")},l(t){e=f(t,"Vulkan Image Object")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RI(c){let e;return{c(){e=i("Vulkan Images")},l(t){e=f(t,"Vulkan Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BI(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LI(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kI(c){let e;return{c(){e=i("Descriptor Sets")},l(t){e=f(t,"Descriptor Sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TI(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/image.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[PI]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[AI]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[RI]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[BI]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[LI]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[kI]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a size and usage and uses this information to create a "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=d("br"),_=Y(),I(v.$$.fragment),P=i(` represent linear arrays of data that are used for different purposes by binding
them to a `),I(R.$$.fragment),A=i(" or "),I(T.$$.fragment),F=i(" via "),I(B.$$.fragment),y=i(` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},l(x){S(e.$$.fragment,x),t=f(x,`
The `),r=g(x,"CODE",{});var M=E(r);$=f(M,"Image"),M.forEach(l),n=f(x," class takes a pointer to a "),S(s.$$.fragment,x),a=f(x," along with a size and usage and uses this information to create a "),S(u.$$.fragment,x),p=f(x,` which it will wrap around to offer functionality such as: binding memory, creating
and destroying buffer views and copying data.`),m=g(x,"BR",{}),_=j(x),S(v.$$.fragment,x),P=f(x,` represent linear arrays of data that are used for different purposes by binding
them to a `),S(R.$$.fragment,x),A=f(x," or "),S(T.$$.fragment,x),F=f(x," via "),S(B.$$.fragment,x),y=f(x,` or via certain commands, or by specifying them directly as parameters for certain
commands.`)},m(x,M){D(e,x,M),h(x,t,M),h(x,r,M),o(r,$),h(x,n,M),D(s,x,M),h(x,a,M),D(u,x,M),h(x,p,M),h(x,m,M),h(x,_,M),D(v,x,M),h(x,P,M),D(R,x,M),h(x,A,M),D(T,x,M),h(x,F,M),D(B,x,M),h(x,y,M),V=!0},p(x,[M]){const O={};M&1&&(O.$$scope={dirty:M,ctx:x}),s.$set(O);const H={};M&1&&(H.$$scope={dirty:M,ctx:x}),u.$set(H);const k={};M&1&&(k.$$scope={dirty:M,ctx:x}),v.$set(k);const N={};M&1&&(N.$$scope={dirty:M,ctx:x}),R.$set(N);const Q={};M&1&&(Q.$$scope={dirty:M,ctx:x}),T.$set(Q);const X={};M&1&&(X.$$scope={dirty:M,ctx:x}),B.$set(X)},i(x){V||(b(e.$$.fragment,x),b(s.$$.fragment,x),b(u.$$.fragment,x),b(v.$$.fragment,x),b(R.$$.fragment,x),b(T.$$.fragment,x),b(B.$$.fragment,x),V=!0)},o(x){w(e.$$.fragment,x),w(s.$$.fragment,x),w(u.$$.fragment,x),w(v.$$.fragment,x),w(R.$$.fragment,x),w(T.$$.fragment,x),w(B.$$.fragment,x),V=!1},d(x){C(e,x),x&&l(t),x&&l(r),x&&l(n),C(s,x),x&&l(a),C(u,x),x&&l(p),x&&l(m),x&&l(_),C(v,x),x&&l(P),C(R,x),x&&l(A),C(T,x),x&&l(F),C(B,x),x&&l(y)}}}class VI extends ve{constructor(e){super(),Ee(this,e,null,TI,be,{})}}function OI(c){let e;return{c(){e=i("Image Director")},l(t){e=f(t,"Image Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FI(c){let e;return{c(){e=i("Image Builder")},l(t){e=f(t,"Image Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yI(c){let e,t,r,$,n,s,a,u,p;return n=new G({props:{sectionID:L.IMAGE_DIRECTOR,$$slots:{default:[OI]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[FI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Image."),r=d("br"),$=i(`
        It is recommended to not create a Image by it's Constructor, but to use a
        `),I(n.$$.fragment),s=i(" or "),I(a.$$.fragment),u=i(" instead."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Create a new Image."),r=g(_,"BR",{}),$=f(_,`
        It is recommended to not create a Image by it's Constructor, but to use a
        `),S(n.$$.fragment,_),s=f(_," or "),S(a.$$.fragment,_),u=f(_," instead."),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),n.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(n),C(a)}}}function MI(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xI(c){let e;return{c(){e=i("VkImageCreateFlagBits")},l(t){e=f(t,"VkImageCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NI(c){let e;return{c(){e=i("VkExtent3D")},l(t){e=f(t,"VkExtent3D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UI(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GI(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HI(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qI(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WI(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QI(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KI(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zI(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YI(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jI(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,Ft,mt,Vt,Rt,Tt,vt,gt,kt,Mt,yt,Ht,$r,Ut,or,Xt,Ot,Zt,Ar,br,ur,Qt,Or,rr,Kr,lr,gr,Fr,Kt,ir,yr,Re,lt,Jt,_r,Yt,nr,vr,Tr,fr,cr,sr,er,zr,_t,ft,qt,Mr,wr,Nt,Wt,xr,pr,Vr,jt,Rr,Ir,Nr,mr,Dr,hr,Br,Cr,en,Ur,tr,Gr,tn,jr,ln,Er,fn,Lr,cn,Yr;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[MI]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html",target:"_blank",$$slots:{default:[xI]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html",target:"_blank",$$slots:{default:[NI]},$$scope:{ctx:c}}}),dt=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html",target:"_blank",$$slots:{default:[UI]},$$scope:{ctx:c}}}),at=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[GI]},$$scope:{ctx:c}}}),Vt=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[HI]},$$scope:{ctx:c}}}),Ht=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[qI]},$$scope:{ctx:c}}}),Ut=new G({props:{sectionID:L.QUEUE,$$slots:{default:[WI]},$$scope:{ctx:c}}}),Qt=new G({props:{sectionID:L.QUEUE,$$slots:{default:[QI]},$$scope:{ctx:c}}}),ir=new G({props:{sectionID:L.QUEUE,$$slots:{default:[KI]},$$scope:{ctx:c}}}),qt=new G({props:{sectionID:L.QUEUE,$$slots:{default:[zI]},$$scope:{ctx:c}}}),jt=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[YI]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Image should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" that describe some properties of the image."),F=Y(),B=d("li"),y=d("code"),V=i("type"),x=d("br"),M=i(`
            The type of image being created. The image type is essentially the dimensionality
            of the image and can be `),O=d("code"),H=i("VK_IMAGE_TYPE_1D"),k=i(`,
            `),N=d("code"),Q=i("VK_IMAGE_TYPE_2D"),X=i(`
            or `),Z=d("code"),K=i("VK_IMAGE_TYPE_3D"),W=i(`
            for a 1D, 2D or 3D image respectively.`),q=Y(),U=d("li"),te=d("code"),ee=i("format"),se=d("br"),ie=i(`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),ae=Y(),J=d("li"),pe=d("code"),Se=i("extent"),de=d("br"),me=i(`
            The size of the image in texels. This should be an instance of the `),I(De.$$.fragment),_e=i(`
            structure , which has three members: `),ne=d("code"),le=i("width"),ge=i(`,
            `),we=d("code"),Pe=i("height"),Be=i(", and "),Ie=d("code"),re=i("depth"),he=i(`. These should be set
            respectively to the width, height and depth of the desired image.
            For 1D images, the height should be set to `),Le=d("code"),Oe=i("1"),oe=i(`, and for
            1D and 2D images, the depth should be set to `),ce=d("code"),Ae=i("1"),ye=i("."),Fe=Y(),Ve=d("li"),Ge=d("code"),He=i("mipLevels"),ze=d("br"),xe=i(`
            The number of mipmap levels to create in the image.`),Ne=Y(),Te=d("li"),qe=d("code"),Ke=i("arrayLayers"),je=d("br"),rt=i(`
            The amount of images each mipmap level of the image has.`),Me=Y(),Ue=d("li"),$t=d("code"),ut=i("samples"),ht=d("br"),Je=i(`
            The number of samples in the image. It must be a member of the `),I(dt.$$.fragment),et=i("-enumerant."),Ze=Y(),nt=d("li"),Qe=d("code"),ct=i("tiling"),st=d("br"),We=i(`
            A member of the `),I(at.$$.fragment),bt=i("-enumerant, which contains only "),wt=d("code"),St=i("VK_IMAGE_TILING_LINEAR"),tt=i(`
            or
            `),ot=d("code"),At=i("VK_IMAGE_TILING_OPTIMAL"),it=i(`. Linear tiling means that image
            data is laid out from left to right, top to bottom, so that if the
            underlying memory is mapped and it is written with the CPU, it would
            form a linear image. Meanwhile, optimal tiling is an opaque display
            used by Vulkan to store data in memory to improve the efficiency of
            the memory subsystem on the device. This is generally what should be
            chosen unless the image needs to be CPU mapped and manipulated.
            Optimal tiling is likely to outperform linear tiling in most
            operations, and linear tiling may not be supported at all for some
            operations or formats, depending on the Vulkan implementation.`),Xe=Y(),Dt=d("li"),Ct=d("code"),pt=i("usage"),Ft=d("br"),mt=i(`
            A bitmask of members of the `),I(Vt.$$.fragment),Rt=i("-enumerant telling Vulkan how the Image will be used."),Tt=Y(),vt=d("li"),gt=d("code"),kt=i("sharingMode"),Mt=d("br"),yt=i(`
            A member of the `),I(Ht.$$.fragment),$r=i(`-enumerant indicating how the Image will be used in the multiple
            device `),I(Ut.$$.fragment),or=i(` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Image will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Xt=d("code"),Ot=i("sharingMode"),Zt=i(`
            to `),Ar=d("code"),br=i("VK_SHARING_MODE_EXCLUSIVE"),ur=i(` tells Vulkan that the
            Image will only be used for a single `),I(Qt.$$.fragment),Or=i(`, while setting
            `),rr=d("code"),Kr=i("sharingMode"),lr=i(`
            to
            `),gr=d("code"),Fr=i("VK_SHARING_MODE_CONCURRENT"),Kt=i(` specifies that the
            application will use the Image on multiple `),I(ir.$$.fragment),yr=i(` at once. Using
            `),Re=d("code"),lt=i("VK_SHARING_MODE_CONCURRENT"),Jt=i(` may result in lower
            performance on some systems, so unless necessary,
            `),_r=d("code"),Yt=i("sharingMode"),nr=i(`
            should be set to `),vr=d("code"),Tr=i("VK_SHARING_MODE_EXCLUSIVE"),fr=i("."),cr=Y(),sr=d("li"),er=d("code"),zr=i("queueFamilyIndices"),_t=d("br"),ft=i(`
            A pointer to an array of `),I(qt.$$.fragment),Mr=i(" family indices on which the image will be used."),wr=Y(),Nt=d("li"),Wt=d("code"),xr=i("initialLayout"),pr=d("br"),Vr=i(`
            Images have a layout, which partially indicates how they will be used
            at a given time. This field determines the layout in which the image
            is created. The available layouts are the members of the `),I(jt.$$.fragment),Rr=i("-enumerant."),Ir=d("br"),Nr=i(`
            Images should initially be created in the format
            `),mr=d("code"),Dr=i("VK_IMAGE_LAYOUT_UNDEFINED"),hr=i(`
            or `),Br=d("code"),Cr=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),en=i(`.
            `),Ur=d("code"),tr=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),Gr=i(`
            should only be used if there is data in memory that is bound immediately
            to the image source.
            `),tn=d("code"),jr=i("VK_IMAGE_LAYOUT_UNDEFINED"),ln=i(`
            should be used when moving the resource to another layout before use.
            Images can be moved out of the
            `),Er=d("code"),fn=i("VK_IMAGE_LAYOUT_UNDEFINED"),Lr=i(` layout at any time with little
            or no time cost.`),cn=Y(),this.h()},l(Lt){e=g(Lt,"DIV",{slot:!0});var It=E(e);t=g(It,"LI",{});var Hr=E(t);r=g(Hr,"CODE",{});var kr=E(r);$=f(kr,"pLogicalDevice"),kr.forEach(l),n=g(Hr,"BR",{}),s=f(Hr,`
            A pointer to the `),S(a.$$.fragment,Hr),u=f(Hr," the Image should be associated with."),Hr.forEach(l),p=j(It),m=g(It,"LI",{});var qr=E(m);_=g(qr,"CODE",{});var dn=E(_);v=f(dn,"flags"),dn.forEach(l),P=g(qr,"BR",{}),R=f(qr,`
            A bitmask of `),S(A.$$.fragment,qr),T=f(qr," that describe some properties of the image."),qr.forEach(l),F=j(It),B=g(It,"LI",{});var Sr=E(B);y=g(Sr,"CODE",{});var gn=E(y);V=f(gn,"type"),gn.forEach(l),x=g(Sr,"BR",{}),M=f(Sr,`
            The type of image being created. The image type is essentially the dimensionality
            of the image and can be `),O=g(Sr,"CODE",{});var _n=E(O);H=f(_n,"VK_IMAGE_TYPE_1D"),_n.forEach(l),k=f(Sr,`,
            `),N=g(Sr,"CODE",{});var Xr=E(N);Q=f(Xr,"VK_IMAGE_TYPE_2D"),Xr.forEach(l),X=f(Sr,`
            or `),Z=g(Sr,"CODE",{});var vn=E(Z);K=f(vn,"VK_IMAGE_TYPE_3D"),vn.forEach(l),W=f(Sr,`
            for a 1D, 2D or 3D image respectively.`),Sr.forEach(l),q=j(It),U=g(It,"LI",{});var nn=E(U);te=g(nn,"CODE",{});var xt=E(te);ee=f(xt,"format"),xt.forEach(l),se=g(nn,"BR",{}),ie=f(nn,`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),nn.forEach(l),ae=j(It),J=g(It,"LI",{});var ar=E(J);pe=g(ar,"CODE",{});var Nn=E(pe);Se=f(Nn,"extent"),Nn.forEach(l),de=g(ar,"BR",{}),me=f(ar,`
            The size of the image in texels. This should be an instance of the `),S(De.$$.fragment,ar),_e=f(ar,`
            structure , which has three members: `),ne=g(ar,"CODE",{});var Un=E(ne);le=f(Un,"width"),Un.forEach(l),ge=f(ar,`,
            `),we=g(ar,"CODE",{});var Gn=E(we);Pe=f(Gn,"height"),Gn.forEach(l),Be=f(ar,", and "),Ie=g(ar,"CODE",{});var Cn=E(Ie);re=f(Cn,"depth"),Cn.forEach(l),he=f(ar,`. These should be set
            respectively to the width, height and depth of the desired image.
            For 1D images, the height should be set to `),Le=g(ar,"CODE",{});var Hn=E(Le);Oe=f(Hn,"1"),Hn.forEach(l),oe=f(ar,`, and for
            1D and 2D images, the depth should be set to `),ce=g(ar,"CODE",{});var qn=E(ce);Ae=f(qn,"1"),qn.forEach(l),ye=f(ar,"."),ar.forEach(l),Fe=j(It),Ve=g(It,"LI",{});var $n=E(Ve);Ge=g($n,"CODE",{});var Wn=E(Ge);He=f(Wn,"mipLevels"),Wn.forEach(l),ze=g($n,"BR",{}),xe=f($n,`
            The number of mipmap levels to create in the image.`),$n.forEach(l),Ne=j(It),Te=g(It,"LI",{});var Sn=E(Te);qe=g(Sn,"CODE",{});var Pn=E(qe);Ke=f(Pn,"arrayLayers"),Pn.forEach(l),je=g(Sn,"BR",{}),rt=f(Sn,`
            The amount of images each mipmap level of the image has.`),Sn.forEach(l),Me=j(It),Ue=g(It,"LI",{});var un=E(Ue);$t=g(un,"CODE",{});var Qn=E($t);ut=f(Qn,"samples"),Qn.forEach(l),ht=g(un,"BR",{}),Je=f(un,`
            The number of samples in the image. It must be a member of the `),S(dt.$$.fragment,un),et=f(un,"-enumerant."),un.forEach(l),Ze=j(It),nt=g(It,"LI",{});var Wr=E(nt);Qe=g(Wr,"CODE",{});var Kn=E(Qe);ct=f(Kn,"tiling"),Kn.forEach(l),st=g(Wr,"BR",{}),We=f(Wr,`
            A member of the `),S(at.$$.fragment,Wr),bt=f(Wr,"-enumerant, which contains only "),wt=g(Wr,"CODE",{});var zn=E(wt);St=f(zn,"VK_IMAGE_TILING_LINEAR"),zn.forEach(l),tt=f(Wr,`
            or
            `),ot=g(Wr,"CODE",{});var An=E(ot);At=f(An,"VK_IMAGE_TILING_OPTIMAL"),An.forEach(l),it=f(Wr,`. Linear tiling means that image
            data is laid out from left to right, top to bottom, so that if the
            underlying memory is mapped and it is written with the CPU, it would
            form a linear image. Meanwhile, optimal tiling is an opaque display
            used by Vulkan to store data in memory to improve the efficiency of
            the memory subsystem on the device. This is generally what should be
            chosen unless the image needs to be CPU mapped and manipulated.
            Optimal tiling is likely to outperform linear tiling in most
            operations, and linear tiling may not be supported at all for some
            operations or formats, depending on the Vulkan implementation.`),Wr.forEach(l),Xe=j(It),Dt=g(It,"LI",{});var pn=E(Dt);Ct=g(pn,"CODE",{});var Yn=E(Ct);pt=f(Yn,"usage"),Yn.forEach(l),Ft=g(pn,"BR",{}),mt=f(pn,`
            A bitmask of members of the `),S(Vt.$$.fragment,pn),Rt=f(pn,"-enumerant telling Vulkan how the Image will be used."),pn.forEach(l),Tt=j(It),vt=g(It,"LI",{});var Gt=E(vt);gt=g(Gt,"CODE",{});var jn=E(gt);kt=f(jn,"sharingMode"),jn.forEach(l),Mt=g(Gt,"BR",{}),yt=f(Gt,`
            A member of the `),S(Ht.$$.fragment,Gt),$r=f(Gt,`-enumerant indicating how the Image will be used in the multiple
            device `),S(Ut.$$.fragment,Gt),or=f(Gt,` supported
            by the Device. Because Vulkan can run many commands in parallel, some
            implementations need to know whether the Image will essentially be used
            by a single command at a time or possibly by several. Setting
            `),Xt=g(Gt,"CODE",{});var Xn=E(Xt);Ot=f(Xn,"sharingMode"),Xn.forEach(l),Zt=f(Gt,`
            to `),Ar=g(Gt,"CODE",{});var Rn=E(Ar);br=f(Rn,"VK_SHARING_MODE_EXCLUSIVE"),Rn.forEach(l),ur=f(Gt,` tells Vulkan that the
            Image will only be used for a single `),S(Qt.$$.fragment,Gt),Or=f(Gt,`, while setting
            `),rr=g(Gt,"CODE",{});var Zn=E(rr);Kr=f(Zn,"sharingMode"),Zn.forEach(l),lr=f(Gt,`
            to
            `),gr=g(Gt,"CODE",{});var Jn=E(gr);Fr=f(Jn,"VK_SHARING_MODE_CONCURRENT"),Jn.forEach(l),Kt=f(Gt,` specifies that the
            application will use the Image on multiple `),S(ir.$$.fragment,Gt),yr=f(Gt,` at once. Using
            `),Re=g(Gt,"CODE",{});var Bn=E(Re);lt=f(Bn,"VK_SHARING_MODE_CONCURRENT"),Bn.forEach(l),Jt=f(Gt,` may result in lower
            performance on some systems, so unless necessary,
            `),_r=g(Gt,"CODE",{});var es=E(_r);Yt=f(es,"sharingMode"),es.forEach(l),nr=f(Gt,`
            should be set to `),vr=g(Gt,"CODE",{});var ts=E(vr);Tr=f(ts,"VK_SHARING_MODE_EXCLUSIVE"),ts.forEach(l),fr=f(Gt,"."),Gt.forEach(l),cr=j(It),sr=g(It,"LI",{});var rn=E(sr);er=g(rn,"CODE",{});var rs=E(er);zr=f(rs,"queueFamilyIndices"),rs.forEach(l),_t=g(rn,"BR",{}),ft=f(rn,`
            A pointer to an array of `),S(qt.$$.fragment,rn),Mr=f(rn," family indices on which the image will be used."),rn.forEach(l),wr=j(It),Nt=g(It,"LI",{});var dr=E(Nt);Wt=g(dr,"CODE",{});var Ln=E(Wt);xr=f(Ln,"initialLayout"),Ln.forEach(l),pr=g(dr,"BR",{}),Vr=f(dr,`
            Images have a layout, which partially indicates how they will be used
            at a given time. This field determines the layout in which the image
            is created. The available layouts are the members of the `),S(jt.$$.fragment,dr),Rr=f(dr,"-enumerant."),Ir=g(dr,"BR",{}),Nr=f(dr,`
            Images should initially be created in the format
            `),mr=g(dr,"CODE",{});var ns=E(mr);Dr=f(ns,"VK_IMAGE_LAYOUT_UNDEFINED"),ns.forEach(l),hr=f(dr,`
            or `),Br=g(dr,"CODE",{});var ss=E(Br);Cr=f(ss,"VK_IMAGE_LAYOUT_PREINITIALIZED"),ss.forEach(l),en=f(dr,`.
            `),Ur=g(dr,"CODE",{});var kn=E(Ur);tr=f(kn,"VK_IMAGE_LAYOUT_PREINITIALIZED"),kn.forEach(l),Gr=f(dr,`
            should only be used if there is data in memory that is bound immediately
            to the image source.
            `),tn=g(dr,"CODE",{});var as=E(tn);jr=f(as,"VK_IMAGE_LAYOUT_UNDEFINED"),as.forEach(l),ln=f(dr,`
            should be used when moving the resource to another layout before use.
            Images can be moved out of the
            `),Er=g(dr,"CODE",{});var os=E(Er);fn=f(os,"VK_IMAGE_LAYOUT_UNDEFINED"),os.forEach(l),Lr=f(dr,` layout at any time with little
            or no time cost.`),dr.forEach(l),cn=j(It),It.forEach(l),this.h()},h(){z(e,"slot","params")},m(Lt,It){h(Lt,e,It),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),o(B,O),o(O,H),o(B,k),o(B,N),o(N,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(e,q),o(e,U),o(U,te),o(te,ee),o(U,se),o(U,ie),o(e,ae),o(e,J),o(J,pe),o(pe,Se),o(J,de),o(J,me),D(De,J,null),o(J,_e),o(J,ne),o(ne,le),o(J,ge),o(J,we),o(we,Pe),o(J,Be),o(J,Ie),o(Ie,re),o(J,he),o(J,Le),o(Le,Oe),o(J,oe),o(J,ce),o(ce,Ae),o(J,ye),o(e,Fe),o(e,Ve),o(Ve,Ge),o(Ge,He),o(Ve,ze),o(Ve,xe),o(e,Ne),o(e,Te),o(Te,qe),o(qe,Ke),o(Te,je),o(Te,rt),o(e,Me),o(e,Ue),o(Ue,$t),o($t,ut),o(Ue,ht),o(Ue,Je),D(dt,Ue,null),o(Ue,et),o(e,Ze),o(e,nt),o(nt,Qe),o(Qe,ct),o(nt,st),o(nt,We),D(at,nt,null),o(nt,bt),o(nt,wt),o(wt,St),o(nt,tt),o(nt,ot),o(ot,At),o(nt,it),o(e,Xe),o(e,Dt),o(Dt,Ct),o(Ct,pt),o(Dt,Ft),o(Dt,mt),D(Vt,Dt,null),o(Dt,Rt),o(e,Tt),o(e,vt),o(vt,gt),o(gt,kt),o(vt,Mt),o(vt,yt),D(Ht,vt,null),o(vt,$r),D(Ut,vt,null),o(vt,or),o(vt,Xt),o(Xt,Ot),o(vt,Zt),o(vt,Ar),o(Ar,br),o(vt,ur),D(Qt,vt,null),o(vt,Or),o(vt,rr),o(rr,Kr),o(vt,lr),o(vt,gr),o(gr,Fr),o(vt,Kt),D(ir,vt,null),o(vt,yr),o(vt,Re),o(Re,lt),o(vt,Jt),o(vt,_r),o(_r,Yt),o(vt,nr),o(vt,vr),o(vr,Tr),o(vt,fr),o(e,cr),o(e,sr),o(sr,er),o(er,zr),o(sr,_t),o(sr,ft),D(qt,sr,null),o(sr,Mr),o(e,wr),o(e,Nt),o(Nt,Wt),o(Wt,xr),o(Nt,pr),o(Nt,Vr),D(jt,Nt,null),o(Nt,Rr),o(Nt,Ir),o(Nt,Nr),o(Nt,mr),o(mr,Dr),o(Nt,hr),o(Nt,Br),o(Br,Cr),o(Nt,en),o(Nt,Ur),o(Ur,tr),o(Nt,Gr),o(Nt,tn),o(tn,jr),o(Nt,ln),o(Nt,Er),o(Er,fn),o(Nt,Lr),o(e,cn),Yr=!0},p(Lt,It){const Hr={};It&1&&(Hr.$$scope={dirty:It,ctx:Lt}),a.$set(Hr);const kr={};It&1&&(kr.$$scope={dirty:It,ctx:Lt}),A.$set(kr);const qr={};It&1&&(qr.$$scope={dirty:It,ctx:Lt}),De.$set(qr);const dn={};It&1&&(dn.$$scope={dirty:It,ctx:Lt}),dt.$set(dn);const Sr={};It&1&&(Sr.$$scope={dirty:It,ctx:Lt}),at.$set(Sr);const gn={};It&1&&(gn.$$scope={dirty:It,ctx:Lt}),Vt.$set(gn);const _n={};It&1&&(_n.$$scope={dirty:It,ctx:Lt}),Ht.$set(_n);const Xr={};It&1&&(Xr.$$scope={dirty:It,ctx:Lt}),Ut.$set(Xr);const vn={};It&1&&(vn.$$scope={dirty:It,ctx:Lt}),Qt.$set(vn);const nn={};It&1&&(nn.$$scope={dirty:It,ctx:Lt}),ir.$set(nn);const xt={};It&1&&(xt.$$scope={dirty:It,ctx:Lt}),qt.$set(xt);const ar={};It&1&&(ar.$$scope={dirty:It,ctx:Lt}),jt.$set(ar)},i(Lt){Yr||(b(a.$$.fragment,Lt),b(A.$$.fragment,Lt),b(De.$$.fragment,Lt),b(dt.$$.fragment,Lt),b(at.$$.fragment,Lt),b(Vt.$$.fragment,Lt),b(Ht.$$.fragment,Lt),b(Ut.$$.fragment,Lt),b(Qt.$$.fragment,Lt),b(ir.$$.fragment,Lt),b(qt.$$.fragment,Lt),b(jt.$$.fragment,Lt),Yr=!0)},o(Lt){w(a.$$.fragment,Lt),w(A.$$.fragment,Lt),w(De.$$.fragment,Lt),w(dt.$$.fragment,Lt),w(at.$$.fragment,Lt),w(Vt.$$.fragment,Lt),w(Ht.$$.fragment,Lt),w(Ut.$$.fragment,Lt),w(Qt.$$.fragment,Lt),w(ir.$$.fragment,Lt),w(qt.$$.fragment,Lt),w(jt.$$.fragment,Lt),Yr=!1},d(Lt){Lt&&l(e),C(a),C(A),C(De),C(dt),C(at),C(Vt),C(Ht),C(Ut),C(Qt),C(ir),C(qt),C(jt)}}}function XI(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZI(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkImage",version:1.3,$$slots:{default:[XI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function JI(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eD(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[JI]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Wrap around a "),I(r.$$.fragment),$=i(" Image."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Wrap around a "),S(r.$$.fragment,a),$=f(a," Image."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tD(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rD(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nD(c){let e;return{c(){e=i("Swapchain")},l(t){e=f(t,"Swapchain")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sD(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aD(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oD(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[tD]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[rD]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.SWAPCHAIN,$$slots:{default:[nD]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[sD]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[aD]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" Image is associated with."),_=Y(),v=d("li"),P=d("code"),R=i("pSwapchain"),A=d("br"),T=i(`
            A pointer to the `),I(F.$$.fragment),B=i(" which owns the "),I(y.$$.fragment),V=i("."),x=Y(),M=d("li"),O=d("code"),H=i("hImage"),k=d("br"),N=i(`
            The handle to the `),I(Q.$$.fragment),X=i(" to wrap around."),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var q=E(t);r=g(q,"CODE",{});var U=E(r);$=f(U,"pLogicalDevice"),U.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A pointer to the `),S(a.$$.fragment,q),u=f(q," the "),S(p.$$.fragment,q),m=f(q," Image is associated with."),q.forEach(l),_=j(W),v=g(W,"LI",{});var te=E(v);P=g(te,"CODE",{});var ee=E(P);R=f(ee,"pSwapchain"),ee.forEach(l),A=g(te,"BR",{}),T=f(te,`
            A pointer to the `),S(F.$$.fragment,te),B=f(te," which owns the "),S(y.$$.fragment,te),V=f(te,"."),te.forEach(l),x=j(W),M=g(W,"LI",{});var se=E(M);O=g(se,"CODE",{});var ie=E(O);H=f(ie,"hImage"),ie.forEach(l),k=g(se,"BR",{}),N=f(se,`
            The handle to the `),S(Q.$$.fragment,se),X=f(se," to wrap around."),se.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),Z=!0},p(K,W){const q={};W&1&&(q.$$scope={dirty:W,ctx:K}),a.$set(q);const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),p.$set(U);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),F.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),y.$set(ee);const se={};W&1&&(se.$$scope={dirty:W,ctx:K}),Q.$set(se)},i(K){Z||(b(a.$$.fragment,K),b(p.$$.fragment,K),b(F.$$.fragment,K),b(y.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(a.$$.fragment,K),w(p.$$.fragment,K),w(F.$$.fragment,K),w(y.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){K&&l(e),C(a),C(p),C(F),C(y),C(Q)}}}function lD(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iD(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[lD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function fD(c){let e,t,r,$;return{c(){e=d("span"),t=i(`This Constructor is primarily used by the Swapchain to create Image
        Views for it's images.`),r=d("br"),$=i(`
        By using this Constructor most class members will have their default values.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,`This Constructor is primarily used by the Swapchain to create Image
        Views for it's images.`),r=g(s,"BR",{}),$=f(s,`
        By using this Constructor most class members will have their default values.`),s.forEach(l),this.h()},h(){z(e,"slot","note")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function cD(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:`Image(
    LogicalDevice* pLogicalDevice, 
    VkImageCreateFlags flags, 
    VkImageType type, 
    VkFormat format, 
    VkExtent3D extent, 
    unsigned int mipLevels,
    unsigned int arrayLayers, 
    VkSampleCountFlagBits samples, 
    VkImageTiling tiling, 
    VkImageUsageFlags usage, 
    VkSharingMode sharingMode,
    std::vector<uint32_t>& queueFamilyIndices, 
    VkImageLayout initialLayout
);`}}),r=new Ce({props:{$$slots:{throws:[ZI],params:[jI],details:[yI]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`Image(
    LogicalDevice* pLogicalDevice, 
    Swapchain* pSwapchain, 
    VkImage hImage
);`}}),u=new Ce({props:{$$slots:{note:[fD],throws:[iD],params:[oD],details:[eD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class $D extends ve{constructor(e){super(),Ee(this,e,null,cD,be,{})}}function uD(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pD(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[uD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mD(c){let e;return{c(){e=i("Vulkan Image")},l(t){e=f(t,"Vulkan Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hD(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html",target:"_blank",$$slots:{default:[mD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function dD(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkImage getImageHandle() const;"}}),r=new Ce({props:{$$slots:{return:[hD],details:[pD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gD extends ve{constructor(e){super(),Ee(this,e,null,dD,be,{})}}function _D(c){let e,t;return{c(){e=d("span"),t=i("Get the flags used for creating the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the flags used for creating the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function vD(c){let e,t;return{c(){e=d("span"),t=i("The flags set when creating of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The flags set when creating of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ED(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageCreateFlags getFlags();"}}),r=new Ce({props:{$$slots:{return:[vD],details:[_D]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bD extends ve{constructor(e){super(),Ee(this,e,null,ED,be,{})}}function wD(c){let e,t;return{c(){e=d("span"),t=i("Get the intended usage of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the intended usage of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ID(c){let e,t;return{c(){e=d("span"),t=i("The intended usage of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The intended usage of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function DD(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageUsageFlags getUsage();"}}),r=new Ce({props:{$$slots:{return:[ID],details:[wD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class CD extends ve{constructor(e){super(),Ee(this,e,null,DD,be,{})}}function SD(c){let e,t;return{c(){e=d("span"),t=i("Get the sharing mode of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sharing mode of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function PD(c){let e,t;return{c(){e=d("span"),t=i("The sharing mode of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sharing mode of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function AD(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSharingMode getSharingMode();"}}),r=new Ce({props:{$$slots:{return:[PD],details:[SD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RD extends ve{constructor(e){super(),Ee(this,e,null,AD,be,{})}}function BD(c){let e,t;return{c(){e=d("span"),t=i("Get the queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function LD(c){let e,t;return{c(){e=d("span"),t=i("The queue family indices of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The queue family indices of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function kD(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<uint32_t>& getQueueFamilyIndices() const;"}}),r=new Ce({props:{$$slots:{return:[LD],details:[BD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TD extends ve{constructor(e){super(),Ee(this,e,null,kD,be,{})}}function VD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OD(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.MEMORY,$$slots:{default:[VD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind "),I(r.$$.fragment),$=i(" to the Image."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind "),S(r.$$.fragment,a),$=f(a," to the Image."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function FD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xD(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return a=new G({props:{sectionID:L.MEMORY,$$slots:{default:[FD]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.MEMORY,$$slots:{default:[yD]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.MEMORY,$$slots:{default:[MD]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pMemory"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to the Image."),p=Y(),m=d("li"),_=d("code"),v=i("memoryOffset"),P=d("br"),R=i(`
            Specifies the offset in the `),I(A.$$.fragment),T=i(` object the Image will live. If only one resource will be bound to
            the `),I(F.$$.fragment),B=i(` object,
            this can be set to
            `),y=d("code"),V=i("0"),x=i("."),this.h()},l(O){e=g(O,"DIV",{slot:!0});var H=E(e);t=g(H,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"pMemory"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            A pointer to the `),S(a.$$.fragment,k),u=f(k," to bind to the Image."),k.forEach(l),p=j(H),m=g(H,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"memoryOffset"),X.forEach(l),P=g(Q,"BR",{}),R=f(Q,`
            Specifies the offset in the `),S(A.$$.fragment,Q),T=f(Q,` object the Image will live. If only one resource will be bound to
            the `),S(F.$$.fragment,Q),B=f(Q,` object,
            this can be set to
            `),y=g(Q,"CODE",{});var Z=E(y);V=f(Z,"0"),Z.forEach(l),x=f(Q,"."),Q.forEach(l),H.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,H){h(O,e,H),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),o(m,y),o(y,V),o(m,x),M=!0},p(O,H){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),a.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),A.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),F.$set(Q)},i(O){M||(b(a.$$.fragment,O),b(A.$$.fragment,O),b(F.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(A.$$.fragment,O),w(F.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(A),C(F)}}}function ND(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void bindMemory(Memory* pMemory, VkDeviceSize memoryOffset = 0);"}}),r=new Ce({props:{$$slots:{params:[xD],details:[OD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class UD extends ve{constructor(e){super(),Ee(this,e,null,ND,be,{})}}function GD(c){let e;return{c(){e=i("bindMemory")},l(t){e=f(t,"bindMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HD(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_bindMemory,$$slots:{default:[GD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the Memory bound with "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the Memory bound with "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WD(c){let e;return{c(){e=i("Memory")},l(t){e=f(t,"Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QD(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.MEMORY,$$slots:{default:[qD]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.MEMORY,$$slots:{default:[WD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function KD(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Memory* getMemory() const;"}}),r=new Ce({props:{$$slots:{return:[QD],details:[HD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class zD extends ve{constructor(e){super(),Ee(this,e,null,KD,be,{})}}function YD(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jD(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[YD]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create an "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create an "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function XD(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZD(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JD(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tC(c){let e;return{c(){e=i("VkImageSubresourceRange")},l(t){e=f(t,"VkImageSubresourceRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nC(c){let e;return{c(){e=i("VkComponentMapping")},l(t){e=f(t,"VkComponentMapping")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sC(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[XD]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[ZD]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[JD]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[eC]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html",target:"_blank",$$slots:{default:[tC]},$$scope:{ctx:c}}}),ee=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[rC]},$$scope:{ctx:c}}}),ie=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html",target:"_blank",$$slots:{default:[nC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewType"),n=d("br"),s=i(`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),I(a.$$.fragment),u=i("-enumeration, which is larger than the "),I(p.$$.fragment),m=i("-enumeration used when creating the parent Image."),_=Y(),v=d("li"),P=d("code"),R=i("format"),A=d("br"),T=i(`
            The format of the new `),I(F.$$.fragment),B=i(`. This must be a format compatible with the parent image. If two
            formats have the same number of bits per pixel, they are generally
            considered compatible.`),y=Y(),V=d("li"),x=d("code"),M=i("subresourceRange"),O=d("br"),H=i(`
            The `),I(k.$$.fragment),N=i(` can be a subset of the parent Image. This subset is specified using
            the embedded `),I(Q.$$.fragment),X=i("-structure."),Z=Y(),K=d("li"),W=d("code"),q=i("components"),U=d("br"),te=i(`
            The order of the components in the `),I(ee.$$.fragment),se=i(` may differ from that in the parent Image. This makes it possible, for
            example, to create an RGBA representation of an Image in BGRA format.
            This remapping is specified using an instance of the `),I(ie.$$.fragment),ae=i("-structure."),this.h()},l(pe){e=g(pe,"DIV",{slot:!0});var Se=E(e);t=g(Se,"LI",{});var de=E(t);r=g(de,"CODE",{});var me=E(r);$=f(me,"viewType"),me.forEach(l),n=g(de,"BR",{}),s=f(de,`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),S(a.$$.fragment,de),u=f(de,"-enumeration, which is larger than the "),S(p.$$.fragment,de),m=f(de,"-enumeration used when creating the parent Image."),de.forEach(l),_=j(Se),v=g(Se,"LI",{});var De=E(v);P=g(De,"CODE",{});var _e=E(P);R=f(_e,"format"),_e.forEach(l),A=g(De,"BR",{}),T=f(De,`
            The format of the new `),S(F.$$.fragment,De),B=f(De,`. This must be a format compatible with the parent image. If two
            formats have the same number of bits per pixel, they are generally
            considered compatible.`),De.forEach(l),y=j(Se),V=g(Se,"LI",{});var ne=E(V);x=g(ne,"CODE",{});var le=E(x);M=f(le,"subresourceRange"),le.forEach(l),O=g(ne,"BR",{}),H=f(ne,`
            The `),S(k.$$.fragment,ne),N=f(ne,` can be a subset of the parent Image. This subset is specified using
            the embedded `),S(Q.$$.fragment,ne),X=f(ne,"-structure."),ne.forEach(l),Z=j(Se),K=g(Se,"LI",{});var ge=E(K);W=g(ge,"CODE",{});var we=E(W);q=f(we,"components"),we.forEach(l),U=g(ge,"BR",{}),te=f(ge,`
            The order of the components in the `),S(ee.$$.fragment,ge),se=f(ge,` may differ from that in the parent Image. This makes it possible, for
            example, to create an RGBA representation of an Image in BGRA format.
            This remapping is specified using an instance of the `),S(ie.$$.fragment,ge),ae=f(ge,"-structure."),ge.forEach(l),Se.forEach(l),this.h()},h(){z(e,"slot","params")},m(pe,Se){h(pe,e,Se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),D(ee,K,null),o(K,se),D(ie,K,null),o(K,ae),J=!0},p(pe,Se){const de={};Se&1&&(de.$$scope={dirty:Se,ctx:pe}),a.$set(de);const me={};Se&1&&(me.$$scope={dirty:Se,ctx:pe}),p.$set(me);const De={};Se&1&&(De.$$scope={dirty:Se,ctx:pe}),F.$set(De);const _e={};Se&1&&(_e.$$scope={dirty:Se,ctx:pe}),k.$set(_e);const ne={};Se&1&&(ne.$$scope={dirty:Se,ctx:pe}),Q.$set(ne);const le={};Se&1&&(le.$$scope={dirty:Se,ctx:pe}),ee.$set(le);const ge={};Se&1&&(ge.$$scope={dirty:Se,ctx:pe}),ie.$set(ge)},i(pe){J||(b(a.$$.fragment,pe),b(p.$$.fragment,pe),b(F.$$.fragment,pe),b(k.$$.fragment,pe),b(Q.$$.fragment,pe),b(ee.$$.fragment,pe),b(ie.$$.fragment,pe),J=!0)},o(pe){w(a.$$.fragment,pe),w(p.$$.fragment,pe),w(F.$$.fragment,pe),w(k.$$.fragment,pe),w(Q.$$.fragment,pe),w(ee.$$.fragment,pe),w(ie.$$.fragment,pe),J=!1},d(pe){pe&&l(e),C(a),C(p),C(F),C(k),C(Q),C(ee),C(ie)}}}function aC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lC(c){let e;return{c(){e=i("getImageView")},l(t){e=f(t,"getImageView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iC(c){let e,t,r,$,n,s,a,u,p;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[aC]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[oC]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.IMAGE_getImageView,$$slots:{default:[lC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The index of the newly created "),I(r.$$.fragment),$=i(". This index can be used to get the created "),I(n.$$.fragment),s=i(" using "),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"The index of the newly created "),S(r.$$.fragment,_),$=f(_,". This index can be used to get the created "),S(n.$$.fragment,_),s=f(_," using "),S(a.$$.fragment,_),u=f(_,"."),_.forEach(l),this.h()},h(){z(e,"slot","return")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),n.$set(P);const R={};_&1&&(R.$$scope={dirty:_,ctx:m}),a.$set(R)},i(m){p||(b(r.$$.fragment,m),b(n.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(n.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(n),C(a)}}}function fC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cC(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[fC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function $C(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`unsigned int createImageView(
    VkImageViewType viewType, 
    VkFormat format,
    VkImageSubresourceRange subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1},
    VkComponentMapping components = {VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY,
                                    VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY}
);`}}),r=new Ce({props:{$$slots:{throws:[cC],return:[iC],params:[sC],details:[jD]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uC extends ve{constructor(e){super(),Ee(this,e,null,$C,be,{})}}function pC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mC(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[pC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a pointer to an "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a pointer to an "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dC(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[hC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to get."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"index"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to get."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function gC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _C(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[gC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vC(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"ImageView* getImageView(unsigned int index);"}}),r=new Ce({props:{$$slots:{return:[_C],params:[dC],details:[mC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class EC extends ve{constructor(e){super(),Ee(this,e,null,vC,be,{})}}function bC(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wC(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[bC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy all created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy all created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function IC(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroyImageViews();"}}),r=new Ce({props:{$$slots:{details:[wC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DC extends ve{constructor(e){super(),Ee(this,e,null,IC,be,{})}}function CC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SC(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[CC]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Destroy an "),I(r.$$.fragment),$=i(" by index."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Destroy an "),S(r.$$.fragment,a),$=f(a," by index."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function PC(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AC(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[PC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("index"),n=d("br"),s=i(`
            The index the `),I(a.$$.fragment),u=i(" to destroy."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"index"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index the `),S(a.$$.fragment,v),u=f(v," to destroy."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function RC(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void destroyImageView(unsigned int index);"}}),r=new Ce({props:{$$slots:{params:[AC],details:[SC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BC extends ve{constructor(e){super(),Ee(this,e,null,RC,be,{})}}function LC(c){let e,t;return{c(){e=d("span"),t=i("Copy this Image's data to a given Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Image's data to a given Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function kC(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VC(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FC(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yC(c){let e;return{c(){e=i("VkImageCopy")},l(t){e=f(t,"VkImageCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MC(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[kC]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.IMAGE,$$slots:{default:[TC]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[VC]},$$scope:{ctx:c}}}),de=new G({props:{sectionID:L.IMAGE,$$slots:{default:[OC]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[FC]},$$scope:{ctx:c}}}),Ge=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html",target:"_blank",$$slots:{default:[yC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=Y(),m=d("li"),_=d("code"),v=i("pImage"),P=d("br"),R=i(`
            A pointer to the Image to copy this Image's data to.`),A=Y(),T=d("li"),F=d("code"),B=i("srcLayout"),y=d("br"),V=i(`
            The layout of the sourece `),I(x.$$.fragment),M=i(` (this Image) subresources for the copy. This should be a member of
            the `),I(O.$$.fragment),H=i("-enumerant."),k=d("br"),N=i(`
            This is most likely either
            `),Q=d("code"),X=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Z=i(`,
            `),K=d("code"),W=i("VK_IMAGE_LAYOUT_GENERAL"),q=i(`
            or `),U=d("code"),te=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ee=i("."),se=Y(),ie=d("li"),ae=d("code"),J=i("dstLayout"),pe=d("br"),Se=i(`
            The layout of the destination `),I(de.$$.fragment),me=i(" subresources for the copy. This should be a member of the "),I(De.$$.fragment),_e=i("-enumerant."),ne=d("br"),le=i(`
            This is most likely either
            `),ge=d("code"),we=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Pe=i(`,
            `),Be=d("code"),Ie=i("VK_IMAGE_LAYOUT_GENERAL"),re=i(`
            or `),he=d("code"),Le=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),Oe=i("."),oe=Y(),ce=d("li"),Ae=d("code"),ye=i("regions"),Fe=d("br"),Ve=i(`
            An array of `),I(Ge.$$.fragment),He=i("-structures, each of which describes a region of data to copy."),ze=Y(),this.h()},l(Ne){e=g(Ne,"DIV",{slot:!0});var Te=E(e);t=g(Te,"LI",{});var qe=E(t);r=g(qe,"CODE",{});var Ke=E(r);$=f(Ke,"pCommandBuffer"),Ke.forEach(l),n=g(qe,"BR",{}),s=f(qe,`
            The `),S(a.$$.fragment,qe),u=f(qe," to use to execute the copy."),qe.forEach(l),p=j(Te),m=g(Te,"LI",{});var je=E(m);_=g(je,"CODE",{});var rt=E(_);v=f(rt,"pImage"),rt.forEach(l),P=g(je,"BR",{}),R=f(je,`
            A pointer to the Image to copy this Image's data to.`),je.forEach(l),A=j(Te),T=g(Te,"LI",{});var Me=E(T);F=g(Me,"CODE",{});var Ue=E(F);B=f(Ue,"srcLayout"),Ue.forEach(l),y=g(Me,"BR",{}),V=f(Me,`
            The layout of the sourece `),S(x.$$.fragment,Me),M=f(Me,` (this Image) subresources for the copy. This should be a member of
            the `),S(O.$$.fragment,Me),H=f(Me,"-enumerant."),k=g(Me,"BR",{}),N=f(Me,`
            This is most likely either
            `),Q=g(Me,"CODE",{});var $t=E(Q);X=f($t,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),$t.forEach(l),Z=f(Me,`,
            `),K=g(Me,"CODE",{});var ut=E(K);W=f(ut,"VK_IMAGE_LAYOUT_GENERAL"),ut.forEach(l),q=f(Me,`
            or `),U=g(Me,"CODE",{});var ht=E(U);te=f(ht,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ht.forEach(l),ee=f(Me,"."),Me.forEach(l),se=j(Te),ie=g(Te,"LI",{});var Je=E(ie);ae=g(Je,"CODE",{});var dt=E(ae);J=f(dt,"dstLayout"),dt.forEach(l),pe=g(Je,"BR",{}),Se=f(Je,`
            The layout of the destination `),S(de.$$.fragment,Je),me=f(Je," subresources for the copy. This should be a member of the "),S(De.$$.fragment,Je),_e=f(Je,"-enumerant."),ne=g(Je,"BR",{}),le=f(Je,`
            This is most likely either
            `),ge=g(Je,"CODE",{});var et=E(ge);we=f(et,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),et.forEach(l),Pe=f(Je,`,
            `),Be=g(Je,"CODE",{});var Ze=E(Be);Ie=f(Ze,"VK_IMAGE_LAYOUT_GENERAL"),Ze.forEach(l),re=f(Je,`
            or `),he=g(Je,"CODE",{});var nt=E(he);Le=f(nt,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),nt.forEach(l),Oe=f(Je,"."),Je.forEach(l),oe=j(Te),ce=g(Te,"LI",{});var Qe=E(ce);Ae=g(Qe,"CODE",{});var ct=E(Ae);ye=f(ct,"regions"),ct.forEach(l),Fe=g(Qe,"BR",{}),Ve=f(Qe,`
            An array of `),S(Ge.$$.fragment,Qe),He=f(Qe,"-structures, each of which describes a region of data to copy."),Qe.forEach(l),ze=j(Te),Te.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ne,Te){h(Ne,e,Te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),D(O,T,null),o(T,H),o(T,k),o(T,N),o(T,Q),o(Q,X),o(T,Z),o(T,K),o(K,W),o(T,q),o(T,U),o(U,te),o(T,ee),o(e,se),o(e,ie),o(ie,ae),o(ae,J),o(ie,pe),o(ie,Se),D(de,ie,null),o(ie,me),D(De,ie,null),o(ie,_e),o(ie,ne),o(ie,le),o(ie,ge),o(ge,we),o(ie,Pe),o(ie,Be),o(Be,Ie),o(ie,re),o(ie,he),o(he,Le),o(ie,Oe),o(e,oe),o(e,ce),o(ce,Ae),o(Ae,ye),o(ce,Fe),o(ce,Ve),D(Ge,ce,null),o(ce,He),o(e,ze),xe=!0},p(Ne,Te){const qe={};Te&1&&(qe.$$scope={dirty:Te,ctx:Ne}),a.$set(qe);const Ke={};Te&1&&(Ke.$$scope={dirty:Te,ctx:Ne}),x.$set(Ke);const je={};Te&1&&(je.$$scope={dirty:Te,ctx:Ne}),O.$set(je);const rt={};Te&1&&(rt.$$scope={dirty:Te,ctx:Ne}),de.$set(rt);const Me={};Te&1&&(Me.$$scope={dirty:Te,ctx:Ne}),De.$set(Me);const Ue={};Te&1&&(Ue.$$scope={dirty:Te,ctx:Ne}),Ge.$set(Ue)},i(Ne){xe||(b(a.$$.fragment,Ne),b(x.$$.fragment,Ne),b(O.$$.fragment,Ne),b(de.$$.fragment,Ne),b(De.$$.fragment,Ne),b(Ge.$$.fragment,Ne),xe=!0)},o(Ne){w(a.$$.fragment,Ne),w(x.$$.fragment,Ne),w(O.$$.fragment,Ne),w(de.$$.fragment,Ne),w(De.$$.fragment,Ne),w(Ge.$$.fragment,Ne),xe=!1},d(Ne){Ne&&l(e),C(a),C(x),C(O),C(de),C(De),C(Ge)}}}function xC(c){let e,t;return{c(){e=d("span"),t=i("Copy this Image's data to a given Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this Image's data to a given Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function NC(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UC(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GC(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HC(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qC(c){let e;return{c(){e=i("VkBufferImageCopy")},l(t){e=f(t,"VkBufferImageCopy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WC(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[NC]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.BUFFER,$$slots:{default:[UC]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.IMAGE,$$slots:{default:[GC]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[HC]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html",target:"_blank",$$slots:{default:[qC]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to execute the copy."),p=Y(),m=d("li"),_=d("code"),v=i("pBuffer"),P=d("br"),R=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to copy this Image's data to."),F=Y(),B=d("li"),y=d("code"),V=i("srcLayout"),x=d("br"),M=i(`
            The layout of the sourece `),I(O.$$.fragment),H=i(` (this Image) subresources for the copy. This should be a member of
            the `),I(k.$$.fragment),N=i("-enumerant."),Q=d("br"),X=i(`
            This is most likely either
            `),Z=d("code"),K=i("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),W=i(`,
            `),q=d("code"),U=i("VK_IMAGE_LAYOUT_GENERAL"),te=i(`
            or `),ee=d("code"),se=i("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ie=i("."),ae=Y(),J=d("li"),pe=d("code"),Se=i("regions"),de=d("br"),me=i(`
            An array of `),I(De.$$.fragment),_e=i("-structures, each of which describes a region of data to copy."),ne=Y(),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Pe=E(t);r=g(Pe,"CODE",{});var Be=E(r);$=f(Be,"pCommandBuffer"),Be.forEach(l),n=g(Pe,"BR",{}),s=f(Pe,`
            The `),S(a.$$.fragment,Pe),u=f(Pe," to use to execute the copy."),Pe.forEach(l),p=j(we),m=g(we,"LI",{});var Ie=E(m);_=g(Ie,"CODE",{});var re=E(_);v=f(re,"pBuffer"),re.forEach(l),P=g(Ie,"BR",{}),R=f(Ie,`
            A pointer to the `),S(A.$$.fragment,Ie),T=f(Ie," to copy this Image's data to."),Ie.forEach(l),F=j(we),B=g(we,"LI",{});var he=E(B);y=g(he,"CODE",{});var Le=E(y);V=f(Le,"srcLayout"),Le.forEach(l),x=g(he,"BR",{}),M=f(he,`
            The layout of the sourece `),S(O.$$.fragment,he),H=f(he,` (this Image) subresources for the copy. This should be a member of
            the `),S(k.$$.fragment,he),N=f(he,"-enumerant."),Q=g(he,"BR",{}),X=f(he,`
            This is most likely either
            `),Z=g(he,"CODE",{});var Oe=E(Z);K=f(Oe,"VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),Oe.forEach(l),W=f(he,`,
            `),q=g(he,"CODE",{});var oe=E(q);U=f(oe,"VK_IMAGE_LAYOUT_GENERAL"),oe.forEach(l),te=f(he,`
            or `),ee=g(he,"CODE",{});var ce=E(ee);se=f(ce,"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),ce.forEach(l),ie=f(he,"."),he.forEach(l),ae=j(we),J=g(we,"LI",{});var Ae=E(J);pe=g(Ae,"CODE",{});var ye=E(pe);Se=f(ye,"regions"),ye.forEach(l),de=g(Ae,"BR",{}),me=f(Ae,`
            An array of `),S(De.$$.fragment,Ae),_e=f(Ae,"-structures, each of which describes a region of data to copy."),Ae.forEach(l),ne=j(we),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),o(B,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,q),o(q,U),o(B,te),o(B,ee),o(ee,se),o(B,ie),o(e,ae),o(e,J),o(J,pe),o(pe,Se),o(J,de),o(J,me),D(De,J,null),o(J,_e),o(e,ne),le=!0},p(ge,we){const Pe={};we&1&&(Pe.$$scope={dirty:we,ctx:ge}),a.$set(Pe);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),A.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),O.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),De.$set(he)},i(ge){le||(b(a.$$.fragment,ge),b(A.$$.fragment,ge),b(O.$$.fragment,ge),b(k.$$.fragment,ge),b(De.$$.fragment,ge),le=!0)},o(ge){w(a.$$.fragment,ge),w(A.$$.fragment,ge),w(O.$$.fragment,ge),w(k.$$.fragment,ge),w(De.$$.fragment,ge),le=!1},d(ge){ge&&l(e),C(a),C(A),C(O),C(k),C(De)}}}function QC(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:`void copyTo(
    CommandBuffer* pCommandBuffer, 
    Image* pImage, 
    VkImageLayout srcLayout, 
    VkImageLayout dstLayout,
    std::vector<VkImageCopy>& regions
);`}}),r=new Ce({props:{$$slots:{params:[MC],details:[LC]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`void copyTo(
    CommandBuffer* pCommandBuffer, 
    Buffer* pImage, 
    VkImageLayout srcLayout, 
    std::vector<VkBufferImageCopy>& regions
);`}}),u=new Ce({props:{$$slots:{params:[WC],details:[xC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment),p=d("br")},l(_){S(e.$$.fragment,_),t=j(_),S(r.$$.fragment,_),$=g(_,"BR",{}),n=j(_),S(s.$$.fragment,_),a=j(_),S(u.$$.fragment,_),p=g(_,"BR",{})},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),h(_,n,v),D(s,_,v),h(_,a,v),D(u,_,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(s.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(s.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),_&&l(n),C(s,_),_&&l(a),C(u,_),_&&l(p)}}}class KC extends ve{constructor(e){super(),Ee(this,e,null,QC,be,{})}}function zC(c){let e,t;return{c(){e=d("span"),t=i("Get the type of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the type of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function YC(c){let e,t;return{c(){e=d("span"),t=i("The type of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The type of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function jC(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageType getType();"}}),r=new Ce({props:{$$slots:{return:[YC],details:[zC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class XC extends ve{constructor(e){super(),Ee(this,e,null,jC,be,{})}}function ZC(c){let e,t;return{c(){e=d("span"),t=i("Get the format of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the format of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function JC(c){let e,t;return{c(){e=d("span"),t=i("The format of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The format of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function eS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkFormat getFormat();"}}),r=new Ce({props:{$$slots:{return:[JC],details:[ZC]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tS extends ve{constructor(e){super(),Ee(this,e,null,eS,be,{})}}function rS(c){let e,t;return{c(){e=d("span"),t=i("Get the extent of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the extent of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function nS(c){let e,t;return{c(){e=d("span"),t=i("The extent of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The extent of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function sS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkExtent3D getExtent();"}}),r=new Ce({props:{$$slots:{return:[nS],details:[rS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aS extends ve{constructor(e){super(),Ee(this,e,null,sS,be,{})}}function oS(c){let e,t;return{c(){e=d("span"),t=i("Get the amount of mipmap levels of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the amount of mipmap levels of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function lS(c){let e,t;return{c(){e=d("span"),t=i("The amount of mipmap levels of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The amount of mipmap levels of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function iS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getMipLevels();"}}),r=new Ce({props:{$$slots:{return:[lS],details:[oS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fS extends ve{constructor(e){super(),Ee(this,e,null,iS,be,{})}}function cS(c){let e,t;return{c(){e=d("span"),t=i("Get the amount of array layers of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the amount of array layers of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function $S(c){let e,t;return{c(){e=d("span"),t=i("The amount of array layers of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The amount of array layers of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function uS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getArrayLayers();"}}),r=new Ce({props:{$$slots:{return:[$S],details:[cS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class pS extends ve{constructor(e){super(),Ee(this,e,null,uS,be,{})}}function mS(c){let e,t;return{c(){e=d("span"),t=i("Get the sample count of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the sample count of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function hS(c){let e,t;return{c(){e=d("span"),t=i("The sample count of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The sample count of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function dS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkSampleCountFlagBits getSamples();"}}),r=new Ce({props:{$$slots:{return:[hS],details:[mS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gS extends ve{constructor(e){super(),Ee(this,e,null,dS,be,{})}}function _S(c){let e,t;return{c(){e=d("span"),t=i("Get the tiling of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the tiling of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function vS(c){let e,t;return{c(){e=d("span"),t=i("The tiling of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The tiling of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ES(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageTiling getTiling();"}}),r=new Ce({props:{$$slots:{return:[vS],details:[_S]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class bS extends ve{constructor(e){super(),Ee(this,e,null,ES,be,{})}}function wS(c){let e,t;return{c(){e=d("span"),t=i("Get the initial layout of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the initial layout of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function IS(c){let e,t;return{c(){e=d("span"),t=i("The initial layout of the Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The initial layout of the Image."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function DS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkImageLayout getInitialLayout();"}}),r=new Ce({props:{$$slots:{return:[IS],details:[wS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class CS extends ve{constructor(e){super(),Ee(this,e,null,DS,be,{})}}function SS(c){let e;return{c(){e=i("Vulkan Image Memory Barrier")},l(t){e=f(t,"Vulkan Image Memory Barrier")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PS(c){let e;return{c(){e=i("image memory barriers")},l(t){e=f(t,"image memory barriers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AS(c){let e;return{c(){e=i("Image memory barriers")},l(t){e=f(t,"Image memory barriers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RS(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BS(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[SS]},$$scope:{ctx:c}}}),a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[PS]},$$scope:{ctx:c}}}),_=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html",target:"_blank",$$slots:{default:[AS]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.QUEUE,$$slots:{default:[RS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Transition an Image from one layout to another using an "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Images are transferred from layout to layout using `),I(a.$$.fragment),u=i("."),p=d("br"),m=Y(),I(_.$$.fragment),v=i(` are used to control access to an Image. They make our operations on the
        GPU happen in a certain order, which ensures that we get the expected result.
        A barrier separates two operations in a `),I(P.$$.fragment),R=i(`: before the barrier and after the barrier. Work done before the
        barrier is completed is always done before it can be used again.`),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var F=E(e);t=f(F,"Transition an Image from one layout to another using an "),S(r.$$.fragment,F),$=f(F,"."),n=g(F,"BR",{}),s=f(F,`
        Images are transferred from layout to layout using `),S(a.$$.fragment,F),u=f(F,"."),p=g(F,"BR",{}),m=j(F),S(_.$$.fragment,F),v=f(F,` are used to control access to an Image. They make our operations on the
        GPU happen in a certain order, which ensures that we get the expected result.
        A barrier separates two operations in a `),S(P.$$.fragment,F),R=f(F,`: before the barrier and after the barrier. Work done before the
        barrier is completed is always done before it can be used again.`),F.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,F){h(T,e,F),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),o(e,p),o(e,m),D(_,e,null),o(e,v),D(P,e,null),o(e,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),r.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),a.$set(y);const V={};F&1&&(V.$$scope={dirty:F,ctx:T}),_.$set(V);const x={};F&1&&(x.$$scope={dirty:F,ctx:T}),P.$set(x)},i(T){A||(b(r.$$.fragment,T),b(a.$$.fragment,T),b(_.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(a.$$.fragment,T),w(_.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(a),C(_),C(P)}}}function LS(c){let e;return{c(){e=i("Command Buffer")},l(t){e=f(t,"Command Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kS(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TS(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VS(c){let e;return{c(){e=i("VkAccessFlagBits")},l(t){e=f(t,"VkAccessFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OS(c){let e;return{c(){e=i("VkAccessFlagBits")},l(t){e=f(t,"VkAccessFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FS(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yS(c){let e;return{c(){e=i("VkPipelineStageFlagBits")},l(t){e=f(t,"VkPipelineStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MS(c){let e;return{c(){e=i("VkDependencyFlagBits")},l(t){e=f(t,"VkDependencyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xS(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[LS]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[kS]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[TS]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html",target:"_blank",$$slots:{default:[VS]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html",target:"_blank",$$slots:{default:[OS]},$$scope:{ctx:c}}}),le=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[FS]},$$scope:{ctx:c}}}),Ve=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html",target:"_blank",$$slots:{default:[yS]},$$scope:{ctx:c}}}),ht=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html",target:"_blank",$$slots:{default:[MS]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to use to transfer the Image layout."),p=Y(),m=d("li"),_=d("code"),v=i("oldLayout"),P=d("br"),R=i(`
            The layout to be used before the barrier for the image. This is a member
            of the `),I(A.$$.fragment),T=i("-enumeration."),F=Y(),B=d("li"),y=d("code"),V=i("newLayout"),x=d("br"),M=i(`
            The layout to use after the barrier for the image. This is a member of
            the `),I(O.$$.fragment),H=i("-enumeration."),k=Y(),N=d("li"),Q=d("code"),X=i("srcAccessMask"),Z=d("br"),K=i(`
            The access type of the source. This is a member of the `),I(W.$$.fragment),q=i("-enumeration."),U=Y(),te=d("li"),ee=d("code"),se=i("dstAccessMask"),ie=d("br"),ae=i(`
            The access type of the destination. This is a member of the `),I(J.$$.fragment),pe=i("-enumeration."),Se=Y(),de=d("li"),me=d("code"),De=i("srcStageMask"),_e=d("br"),ne=i(`
            The access type of the resource. This is a member of the `),I(le.$$.fragment),ge=i("-enumeration."),we=d("br"),Pe=i(`
            The `),Be=d("code"),Ie=i("srcStageMask"),re=i(` indicates when the source stage has
            finished reading or writing a source. As a result, moving that
            stage's effective position later in the pipeline doesn't change the
            fact that those accesses have been completed; it can only mean that
            the implementation is waiting longer than is really necessary to
            complete.`),he=d("br"),Le=i(`
            So it also waits for all phases of the pipeline before the specified
            phase.`),Oe=Y(),oe=d("li"),ce=d("code"),Ae=i("dstStageMask"),ye=d("br"),Fe=i(`
            Which pipeline stages will read from the source. This is what happens
            after the barrier. Built from a number of members of the `),I(Ve.$$.fragment),Ge=i("-enumeration."),He=d("br"),ze=i(`
            The `),xe=d("code"),Ne=i("dstStageMask"),Te=i(` specifies the point at which the
            pipeline will wait before continuing. If an implementation moves
            that holdpoint before, it will still work. The event it's waiting
            for will still complete when the later parts of the pipeline run.
            That implementation simply misses the opportunity to perform work
            while it waited.`),qe=d("br"),Ke=i(`
            Later phases in the pipeline after the specified phase are therefore
            also blocked.`),je=Y(),rt=d("li"),Me=d("code"),Ue=i("dependencyFlags"),$t=d("br"),ut=i(`
            Specifies a set of `),I(ht.$$.fragment),Je=i(`-flags describing how the dependency represented by the barrier
            affects the resources referenced by the barrier.`),this.h()},l(et){e=g(et,"DIV",{slot:!0});var Ze=E(e);t=g(Ze,"LI",{});var nt=E(t);r=g(nt,"CODE",{});var Qe=E(r);$=f(Qe,"pCommandBuffer"),Qe.forEach(l),n=g(nt,"BR",{}),s=f(nt,`
            The `),S(a.$$.fragment,nt),u=f(nt," to use to transfer the Image layout."),nt.forEach(l),p=j(Ze),m=g(Ze,"LI",{});var ct=E(m);_=g(ct,"CODE",{});var st=E(_);v=f(st,"oldLayout"),st.forEach(l),P=g(ct,"BR",{}),R=f(ct,`
            The layout to be used before the barrier for the image. This is a member
            of the `),S(A.$$.fragment,ct),T=f(ct,"-enumeration."),ct.forEach(l),F=j(Ze),B=g(Ze,"LI",{});var We=E(B);y=g(We,"CODE",{});var at=E(y);V=f(at,"newLayout"),at.forEach(l),x=g(We,"BR",{}),M=f(We,`
            The layout to use after the barrier for the image. This is a member of
            the `),S(O.$$.fragment,We),H=f(We,"-enumeration."),We.forEach(l),k=j(Ze),N=g(Ze,"LI",{});var bt=E(N);Q=g(bt,"CODE",{});var wt=E(Q);X=f(wt,"srcAccessMask"),wt.forEach(l),Z=g(bt,"BR",{}),K=f(bt,`
            The access type of the source. This is a member of the `),S(W.$$.fragment,bt),q=f(bt,"-enumeration."),bt.forEach(l),U=j(Ze),te=g(Ze,"LI",{});var St=E(te);ee=g(St,"CODE",{});var tt=E(ee);se=f(tt,"dstAccessMask"),tt.forEach(l),ie=g(St,"BR",{}),ae=f(St,`
            The access type of the destination. This is a member of the `),S(J.$$.fragment,St),pe=f(St,"-enumeration."),St.forEach(l),Se=j(Ze),de=g(Ze,"LI",{});var ot=E(de);me=g(ot,"CODE",{});var At=E(me);De=f(At,"srcStageMask"),At.forEach(l),_e=g(ot,"BR",{}),ne=f(ot,`
            The access type of the resource. This is a member of the `),S(le.$$.fragment,ot),ge=f(ot,"-enumeration."),we=g(ot,"BR",{}),Pe=f(ot,`
            The `),Be=g(ot,"CODE",{});var it=E(Be);Ie=f(it,"srcStageMask"),it.forEach(l),re=f(ot,` indicates when the source stage has
            finished reading or writing a source. As a result, moving that
            stage's effective position later in the pipeline doesn't change the
            fact that those accesses have been completed; it can only mean that
            the implementation is waiting longer than is really necessary to
            complete.`),he=g(ot,"BR",{}),Le=f(ot,`
            So it also waits for all phases of the pipeline before the specified
            phase.`),ot.forEach(l),Oe=j(Ze),oe=g(Ze,"LI",{});var Xe=E(oe);ce=g(Xe,"CODE",{});var Dt=E(ce);Ae=f(Dt,"dstStageMask"),Dt.forEach(l),ye=g(Xe,"BR",{}),Fe=f(Xe,`
            Which pipeline stages will read from the source. This is what happens
            after the barrier. Built from a number of members of the `),S(Ve.$$.fragment,Xe),Ge=f(Xe,"-enumeration."),He=g(Xe,"BR",{}),ze=f(Xe,`
            The `),xe=g(Xe,"CODE",{});var Ct=E(xe);Ne=f(Ct,"dstStageMask"),Ct.forEach(l),Te=f(Xe,` specifies the point at which the
            pipeline will wait before continuing. If an implementation moves
            that holdpoint before, it will still work. The event it's waiting
            for will still complete when the later parts of the pipeline run.
            That implementation simply misses the opportunity to perform work
            while it waited.`),qe=g(Xe,"BR",{}),Ke=f(Xe,`
            Later phases in the pipeline after the specified phase are therefore
            also blocked.`),Xe.forEach(l),je=j(Ze),rt=g(Ze,"LI",{});var pt=E(rt);Me=g(pt,"CODE",{});var Ft=E(Me);Ue=f(Ft,"dependencyFlags"),Ft.forEach(l),$t=g(pt,"BR",{}),ut=f(pt,`
            Specifies a set of `),S(ht.$$.fragment,pt),Je=f(pt,`-flags describing how the dependency represented by the barrier
            affects the resources referenced by the barrier.`),pt.forEach(l),Ze.forEach(l),this.h()},h(){z(e,"slot","params")},m(et,Ze){h(et,e,Ze),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),D(J,te,null),o(te,pe),o(e,Se),o(e,de),o(de,me),o(me,De),o(de,_e),o(de,ne),D(le,de,null),o(de,ge),o(de,we),o(de,Pe),o(de,Be),o(Be,Ie),o(de,re),o(de,he),o(de,Le),o(e,Oe),o(e,oe),o(oe,ce),o(ce,Ae),o(oe,ye),o(oe,Fe),D(Ve,oe,null),o(oe,Ge),o(oe,He),o(oe,ze),o(oe,xe),o(xe,Ne),o(oe,Te),o(oe,qe),o(oe,Ke),o(e,je),o(e,rt),o(rt,Me),o(Me,Ue),o(rt,$t),o(rt,ut),D(ht,rt,null),o(rt,Je),dt=!0},p(et,Ze){const nt={};Ze&1&&(nt.$$scope={dirty:Ze,ctx:et}),a.$set(nt);const Qe={};Ze&1&&(Qe.$$scope={dirty:Ze,ctx:et}),A.$set(Qe);const ct={};Ze&1&&(ct.$$scope={dirty:Ze,ctx:et}),O.$set(ct);const st={};Ze&1&&(st.$$scope={dirty:Ze,ctx:et}),W.$set(st);const We={};Ze&1&&(We.$$scope={dirty:Ze,ctx:et}),J.$set(We);const at={};Ze&1&&(at.$$scope={dirty:Ze,ctx:et}),le.$set(at);const bt={};Ze&1&&(bt.$$scope={dirty:Ze,ctx:et}),Ve.$set(bt);const wt={};Ze&1&&(wt.$$scope={dirty:Ze,ctx:et}),ht.$set(wt)},i(et){dt||(b(a.$$.fragment,et),b(A.$$.fragment,et),b(O.$$.fragment,et),b(W.$$.fragment,et),b(J.$$.fragment,et),b(le.$$.fragment,et),b(Ve.$$.fragment,et),b(ht.$$.fragment,et),dt=!0)},o(et){w(a.$$.fragment,et),w(A.$$.fragment,et),w(O.$$.fragment,et),w(W.$$.fragment,et),w(J.$$.fragment,et),w(le.$$.fragment,et),w(Ve.$$.fragment,et),w(ht.$$.fragment,et),dt=!1},d(et){et&&l(e),C(a),C(A),C(O),C(W),C(J),C(le),C(Ve),C(ht)}}}function NS(c){let e;return{c(){e=i("Image View")},l(t){e=f(t,"Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function US(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[NS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the requested "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function GS(c){let e;return{c(){e=i("Render Passes")},l(t){e=f(t,"Render Passes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HS(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[GS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("It is usually better to use "),I(r.$$.fragment),$=i(" whenever possible for transferring Images from layout to layout."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"It is usually better to use "),S(r.$$.fragment,a),$=f(a," whenever possible for transferring Images from layout to layout."),a.forEach(l),this.h()},h(){z(e,"slot","note")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void transitionImageLayout(
    CommandBuffer* pCommandBuffer, 
    VkImageLayout oldLayout, 
    VkImageLayout newLayout, 
    VkAccessFlags srcAccessMask,
    VkAccessFlags dstAccessMask, 
    VkPipelineStageFlags srcStageMask, 
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags = 0
);`}}),r=new Ce({props:{$$slots:{note:[HS],return:[US],params:[xS],details:[BS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class WS extends ve{constructor(e){super(),Ee(this,e,null,qS,be,{})}}function QS(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KS(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[QS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zS(c){let e;return{c(){e=i("Image Views")},l(t){e=f(t,"Image Views")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YS(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[zS]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function jS(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<ImageView*> getImageViews();"}}),r=new Ce({props:{$$slots:{return:[YS],details:[KS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class XS extends ve{constructor(e){super(),Ee(this,e,null,jS,be,{})}}function ZS(c){let e,t;return{c(){e=d("span"),t=i("Get the index of the queue family of this Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the index of the queue family of this Queue."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function JS(c){let e,t;return{c(){e=d("span"),t=i("The index of the queue family of this Queue."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of the queue family of this Queue."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function eP(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getQueueFamilyIndex();"}}),r=new Ce({props:{$$slots:{return:[JS],details:[ZS]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tP extends ve{constructor(e){super(),Ee(this,e,null,eP,be,{})}}function rP(c){let e,t;return{c(){e=d("span"),t=i("Get the index of this Queue within the queue family."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the index of this Queue within the queue family."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function nP(c){let e,t;return{c(){e=d("span"),t=i("The index of this Queue within the queue family."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of this Queue within the queue family."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function sP(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getQueuendex();"}}),r=new Ce({props:{$$slots:{return:[nP],details:[rP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aP extends ve{constructor(e){super(),Ee(this,e,null,sP,be,{})}}function oP(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lP(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[oP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function iP(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fP(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[iP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function cP(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkBufferView getBufferViewHandle() const;"}}),r=new Ce({props:{$$slots:{return:[fP],details:[lP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $P extends ve{constructor(e){super(),Ee(this,e,null,cP,be,{})}}function uP(c){let e;return{c(){e=i("createBufferView")},l(t){e=f(t,"createBufferView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pP(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER_createBufferView,$$slots:{default:[uP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Buffer View."),r=d("br"),$=i(`
        It is recommended to not create a Buffer View by it's Constructor, but to
        use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Buffer View."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Buffer View by it's Constructor, but to
        use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function mP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dP(c){let e;return{c(){e=i("getFormatProperties")},l(t){e=f(t,"getFormatProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _P(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wP(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IP(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DP(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SP(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[mP]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.BUFFER,$$slots:{default:[hP]},$$scope:{ctx:c}}}),te=new G({props:{sectionID:L.PHYSICAL_DEVICE_getFormatProperties,$$slots:{default:[dP]},$$scope:{ctx:c}}}),de=new G({props:{sectionID:L.BUFFER,$$slots:{default:[gP]},$$scope:{ctx:c}}}),ne=new G({props:{sectionID:L.BUFFER,$$slots:{default:[_P]},$$scope:{ctx:c}}}),ge=new G({props:{sectionID:L.BUFFER,$$slots:{default:[vP]},$$scope:{ctx:c}}}),Ae=new G({props:{sectionID:L.BUFFER,$$slots:{default:[EP]},$$scope:{ctx:c}}}),xe=new G({props:{sectionID:L.BUFFER,$$slots:{default:[bP]},$$scope:{ctx:c}}}),ut=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[wP]},$$scope:{ctx:c}}}),Je=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html",target:"_blank",$$slots:{default:[IP]},$$scope:{ctx:c}}}),et=new G({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[DP]},$$scope:{ctx:c}}}),nt=new G({props:{sectionID:L.BUFFER,$$slots:{default:[CP]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Buffer View should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("pBuffer"),P=d("br"),R=i(`
            A pointer to the parent `),I(A.$$.fragment),T=i(" to create a Buffer View of."),F=Y(),B=d("li"),y=d("code"),V=i("format"),x=d("br"),M=i(`
            When bound as a texel buffer, the data in the Buffer is interpreted as
            a string of texels with the format specified in this field.`),O=d("br"),H=i(`
            The specified format must support
            `),k=d("code"),N=i("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),Q=i(`,
            `),X=d("code"),Z=i("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),K=i(` or
            `),W=d("code"),q=i("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),U=i(`, as
            reported by `),I(te.$$.fragment),ee=i("."),se=Y(),ie=d("li"),ae=d("code"),J=i("offset"),pe=d("br"),Se=i(`
            The new view will be a "window" in the parent `),I(de.$$.fragment),me=i(", starting from offset bytes."),De=d("br"),_e=i(`
            The number of bytes of the `),I(ne.$$.fragment),le=i(` where the Buffer View should start. To create a Buffer View of the
            entire `),I(ge.$$.fragment),we=i(`,
            this must be `),Pe=d("code"),Be=i("0"),Ie=i("."),re=Y(),he=d("li"),Le=d("code"),Oe=i("range"),oe=d("br"),ce=i(`
            The new view will be a "window" in the parent `),I(Ae.$$.fragment),ye=i(", expanding to range bytes."),Fe=d("br"),Ve=i(`
            The number of bytes the Buffer View will contain from
            `),Ge=d("code"),He=i("offset"),ze=i(`
            To create a Buffer View of the entire `),I(xe.$$.fragment),Ne=i(", it must be "),Te=d("code"),qe=i("VK_WHOLE_SIZE"),Ke=i("."),je=d("br"),rt=i(`
            The maximum number of texels that can be stored in a texel buffer is
            determined by inspecting the `),Me=d("code"),Ue=i("maxTexelBufferElements"),$t=i(`
            field of the `),I(ut.$$.fragment),ht=i("'s "),I(Je.$$.fragment),dt=i(`-structure, which can be retrieved by calling
            `),I(et.$$.fragment),Ze=i(` If the
            `),I(nt.$$.fragment),Qe=i(` is used as
            a texel buffer, the range divided by the size of a texel in format field
            must be less than or equal to this limit.
            `),ct=d("code"),st=i("maxTexelBufferElements"),We=i(`
            is guaranteed to be a minimum of `),at=d("code"),bt=i("65.536"),wt=i(`, so if the view
            being created contains fewer texels, this limit does not need to be
            requested.`),this.h()},l(tt){e=g(tt,"DIV",{slot:!0});var ot=E(e);t=g(ot,"LI",{});var At=E(t);r=g(At,"CODE",{});var it=E(r);$=f(it,"pLogicalDevice"),it.forEach(l),n=g(At,"BR",{}),s=f(At,`
            A pointer to the `),S(a.$$.fragment,At),u=f(At," the Buffer View should be associated with."),At.forEach(l),p=j(ot),m=g(ot,"LI",{});var Xe=E(m);_=g(Xe,"CODE",{});var Dt=E(_);v=f(Dt,"pBuffer"),Dt.forEach(l),P=g(Xe,"BR",{}),R=f(Xe,`
            A pointer to the parent `),S(A.$$.fragment,Xe),T=f(Xe," to create a Buffer View of."),Xe.forEach(l),F=j(ot),B=g(ot,"LI",{});var Ct=E(B);y=g(Ct,"CODE",{});var pt=E(y);V=f(pt,"format"),pt.forEach(l),x=g(Ct,"BR",{}),M=f(Ct,`
            When bound as a texel buffer, the data in the Buffer is interpreted as
            a string of texels with the format specified in this field.`),O=g(Ct,"BR",{}),H=f(Ct,`
            The specified format must support
            `),k=g(Ct,"CODE",{});var Ft=E(k);N=f(Ft,"VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),Ft.forEach(l),Q=f(Ct,`,
            `),X=g(Ct,"CODE",{});var mt=E(X);Z=f(mt,"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),mt.forEach(l),K=f(Ct,` or
            `),W=g(Ct,"CODE",{});var Vt=E(W);q=f(Vt,"VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),Vt.forEach(l),U=f(Ct,`, as
            reported by `),S(te.$$.fragment,Ct),ee=f(Ct,"."),Ct.forEach(l),se=j(ot),ie=g(ot,"LI",{});var Rt=E(ie);ae=g(Rt,"CODE",{});var Tt=E(ae);J=f(Tt,"offset"),Tt.forEach(l),pe=g(Rt,"BR",{}),Se=f(Rt,`
            The new view will be a "window" in the parent `),S(de.$$.fragment,Rt),me=f(Rt,", starting from offset bytes."),De=g(Rt,"BR",{}),_e=f(Rt,`
            The number of bytes of the `),S(ne.$$.fragment,Rt),le=f(Rt,` where the Buffer View should start. To create a Buffer View of the
            entire `),S(ge.$$.fragment,Rt),we=f(Rt,`,
            this must be `),Pe=g(Rt,"CODE",{});var vt=E(Pe);Be=f(vt,"0"),vt.forEach(l),Ie=f(Rt,"."),Rt.forEach(l),re=j(ot),he=g(ot,"LI",{});var gt=E(he);Le=g(gt,"CODE",{});var kt=E(Le);Oe=f(kt,"range"),kt.forEach(l),oe=g(gt,"BR",{}),ce=f(gt,`
            The new view will be a "window" in the parent `),S(Ae.$$.fragment,gt),ye=f(gt,", expanding to range bytes."),Fe=g(gt,"BR",{}),Ve=f(gt,`
            The number of bytes the Buffer View will contain from
            `),Ge=g(gt,"CODE",{});var Mt=E(Ge);He=f(Mt,"offset"),Mt.forEach(l),ze=f(gt,`
            To create a Buffer View of the entire `),S(xe.$$.fragment,gt),Ne=f(gt,", it must be "),Te=g(gt,"CODE",{});var yt=E(Te);qe=f(yt,"VK_WHOLE_SIZE"),yt.forEach(l),Ke=f(gt,"."),je=g(gt,"BR",{}),rt=f(gt,`
            The maximum number of texels that can be stored in a texel buffer is
            determined by inspecting the `),Me=g(gt,"CODE",{});var Ht=E(Me);Ue=f(Ht,"maxTexelBufferElements"),Ht.forEach(l),$t=f(gt,`
            field of the `),S(ut.$$.fragment,gt),ht=f(gt,"'s "),S(Je.$$.fragment,gt),dt=f(gt,`-structure, which can be retrieved by calling
            `),S(et.$$.fragment,gt),Ze=f(gt,` If the
            `),S(nt.$$.fragment,gt),Qe=f(gt,` is used as
            a texel buffer, the range divided by the size of a texel in format field
            must be less than or equal to this limit.
            `),ct=g(gt,"CODE",{});var $r=E(ct);st=f($r,"maxTexelBufferElements"),$r.forEach(l),We=f(gt,`
            is guaranteed to be a minimum of `),at=g(gt,"CODE",{});var Ut=E(at);bt=f(Ut,"65.536"),Ut.forEach(l),wt=f(gt,`, so if the view
            being created contains fewer texels, this limit does not need to be
            requested.`),gt.forEach(l),ot.forEach(l),this.h()},h(){z(e,"slot","params")},m(tt,ot){h(tt,e,ot),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),o(B,O),o(B,H),o(B,k),o(k,N),o(B,Q),o(B,X),o(X,Z),o(B,K),o(B,W),o(W,q),o(B,U),D(te,B,null),o(B,ee),o(e,se),o(e,ie),o(ie,ae),o(ae,J),o(ie,pe),o(ie,Se),D(de,ie,null),o(ie,me),o(ie,De),o(ie,_e),D(ne,ie,null),o(ie,le),D(ge,ie,null),o(ie,we),o(ie,Pe),o(Pe,Be),o(ie,Ie),o(e,re),o(e,he),o(he,Le),o(Le,Oe),o(he,oe),o(he,ce),D(Ae,he,null),o(he,ye),o(he,Fe),o(he,Ve),o(he,Ge),o(Ge,He),o(he,ze),D(xe,he,null),o(he,Ne),o(he,Te),o(Te,qe),o(he,Ke),o(he,je),o(he,rt),o(he,Me),o(Me,Ue),o(he,$t),D(ut,he,null),o(he,ht),D(Je,he,null),o(he,dt),D(et,he,null),o(he,Ze),D(nt,he,null),o(he,Qe),o(he,ct),o(ct,st),o(he,We),o(he,at),o(at,bt),o(he,wt),St=!0},p(tt,ot){const At={};ot&1&&(At.$$scope={dirty:ot,ctx:tt}),a.$set(At);const it={};ot&1&&(it.$$scope={dirty:ot,ctx:tt}),A.$set(it);const Xe={};ot&1&&(Xe.$$scope={dirty:ot,ctx:tt}),te.$set(Xe);const Dt={};ot&1&&(Dt.$$scope={dirty:ot,ctx:tt}),de.$set(Dt);const Ct={};ot&1&&(Ct.$$scope={dirty:ot,ctx:tt}),ne.$set(Ct);const pt={};ot&1&&(pt.$$scope={dirty:ot,ctx:tt}),ge.$set(pt);const Ft={};ot&1&&(Ft.$$scope={dirty:ot,ctx:tt}),Ae.$set(Ft);const mt={};ot&1&&(mt.$$scope={dirty:ot,ctx:tt}),xe.$set(mt);const Vt={};ot&1&&(Vt.$$scope={dirty:ot,ctx:tt}),ut.$set(Vt);const Rt={};ot&1&&(Rt.$$scope={dirty:ot,ctx:tt}),Je.$set(Rt);const Tt={};ot&1&&(Tt.$$scope={dirty:ot,ctx:tt}),et.$set(Tt);const vt={};ot&1&&(vt.$$scope={dirty:ot,ctx:tt}),nt.$set(vt)},i(tt){St||(b(a.$$.fragment,tt),b(A.$$.fragment,tt),b(te.$$.fragment,tt),b(de.$$.fragment,tt),b(ne.$$.fragment,tt),b(ge.$$.fragment,tt),b(Ae.$$.fragment,tt),b(xe.$$.fragment,tt),b(ut.$$.fragment,tt),b(Je.$$.fragment,tt),b(et.$$.fragment,tt),b(nt.$$.fragment,tt),St=!0)},o(tt){w(a.$$.fragment,tt),w(A.$$.fragment,tt),w(te.$$.fragment,tt),w(de.$$.fragment,tt),w(ne.$$.fragment,tt),w(ge.$$.fragment,tt),w(Ae.$$.fragment,tt),w(xe.$$.fragment,tt),w(ut.$$.fragment,tt),w(Je.$$.fragment,tt),w(et.$$.fragment,tt),w(nt.$$.fragment,tt),St=!1},d(tt){tt&&l(e),C(a),C(A),C(te),C(de),C(ne),C(ge),C(Ae),C(xe),C(ut),C(Je),C(et),C(nt)}}}function PP(c){let e;return{c(){e=i("Vulkan Buffer View")},l(t){e=f(t,"Vulkan Buffer View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AP(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferView.html",target:"_blank",$$slots:{default:[PP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function RP(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`BufferView(
    LogicalDevic pLogicalDevice, 
    Buffe pBuffer, 
    VkFormat format, 
    VkDeviceSize offset = 0, 
    VkDeviceSize range = VK_WHOLE_SIZE
);`}}),r=new Ce({props:{$$slots:{throws:[AP],params:[SP],details:[pP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class BP extends ve{constructor(e){super(),Ee(this,e,null,RP,be,{})}}function LP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OP(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FP(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/buffer_view.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[LP]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.BUFFER,$$slots:{default:[kP]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.BUFFER,$$slots:{default:[TP]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.BUFFER,$$slots:{default:[VP]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.BUFFER,$$slots:{default:[OP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer View"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to the parent "),I(u.$$.fragment),p=i(` which it will create a Buffer View of, along with information regarding the format
and size of the Buffer View.`),m=d("br"),_=i(`
A Buffer View is used to interpret the data in a `),I(v.$$.fragment),P=i(` with a specific format. Buffer Views represent a sub-scope of a buffer object.
Since the raw data in the `),I(R.$$.fragment),A=i(`
is then treated as a sequence of texels, this is also known as a texel buffer view.
A texel buffer view is directly accessible in shaders and Vulkan will automatically
convert the texels in the `),I(T.$$.fragment),F=i(" to the format expected by the shader.")},l(y){S(e.$$.fragment,y),t=f(y,`
The `),r=g(y,"CODE",{});var V=E(r);$=f(V,"Buffer View"),V.forEach(l),n=f(y," class takes a pointer to a "),S(s.$$.fragment,y),a=f(y,", a pointer to the parent "),S(u.$$.fragment,y),p=f(y,` which it will create a Buffer View of, along with information regarding the format
and size of the Buffer View.`),m=g(y,"BR",{}),_=f(y,`
A Buffer View is used to interpret the data in a `),S(v.$$.fragment,y),P=f(y,` with a specific format. Buffer Views represent a sub-scope of a buffer object.
Since the raw data in the `),S(R.$$.fragment,y),A=f(y,`
is then treated as a sequence of texels, this is also known as a texel buffer view.
A texel buffer view is directly accessible in shaders and Vulkan will automatically
convert the texels in the `),S(T.$$.fragment,y),F=f(y," to the format expected by the shader.")},m(y,V){D(e,y,V),h(y,t,V),h(y,r,V),o(r,$),h(y,n,V),D(s,y,V),h(y,a,V),D(u,y,V),h(y,p,V),h(y,m,V),h(y,_,V),D(v,y,V),h(y,P,V),D(R,y,V),h(y,A,V),D(T,y,V),h(y,F,V),B=!0},p(y,[V]){const x={};V&1&&(x.$$scope={dirty:V,ctx:y}),s.$set(x);const M={};V&1&&(M.$$scope={dirty:V,ctx:y}),u.$set(M);const O={};V&1&&(O.$$scope={dirty:V,ctx:y}),v.$set(O);const H={};V&1&&(H.$$scope={dirty:V,ctx:y}),R.$set(H);const k={};V&1&&(k.$$scope={dirty:V,ctx:y}),T.$set(k)},i(y){B||(b(e.$$.fragment,y),b(s.$$.fragment,y),b(u.$$.fragment,y),b(v.$$.fragment,y),b(R.$$.fragment,y),b(T.$$.fragment,y),B=!0)},o(y){w(e.$$.fragment,y),w(s.$$.fragment,y),w(u.$$.fragment,y),w(v.$$.fragment,y),w(R.$$.fragment,y),w(T.$$.fragment,y),B=!1},d(y){C(e,y),y&&l(t),y&&l(r),y&&l(n),C(s,y),y&&l(a),C(u,y),y&&l(p),y&&l(m),y&&l(_),C(v,y),y&&l(P),C(R,y),y&&l(A),C(T,y),y&&l(F)}}}class yP extends ve{constructor(e){super(),Ee(this,e,null,FP,be,{})}}function MP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GP(c){let e;return{c(){e=i("Framebuffer")},l(t){e=f(t,"Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HP(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WP(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/image_view.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[MP]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.IMAGE,$$slots:{default:[xP]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.IMAGE,$$slots:{default:[NP]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.IMAGE,$$slots:{default:[UP]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[GP]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[HP]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.IMAGE,$$slots:{default:[qP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image View"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to the parent "),I(u.$$.fragment),p=i(` which it will create an Image View of, along with information regarding the view
type and format.`),m=d("br"),_=i(`
In many cases, the `),I(v.$$.fragment),P=i(` resource
cannot be used directly because it requires more information than is contained in
the resource itself. For example, an `),I(R.$$.fragment),A=i(" resource cannot be used directly as an attachment to a "),I(T.$$.fragment),F=i(" or bound in a "),I(B.$$.fragment),y=i(` to be sampled in a shader. To meet these additional requirements, an image view
must be created, which is essentially a collection of properties and a reference
to a parent `),I(V.$$.fragment),x=i(" resource.")},l(O){S(e.$$.fragment,O),t=f(O,`
The `),r=g(O,"CODE",{});var H=E(r);$=f(H,"Image View"),H.forEach(l),n=f(O," class takes a pointer to a "),S(s.$$.fragment,O),a=f(O,", a pointer to the parent "),S(u.$$.fragment,O),p=f(O,` which it will create an Image View of, along with information regarding the view
type and format.`),m=g(O,"BR",{}),_=f(O,`
In many cases, the `),S(v.$$.fragment,O),P=f(O,` resource
cannot be used directly because it requires more information than is contained in
the resource itself. For example, an `),S(R.$$.fragment,O),A=f(O," resource cannot be used directly as an attachment to a "),S(T.$$.fragment,O),F=f(O," or bound in a "),S(B.$$.fragment,O),y=f(O,` to be sampled in a shader. To meet these additional requirements, an image view
must be created, which is essentially a collection of properties and a reference
to a parent `),S(V.$$.fragment,O),x=f(O," resource.")},m(O,H){D(e,O,H),h(O,t,H),h(O,r,H),o(r,$),h(O,n,H),D(s,O,H),h(O,a,H),D(u,O,H),h(O,p,H),h(O,m,H),h(O,_,H),D(v,O,H),h(O,P,H),D(R,O,H),h(O,A,H),D(T,O,H),h(O,F,H),D(B,O,H),h(O,y,H),D(V,O,H),h(O,x,H),M=!0},p(O,[H]){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),s.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),u.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),v.$set(Q);const X={};H&1&&(X.$$scope={dirty:H,ctx:O}),R.$set(X);const Z={};H&1&&(Z.$$scope={dirty:H,ctx:O}),T.$set(Z);const K={};H&1&&(K.$$scope={dirty:H,ctx:O}),B.$set(K);const W={};H&1&&(W.$$scope={dirty:H,ctx:O}),V.$set(W)},i(O){M||(b(e.$$.fragment,O),b(s.$$.fragment,O),b(u.$$.fragment,O),b(v.$$.fragment,O),b(R.$$.fragment,O),b(T.$$.fragment,O),b(B.$$.fragment,O),b(V.$$.fragment,O),M=!0)},o(O){w(e.$$.fragment,O),w(s.$$.fragment,O),w(u.$$.fragment,O),w(v.$$.fragment,O),w(R.$$.fragment,O),w(T.$$.fragment,O),w(B.$$.fragment,O),w(V.$$.fragment,O),M=!1},d(O){C(e,O),O&&l(t),O&&l(r),O&&l(n),C(s,O),O&&l(a),C(u,O),O&&l(p),O&&l(m),O&&l(_),C(v,O),O&&l(P),C(R,O),O&&l(A),C(T,O),O&&l(F),C(B,O),O&&l(y),C(V,O),O&&l(x)}}}class QP extends ve{constructor(e){super(),Ee(this,e,null,WP,be,{})}}function KP(c){let e;return{c(){e=i("createImageView")},l(t){e=f(t,"createImageView")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zP(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.IMAGE_createImageView,$$slots:{default:[KP]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Image View."),r=d("br"),$=i(`
        It is recommended to not create an Image View by it's Constructor, but to
        use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Image View."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create an Image View by it's Constructor, but to
        use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function YP(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XP(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZP(c){let e;return{c(){e=i("VkImageViewType")},l(t){e=f(t,"VkImageViewType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JP(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rA(c){let e;return{c(){e=i("VkImageSubresourceRange")},l(t){e=f(t,"VkImageSubresourceRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sA(c){let e;return{c(){e=i("VkComponentMapping")},l(t){e=f(t,"VkComponentMapping")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aA(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YP]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[jP]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[XP]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html",target:"_blank",$$slots:{default:[ZP]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.IMAGE,$$slots:{default:[JP]},$$scope:{ctx:c}}}),ee=new G({props:{sectionID:L.IMAGE,$$slots:{default:[eA]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.IMAGE,$$slots:{default:[tA]},$$scope:{ctx:c}}}),_e=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html",target:"_blank",$$slots:{default:[rA]},$$scope:{ctx:c}}}),re=new G({props:{sectionID:L.IMAGE,$$slots:{default:[nA]},$$scope:{ctx:c}}}),Le=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html",target:"_blank",$$slots:{default:[sA]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Image View should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("pBuffer"),P=d("br"),R=i(`
            A pointer to the parent `),I(A.$$.fragment),T=i(" to create a Image View of."),F=Y(),B=d("li"),y=d("code"),V=i("viewType"),x=d("br"),M=i(`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),I(O.$$.fragment),H=i("-enumeration, which is larger than the "),I(k.$$.fragment),N=i("-enumeration used when creating the parent "),I(Q.$$.fragment),X=i("."),Z=Y(),K=d("li"),W=d("code"),q=i("format"),U=d("br"),te=i(`
            The format of the new Image View. This must be a format compatible with
            the parent `),I(ee.$$.fragment),se=i(`.
            If two formats have the same number of bits per pixel, they are
            generally considered compatible.`),ie=Y(),ae=d("li"),J=d("code"),pe=i("subresourceRange"),Se=d("br"),de=i(`
            The Image View can be a subset of the parent `),I(me.$$.fragment),De=i(". This subset is specified using the embedded "),I(_e.$$.fragment),ne=i("-structure."),le=Y(),ge=d("li"),we=d("code"),Pe=i("components"),Be=d("br"),Ie=i(`
            The order of the components in the Image View may differ from that in
            the parent `),I(re.$$.fragment),he=i(`.
            This makes it possible, for example, to create an RGBA
            representation of an Image in BGRA format. This remapping is
            specified using an instance of the `),I(Le.$$.fragment),Oe=i("-structure."),this.h()},l(ce){e=g(ce,"DIV",{slot:!0});var Ae=E(e);t=g(Ae,"LI",{});var ye=E(t);r=g(ye,"CODE",{});var Fe=E(r);$=f(Fe,"pLogicalDevice"),Fe.forEach(l),n=g(ye,"BR",{}),s=f(ye,`
            A pointer to the `),S(a.$$.fragment,ye),u=f(ye," the Image View should be associated with."),ye.forEach(l),p=j(Ae),m=g(Ae,"LI",{});var Ve=E(m);_=g(Ve,"CODE",{});var Ge=E(_);v=f(Ge,"pBuffer"),Ge.forEach(l),P=g(Ve,"BR",{}),R=f(Ve,`
            A pointer to the parent `),S(A.$$.fragment,Ve),T=f(Ve," to create a Image View of."),Ve.forEach(l),F=j(Ae),B=g(Ae,"LI",{});var He=E(B);y=g(He,"CODE",{});var ze=E(y);V=f(ze,"viewType"),ze.forEach(l),x=g(He,"BR",{}),M=f(He,`
            The type of view to create. The display type must be compatible with
            the parent Image type and is a member of the `),S(O.$$.fragment,He),H=f(He,"-enumeration, which is larger than the "),S(k.$$.fragment,He),N=f(He,"-enumeration used when creating the parent "),S(Q.$$.fragment,He),X=f(He,"."),He.forEach(l),Z=j(Ae),K=g(Ae,"LI",{});var xe=E(K);W=g(xe,"CODE",{});var Ne=E(W);q=f(Ne,"format"),Ne.forEach(l),U=g(xe,"BR",{}),te=f(xe,`
            The format of the new Image View. This must be a format compatible with
            the parent `),S(ee.$$.fragment,xe),se=f(xe,`.
            If two formats have the same number of bits per pixel, they are
            generally considered compatible.`),xe.forEach(l),ie=j(Ae),ae=g(Ae,"LI",{});var Te=E(ae);J=g(Te,"CODE",{});var qe=E(J);pe=f(qe,"subresourceRange"),qe.forEach(l),Se=g(Te,"BR",{}),de=f(Te,`
            The Image View can be a subset of the parent `),S(me.$$.fragment,Te),De=f(Te,". This subset is specified using the embedded "),S(_e.$$.fragment,Te),ne=f(Te,"-structure."),Te.forEach(l),le=j(Ae),ge=g(Ae,"LI",{});var Ke=E(ge);we=g(Ke,"CODE",{});var je=E(we);Pe=f(je,"components"),je.forEach(l),Be=g(Ke,"BR",{}),Ie=f(Ke,`
            The order of the components in the Image View may differ from that in
            the parent `),S(re.$$.fragment,Ke),he=f(Ke,`.
            This makes it possible, for example, to create an RGBA
            representation of an Image in BGRA format. This remapping is
            specified using an instance of the `),S(Le.$$.fragment,Ke),Oe=f(Ke,"-structure."),Ke.forEach(l),Ae.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Ae){h(ce,e,Ae),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),D(Q,B,null),o(B,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),D(ee,K,null),o(K,se),o(e,ie),o(e,ae),o(ae,J),o(J,pe),o(ae,Se),o(ae,de),D(me,ae,null),o(ae,De),D(_e,ae,null),o(ae,ne),o(e,le),o(e,ge),o(ge,we),o(we,Pe),o(ge,Be),o(ge,Ie),D(re,ge,null),o(ge,he),D(Le,ge,null),o(ge,Oe),oe=!0},p(ce,Ae){const ye={};Ae&1&&(ye.$$scope={dirty:Ae,ctx:ce}),a.$set(ye);const Fe={};Ae&1&&(Fe.$$scope={dirty:Ae,ctx:ce}),A.$set(Fe);const Ve={};Ae&1&&(Ve.$$scope={dirty:Ae,ctx:ce}),O.$set(Ve);const Ge={};Ae&1&&(Ge.$$scope={dirty:Ae,ctx:ce}),k.$set(Ge);const He={};Ae&1&&(He.$$scope={dirty:Ae,ctx:ce}),Q.$set(He);const ze={};Ae&1&&(ze.$$scope={dirty:Ae,ctx:ce}),ee.$set(ze);const xe={};Ae&1&&(xe.$$scope={dirty:Ae,ctx:ce}),me.$set(xe);const Ne={};Ae&1&&(Ne.$$scope={dirty:Ae,ctx:ce}),_e.$set(Ne);const Te={};Ae&1&&(Te.$$scope={dirty:Ae,ctx:ce}),re.$set(Te);const qe={};Ae&1&&(qe.$$scope={dirty:Ae,ctx:ce}),Le.$set(qe)},i(ce){oe||(b(a.$$.fragment,ce),b(A.$$.fragment,ce),b(O.$$.fragment,ce),b(k.$$.fragment,ce),b(Q.$$.fragment,ce),b(ee.$$.fragment,ce),b(me.$$.fragment,ce),b(_e.$$.fragment,ce),b(re.$$.fragment,ce),b(Le.$$.fragment,ce),oe=!0)},o(ce){w(a.$$.fragment,ce),w(A.$$.fragment,ce),w(O.$$.fragment,ce),w(k.$$.fragment,ce),w(Q.$$.fragment,ce),w(ee.$$.fragment,ce),w(me.$$.fragment,ce),w(_e.$$.fragment,ce),w(re.$$.fragment,ce),w(Le.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(a),C(A),C(O),C(k),C(Q),C(ee),C(me),C(_e),C(re),C(Le)}}}function oA(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lA(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[oA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function iA(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`ImageView(
    LogicalDevice* pLogicalDevice, 
    Image* pImage, 
    VkImageViewType viewType, 
    VkFormat format, 
    VkImageSubresourceRange subresourceRange,
    VkComponentMapping components
);`}}),r=new Ce({props:{$$slots:{throws:[lA],params:[aA],details:[zP]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fA extends ve{constructor(e){super(),Ee(this,e,null,iA,be,{})}}function cA(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $A(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[cA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function uA(c){let e;return{c(){e=i("Vulkan Image View")},l(t){e=f(t,"Vulkan Image View")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pA(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html",target:"_blank",$$slots:{default:[uA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mA(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkImageView getImageViewHandle() const;"}}),r=new Ce({props:{$$slots:{return:[pA],details:[$A]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hA extends ve{constructor(e){super(),Ee(this,e,null,mA,be,{})}}function dA(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gA(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _A(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vA(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bA(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IA(c){let e;return{c(){e=i("VkDeviceMemory")},l(t){e=f(t,"VkDeviceMemory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DA(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/memory.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[dA]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.BUFFER,$$slots:{default:[gA]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.IMAGE,$$slots:{default:[_A]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.BUFFER,$$slots:{default:[vA]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.IMAGE,$$slots:{default:[EA]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.BUFFER,$$slots:{default:[bA]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.IMAGE,$$slots:{default:[wA]},$$scope:{ctx:c}}}),M=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[IA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Memory"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a pointer to a "),I(u.$$.fragment),p=i(" or "),I(m.$$.fragment),_=i(` and required memory
properties and uses this information to allocate Memory for a given `),I(v.$$.fragment),P=i(" or "),I(R.$$.fragment),A=i("."),T=d("br"),F=i(`

Before a resource, such as a `),I(B.$$.fragment),y=i(" or "),I(V.$$.fragment),x=i(`, can be used by
Vulkan to store data, it must be associated with memory. A device memory
allocation is represented as a `),I(M.$$.fragment),O=i("-object.")},l(k){S(e.$$.fragment,k),t=f(k,`
The `),r=g(k,"CODE",{});var N=E(r);$=f(N,"Memory"),N.forEach(l),n=f(k," class takes a pointer to a "),S(s.$$.fragment,k),a=f(k," along with a pointer to a "),S(u.$$.fragment,k),p=f(k," or "),S(m.$$.fragment,k),_=f(k,` and required memory
properties and uses this information to allocate Memory for a given `),S(v.$$.fragment,k),P=f(k," or "),S(R.$$.fragment,k),A=f(k,"."),T=g(k,"BR",{}),F=f(k,`

Before a resource, such as a `),S(B.$$.fragment,k),y=f(k," or "),S(V.$$.fragment,k),x=f(k,`, can be used by
Vulkan to store data, it must be associated with memory. A device memory
allocation is represented as a `),S(M.$$.fragment,k),O=f(k,"-object.")},m(k,N){D(e,k,N),h(k,t,N),h(k,r,N),o(r,$),h(k,n,N),D(s,k,N),h(k,a,N),D(u,k,N),h(k,p,N),D(m,k,N),h(k,_,N),D(v,k,N),h(k,P,N),D(R,k,N),h(k,A,N),h(k,T,N),h(k,F,N),D(B,k,N),h(k,y,N),D(V,k,N),h(k,x,N),D(M,k,N),h(k,O,N),H=!0},p(k,[N]){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),s.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),u.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),m.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),v.$set(K);const W={};N&1&&(W.$$scope={dirty:N,ctx:k}),R.$set(W);const q={};N&1&&(q.$$scope={dirty:N,ctx:k}),B.$set(q);const U={};N&1&&(U.$$scope={dirty:N,ctx:k}),V.$set(U);const te={};N&1&&(te.$$scope={dirty:N,ctx:k}),M.$set(te)},i(k){H||(b(e.$$.fragment,k),b(s.$$.fragment,k),b(u.$$.fragment,k),b(m.$$.fragment,k),b(v.$$.fragment,k),b(R.$$.fragment,k),b(B.$$.fragment,k),b(V.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(e.$$.fragment,k),w(s.$$.fragment,k),w(u.$$.fragment,k),w(m.$$.fragment,k),w(v.$$.fragment,k),w(R.$$.fragment,k),w(B.$$.fragment,k),w(V.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){C(e,k),k&&l(t),k&&l(r),k&&l(n),C(s,k),k&&l(a),C(u,k),k&&l(p),C(m,k),k&&l(_),C(v,k),k&&l(P),C(R,k),k&&l(A),k&&l(T),k&&l(F),C(B,k),k&&l(y),C(V,k),k&&l(x),C(M,k),k&&l(O)}}}class CA extends ve{constructor(e){super(),Ee(this,e,null,DA,be,{})}}function SA(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PA(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[SA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Memory allocation for a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a new Memory allocation for a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function AA(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RA(c){let e;return{c(){e=i("VkMemoryPropertyFlagBits")},l(t){e=f(t,"VkMemoryPropertyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BA(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return P=new G({props:{sectionID:L.BUFFER,$$slots:{default:[AA]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html",target:"_blank",$$slots:{default:[RA]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),a=Y(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the `),I(P.$$.fragment),R=i(" to create a Memory allocation for."),A=Y(),T=d("li"),F=d("code"),B=i("flags"),y=d("br"),V=i(`
            A bitmask of `),I(x.$$.fragment),M=i(" specifying the required properties for the Memory."),O=Y(),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"pLogicalDevice"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),Q.forEach(l),a=j(N),u=g(N,"LI",{});var Z=E(u);p=g(Z,"CODE",{});var K=E(p);m=f(K,"pBuffer"),K.forEach(l),_=g(Z,"BR",{}),v=f(Z,`
            A pointer to the `),S(P.$$.fragment,Z),R=f(Z," to create a Memory allocation for."),Z.forEach(l),A=j(N),T=g(N,"LI",{});var W=E(T);F=g(W,"CODE",{});var q=E(F);B=f(q,"flags"),q.forEach(l),y=g(W,"BR",{}),V=f(W,`
            A bitmask of `),S(x.$$.fragment,W),M=f(W," specifying the required properties for the Memory."),W.forEach(l),O=j(N),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),o(e,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),P.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),x.$set(X)},i(k){H||(b(P.$$.fragment,k),b(x.$$.fragment,k),H=!0)},o(k){w(P.$$.fragment,k),w(x.$$.fragment,k),H=!1},d(k){k&&l(e),C(P),C(x)}}}function LA(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kA(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TA(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[LA]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[kA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created, the given "),a=d("code"),u=i("flags"),p=i(` are not supported or
        the memory requirements are not supported by the `),I(m.$$.fragment),_=i(`.
    `),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R," couldn't be created, the given "),a=g(R,"CODE",{});var T=E(a);u=f(T,"flags"),T.forEach(l),p=f(R,` are not supported or
        the memory requirements are not supported by the `),S(m.$$.fragment,R),_=f(R,`.
    `),R.forEach(l),this.h()},h(){z(e,"slot","throws")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),m.$set(T)},i(P){v||(b(n.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){P&&l(e),C(n),C(m)}}}function VA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OA(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[VA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Memory allocation for an "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Create a new Memory allocation for an "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function FA(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yA(c){let e;return{c(){e=i("VkMemoryPropertyFlagBits")},l(t){e=f(t,"VkMemoryPropertyFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MA(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O;return P=new G({props:{sectionID:L.IMAGE,$$slots:{default:[FA]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html",target:"_blank",$$slots:{default:[yA]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),a=Y(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the `),I(P.$$.fragment),R=i(" to create a Memory allocation for."),A=Y(),T=d("li"),F=d("code"),B=i("flags"),y=d("br"),V=i(`
            A bitmask of `),I(x.$$.fragment),M=i(" specifying the required properties for the Memory."),this.h()},l(H){e=g(H,"DIV",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"pLogicalDevice"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            A pointer to the Logical Device the Memory allocation should be associated
            with.`),N.forEach(l),a=j(k),u=g(k,"LI",{});var X=E(u);p=g(X,"CODE",{});var Z=E(p);m=f(Z,"pBuffer"),Z.forEach(l),_=g(X,"BR",{}),v=f(X,`
            A pointer to the `),S(P.$$.fragment,X),R=f(X," to create a Memory allocation for."),X.forEach(l),A=j(k),T=g(k,"LI",{});var K=E(T);F=g(K,"CODE",{});var W=E(F);B=f(W,"flags"),W.forEach(l),y=g(K,"BR",{}),V=f(K,`
            A bitmask of `),S(x.$$.fragment,K),M=f(K," specifying the required properties for the Memory."),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(H,k){h(H,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),O=!0},p(H,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:H}),P.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:H}),x.$set(Q)},i(H){O||(b(P.$$.fragment,H),b(x.$$.fragment,H),O=!0)},o(H){w(P.$$.fragment,H),w(x.$$.fragment,H),O=!1},d(H){H&&l(e),C(P),C(x)}}}function xA(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NA(c){let e;return{c(){e=i("Physical Device")},l(t){e=f(t,"Physical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UA(c){let e,t,r,$,n,s,a,u,p,m,_,v;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[xA]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.PHYSICAL_DEVICE,$$slots:{default:[NA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created, the given "),a=d("code"),u=i("flags"),p=i(` are not supported or
        the memory requirements are not supported by the `),I(m.$$.fragment),_=i("."),this.h()},l(P){e=g(P,"SPAN",{slot:!0});var R=E(e);t=g(R,"CODE",{});var A=E(t);r=f(A,"std::runtime_error"),A.forEach(l),$=f(R," if the "),S(n.$$.fragment,R),s=f(R," couldn't be created, the given "),a=g(R,"CODE",{});var T=E(a);u=f(T,"flags"),T.forEach(l),p=f(R,` are not supported or
        the memory requirements are not supported by the `),S(m.$$.fragment,R),_=f(R,"."),R.forEach(l),this.h()},h(){z(e,"slot","throws")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),D(m,e,null),o(e,_),v=!0},p(P,R){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),n.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),m.$set(T)},i(P){v||(b(n.$$.fragment,P),b(m.$$.fragment,P),v=!0)},o(P){w(n.$$.fragment,P),w(m.$$.fragment,P),v=!1},d(P){P&&l(e),C(n),C(m)}}}function GA(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:`Memory(
    LogicalDevice* pLogicalDevice, 
    Buffer* pBuffer, 
    VkMemoryPropertyFlags flags
);`}}),r=new Ce({props:{$$slots:{throws:[TA],params:[BA],details:[PA]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`Memory(
    LogicalDevice* pLogicalDevice, 
    Image* pImage, 
    VkMemoryPropertyFlags flags
);`}}),u=new Ce({props:{$$slots:{throws:[UA],params:[MA],details:[OA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class HA extends ve{constructor(e){super(),Ee(this,e,null,GA,be,{})}}function qA(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WA(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[qA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function QA(c){let e;return{c(){e=i("Vulkan Device Memory")},l(t){e=f(t,"Vulkan Device Memory")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KA(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html",target:"_blank",$$slots:{default:[QA]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zA(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkDeviceMemory getMemoryHandle() const;"}}),r=new Ce({props:{$$slots:{return:[KA],details:[WA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class YA extends ve{constructor(e){super(),Ee(this,e,null,zA,be,{})}}function jA(c){let e,t;return{c(){e=d("span"),t=i("Allocate memory to get a host usable pointer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Allocate memory to get a host usable pointer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function XA(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            Access to the memory object must be synchronized externally. To assign
            a range of a memory object, the initial offset in bytes must be specified
            in offset.`),a=d("br"),u=i(`
            To map the entire memory object, this must be `),p=d("code"),m=i("0"),_=i("."),v=Y(),P=d("li"),R=d("code"),A=i("size"),T=d("br"),F=i(`
            Access to the memory object must be synchronized externally. To allocate
            a range of a memory object, the size in bytes must be specified.`),B=d("br"),y=i(`
            To map the entire memory object, it must be
            `),V=d("code"),x=i("VK_WHOLE_SIZE"),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"offset"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            Access to the memory object must be synchronized externally. To assign
            a range of a memory object, the initial offset in bytes must be specified
            in offset.`),a=g(H,"BR",{}),u=f(H,`
            To map the entire memory object, this must be `),p=g(H,"CODE",{});var N=E(p);m=f(N,"0"),N.forEach(l),_=f(H,"."),H.forEach(l),v=j(O),P=g(O,"LI",{});var Q=E(P);R=g(Q,"CODE",{});var X=E(R);A=f(X,"size"),X.forEach(l),T=g(Q,"BR",{}),F=f(Q,`
            Access to the memory object must be synchronized externally. To allocate
            a range of a memory object, the size in bytes must be specified.`),B=g(Q,"BR",{}),y=f(Q,`
            To map the entire memory object, it must be
            `),V=g(Q,"CODE",{});var Z=E(V);x=f(Z,"VK_WHOLE_SIZE"),Z.forEach(l),Q.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(t,u),o(t,p),o(p,m),o(t,_),o(e,v),o(e,P),o(P,R),o(R,A),o(P,T),o(P,F),o(P,B),o(P,y),o(P,V),o(V,x)},p:ke,d(M){M&&l(e)}}}function ZA(c){let e,t;return{c(){e=d("span"),t=i(`If successful, it returns a pointer to the mapped area. This pointer can
        then be cast to the appropriate type in the application and dereferenced
        to read and write the device memory directly.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`If successful, it returns a pointer to the mapped area. This pointer can
        then be cast to the appropriate type in the application and dereferenced
        to read and write the device memory directly.`),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function JA(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the Memory failed to map."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the Memory failed to map."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function eR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void** map(VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE);"}}),r=new Ce({props:{$$slots:{throws:[JA],return:[ZA],params:[XA],details:[jA]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class tR extends ve{constructor(e){super(),Ee(this,e,null,eR,be,{})}}function rR(c){let e,t;return{c(){e=d("span"),t=i("Unmap any mapped memory."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Unmap any mapped memory."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function nR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void unmap();"}}),r=new Ce({props:{$$slots:{details:[rR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sR extends ve{constructor(e){super(),Ee(this,e,null,nR,be,{})}}function aR(c){let e,t;return{c(){e=d("span"),t=i("Return a pointer to the mapped memory area."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Return a pointer to the mapped memory area."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function oR(c){let e;return{c(){e=i("map")},l(t){e=f(t,"map")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lR(c){let e,t,r,$,n,s,a,u;return r=new G({props:{sectionID:L.MEMORY_map,$$slots:{default:[oR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The mapped memory mapped with "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no memory is mapped."),this.h()},l(p){e=g(p,"SPAN",{slot:!0});var m=E(e);t=f(m,"The mapped memory mapped with "),S(r.$$.fragment,m),$=f(m," or "),n=g(m,"CODE",{});var _=E(n);s=f(_,"nullptr"),_.forEach(l),a=f(m," if no memory is mapped."),m.forEach(l),this.h()},h(){z(e,"slot","return")},m(p,m){h(p,e,m),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),u=!0},p(p,m){const _={};m&1&&(_.$$scope={dirty:m,ctx:p}),r.$set(_)},i(p){u||(b(r.$$.fragment,p),u=!0)},o(p){w(r.$$.fragment,p),u=!1},d(p){p&&l(e),C(r)}}}function iR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void unmap();"}}),r=new Ce({props:{$$slots:{return:[lR],details:[aR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fR extends ve{constructor(e){super(),Ee(this,e,null,iR,be,{})}}function cR(c){let e,t,r,$,n,s,a,u,p;return{c(){e=d("span"),t=i("Flush a mapped memory range."),r=d("br"),$=i(`
        If `),n=d("code"),s=i("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),a=i(` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly flush or invalidate any caches that may be
        affected by the application.`),u=d("br"),p=i(`
        A flush is needed if the host has written to an allocated memory region and
        wants the device to see the effect of those writes.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Flush a mapped memory range."),r=g(_,"BR",{}),$=f(_,`
        If `),n=g(_,"CODE",{});var v=E(n);s=f(v,"VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),v.forEach(l),a=f(_,` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly flush or invalidate any caches that may be
        affected by the application.`),u=g(_,"BR",{}),p=f(_,`
        A flush is needed if the host has written to an allocated memory region and
        wants the device to see the effect of those writes.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(e,p)},p:ke,d(m){m&&l(e)}}}function $R(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            The offset of the range of mapped memory to be flushed. To flush the
            entire memory area, this must be `),a=d("code"),u=i("0"),p=Y(),m=d("li"),_=d("code"),v=i("size"),P=d("br"),R=i(`
            The size of the mapped memory range to be flushed. To flush the entire
            memory area, it must be `),A=d("code"),T=i("VK_WHOLE_SIZE"),F=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"offset"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The offset of the range of mapped memory to be flushed. To flush the
            entire memory area, this must be `),a=g(V,"CODE",{});var M=E(a);u=f(M,"0"),M.forEach(l),V.forEach(l),p=j(y),m=g(y,"LI",{});var O=E(m);_=g(O,"CODE",{});var H=E(_);v=f(H,"size"),H.forEach(l),P=g(O,"BR",{}),R=f(O,`
            The size of the mapped memory range to be flushed. To flush the entire
            memory area, it must be `),A=g(O,"CODE",{});var k=E(A);T=f(k,"VK_WHOLE_SIZE"),k.forEach(l),F=f(O,"."),O.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(m,A),o(A,T),o(m,F)},p:ke,d(B){B&&l(e)}}}function uR(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the mapped memory range failed to flush."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the mapped memory range failed to flush."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function pR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void unmap();"}}),r=new Ce({props:{$$slots:{throws:[uR],params:[$R],details:[cR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class mR extends ve{constructor(e){super(),Ee(this,e,null,pR,be,{})}}function hR(c){let e,t,r,$,n,s,a,u,p;return{c(){e=d("span"),t=i("Invalidate a mapped memory range."),r=d("br"),$=i(`
        If `),n=d("code"),s=i("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),a=i(` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly clear or invalidate any caches that may be
        affected by the application.`),u=d("br"),p=i(`
        An invalidation is needed if the device is writing to a mapped memory region
        and the host needs to see the effect of the device's writes.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Invalidate a mapped memory range."),r=g(_,"BR",{}),$=f(_,`
        If `),n=g(_,"CODE",{});var v=E(n);s=f(v,"VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),v.forEach(l),a=f(_,` is not set in the
        memory properties of a mapped memory region, it is the responsibility of
        the application to explicitly clear or invalidate any caches that may be
        affected by the application.`),u=g(_,"BR",{}),p=f(_,`
        An invalidation is needed if the device is writing to a mapped memory region
        and the host needs to see the effect of the device's writes.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),o(e,u),o(e,p)},p:ke,d(m){m&&l(e)}}}function dR(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("offset"),n=d("br"),s=i(`
            The offset of the range of mapped memory to be invalidated. To invalidate
            the entire memory area, this must be `),a=d("code"),u=i("0"),p=Y(),m=d("li"),_=d("code"),v=i("size"),P=d("br"),R=i(`
            The size of the mapped memory range to be invalidated. To invalidate
            the entire memory area, it must be `),A=d("code"),T=i("VK_WHOLE_SIZE"),F=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"offset"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The offset of the range of mapped memory to be invalidated. To invalidate
            the entire memory area, this must be `),a=g(V,"CODE",{});var M=E(a);u=f(M,"0"),M.forEach(l),V.forEach(l),p=j(y),m=g(y,"LI",{});var O=E(m);_=g(O,"CODE",{});var H=E(_);v=f(H,"size"),H.forEach(l),P=g(O,"BR",{}),R=f(O,`
            The size of the mapped memory range to be invalidated. To invalidate
            the entire memory area, it must be `),A=g(O,"CODE",{});var k=E(A);T=f(k,"VK_WHOLE_SIZE"),k.forEach(l),F=f(O,"."),O.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(m,A),o(A,T),o(m,F)},p:ke,d(B){B&&l(e)}}}function gR(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the mapped memory range failed to invalidate."),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s," if the mapped memory range failed to invalidate."),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function _R(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void invalidate();"}}),r=new Ce({props:{$$slots:{throws:[gR],params:[dR],details:[hR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vR extends ve{constructor(e){super(),Ee(this,e,null,_R,be,{})}}function ER(c){let e;return{c(){e=i("builder")},l(t){e=f(t,"builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wR(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CR(c){let e;return{c(){e=i("Buffer Builder")},l(t){e=f(t,"Buffer Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PR(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AR(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/buffer_director.hpp>"}}),u=new G({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[ER]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.BUFFER,$$slots:{default:[bR]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[wR]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.BUFFER,$$slots:{default:[IR]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.BUFFER,$$slots:{default:[DR]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.BUFFER_BUILDER,$$slots:{default:[CR]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.BUFFER,$$slots:{default:[SR]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[PR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer Director"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The director defines the order in which to execute building steps, while the
`),I(u.$$.fragment),p=i(` provides the
implementation for those steps.`),m=d("br"),_=i(`
The Buffer Director defines methods for constructing frequently used `),I(v.$$.fragment),P=i(" configurations. For it's methods it takes in the "),I(R.$$.fragment),A=i(" with which the "),I(T.$$.fragment),F=i(` should
be associated with, the size of the `),I(B.$$.fragment),y=i(` and it's sharing mode, which will default to
`),V=d("code"),x=i("VK_SHARING_MODE_EXCLUSIVE"),M=i(` most of the time. With this information
it will use the `),I(O.$$.fragment),H=i(" to construct the requested "),I(k.$$.fragment),N=i(" which it will then return as a "),I(Q.$$.fragment),X=i(" which ownership will be moved to the application.")},l(K){S(e.$$.fragment,K),t=f(K,`
The `),r=g(K,"CODE",{});var W=E(r);$=f(W,"Buffer Director"),W.forEach(l),n=f(K,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(K,"BR",{}),a=f(K,`
The director defines the order in which to execute building steps, while the
`),S(u.$$.fragment,K),p=f(K,` provides the
implementation for those steps.`),m=g(K,"BR",{}),_=f(K,`
The Buffer Director defines methods for constructing frequently used `),S(v.$$.fragment,K),P=f(K," configurations. For it's methods it takes in the "),S(R.$$.fragment,K),A=f(K," with which the "),S(T.$$.fragment,K),F=f(K,` should
be associated with, the size of the `),S(B.$$.fragment,K),y=f(K,` and it's sharing mode, which will default to
`),V=g(K,"CODE",{});var q=E(V);x=f(q,"VK_SHARING_MODE_EXCLUSIVE"),q.forEach(l),M=f(K,` most of the time. With this information
it will use the `),S(O.$$.fragment,K),H=f(K," to construct the requested "),S(k.$$.fragment,K),N=f(K," which it will then return as a "),S(Q.$$.fragment,K),X=f(K," which ownership will be moved to the application.")},m(K,W){D(e,K,W),h(K,t,W),h(K,r,W),o(r,$),h(K,n,W),h(K,s,W),h(K,a,W),D(u,K,W),h(K,p,W),h(K,m,W),h(K,_,W),D(v,K,W),h(K,P,W),D(R,K,W),h(K,A,W),D(T,K,W),h(K,F,W),D(B,K,W),h(K,y,W),h(K,V,W),o(V,x),h(K,M,W),D(O,K,W),h(K,H,W),D(k,K,W),h(K,N,W),D(Q,K,W),h(K,X,W),Z=!0},p(K,[W]){const q={};W&1&&(q.$$scope={dirty:W,ctx:K}),u.$set(q);const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),v.$set(U);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),R.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),T.$set(ee);const se={};W&1&&(se.$$scope={dirty:W,ctx:K}),B.$set(se);const ie={};W&1&&(ie.$$scope={dirty:W,ctx:K}),O.$set(ie);const ae={};W&1&&(ae.$$scope={dirty:W,ctx:K}),k.$set(ae);const J={};W&1&&(J.$$scope={dirty:W,ctx:K}),Q.$set(J)},i(K){Z||(b(e.$$.fragment,K),b(u.$$.fragment,K),b(v.$$.fragment,K),b(R.$$.fragment,K),b(T.$$.fragment,K),b(B.$$.fragment,K),b(O.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(e.$$.fragment,K),w(u.$$.fragment,K),w(v.$$.fragment,K),w(R.$$.fragment,K),w(T.$$.fragment,K),w(B.$$.fragment,K),w(O.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){C(e,K),K&&l(t),K&&l(r),K&&l(n),K&&l(s),K&&l(a),C(u,K),K&&l(p),K&&l(m),K&&l(_),C(v,K),K&&l(P),C(R,K),K&&l(A),C(T,K),K&&l(F),C(B,K),K&&l(y),K&&l(V),K&&l(M),C(O,K),K&&l(H),C(k,K),K&&l(N),C(Q,K),K&&l(X)}}}class RR extends ve{constructor(e){super(),Ee(this,e,null,AR,be,{})}}function BR(c){let e,t;return{c(){e=d("span"),t=i("Create a new Buffer Director."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Buffer Director."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function LR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"BufferDirector();"}}),r=new Ce({props:{$$slots:{details:[BR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kR extends ve{constructor(e){super(),Ee(this,e,null,LR,be,{})}}function TR(c){let e,t;return{c(){e=d("span"),t=i("Create a new Vertex Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Vertex Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function VR(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yR(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xR(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NR(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[VR]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[OR]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[FR]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[yR]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[MR]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[xR]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function UR(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HR(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[UR]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[GR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function qR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WR(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[qR]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function QR(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeVertexBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[WR],return:[HR],params:[NR],details:[TR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class KR extends ve{constructor(e){super(),Ee(this,e,null,QR,be,{})}}function zR(c){let e,t;return{c(){e=d("span"),t=i(`Create a new Vertex Buffer which will be used as a destination for a
        transfer operation.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Create a new Vertex Buffer which will be used as a destination for a
        transfer operation.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function YR(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZR(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JR(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eB(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tB(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YR]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[jR]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[XR]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[ZR]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[JR]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[eB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(" will be used in the multiple device "),I(Z.$$.fragment),K=i(" supported by the Device."),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae," will be used in the multiple device "),S(Z.$$.fragment,ae),K=f(ae," supported by the Device."),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function rB(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sB(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[rB]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[nB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function aB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oB(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[aB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function lB(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeVertexTransferDestinationBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[oB],return:[sB],params:[tB],details:[zR]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iB extends ve{constructor(e){super(),Ee(this,e,null,lB,be,{})}}function fB(c){let e,t;return{c(){e=d("span"),t=i("Create a new Uniform Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Uniform Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function cB(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $B(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pB(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hB(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dB(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[cB]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[$B]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[uB]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[pB]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[mB]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[hB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function gB(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _B(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vB(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[gB]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[_B]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function EB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bB(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[EB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function wB(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeUniformBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[bB],return:[vB],params:[dB],details:[fB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class IB extends ve{constructor(e){super(),Ee(this,e,null,wB,be,{})}}function DB(c){let e,t;return{c(){e=d("span"),t=i("Create a new Storage Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Storage Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function CB(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AB(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BB(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LB(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[CB]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[SB]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[PB]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[AB]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[RB]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[BB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function kB(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VB(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[kB]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[TB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function OB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FB(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[OB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function yB(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeStorageBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[FB],return:[VB],params:[LB],details:[DB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class MB extends ve{constructor(e){super(),Ee(this,e,null,yB,be,{})}}function xB(c){let e,t;return{c(){e=d("span"),t=i("Create a new Uniform Texel Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Uniform Texel Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function NB(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HB(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WB(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QB(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[NB]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[UB]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[GB]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[HB]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[qB]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[WB]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function KB(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YB(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[KB]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[zB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function jB(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XB(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[jB]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function ZB(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeUniformTexelBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[XB],return:[YB],params:[QB],details:[xB]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class JB extends ve{constructor(e){super(),Ee(this,e,null,ZB,be,{})}}function eL(c){let e,t;return{c(){e=d("span"),t=i("Create a new Storage Texel Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Storage Texel Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function tL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sL(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oL(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lL(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[tL]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[rL]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[nL]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[sL]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[aL]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[oL]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function iL(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cL(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[iL]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[fL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function $L(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uL(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[$L]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function pL(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeStorageTexelBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[uL],return:[cL],params:[lL],details:[eL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class mL extends ve{constructor(e){super(),Ee(this,e,null,pL,be,{})}}function hL(c){let e,t;return{c(){e=d("span"),t=i("Create a new Index Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Index Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function dL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _L(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vL(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bL(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wL(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[dL]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[gL]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[_L]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[vL]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[EL]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[bL]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(" will be used in the multiple device "),I(Z.$$.fragment),K=i(" supported by the Device."),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae," will be used in the multiple device "),S(Z.$$.fragment,ae),K=f(ae," supported by the Device."),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function IL(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CL(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[IL]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[DL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function SL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PL(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[SL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function AL(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeIndexBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[PL],return:[CL],params:[wL],details:[hL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RL extends ve{constructor(e){super(),Ee(this,e,null,AL,be,{})}}function BL(c){let e,t;return{c(){e=d("span"),t=i(`Create a new Index Buffer which will be used as a destination for a
        transfer operation.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Create a new Index Buffer which will be used as a destination for a
        transfer operation.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function LL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VL(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FL(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yL(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[LL]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[kL]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[TL]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[VL]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[OL]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[FL]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function ML(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NL(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[ML]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[xL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function UL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GL(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[UL]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function HL(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeIndexTransferDestinationBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[GL],return:[NL],params:[yL],details:[BL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class qL extends ve{constructor(e){super(),Ee(this,e,null,HL,be,{})}}function WL(c){let e,t;return{c(){e=d("span"),t=i("Create a new Indirect Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Indirect Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function QL(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YL(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jL(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XL(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZL(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[QL]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[KL]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[zL]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[YL]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[jL]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[XL]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function JL(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ek(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[JL]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[ek]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function rk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nk(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[rk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function sk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeIndirectBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[nk],return:[tk],params:[ZL],details:[WL]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ak extends ve{constructor(e){super(),Ee(this,e,null,sk,be,{})}}function ok(c){let e,t;return{c(){e=d("span"),t=i("Create a new Staging Buffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Staging Buffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function lk(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ik(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ck(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $k(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uk(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pk(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[lk]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[ik]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[fk]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[ck]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.BUFFER,$$slots:{default:[$k]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.QUEUE,$$slots:{default:[uk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("size"),A=d("br"),T=i(`
            The size the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("sharingMode"),O=d("br"),H=i(`
            A member of the `),I(k.$$.fragment),N=i("-enumerant indicating how the "),I(Q.$$.fragment),X=i(` will be used in the multiple
            device `),I(Z.$$.fragment),K=i(` supported
            by the Device.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            The `),S(a.$$.fragment,te),u=f(te," the "),S(p.$$.fragment,te),m=f(te,` should
            be associated with.`),te.forEach(l),_=j(U),v=g(U,"LI",{});var se=E(v);P=g(se,"CODE",{});var ie=E(P);R=f(ie,"size"),ie.forEach(l),A=g(se,"BR",{}),T=f(se,`
            The size the `),S(F.$$.fragment,se),B=f(se," should have."),se.forEach(l),y=j(U),V=g(U,"LI",{});var ae=E(V);x=g(ae,"CODE",{});var J=E(x);M=f(J,"sharingMode"),J.forEach(l),O=g(ae,"BR",{}),H=f(ae,`
            A member of the `),S(k.$$.fragment,ae),N=f(ae,"-enumerant indicating how the "),S(Q.$$.fragment,ae),X=f(ae,` will be used in the multiple
            device `),S(Z.$$.fragment,ae),K=f(ae,` supported
            by the Device.`),ae.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),D(Q,V,null),o(V,X),D(Z,V,null),o(V,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),p.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),F.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),k.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),Q.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),Z.$set(J)},i(q){W||(b(a.$$.fragment,q),b(p.$$.fragment,q),b(F.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(p.$$.fragment,q),w(F.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(p),C(F),C(k),C(Q),C(Z)}}}function mk(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dk(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[mk]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[hk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function gk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _k(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[gk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function vk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Buffer> makeStagingBuffer(
    LogicalDevice* pLogicalDevice, 
    VkDeviceSize size,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[_k],return:[dk],params:[pk],details:[ok]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ek extends ve{constructor(e){super(),Ee(this,e,null,vk,be,{})}}function bk(c){let e;return{c(){e=i("Buffer Director")},l(t){e=f(t,"Buffer Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wk(c){let e;return{c(){e=i("Buffers")},l(t){e=f(t,"Buffers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ik(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/buffer_builder.hpp>"}}),m=new G({props:{sectionID:L.BUFFER_DIRECTOR,$$slots:{default:[bk]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.BUFFER,$$slots:{default:[wk]},$$scope:{ctx:c}}}),T=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
VkBufferCreateFlags flags = 0;
VkDeviceSize size = 0;
VkBufferUsageFlags usage = 0;
VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE;
std::vector<uint32_t> queueFamilyIndices = {};`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Buffer Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
It is recommended to use the `),I(m.$$.fragment),_=i(" for creating "),I(v.$$.fragment),P=i(` unless
the director doesn't offer the required configuration.`),R=d("br"),A=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var y=E(r);$=f(y,"Buffer Builder"),y.forEach(l),n=f(B,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(B,"BR",{}),a=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(B,"BR",{}),p=f(B,`
It is recommended to use the `),S(m.$$.fragment,B),_=f(B," for creating "),S(v.$$.fragment,B),P=f(B,` unless
the director doesn't offer the required configuration.`),R=g(B,"BR",{}),A=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(T.$$.fragment,B)},m(B,y){D(e,B,y),h(B,t,y),h(B,r,y),o(r,$),h(B,n,y),h(B,s,y),h(B,a,y),h(B,u,y),h(B,p,y),D(m,B,y),h(B,_,y),D(v,B,y),h(B,P,y),h(B,R,y),h(B,A,y),D(T,B,y),F=!0},p(B,[y]){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),m.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),v.$set(x)},i(B){F||(b(e.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),F=!0)},o(B){w(e.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),F=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(a),B&&l(u),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(P),B&&l(R),B&&l(A),C(T,B)}}}class Dk extends ve{constructor(e){super(),Ee(this,e,null,Ik,be,{})}}function Ck(c){let e,t;return{c(){e=d("span"),t=i("Create a new Buffer Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Buffer Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Sk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"BufferBuilder();"}}),r=new Ce({props:{$$slots:{details:[Ck]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Pk extends ve{constructor(e){super(),Ee(this,e,null,Sk,be,{})}}function Ak(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Rk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bk(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Ak]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[Rk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Lk(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tk(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Lk]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[kk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R,` should
            be associated with.`),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Vk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[Tk],details:[Bk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ok extends ve{constructor(e){super(),Ee(this,e,null,Vk,be,{})}}function Fk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yk(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[Fk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Mk(c){let e;return{c(){e=i("VkBufferCreateFlagBits")},l(t){e=f(t,"VkBufferCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xk(c){let e,t,r,$,n,s,a,u,p,m,_=Ye().Fillcan.version+"",v,P,R;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html",target:"_blank",$$slots:{default:[Mk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" which are all related to sparse buffers."),p=d("br"),m=i(`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),v=i(_),P=i("."),this.h()},l(A){e=g(A,"DIV",{slot:!0});var T=E(e);t=g(T,"LI",{});var F=E(t);r=g(F,"CODE",{});var B=E(r);$=f(B,"flags"),B.forEach(l),n=g(F,"BR",{}),s=f(F,`
            A bitmask of `),S(a.$$.fragment,F),u=f(F," which are all related to sparse buffers."),p=g(F,"BR",{}),m=f(F,`
            Sparse resources are not yet explicitly supported in Fillcan version
            `),v=f(F,_),P=f(F,"."),F.forEach(l),T.forEach(l),this.h()},h(){z(e,"slot","params")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),o(t,v),o(t,P),R=!0},p(A,T){const F={};T&1&&(F.$$scope={dirty:T,ctx:A}),a.$set(F)},i(A){R||(b(a.$$.fragment,A),R=!0)},o(A){w(a.$$.fragment,A),R=!1},d(A){A&&l(e),C(a)}}}function Nk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFlags(VkBufferCreateFlags flags);"}}),r=new Ce({props:{$$slots:{params:[xk],details:[yk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Uk extends ve{constructor(e){super(),Ee(this,e,null,Nk,be,{})}}function Gk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hk(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[Gk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the size for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the size for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function qk(c){let e,t,r,$,n,s,a,u,p,m,_,v;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("size"),n=d("br"),s=i(`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),a=d("code"),u=i("1024"),p=i(`
            * `),m=d("code"),_=i("1024"),v=i(")."),this.h()},l(P){e=g(P,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var A=E(t);r=g(A,"CODE",{});var T=E(r);$=f(T,"size"),T.forEach(l),n=g(A,"BR",{}),s=f(A,`
            The size of the Buffer, in bytes. (For example, 1MiB is
            `),a=g(A,"CODE",{});var F=E(a);u=f(F,"1024"),F.forEach(l),p=f(A,`
            * `),m=g(A,"CODE",{});var B=E(m);_=f(B,"1024"),B.forEach(l),v=f(A,")."),A.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(t,m),o(m,_),o(t,v)},p:ke,d(P){P&&l(e)}}}function Wk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setSize(VkDeviceSize size);"}}),r=new Ce({props:{$$slots:{params:[qk],details:[Hk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Qk extends ve{constructor(e){super(),Ee(this,e,null,Wk,be,{})}}function Kk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zk(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[Kk]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the usage for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the usage for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Yk(c){let e;return{c(){e=i("VkBufferUsageFlagBits")},l(t){e=f(t,"VkBufferUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jk(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xk(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html",target:"_blank",$$slots:{default:[Yk]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[jk]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("usage"),n=d("br"),s=i(`
            A bitmask of members of the `),I(a.$$.fragment),u=i("-enumerant telling Vulkan how the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"usage"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A bitmask of members of the `),S(a.$$.fragment,R),u=f(R,"-enumerant telling Vulkan how the "),S(p.$$.fragment,R),m=f(R," will be used."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function Zk(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setUsage(VkBufferUsageFlags usage);"}}),r=new Ce({props:{$$slots:{params:[Xk],details:[zk]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Jk extends ve{constructor(e){super(),Ee(this,e,null,Zk,be,{})}}function eT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tT(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[eT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sharing mode for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sharing mode for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sT(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lT(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fT(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cT(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[rT]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.BUFFER,$$slots:{default:[nT]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.QUEUE,$$slots:{default:[sT]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.BUFFER,$$slots:{default:[aT]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.BUFFER,$$slots:{default:[oT]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.QUEUE,$$slots:{default:[lT]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.BUFFER,$$slots:{default:[iT]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.QUEUE,$$slots:{default:[fT]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("sharingMode"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant indicating how the "),I(p.$$.fragment),m=i(" will be used in the multiple device "),I(_.$$.fragment),v=i(` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),I(P.$$.fragment),R=i(` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=d("code"),T=i("sharingMode"),F=i(`
            to `),B=d("code"),y=i("VK_SHARING_MODE_EXCLUSIVE"),V=i(` tells Vulkan that the
            `),I(x.$$.fragment),M=i(` will only
            be used for a single `),I(O.$$.fragment),H=i(`, while setting
            `),k=d("code"),N=i("sharingMode"),Q=i(`
            to
            `),X=d("code"),Z=i("VK_SHARING_MODE_CONCURRENT"),K=i(` specifies that the
            application will use the `),I(W.$$.fragment),q=i(" on multiple "),I(U.$$.fragment),te=i(` at once. Using
            `),ee=d("code"),se=i("VK_SHARING_MODE_CONCURRENT"),ie=i(` may result in lower
            performance on some systems, so unless necessary,
            `),ae=d("code"),J=i("sharingMode"),pe=i(`
            should be set to `),Se=d("code"),de=i("VK_SHARING_MODE_EXCLUSIVE"),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var ne=E(e);t=g(ne,"LI",{});var le=E(t);r=g(le,"CODE",{});var ge=E(r);$=f(ge,"sharingMode"),ge.forEach(l),n=g(le,"BR",{}),s=f(le,`
            A member of the `),S(a.$$.fragment,le),u=f(le,"-enumerant indicating how the "),S(p.$$.fragment,le),m=f(le," will be used in the multiple device "),S(_.$$.fragment,le),v=f(le,` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),S(P.$$.fragment,le),R=f(le,` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=g(le,"CODE",{});var we=E(A);T=f(we,"sharingMode"),we.forEach(l),F=f(le,`
            to `),B=g(le,"CODE",{});var Pe=E(B);y=f(Pe,"VK_SHARING_MODE_EXCLUSIVE"),Pe.forEach(l),V=f(le,` tells Vulkan that the
            `),S(x.$$.fragment,le),M=f(le,` will only
            be used for a single `),S(O.$$.fragment,le),H=f(le,`, while setting
            `),k=g(le,"CODE",{});var Be=E(k);N=f(Be,"sharingMode"),Be.forEach(l),Q=f(le,`
            to
            `),X=g(le,"CODE",{});var Ie=E(X);Z=f(Ie,"VK_SHARING_MODE_CONCURRENT"),Ie.forEach(l),K=f(le,` specifies that the
            application will use the `),S(W.$$.fragment,le),q=f(le," on multiple "),S(U.$$.fragment,le),te=f(le,` at once. Using
            `),ee=g(le,"CODE",{});var re=E(ee);se=f(re,"VK_SHARING_MODE_CONCURRENT"),re.forEach(l),ie=f(le,` may result in lower
            performance on some systems, so unless necessary,
            `),ae=g(le,"CODE",{});var he=E(ae);J=f(he,"sharingMode"),he.forEach(l),pe=f(le,`
            should be set to `),Se=g(le,"CODE",{});var Le=E(Se);de=f(Le,"VK_SHARING_MODE_EXCLUSIVE"),Le.forEach(l),me=f(le,"."),le.forEach(l),ne.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,ne){h(_e,e,ne),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),D(P,t,null),o(t,R),o(t,A),o(A,T),o(t,F),o(t,B),o(B,y),o(t,V),D(x,t,null),o(t,M),D(O,t,null),o(t,H),o(t,k),o(k,N),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,q),D(U,t,null),o(t,te),o(t,ee),o(ee,se),o(t,ie),o(t,ae),o(ae,J),o(t,pe),o(t,Se),o(Se,de),o(t,me),De=!0},p(_e,ne){const le={};ne&1&&(le.$$scope={dirty:ne,ctx:_e}),a.$set(le);const ge={};ne&1&&(ge.$$scope={dirty:ne,ctx:_e}),p.$set(ge);const we={};ne&1&&(we.$$scope={dirty:ne,ctx:_e}),_.$set(we);const Pe={};ne&1&&(Pe.$$scope={dirty:ne,ctx:_e}),P.$set(Pe);const Be={};ne&1&&(Be.$$scope={dirty:ne,ctx:_e}),x.$set(Be);const Ie={};ne&1&&(Ie.$$scope={dirty:ne,ctx:_e}),O.$set(Ie);const re={};ne&1&&(re.$$scope={dirty:ne,ctx:_e}),W.$set(re);const he={};ne&1&&(he.$$scope={dirty:ne,ctx:_e}),U.$set(he)},i(_e){De||(b(a.$$.fragment,_e),b(p.$$.fragment,_e),b(_.$$.fragment,_e),b(P.$$.fragment,_e),b(x.$$.fragment,_e),b(O.$$.fragment,_e),b(W.$$.fragment,_e),b(U.$$.fragment,_e),De=!0)},o(_e){w(a.$$.fragment,_e),w(p.$$.fragment,_e),w(_.$$.fragment,_e),w(P.$$.fragment,_e),w(x.$$.fragment,_e),w(O.$$.fragment,_e),w(W.$$.fragment,_e),w(U.$$.fragment,_e),De=!1},d(_e){_e&&l(e),C(a),C(p),C(_),C(P),C(x),C(O),C(W),C(U)}}}function $T(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setSharingMode(VkSharingMode sharingMode);"}}),r=new Ce({props:{$$slots:{params:[cT],details:[tT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uT extends ve{constructor(e){super(),Ee(this,e,null,$T,be,{})}}function pT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mT(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[pT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hT(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dT(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.QUEUE,$$slots:{default:[hT]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("queueFamilyIndices"),n=d("br"),s=i(`
            An array of `),I(a.$$.fragment),u=i(`
            family indices on which the buffer will be used.`),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"queueFamilyIndices"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            An array of `),S(a.$$.fragment,v),u=f(v,`
            family indices on which the buffer will be used.`),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function gT(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setQueueFamilyIndices(std::vector<uint32_t>& queueFamilyIndices);"}}),r=new Ce({props:{$$slots:{params:[dT],details:[mT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _T extends ve{constructor(e){super(),Ee(this,e,null,gT,be,{})}}function vT(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ET(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function bT(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[ET],default:[vT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wT extends ve{constructor(e){super(),Ee(this,e,null,bT,be,{})}}function IT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DT(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[IT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function CT(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ST(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PT(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[CT]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[ST]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function AT(c){let e;return{c(){e=i("Buffer")},l(t){e=f(t,"Buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RT(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.BUFFER,$$slots:{default:[AT]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function BT(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<Buffer> getResult();"}}),r=new Ce({props:{$$slots:{throws:[RT],return:[PT],details:[DT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LT extends ve{constructor(e){super(),Ee(this,e,null,BT,be,{})}}function kT(c){let e,t;return{c(){e=d("span"),t=i("Create a new Image Director."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Image Director."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function TT(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"ImageDirector();"}}),r=new Ce({props:{$$slots:{details:[kT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class VT extends ve{constructor(e){super(),Ee(this,e,null,TT,be,{})}}function OT(c){let e;return{c(){e=i("builder")},l(t){e=f(t,"builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UT(c){let e;return{c(){e=i("Image Builder")},l(t){e=f(t,"Image Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HT(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qT(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/image_director.hpp>"}}),u=new G({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[OT]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.IMAGE,$$slots:{default:[FT]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[yT]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.IMAGE,$$slots:{default:[MT]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.IMAGE,$$slots:{default:[xT]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.IMAGE,$$slots:{default:[NT]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.IMAGE_BUILDER,$$slots:{default:[UT]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.IMAGE,$$slots:{default:[GT]},$$scope:{ctx:c}}}),Z=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[HT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image Director"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The director defines the order in which to execute building steps, while the
`),I(u.$$.fragment),p=i(` provides the implementation
for those steps.`),m=d("br"),_=i(`
The Image Director defines methods for constructing frequently used `),I(v.$$.fragment),P=i(" configurations. For it's methods it takes in the "),I(R.$$.fragment),A=i(" with which the "),I(T.$$.fragment),F=i(` should
be associated with, the width and height the `),I(B.$$.fragment),y=i(", the sample count of the "),I(V.$$.fragment),x=i(` and it's sharing mode, which will default to
`),M=d("code"),O=i("VK_SHARING_MODE_EXCLUSIVE"),H=i(` most of the time. With this information
it will use the `),I(k.$$.fragment),N=i(" to construct the requested "),I(Q.$$.fragment),X=i(" which it will then return as a "),I(Z.$$.fragment),K=i(" which ownership will be moved to the application.")},l(q){S(e.$$.fragment,q),t=f(q,`
The `),r=g(q,"CODE",{});var U=E(r);$=f(U,"Image Director"),U.forEach(l),n=f(q,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(q,"BR",{}),a=f(q,`
The director defines the order in which to execute building steps, while the
`),S(u.$$.fragment,q),p=f(q,` provides the implementation
for those steps.`),m=g(q,"BR",{}),_=f(q,`
The Image Director defines methods for constructing frequently used `),S(v.$$.fragment,q),P=f(q," configurations. For it's methods it takes in the "),S(R.$$.fragment,q),A=f(q," with which the "),S(T.$$.fragment,q),F=f(q,` should
be associated with, the width and height the `),S(B.$$.fragment,q),y=f(q,", the sample count of the "),S(V.$$.fragment,q),x=f(q,` and it's sharing mode, which will default to
`),M=g(q,"CODE",{});var te=E(M);O=f(te,"VK_SHARING_MODE_EXCLUSIVE"),te.forEach(l),H=f(q,` most of the time. With this information
it will use the `),S(k.$$.fragment,q),N=f(q," to construct the requested "),S(Q.$$.fragment,q),X=f(q," which it will then return as a "),S(Z.$$.fragment,q),K=f(q," which ownership will be moved to the application.")},m(q,U){D(e,q,U),h(q,t,U),h(q,r,U),o(r,$),h(q,n,U),h(q,s,U),h(q,a,U),D(u,q,U),h(q,p,U),h(q,m,U),h(q,_,U),D(v,q,U),h(q,P,U),D(R,q,U),h(q,A,U),D(T,q,U),h(q,F,U),D(B,q,U),h(q,y,U),D(V,q,U),h(q,x,U),h(q,M,U),o(M,O),h(q,H,U),D(k,q,U),h(q,N,U),D(Q,q,U),h(q,X,U),D(Z,q,U),h(q,K,U),W=!0},p(q,[U]){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),u.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),v.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),R.$set(se);const ie={};U&1&&(ie.$$scope={dirty:U,ctx:q}),T.$set(ie);const ae={};U&1&&(ae.$$scope={dirty:U,ctx:q}),B.$set(ae);const J={};U&1&&(J.$$scope={dirty:U,ctx:q}),V.$set(J);const pe={};U&1&&(pe.$$scope={dirty:U,ctx:q}),k.$set(pe);const Se={};U&1&&(Se.$$scope={dirty:U,ctx:q}),Q.$set(Se);const de={};U&1&&(de.$$scope={dirty:U,ctx:q}),Z.$set(de)},i(q){W||(b(e.$$.fragment,q),b(u.$$.fragment,q),b(v.$$.fragment,q),b(R.$$.fragment,q),b(T.$$.fragment,q),b(B.$$.fragment,q),b(V.$$.fragment,q),b(k.$$.fragment,q),b(Q.$$.fragment,q),b(Z.$$.fragment,q),W=!0)},o(q){w(e.$$.fragment,q),w(u.$$.fragment,q),w(v.$$.fragment,q),w(R.$$.fragment,q),w(T.$$.fragment,q),w(B.$$.fragment,q),w(V.$$.fragment,q),w(k.$$.fragment,q),w(Q.$$.fragment,q),w(Z.$$.fragment,q),W=!1},d(q){C(e,q),q&&l(t),q&&l(r),q&&l(n),q&&l(s),q&&l(a),C(u,q),q&&l(p),q&&l(m),q&&l(_),C(v,q),q&&l(P),C(R,q),q&&l(A),C(T,q),q&&l(F),C(B,q),q&&l(y),C(V,q),q&&l(x),q&&l(M),q&&l(H),C(k,q),q&&l(N),C(Q,q),q&&l(X),C(Z,q),q&&l(K)}}}class WT extends ve{constructor(e){super(),Ee(this,e,null,qT,be,{})}}function QT(c){let e,t;return{c(){e=d("span"),t=i("Create a new 2D texture."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new 2D texture."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function KT(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZT(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JT(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eV(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tV(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[KT]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[zT]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[YT]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.IMAGE,$$slots:{default:[jT]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.IMAGE,$$slots:{default:[XT]},$$scope:{ctx:c}}}),Se=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[ZT]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.IMAGE,$$slots:{default:[JT]},$$scope:{ctx:c}}}),_e=new G({props:{sectionID:L.QUEUE,$$slots:{default:[eV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("width"),A=d("br"),T=i(`
            The width the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("height"),O=d("br"),H=i(`
            The height the `),I(k.$$.fragment),N=i(" should have."),Q=Y(),X=d("li"),Z=d("code"),K=i("samples"),W=d("br"),q=i(`
            The sample count the `),I(U.$$.fragment),te=i(" should have."),ee=Y(),se=d("li"),ie=d("code"),ae=i("sharingMode"),J=d("br"),pe=i(`
            A member of the `),I(Se.$$.fragment),de=i("-enumerant indicating how the "),I(me.$$.fragment),De=i(" will be used in the multiple device "),I(_e.$$.fragment),ne=i(" supported by the Device."),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Pe=E(t);r=g(Pe,"CODE",{});var Be=E(r);$=f(Be,"pLogicalDevice"),Be.forEach(l),n=g(Pe,"BR",{}),s=f(Pe,`
            The `),S(a.$$.fragment,Pe),u=f(Pe," the "),S(p.$$.fragment,Pe),m=f(Pe,` should
            be associated with.`),Pe.forEach(l),_=j(we),v=g(we,"LI",{});var Ie=E(v);P=g(Ie,"CODE",{});var re=E(P);R=f(re,"width"),re.forEach(l),A=g(Ie,"BR",{}),T=f(Ie,`
            The width the `),S(F.$$.fragment,Ie),B=f(Ie," should have."),Ie.forEach(l),y=j(we),V=g(we,"LI",{});var he=E(V);x=g(he,"CODE",{});var Le=E(x);M=f(Le,"height"),Le.forEach(l),O=g(he,"BR",{}),H=f(he,`
            The height the `),S(k.$$.fragment,he),N=f(he," should have."),he.forEach(l),Q=j(we),X=g(we,"LI",{});var Oe=E(X);Z=g(Oe,"CODE",{});var oe=E(Z);K=f(oe,"samples"),oe.forEach(l),W=g(Oe,"BR",{}),q=f(Oe,`
            The sample count the `),S(U.$$.fragment,Oe),te=f(Oe," should have."),Oe.forEach(l),ee=j(we),se=g(we,"LI",{});var ce=E(se);ie=g(ce,"CODE",{});var Ae=E(ie);ae=f(Ae,"sharingMode"),Ae.forEach(l),J=g(ce,"BR",{}),pe=f(ce,`
            A member of the `),S(Se.$$.fragment,ce),de=f(ce,"-enumerant indicating how the "),S(me.$$.fragment,ce),De=f(ce," will be used in the multiple device "),S(_e.$$.fragment,ce),ne=f(ce," supported by the Device."),ce.forEach(l),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),D(U,X,null),o(X,te),o(e,ee),o(e,se),o(se,ie),o(ie,ae),o(se,J),o(se,pe),D(Se,se,null),o(se,de),D(me,se,null),o(se,De),D(_e,se,null),o(se,ne),le=!0},p(ge,we){const Pe={};we&1&&(Pe.$$scope={dirty:we,ctx:ge}),a.$set(Pe);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),p.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),F.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),U.$set(he);const Le={};we&1&&(Le.$$scope={dirty:we,ctx:ge}),Se.$set(Le);const Oe={};we&1&&(Oe.$$scope={dirty:we,ctx:ge}),me.$set(Oe);const oe={};we&1&&(oe.$$scope={dirty:we,ctx:ge}),_e.$set(oe)},i(ge){le||(b(a.$$.fragment,ge),b(p.$$.fragment,ge),b(F.$$.fragment,ge),b(k.$$.fragment,ge),b(U.$$.fragment,ge),b(Se.$$.fragment,ge),b(me.$$.fragment,ge),b(_e.$$.fragment,ge),le=!0)},o(ge){w(a.$$.fragment,ge),w(p.$$.fragment,ge),w(F.$$.fragment,ge),w(k.$$.fragment,ge),w(U.$$.fragment,ge),w(Se.$$.fragment,ge),w(me.$$.fragment,ge),w(_e.$$.fragment,ge),le=!1},d(ge){ge&&l(e),C(a),C(p),C(F),C(k),C(U),C(Se),C(me),C(_e)}}}function rV(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sV(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[rV]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[nV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function aV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oV(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[aV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if a supported format could not be found.
        Also throws if the `),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if a supported format could not be found.
        Also throws if the `),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function lV(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Image> make2DTexture(
    LogicalDevice* pLogicalDevice, 
    unsigned int width, 
    unsigned int height, 
    VkSampleCountFlagBits samples,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[oV],return:[sV],params:[tV],details:[QT]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class iV extends ve{constructor(e){super(),Ee(this,e,null,lV,be,{})}}function fV(c){let e,t;return{c(){e=d("span"),t=i("Create a new Depth Image."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Depth Image."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function cV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $V(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hV(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gV(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _V(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[cV]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[$V]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[uV]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.IMAGE,$$slots:{default:[pV]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.IMAGE,$$slots:{default:[mV]},$$scope:{ctx:c}}}),Se=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[hV]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.IMAGE,$$slots:{default:[dV]},$$scope:{ctx:c}}}),_e=new G({props:{sectionID:L.QUEUE,$$slots:{default:[gV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),_=Y(),v=d("li"),P=d("code"),R=i("width"),A=d("br"),T=i(`
            The width the `),I(F.$$.fragment),B=i(" should have."),y=Y(),V=d("li"),x=d("code"),M=i("height"),O=d("br"),H=i(`
            The height the `),I(k.$$.fragment),N=i(" should have."),Q=Y(),X=d("li"),Z=d("code"),K=i("samples"),W=d("br"),q=i(`
            The sample count the `),I(U.$$.fragment),te=i(" should have."),ee=Y(),se=d("li"),ie=d("code"),ae=i("sharingMode"),J=d("br"),pe=i(`
            A member of the `),I(Se.$$.fragment),de=i("-enumerant indicating how the "),I(me.$$.fragment),De=i(" will be used in the multiple device "),I(_e.$$.fragment),ne=i(" supported by the Device."),this.h()},l(ge){e=g(ge,"DIV",{slot:!0});var we=E(e);t=g(we,"LI",{});var Pe=E(t);r=g(Pe,"CODE",{});var Be=E(r);$=f(Be,"pLogicalDevice"),Be.forEach(l),n=g(Pe,"BR",{}),s=f(Pe,`
            The `),S(a.$$.fragment,Pe),u=f(Pe," the "),S(p.$$.fragment,Pe),m=f(Pe,` should
            be associated with.`),Pe.forEach(l),_=j(we),v=g(we,"LI",{});var Ie=E(v);P=g(Ie,"CODE",{});var re=E(P);R=f(re,"width"),re.forEach(l),A=g(Ie,"BR",{}),T=f(Ie,`
            The width the `),S(F.$$.fragment,Ie),B=f(Ie," should have."),Ie.forEach(l),y=j(we),V=g(we,"LI",{});var he=E(V);x=g(he,"CODE",{});var Le=E(x);M=f(Le,"height"),Le.forEach(l),O=g(he,"BR",{}),H=f(he,`
            The height the `),S(k.$$.fragment,he),N=f(he," should have."),he.forEach(l),Q=j(we),X=g(we,"LI",{});var Oe=E(X);Z=g(Oe,"CODE",{});var oe=E(Z);K=f(oe,"samples"),oe.forEach(l),W=g(Oe,"BR",{}),q=f(Oe,`
            The sample count the `),S(U.$$.fragment,Oe),te=f(Oe," should have."),Oe.forEach(l),ee=j(we),se=g(we,"LI",{});var ce=E(se);ie=g(ce,"CODE",{});var Ae=E(ie);ae=f(Ae,"sharingMode"),Ae.forEach(l),J=g(ce,"BR",{}),pe=f(ce,`
            A member of the `),S(Se.$$.fragment,ce),de=f(ce,"-enumerant indicating how the "),S(me.$$.fragment,ce),De=f(ce," will be used in the multiple device "),S(_e.$$.fragment,ce),ne=f(ce," supported by the Device."),ce.forEach(l),we.forEach(l),this.h()},h(){z(e,"slot","params")},m(ge,we){h(ge,e,we),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),D(U,X,null),o(X,te),o(e,ee),o(e,se),o(se,ie),o(ie,ae),o(se,J),o(se,pe),D(Se,se,null),o(se,de),D(me,se,null),o(se,De),D(_e,se,null),o(se,ne),le=!0},p(ge,we){const Pe={};we&1&&(Pe.$$scope={dirty:we,ctx:ge}),a.$set(Pe);const Be={};we&1&&(Be.$$scope={dirty:we,ctx:ge}),p.$set(Be);const Ie={};we&1&&(Ie.$$scope={dirty:we,ctx:ge}),F.$set(Ie);const re={};we&1&&(re.$$scope={dirty:we,ctx:ge}),k.$set(re);const he={};we&1&&(he.$$scope={dirty:we,ctx:ge}),U.$set(he);const Le={};we&1&&(Le.$$scope={dirty:we,ctx:ge}),Se.$set(Le);const Oe={};we&1&&(Oe.$$scope={dirty:we,ctx:ge}),me.$set(Oe);const oe={};we&1&&(oe.$$scope={dirty:we,ctx:ge}),_e.$set(oe)},i(ge){le||(b(a.$$.fragment,ge),b(p.$$.fragment,ge),b(F.$$.fragment,ge),b(k.$$.fragment,ge),b(U.$$.fragment,ge),b(Se.$$.fragment,ge),b(me.$$.fragment,ge),b(_e.$$.fragment,ge),le=!0)},o(ge){w(a.$$.fragment,ge),w(p.$$.fragment,ge),w(F.$$.fragment,ge),w(k.$$.fragment,ge),w(U.$$.fragment,ge),w(Se.$$.fragment,ge),w(me.$$.fragment,ge),w(_e.$$.fragment,ge),le=!1},d(ge){ge&&l(e),C(a),C(p),C(F),C(k),C(U),C(Se),C(me),C(_e)}}}function vV(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bV(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[vV]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[EV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function wV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IV(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[wV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if a supported format could not be
        found. Also throws if the `),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p,` if a supported format could not be
        found. Also throws if the `),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function DV(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`std::unique_ptr<Image> makeDepthImage(
    LogicalDevice* pLogicalDevice, 
    unsigned int width, 
    unsigned int height, 
    VkSampleCountFlagBits samples,
    VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE
);`}}),r=new Ce({props:{$$slots:{throws:[IV],return:[bV],params:[_V],details:[fV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class CV extends ve{constructor(e){super(),Ee(this,e,null,DV,be,{})}}function SV(c){let e;return{c(){e=i("Image Director")},l(t){e=f(t,"Image Director")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PV(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AV(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/image_builder.hpp>"}}),m=new G({props:{sectionID:L.IMAGE_DIRECTOR,$$slots:{default:[SV]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.IMAGE,$$slots:{default:[PV]},$$scope:{ctx:c}}}),T=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
VkImageCreateFlags flags = 0;
VkImageType type = VK_IMAGE_TYPE_2D;
VkFormat format = VK_FORMAT_R8G8B8A8_SRGB;
VkExtent3D extent = {1, 1, 1};
unsigned int mipLevels = 1;
unsigned int arrayLayers = 1;
VkSampleCountFlagBits samples = VK_SAMPLE_COUNT_1_BIT;
VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT;
VkSharingMode sharingMode = VK_SHARING_MODE_EXCLUSIVE;
std::vector<uint32_t> queueFamilyIndices = {};
VkImageLayout initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Image Builder"),n=i(` class is part of the creational design pattern to
construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
It is recommended to use the `),I(m.$$.fragment),_=i(" for creating "),I(v.$$.fragment),P=i(` unless the
director doesn't offer the required configuration.`),R=d("br"),A=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var y=E(r);$=f(y,"Image Builder"),y.forEach(l),n=f(B,` class is part of the creational design pattern to
construct complex objects step by step.`),s=g(B,"BR",{}),a=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(B,"BR",{}),p=f(B,`
It is recommended to use the `),S(m.$$.fragment,B),_=f(B," for creating "),S(v.$$.fragment,B),P=f(B,` unless the
director doesn't offer the required configuration.`),R=g(B,"BR",{}),A=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(T.$$.fragment,B)},m(B,y){D(e,B,y),h(B,t,y),h(B,r,y),o(r,$),h(B,n,y),h(B,s,y),h(B,a,y),h(B,u,y),h(B,p,y),D(m,B,y),h(B,_,y),D(v,B,y),h(B,P,y),h(B,R,y),h(B,A,y),D(T,B,y),F=!0},p(B,[y]){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),m.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),v.$set(x)},i(B){F||(b(e.$$.fragment,B),b(m.$$.fragment,B),b(v.$$.fragment,B),b(T.$$.fragment,B),F=!0)},o(B){w(e.$$.fragment,B),w(m.$$.fragment,B),w(v.$$.fragment,B),w(T.$$.fragment,B),F=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(a),B&&l(u),B&&l(p),C(m,B),B&&l(_),C(v,B),B&&l(P),B&&l(R),B&&l(A),C(T,B)}}}class RV extends ve{constructor(e){super(),Ee(this,e,null,AV,be,{})}}function BV(c){let e,t;return{c(){e=d("span"),t=i("Create a new Image Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Image Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function LV(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"ImageBuilder();"}}),r=new Ce({props:{$$slots:{details:[BV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class kV extends ve{constructor(e){super(),Ee(this,e,null,LV,be,{})}}function TV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OV(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[TV]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[VV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function FV(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MV(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[FV]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[yV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R,` should
            be associated with.`),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function xV(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[MV],details:[OV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class NV extends ve{constructor(e){super(),Ee(this,e,null,xV,be,{})}}function UV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GV(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[UV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function HV(c){let e;return{c(){e=i("VkImageCreateFlagBits")},l(t){e=f(t,"VkImageCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qV(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html",target:"_blank",$$slots:{default:[HV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that describe some properties of the image."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"flags"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A bitmask of `),S(a.$$.fragment,v),u=f(v," that describe some properties of the image."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function WV(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFlags(VkImageCreateFlags flags);"}}),r=new Ce({props:{$$slots:{params:[qV],details:[GV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class QV extends ve{constructor(e){super(),Ee(this,e,null,WV,be,{})}}function KV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zV(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[KV]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Set the image type for
        the `),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,`Set the image type for
        the `),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function YV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZV(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JV(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[YV]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[jV]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.IMAGE,$$slots:{default:[XV]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.IMAGE,$$slots:{default:[ZV]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("type"),n=d("br"),s=i(`
            The type of `),I(a.$$.fragment),u=i(`
            being created. The `),I(p.$$.fragment),m=i(" type is essentially the dimensionality of the "),I(_.$$.fragment),v=i(" and can be "),P=d("code"),R=i("VK_IMAGE_TYPE_1D"),A=i(`,
            `),T=d("code"),F=i("VK_IMAGE_TYPE_2D"),B=i(`
            or `),y=d("code"),V=i("VK_IMAGE_TYPE_3D"),x=i(`
            for a 1D, 2D or 3D `),I(M.$$.fragment),O=i(" respectively."),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"type"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The type of `),S(a.$$.fragment,Q),u=f(Q,`
            being created. The `),S(p.$$.fragment,Q),m=f(Q," type is essentially the dimensionality of the "),S(_.$$.fragment,Q),v=f(Q," and can be "),P=g(Q,"CODE",{});var Z=E(P);R=f(Z,"VK_IMAGE_TYPE_1D"),Z.forEach(l),A=f(Q,`,
            `),T=g(Q,"CODE",{});var K=E(T);F=f(K,"VK_IMAGE_TYPE_2D"),K.forEach(l),B=f(Q,`
            or `),y=g(Q,"CODE",{});var W=E(y);V=f(W,"VK_IMAGE_TYPE_3D"),W.forEach(l),x=f(Q,`
            for a 1D, 2D or 3D `),S(M.$$.fragment,Q),O=f(Q," respectively."),Q.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),o(t,P),o(P,R),o(t,A),o(t,T),o(T,F),o(t,B),o(t,y),o(y,V),o(t,x),D(M,t,null),o(t,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),a.$set(Q);const X={};N&1&&(X.$$scope={dirty:N,ctx:k}),p.$set(X);const Z={};N&1&&(Z.$$scope={dirty:N,ctx:k}),_.$set(Z);const K={};N&1&&(K.$$scope={dirty:N,ctx:k}),M.$set(K)},i(k){H||(b(a.$$.fragment,k),b(p.$$.fragment,k),b(_.$$.fragment,k),b(M.$$.fragment,k),H=!0)},o(k){w(a.$$.fragment,k),w(p.$$.fragment,k),w(_.$$.fragment,k),w(M.$$.fragment,k),H=!1},d(k){k&&l(e),C(a),C(p),C(_),C(M)}}}function e0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setImageType(VkImageType type);"}}),r=new Ce({props:{$$slots:{params:[JV],details:[zV]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class t0 extends ve{constructor(e){super(),Ee(this,e,null,e0,be,{})}}function r0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[r0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the format for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the format for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function s0(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("format"),n=d("br"),s=i(`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"format"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            Describes how texel data is stored in memory and interpreted by Vulkan.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function a0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFormat(VkFormat format);"}}),r=new Ce({props:{$$slots:{params:[s0],details:[n0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class o0 extends ve{constructor(e){super(),Ee(this,e,null,a0,be,{})}}function l0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[l0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the extent for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the extent for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function f0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c0(c){let e;return{c(){e=i("VkExtent3D")},l(t){e=f(t,"VkExtent3D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u0(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p0(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m0(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[f0]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html",target:"_blank",$$slots:{default:[c0]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.IMAGE,$$slots:{default:[$0]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.IMAGE,$$slots:{default:[u0]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.IMAGE,$$slots:{default:[p0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("extent"),n=d("br"),s=i(`
            The size of the `),I(a.$$.fragment),u=i(" in texels. This should be an instance of the "),I(p.$$.fragment),m=i(`
            structure , which has three members: `),_=d("code"),v=i("width"),P=i(`,
            `),R=d("code"),A=i("height"),T=i(", and "),F=d("code"),B=i("depth"),y=i(`. These should be set
            respectively to the width, height and depth of the desired `),I(V.$$.fragment),x=i(". For 1D "),I(M.$$.fragment),O=i(`,
            the height should be set to `),H=d("code"),k=i("1"),N=i(`, and for 1D and 2D
            `),I(Q.$$.fragment),X=i(`, the depth
            should be set to `),Z=d("code"),K=i("1"),W=i("."),this.h()},l(U){e=g(U,"DIV",{slot:!0});var te=E(e);t=g(te,"LI",{});var ee=E(t);r=g(ee,"CODE",{});var se=E(r);$=f(se,"extent"),se.forEach(l),n=g(ee,"BR",{}),s=f(ee,`
            The size of the `),S(a.$$.fragment,ee),u=f(ee," in texels. This should be an instance of the "),S(p.$$.fragment,ee),m=f(ee,`
            structure , which has three members: `),_=g(ee,"CODE",{});var ie=E(_);v=f(ie,"width"),ie.forEach(l),P=f(ee,`,
            `),R=g(ee,"CODE",{});var ae=E(R);A=f(ae,"height"),ae.forEach(l),T=f(ee,", and "),F=g(ee,"CODE",{});var J=E(F);B=f(J,"depth"),J.forEach(l),y=f(ee,`. These should be set
            respectively to the width, height and depth of the desired `),S(V.$$.fragment,ee),x=f(ee,". For 1D "),S(M.$$.fragment,ee),O=f(ee,`,
            the height should be set to `),H=g(ee,"CODE",{});var pe=E(H);k=f(pe,"1"),pe.forEach(l),N=f(ee,`, and for 1D and 2D
            `),S(Q.$$.fragment,ee),X=f(ee,`, the depth
            should be set to `),Z=g(ee,"CODE",{});var Se=E(Z);K=f(Se,"1"),Se.forEach(l),W=f(ee,"."),ee.forEach(l),te.forEach(l),this.h()},h(){z(e,"slot","params")},m(U,te){h(U,e,te),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(_,v),o(t,P),o(t,R),o(R,A),o(t,T),o(t,F),o(F,B),o(t,y),D(V,t,null),o(t,x),D(M,t,null),o(t,O),o(t,H),o(H,k),o(t,N),D(Q,t,null),o(t,X),o(t,Z),o(Z,K),o(t,W),q=!0},p(U,te){const ee={};te&1&&(ee.$$scope={dirty:te,ctx:U}),a.$set(ee);const se={};te&1&&(se.$$scope={dirty:te,ctx:U}),p.$set(se);const ie={};te&1&&(ie.$$scope={dirty:te,ctx:U}),V.$set(ie);const ae={};te&1&&(ae.$$scope={dirty:te,ctx:U}),M.$set(ae);const J={};te&1&&(J.$$scope={dirty:te,ctx:U}),Q.$set(J)},i(U){q||(b(a.$$.fragment,U),b(p.$$.fragment,U),b(V.$$.fragment,U),b(M.$$.fragment,U),b(Q.$$.fragment,U),q=!0)},o(U){w(a.$$.fragment,U),w(p.$$.fragment,U),w(V.$$.fragment,U),w(M.$$.fragment,U),w(Q.$$.fragment,U),q=!1},d(U){U&&l(e),C(a),C(p),C(V),C(M),C(Q)}}}function h0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setExtent(VkExtent3D extent);"}}),r=new Ce({props:{$$slots:{params:[m0],details:[i0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class d0 extends ve{constructor(e){super(),Ee(this,e,null,h0,be,{})}}function g0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[g0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the number of mipmap levels for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the number of mipmap levels for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function v0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E0(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[v0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipLevels"),n=d("br"),s=i(`
            The number of mipmap levels to create in the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"mipLevels"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The number of mipmap levels to create in the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function b0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setMipLevels(unsigned int mipLevels);"}}),r=new Ce({props:{$$slots:{params:[E0],details:[_0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class w0 extends ve{constructor(e){super(),Ee(this,e,null,b0,be,{})}}function I0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[I0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the number of array layers for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the number of array layers for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function C0(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S0(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P0(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[C0]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[S0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("arrayLayers"),n=d("br"),s=i(`
            The amount of `),I(a.$$.fragment),u=i(" each mipmap level of the "),I(p.$$.fragment),m=i(" has."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"arrayLayers"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The amount of `),S(a.$$.fragment,R),u=f(R," each mipmap level of the "),S(p.$$.fragment,R),m=f(R," has."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function A0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setArrayLayers(unsigned int arrayLayers);"}}),r=new Ce({props:{$$slots:{params:[P0],details:[D0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class R0 extends ve{constructor(e){super(),Ee(this,e,null,A0,be,{})}}function B0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[B0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sample count for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sample count for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function k0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T0(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V0(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[k0]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html",target:"_blank",$$slots:{default:[T0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("samples"),n=d("br"),s=i(`
            The number of samples in the `),I(a.$$.fragment),u=i(". It must be a member of the "),I(p.$$.fragment),m=i("-enumerant."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"samples"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            The number of samples in the `),S(a.$$.fragment,R),u=f(R,". It must be a member of the "),S(p.$$.fragment,R),m=f(R,"-enumerant."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function O0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setSamples(VkSampleCountFlagBits samples);"}}),r=new Ce({props:{$$slots:{params:[V0],details:[L0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class F0 extends ve{constructor(e){super(),Ee(this,e,null,O0,be,{})}}function y0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[y0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sample count for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sample count for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function x0(c){let e;return{c(){e=i("VkImageTiling")},l(t){e=f(t,"VkImageTiling")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N0(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function U0(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G0(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H0(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html",target:"_blank",$$slots:{default:[x0]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[N0]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[U0]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.IMAGE,$$slots:{default:[G0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("tiling"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant, which contains only "),p=d("code"),m=i("VK_IMAGE_TILING_LINEAR"),_=i(`
            or
            `),v=d("code"),P=i("VK_IMAGE_TILING_OPTIMAL"),R=i(". Linear tiling means that "),I(A.$$.fragment),T=i(`
            data is laid out from left to right, top to bottom, so that if the underlying
            memory is mapped and it is written with the CPU, it would form a linear
            `),I(F.$$.fragment),B=i(`. Meanwhile,
            optimal tiling is an opaque display used by Vulkan to store data in
            memory to improve the efficiency of the memory subsystem on the
            device. This is generally what should be chosen unless the `),I(y.$$.fragment),V=i(` needs to be CPU mapped and manipulated. Optimal tiling is likely to
            outperform linear tiling in most operations, and linear tiling may not
            be supported at all for some operations or formats, depending on the
            Vulkan implementation.`),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"tiling"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            A member of the `),S(a.$$.fragment,H),u=f(H,"-enumerant, which contains only "),p=g(H,"CODE",{});var N=E(p);m=f(N,"VK_IMAGE_TILING_LINEAR"),N.forEach(l),_=f(H,`
            or
            `),v=g(H,"CODE",{});var Q=E(v);P=f(Q,"VK_IMAGE_TILING_OPTIMAL"),Q.forEach(l),R=f(H,". Linear tiling means that "),S(A.$$.fragment,H),T=f(H,`
            data is laid out from left to right, top to bottom, so that if the underlying
            memory is mapped and it is written with the CPU, it would form a linear
            `),S(F.$$.fragment,H),B=f(H,`. Meanwhile,
            optimal tiling is an opaque display used by Vulkan to store data in
            memory to improve the efficiency of the memory subsystem on the
            device. This is generally what should be chosen unless the `),S(y.$$.fragment,H),V=f(H,` needs to be CPU mapped and manipulated. Optimal tiling is likely to
            outperform linear tiling in most operations, and linear tiling may not
            be supported at all for some operations or formats, depending on the
            Vulkan implementation.`),H.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(p,m),o(t,_),o(t,v),o(v,P),o(t,R),D(A,t,null),o(t,T),D(F,t,null),o(t,B),D(y,t,null),o(t,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),A.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(A.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(A.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(A),C(F),C(y)}}}function q0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setImageTiling(VkImageTiling tiling);"}}),r=new Ce({props:{$$slots:{params:[H0],details:[M0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class W0 extends ve{constructor(e){super(),Ee(this,e,null,q0,be,{})}}function Q0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K0(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Q0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the usage for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the usage for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function z0(c){let e;return{c(){e=i("VkImageUsageFlagBits")},l(t){e=f(t,"VkImageUsageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j0(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html",target:"_blank",$$slots:{default:[z0]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Y0]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("usage"),n=d("br"),s=i(`
            A bitmask of members of the `),I(a.$$.fragment),u=i("-enumerant telling Vulkan how the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"usage"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A bitmask of members of the `),S(a.$$.fragment,R),u=f(R,"-enumerant telling Vulkan how the "),S(p.$$.fragment,R),m=f(R," will be used."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function X0(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setImageTiling(VkImageTiling tiling);"}}),r=new Ce({props:{$$slots:{params:[j0],details:[K0]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Z0 extends ve{constructor(e){super(),Ee(this,e,null,X0,be,{})}}function J0(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eO(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[J0]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the sharing mode for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the sharing mode for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function tO(c){let e;return{c(){e=i("VkSharingMode")},l(t){e=f(t,"VkSharingMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nO(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oO(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iO(c){let e;return{c(){e=i("Queues")},l(t){e=f(t,"Queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fO(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html",target:"_blank",$$slots:{default:[tO]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[rO]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.QUEUE,$$slots:{default:[nO]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.IMAGE,$$slots:{default:[sO]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.IMAGE,$$slots:{default:[aO]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.QUEUE,$$slots:{default:[oO]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.IMAGE,$$slots:{default:[lO]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.QUEUE,$$slots:{default:[iO]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("sharingMode"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant indicating how the "),I(p.$$.fragment),m=i(" will be used in the multiple device "),I(_.$$.fragment),v=i(` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),I(P.$$.fragment),R=i(` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=d("code"),T=i("sharingMode"),F=i(`
            to `),B=d("code"),y=i("VK_SHARING_MODE_EXCLUSIVE"),V=i(` tells Vulkan that the
            `),I(x.$$.fragment),M=i(` will only be
            used for a single `),I(O.$$.fragment),H=i(`, while setting
            `),k=d("code"),N=i("sharingMode"),Q=i(`
            to
            `),X=d("code"),Z=i("VK_SHARING_MODE_CONCURRENT"),K=i(` specifies that the
            application will use the `),I(W.$$.fragment),q=i(" on multiple "),I(U.$$.fragment),te=i(` at once. Using
            `),ee=d("code"),se=i("VK_SHARING_MODE_CONCURRENT"),ie=i(` may result in lower
            performance on some systems, so unless necessary,
            `),ae=d("code"),J=i("sharingMode"),pe=i(`
            should be set to `),Se=d("code"),de=i("VK_SHARING_MODE_EXCLUSIVE"),me=i("."),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var ne=E(e);t=g(ne,"LI",{});var le=E(t);r=g(le,"CODE",{});var ge=E(r);$=f(ge,"sharingMode"),ge.forEach(l),n=g(le,"BR",{}),s=f(le,`
            A member of the `),S(a.$$.fragment,le),u=f(le,"-enumerant indicating how the "),S(p.$$.fragment,le),m=f(le," will be used in the multiple device "),S(_.$$.fragment,le),v=f(le,` supported by the Device. Because Vulkan can run many commands in parallel,
            some implementations need to know whether the `),S(P.$$.fragment,le),R=f(le,` will essentially be used by a single command at a time or possibly
            by several. Setting
            `),A=g(le,"CODE",{});var we=E(A);T=f(we,"sharingMode"),we.forEach(l),F=f(le,`
            to `),B=g(le,"CODE",{});var Pe=E(B);y=f(Pe,"VK_SHARING_MODE_EXCLUSIVE"),Pe.forEach(l),V=f(le,` tells Vulkan that the
            `),S(x.$$.fragment,le),M=f(le,` will only be
            used for a single `),S(O.$$.fragment,le),H=f(le,`, while setting
            `),k=g(le,"CODE",{});var Be=E(k);N=f(Be,"sharingMode"),Be.forEach(l),Q=f(le,`
            to
            `),X=g(le,"CODE",{});var Ie=E(X);Z=f(Ie,"VK_SHARING_MODE_CONCURRENT"),Ie.forEach(l),K=f(le,` specifies that the
            application will use the `),S(W.$$.fragment,le),q=f(le," on multiple "),S(U.$$.fragment,le),te=f(le,` at once. Using
            `),ee=g(le,"CODE",{});var re=E(ee);se=f(re,"VK_SHARING_MODE_CONCURRENT"),re.forEach(l),ie=f(le,` may result in lower
            performance on some systems, so unless necessary,
            `),ae=g(le,"CODE",{});var he=E(ae);J=f(he,"sharingMode"),he.forEach(l),pe=f(le,`
            should be set to `),Se=g(le,"CODE",{});var Le=E(Se);de=f(Le,"VK_SHARING_MODE_EXCLUSIVE"),Le.forEach(l),me=f(le,"."),le.forEach(l),ne.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,ne){h(_e,e,ne),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),D(P,t,null),o(t,R),o(t,A),o(A,T),o(t,F),o(t,B),o(B,y),o(t,V),D(x,t,null),o(t,M),D(O,t,null),o(t,H),o(t,k),o(k,N),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,q),D(U,t,null),o(t,te),o(t,ee),o(ee,se),o(t,ie),o(t,ae),o(ae,J),o(t,pe),o(t,Se),o(Se,de),o(t,me),De=!0},p(_e,ne){const le={};ne&1&&(le.$$scope={dirty:ne,ctx:_e}),a.$set(le);const ge={};ne&1&&(ge.$$scope={dirty:ne,ctx:_e}),p.$set(ge);const we={};ne&1&&(we.$$scope={dirty:ne,ctx:_e}),_.$set(we);const Pe={};ne&1&&(Pe.$$scope={dirty:ne,ctx:_e}),P.$set(Pe);const Be={};ne&1&&(Be.$$scope={dirty:ne,ctx:_e}),x.$set(Be);const Ie={};ne&1&&(Ie.$$scope={dirty:ne,ctx:_e}),O.$set(Ie);const re={};ne&1&&(re.$$scope={dirty:ne,ctx:_e}),W.$set(re);const he={};ne&1&&(he.$$scope={dirty:ne,ctx:_e}),U.$set(he)},i(_e){De||(b(a.$$.fragment,_e),b(p.$$.fragment,_e),b(_.$$.fragment,_e),b(P.$$.fragment,_e),b(x.$$.fragment,_e),b(O.$$.fragment,_e),b(W.$$.fragment,_e),b(U.$$.fragment,_e),De=!0)},o(_e){w(a.$$.fragment,_e),w(p.$$.fragment,_e),w(_.$$.fragment,_e),w(P.$$.fragment,_e),w(x.$$.fragment,_e),w(O.$$.fragment,_e),w(W.$$.fragment,_e),w(U.$$.fragment,_e),De=!1},d(_e){_e&&l(e),C(a),C(p),C(_),C(P),C(x),C(O),C(W),C(U)}}}function cO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setSharingMode(VkSharingMode sharingMode);"}}),r=new Ce({props:{$$slots:{params:[fO],details:[eO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $O extends ve{constructor(e){super(),Ee(this,e,null,cO,be,{})}}function uO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pO(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[uO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mO(c){let e;return{c(){e=i("Queue")},l(t){e=f(t,"Queue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hO(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dO(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.QUEUE,$$slots:{default:[mO]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[hO]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("queueFamilyIndices"),n=d("br"),s=i(`
            A pointer to an array of `),I(a.$$.fragment),u=i(" family indices on which the "),I(p.$$.fragment),m=i(" will be used."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"queueFamilyIndices"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to an array of `),S(a.$$.fragment,R),u=f(R," family indices on which the "),S(p.$$.fragment,R),m=f(R," will be used."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function gO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setQueueFamilyIndices(std::vector<uint32_t>& queueFamilyIndices);"}}),r=new Ce({props:{$$slots:{params:[dO],details:[pO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _O extends ve{constructor(e){super(),Ee(this,e,null,gO,be,{})}}function vO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EO(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[vO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the queue family indices for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the queue family indices for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bO(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wO(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IO(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DO(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CO(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SO(c){let e;return{c(){e=i("Images")},l(t){e=f(t,"Images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PO(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[bO]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.IMAGE,$$slots:{default:[wO]},$$scope:{ctx:c}}}),_=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[IO]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[DO]},$$scope:{ctx:c}}}),N=new G({props:{sectionID:L.IMAGE,$$slots:{default:[CO]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.IMAGE,$$slots:{default:[SO]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("initialLayout"),n=d("br"),s=Y(),I(a.$$.fragment),u=i(` have a layout,
            which partially indicates how they will be used at a given time. This
            field determines the layout in which the `),I(p.$$.fragment),m=i(" is created. The available layouts are the members of the "),I(_.$$.fragment),v=i("-enumerant."),P=d("br"),R=Y(),I(A.$$.fragment),T=i(` should initially
            be created in the format
            `),F=d("code"),B=i("VK_IMAGE_LAYOUT_UNDEFINED"),y=i(`
            or `),V=d("code"),x=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),M=i(`.
            `),O=d("code"),H=i("VK_IMAGE_LAYOUT_PREINITIALIZED"),k=i(`
            should only be used if there is data in memory that is bound immediately
            to the `),I(N.$$.fragment),Q=i(` source.
            `),X=d("code"),Z=i("VK_IMAGE_LAYOUT_UNDEFINED"),K=i(`
            should be used when moving the resource to another layout before use.
            `),I(W.$$.fragment),q=i(` can be moved
            out of the
            `),U=d("code"),te=i("VK_IMAGE_LAYOUT_UNDEFINED"),ee=i(` layout at any time with little
            or no time cost.`),this.h()},l(ie){e=g(ie,"DIV",{slot:!0});var ae=E(e);t=g(ae,"LI",{});var J=E(t);r=g(J,"CODE",{});var pe=E(r);$=f(pe,"initialLayout"),pe.forEach(l),n=g(J,"BR",{}),s=j(J),S(a.$$.fragment,J),u=f(J,` have a layout,
            which partially indicates how they will be used at a given time. This
            field determines the layout in which the `),S(p.$$.fragment,J),m=f(J," is created. The available layouts are the members of the "),S(_.$$.fragment,J),v=f(J,"-enumerant."),P=g(J,"BR",{}),R=j(J),S(A.$$.fragment,J),T=f(J,` should initially
            be created in the format
            `),F=g(J,"CODE",{});var Se=E(F);B=f(Se,"VK_IMAGE_LAYOUT_UNDEFINED"),Se.forEach(l),y=f(J,`
            or `),V=g(J,"CODE",{});var de=E(V);x=f(de,"VK_IMAGE_LAYOUT_PREINITIALIZED"),de.forEach(l),M=f(J,`.
            `),O=g(J,"CODE",{});var me=E(O);H=f(me,"VK_IMAGE_LAYOUT_PREINITIALIZED"),me.forEach(l),k=f(J,`
            should only be used if there is data in memory that is bound immediately
            to the `),S(N.$$.fragment,J),Q=f(J,` source.
            `),X=g(J,"CODE",{});var De=E(X);Z=f(De,"VK_IMAGE_LAYOUT_UNDEFINED"),De.forEach(l),K=f(J,`
            should be used when moving the resource to another layout before use.
            `),S(W.$$.fragment,J),q=f(J,` can be moved
            out of the
            `),U=g(J,"CODE",{});var _e=E(U);te=f(_e,"VK_IMAGE_LAYOUT_UNDEFINED"),_e.forEach(l),ee=f(J,` layout at any time with little
            or no time cost.`),J.forEach(l),ae.forEach(l),this.h()},h(){z(e,"slot","params")},m(ie,ae){h(ie,e,ae),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),D(_,t,null),o(t,v),o(t,P),o(t,R),D(A,t,null),o(t,T),o(t,F),o(F,B),o(t,y),o(t,V),o(V,x),o(t,M),o(t,O),o(O,H),o(t,k),D(N,t,null),o(t,Q),o(t,X),o(X,Z),o(t,K),D(W,t,null),o(t,q),o(t,U),o(U,te),o(t,ee),se=!0},p(ie,ae){const J={};ae&1&&(J.$$scope={dirty:ae,ctx:ie}),a.$set(J);const pe={};ae&1&&(pe.$$scope={dirty:ae,ctx:ie}),p.$set(pe);const Se={};ae&1&&(Se.$$scope={dirty:ae,ctx:ie}),_.$set(Se);const de={};ae&1&&(de.$$scope={dirty:ae,ctx:ie}),A.$set(de);const me={};ae&1&&(me.$$scope={dirty:ae,ctx:ie}),N.$set(me);const De={};ae&1&&(De.$$scope={dirty:ae,ctx:ie}),W.$set(De)},i(ie){se||(b(a.$$.fragment,ie),b(p.$$.fragment,ie),b(_.$$.fragment,ie),b(A.$$.fragment,ie),b(N.$$.fragment,ie),b(W.$$.fragment,ie),se=!0)},o(ie){w(a.$$.fragment,ie),w(p.$$.fragment,ie),w(_.$$.fragment,ie),w(A.$$.fragment,ie),w(N.$$.fragment,ie),w(W.$$.fragment,ie),se=!1},d(ie){ie&&l(e),C(a),C(p),C(_),C(A),C(N),C(W)}}}function AO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setInitialLayout(VkImageLayout initialLayout);"}}),r=new Ce({props:{$$slots:{params:[PO],details:[EO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RO extends ve{constructor(e){super(),Ee(this,e,null,AO,be,{})}}function BO(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LO(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function kO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[LO],default:[BO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TO extends ve{constructor(e){super(),Ee(this,e,null,kO,be,{})}}function VO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OO(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[VO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function FO(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MO(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[FO]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[yO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`, it's
        ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`, it's
        ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function xO(c){let e;return{c(){e=i("Image")},l(t){e=f(t,"Image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NO(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[xO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function UO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<Image> getResult();"}}),r=new Ce({props:{$$slots:{throws:[NO],return:[MO],details:[OO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GO extends ve{constructor(e){super(),Ee(this,e,null,UO,be,{})}}function HO(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qO(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WO(c){let e,t,r,$,n,s,a,u,p,m,_,v;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/fence.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[HO]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[qO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Fence"),n=i(" class takes in a pointer to a "),I(s.$$.fragment),a=i(" and a bitmask of optional flags and uses this information to construct a new "),I(u.$$.fragment),p=i(` which it will wrap around to offer functionality such as: waiting for the fence
to be signaled and resetting the fence.`),m=d("br"),_=i(`
A fence is a kind of synchronization primitive. Fences are used when the host has
to wait for the device to complete the execution of (large) pieces of work represented
by a submission, usually with the help of the operating system.`)},l(P){S(e.$$.fragment,P),t=f(P,`
The `),r=g(P,"CODE",{});var R=E(r);$=f(R,"Fence"),R.forEach(l),n=f(P," class takes in a pointer to a "),S(s.$$.fragment,P),a=f(P," and a bitmask of optional flags and uses this information to construct a new "),S(u.$$.fragment,P),p=f(P,` which it will wrap around to offer functionality such as: waiting for the fence
to be signaled and resetting the fence.`),m=g(P,"BR",{}),_=f(P,`
A fence is a kind of synchronization primitive. Fences are used when the host has
to wait for the device to complete the execution of (large) pieces of work represented
by a submission, usually with the help of the operating system.`)},m(P,R){D(e,P,R),h(P,t,R),h(P,r,R),o(r,$),h(P,n,R),D(s,P,R),h(P,a,R),D(u,P,R),h(P,p,R),h(P,m,R),h(P,_,R),v=!0},p(P,[R]){const A={};R&1&&(A.$$scope={dirty:R,ctx:P}),s.$set(A);const T={};R&1&&(T.$$scope={dirty:R,ctx:P}),u.$set(T)},i(P){v||(b(e.$$.fragment,P),b(s.$$.fragment,P),b(u.$$.fragment,P),v=!0)},o(P){w(e.$$.fragment,P),w(s.$$.fragment,P),w(u.$$.fragment,P),v=!1},d(P){C(e,P),P&&l(t),P&&l(r),P&&l(n),C(s,P),P&&l(a),C(u,P),P&&l(p),P&&l(m),P&&l(_)}}}class QO extends ve{constructor(e){super(),Ee(this,e,null,WO,be,{})}}function KO(c){let e,t;return{c(){e=d("span"),t=i("Create a new Fence."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Fence."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function zO(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YO(c){let e;return{c(){e=i("VkFenceCreateFlagBits")},l(t){e=f(t,"VkFenceCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jO(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[zO]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html",target:"_blank",$$slots:{default:[YO]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Fence should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" which specify the initial state and behaviour of the fence."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"pLogicalDevice"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            A pointer to the `),S(a.$$.fragment,V),u=f(V," the Fence should be associated with."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"flags"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            A bitmask of `),S(A.$$.fragment,M),T=f(M," which specify the initial state and behaviour of the fence."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function XO(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZO(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[XO]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function JO(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Fence(LogicalDevice* pLogicalDevice, VkFenceCreateFlags flags = 0);"}}),r=new Ce({props:{$$slots:{throws:[ZO],params:[jO],details:[KO]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class e3 extends ve{constructor(e){super(),Ee(this,e,null,JO,be,{})}}function t3(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r3(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[t3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function n3(c){let e;return{c(){e=i("Vulkan Fence")},l(t){e=f(t,"Vulkan Fence")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s3(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html",target:"_blank",$$slots:{default:[n3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function a3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkFence getFenceHandle() const;"}}),r=new Ce({props:{$$slots:{return:[s3],details:[r3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class o3 extends ve{constructor(e){super(),Ee(this,e,null,a3,be,{})}}function l3(c){let e,t;return{c(){e=d("span"),t=i("Wait for the Fence to be signaled."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Wait for the Fence to be signaled."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function i3(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("timeout"),n=d("br"),s=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"timeout"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The timeout period in units of nanoseconds to wait before returning.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function f3(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the Fence was succesfully waited for.
        `),n=d("code"),s=i("false"),a=i(" if the timeout expired."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the Fence was succesfully waited for.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the timeout expired."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function c3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool waitFor(uint64_t timeout = UINT64_MAX);"}}),r=new Ce({props:{$$slots:{return:[f3],params:[i3],details:[l3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class $3 extends ve{constructor(e){super(),Ee(this,e,null,c3,be,{})}}function u3(c){let e,t;return{c(){e=d("span"),t=i("Wait for all given Fences to be signaled."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Wait for all given Fences to be signaled."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function p3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m3(c){let e;return{c(){e=i("Fences")},l(t){e=f(t,"Fences")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h3(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[p3]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.FENCE,$$slots:{default:[m3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" which owns the given Fences."),p=Y(),m=d("li"),_=d("code"),v=i("pFences"),P=d("br"),R=i(`
            A list of pointers to the `),I(A.$$.fragment),T=i(" to wait for."),F=Y(),B=d("li"),y=d("code"),V=i("timeout"),x=d("br"),M=i(`
            The timeout period in units of nanoseconds to wait before returning.`),this.h()},l(H){e=g(H,"DIV",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"pLogicalDevice"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            The `),S(a.$$.fragment,N),u=f(N," which owns the given Fences."),N.forEach(l),p=j(k),m=g(k,"LI",{});var X=E(m);_=g(X,"CODE",{});var Z=E(_);v=f(Z,"pFences"),Z.forEach(l),P=g(X,"BR",{}),R=f(X,`
            A list of pointers to the `),S(A.$$.fragment,X),T=f(X," to wait for."),X.forEach(l),F=j(k),B=g(k,"LI",{});var K=E(B);y=g(K,"CODE",{});var W=E(y);V=f(W,"timeout"),W.forEach(l),x=g(K,"BR",{}),M=f(K,`
            The timeout period in units of nanoseconds to wait before returning.`),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(H,k){h(H,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),O=!0},p(H,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:H}),a.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:H}),A.$set(Q)},i(H){O||(b(a.$$.fragment,H),b(A.$$.fragment,H),O=!0)},o(H){w(a.$$.fragment,H),w(A.$$.fragment,H),O=!1},d(H){H&&l(e),C(a),C(A)}}}function d3(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fences were succesfully waited for.
        `),n=d("code"),s=i("false"),a=i(" if the timeout expired."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fences were succesfully waited for.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the timeout expired."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function g3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"static bool s_waitForAll(LogicalDevice* pLogicalDevice, std::vector<Fence*> pFences, uint64_t timeout = UINT64_MAX);"}}),r=new Ce({props:{$$slots:{return:[d3],params:[h3],details:[u3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _3 extends ve{constructor(e){super(),Ee(this,e,null,g3,be,{})}}function v3(c){let e,t;return{c(){e=d("span"),t=i("Reset all given Fences."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset all given Fences."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function E3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b3(c){let e;return{c(){e=i("Fences")},l(t){e=f(t,"Fences")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w3(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[E3]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.FENCE,$$slots:{default:[b3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" which owns the given Fences."),p=Y(),m=d("li"),_=d("code"),v=i("pFences"),P=d("br"),R=i(`
            A list of pointers to the `),I(A.$$.fragment),T=i(" to reset."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"pLogicalDevice"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The `),S(a.$$.fragment,V),u=f(V," which owns the given Fences."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"pFences"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            A list of pointers to the `),S(A.$$.fragment,M),T=f(M," to reset."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function I3(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fences were succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if not all Fences could be reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fences were succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all Fences could be reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function D3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"static bool s_resetAll(LogicalDevice* pLogicalDevice, std::vector<Fence*> pFences);"}}),r=new Ce({props:{$$slots:{return:[I3],params:[w3],details:[v3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class C3 extends ve{constructor(e){super(),Ee(this,e,null,D3,be,{})}}function S3(c){let e,t;return{c(){e=d("span"),t=i("Reset the Fence to an unsignaled state."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Fence to an unsignaled state."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function P3(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the Fence was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the Fence failed to reset."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the Fence was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the Fence failed to reset."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function A3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool reset();"}}),r=new Ce({props:{$$slots:{return:[P3],details:[S3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class R3 extends ve{constructor(e){super(),Ee(this,e,null,A3,be,{})}}function B3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L3(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k3(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T3(c){let e;return{c(){e=i("queues")},l(t){e=f(t,"queues")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V3(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return e=new $e({props:{language:ue,code:"#include <fillcan/memory/semaphore.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[B3]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[L3]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.QUEUE,$$slots:{default:[k3]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.QUEUE,$$slots:{default:[T3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Semaphore"),n=i(" class takes in a pointer to a "),I(s.$$.fragment),a=i(" uses this information to construct a new "),I(u.$$.fragment),p=d("br"),m=i(`
A semaphore is a type of synchronization primitive that allows work performed by
different `),I(_.$$.fragment),v=i(` to be properly
planned and coordinated. Semaphores are used to manage the ownership of resources
in different `),I(P.$$.fragment),R=i(` on a single
device.`)},l(T){S(e.$$.fragment,T),t=f(T,`
The `),r=g(T,"CODE",{});var F=E(r);$=f(F,"Semaphore"),F.forEach(l),n=f(T," class takes in a pointer to a "),S(s.$$.fragment,T),a=f(T," uses this information to construct a new "),S(u.$$.fragment,T),p=g(T,"BR",{}),m=f(T,`
A semaphore is a type of synchronization primitive that allows work performed by
different `),S(_.$$.fragment,T),v=f(T,` to be properly
planned and coordinated. Semaphores are used to manage the ownership of resources
in different `),S(P.$$.fragment,T),R=f(T,` on a single
device.`)},m(T,F){D(e,T,F),h(T,t,F),h(T,r,F),o(r,$),h(T,n,F),D(s,T,F),h(T,a,F),D(u,T,F),h(T,p,F),h(T,m,F),D(_,T,F),h(T,v,F),D(P,T,F),h(T,R,F),A=!0},p(T,[F]){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),s.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),u.$set(y);const V={};F&1&&(V.$$scope={dirty:F,ctx:T}),_.$set(V);const x={};F&1&&(x.$$scope={dirty:F,ctx:T}),P.$set(x)},i(T){A||(b(e.$$.fragment,T),b(s.$$.fragment,T),b(u.$$.fragment,T),b(_.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(e.$$.fragment,T),w(s.$$.fragment,T),w(u.$$.fragment,T),w(_.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){C(e,T),T&&l(t),T&&l(r),T&&l(n),C(s,T),T&&l(a),C(u,T),T&&l(p),T&&l(m),C(_,T),T&&l(v),C(P,T),T&&l(R)}}}class O3 extends ve{constructor(e){super(),Ee(this,e,null,V3,be,{})}}function F3(c){let e,t;return{c(){e=d("span"),t=i("Create a new Semaphore."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Semaphore."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function y3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M3(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[y3]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Semaphore should be associated with."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pLogicalDevice"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," the Semaphore should be associated with."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function x3(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N3(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[x3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function U3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"Semaphore(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{throws:[N3],params:[M3],details:[F3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class G3 extends ve{constructor(e){super(),Ee(this,e,null,U3,be,{})}}function H3(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q3(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[H3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function W3(c){let e;return{c(){e=i("Vulkan Semaphore")},l(t){e=f(t,"Vulkan Semaphore")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q3(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html",target:"_blank",$$slots:{default:[W3]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function K3(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkSemaphore getSemaphoreHandle() const;"}}),r=new Ce({props:{$$slots:{return:[Q3],details:[q3]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class z3 extends ve{constructor(e){super(),Ee(this,e,null,K3,be,{})}}function Y3(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j3(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X3(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z3(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J3(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e2(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t2(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r2(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n2(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s2(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function a2(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o2(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l2(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i2(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f2(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c2(c){let e;return{c(){e=i("SPIR-V")},l(t){e=f(t,"SPIR-V")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $2(c){let e;return{c(){e=i("GLSL")},l(t){e=f(t,"GLSL")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u2(c){let e;return{c(){e=i("Shaderc")},l(t){e=f(t,"Shaderc")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p2(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/shader_module.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Y3]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[j3]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[X3]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Z3]},$$scope:{ctx:c}}}),R=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[J3]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[e2]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[t2]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[r2]},$$scope:{ctx:c}}}),H=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[n2]},$$scope:{ctx:c}}}),N=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[s2]},$$scope:{ctx:c}}}),q=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[a2]},$$scope:{ctx:c}}}),te=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[o2]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[l2]},$$scope:{ctx:c}}}),pe=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[i2]},$$scope:{ctx:c}}}),de=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[f2]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://www.khronos.org/spir/",target:"_blank",$$slots:{default:[c2]},$$scope:{ctx:c}}}),Ie=new fe({props:{href:"https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)",target:"_blank",$$slots:{default:[$2]},$$scope:{ctx:c}}}),he=new fe({props:{href:"https://github.com/google/shaderc",target:"_blank",$$slots:{default:[u2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Shader Module"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a list of characters representing the GLSL code and a list of "),I(u.$$.fragment),p=i(" to the "),I(m.$$.fragment),_=i(" describing the "),I(v.$$.fragment),P=i(" that expose resources to the shader, and a "),I(R.$$.fragment),A=i(" to a "),I(T.$$.fragment),F=i(" from which the "),I(B.$$.fragment),y=i(" will be allocated."),V=d("br"),x=i(`
Note that the ownership of both the `),I(M.$$.fragment),O=i(" and the "),I(H.$$.fragment),k=i(" needs to be transferred using "),I(N.$$.fragment),Q=i("."),X=d("br"),Z=i(`
Shaders are small programs that run directly on the device (like a GPU). Shaders
are the fundamental building blocks of the work to be done on the device.`),K=d("br"),W=i(`
Vulkan shaders are represented by `),I(q.$$.fragment),U=i(` (Standard Portable Intermediate Representation), a binary intermediate representation
of program code. `),I(te.$$.fragment),ee=i(` can be generated outside the application using a compiler, directly in the application
or by passing a high-level language to a library at run-time.`),se=d("br"),ie=i(`
The original shaders are written in `),I(ae.$$.fragment),J=i(` using the Vulkan profile. This is a modified and extended version of the same shading
language used with OpenGL. Most examples therefore discuss Vulkan features in terms
of their representation in `),I(pe.$$.fragment),Se=i(". Note that Vulkan itself knows nothing about "),I(de.$$.fragment),me=i(" and only cares about the compiled "),I(De.$$.fragment),_e=i(" representation."),ne=d("br"),le=d("br"),ge=i(`

The `),we=d("code"),Pe=i("Shader Module"),Be=i(" class compiles "),I(Ie.$$.fragment),re=i(" shaders at run-time using "),I(he.$$.fragment),Le=i(".")},l(oe){S(e.$$.fragment,oe),t=f(oe,`

The `),r=g(oe,"CODE",{});var ce=E(r);$=f(ce,"Shader Module"),ce.forEach(l),n=f(oe," class takes a pointer to a "),S(s.$$.fragment,oe),a=f(oe," along with a list of characters representing the GLSL code and a list of "),S(u.$$.fragment,oe),p=f(oe," to the "),S(m.$$.fragment,oe),_=f(oe," describing the "),S(v.$$.fragment,oe),P=f(oe," that expose resources to the shader, and a "),S(R.$$.fragment,oe),A=f(oe," to a "),S(T.$$.fragment,oe),F=f(oe," from which the "),S(B.$$.fragment,oe),y=f(oe," will be allocated."),V=g(oe,"BR",{}),x=f(oe,`
Note that the ownership of both the `),S(M.$$.fragment,oe),O=f(oe," and the "),S(H.$$.fragment,oe),k=f(oe," needs to be transferred using "),S(N.$$.fragment,oe),Q=f(oe,"."),X=g(oe,"BR",{}),Z=f(oe,`
Shaders are small programs that run directly on the device (like a GPU). Shaders
are the fundamental building blocks of the work to be done on the device.`),K=g(oe,"BR",{}),W=f(oe,`
Vulkan shaders are represented by `),S(q.$$.fragment,oe),U=f(oe,` (Standard Portable Intermediate Representation), a binary intermediate representation
of program code. `),S(te.$$.fragment,oe),ee=f(oe,` can be generated outside the application using a compiler, directly in the application
or by passing a high-level language to a library at run-time.`),se=g(oe,"BR",{}),ie=f(oe,`
The original shaders are written in `),S(ae.$$.fragment,oe),J=f(oe,` using the Vulkan profile. This is a modified and extended version of the same shading
language used with OpenGL. Most examples therefore discuss Vulkan features in terms
of their representation in `),S(pe.$$.fragment,oe),Se=f(oe,". Note that Vulkan itself knows nothing about "),S(de.$$.fragment,oe),me=f(oe," and only cares about the compiled "),S(De.$$.fragment,oe),_e=f(oe," representation."),ne=g(oe,"BR",{}),le=g(oe,"BR",{}),ge=f(oe,`

The `),we=g(oe,"CODE",{});var Ae=E(we);Pe=f(Ae,"Shader Module"),Ae.forEach(l),Be=f(oe," class compiles "),S(Ie.$$.fragment,oe),re=f(oe," shaders at run-time using "),S(he.$$.fragment,oe),Le=f(oe,".")},m(oe,ce){D(e,oe,ce),h(oe,t,ce),h(oe,r,ce),o(r,$),h(oe,n,ce),D(s,oe,ce),h(oe,a,ce),D(u,oe,ce),h(oe,p,ce),D(m,oe,ce),h(oe,_,ce),D(v,oe,ce),h(oe,P,ce),D(R,oe,ce),h(oe,A,ce),D(T,oe,ce),h(oe,F,ce),D(B,oe,ce),h(oe,y,ce),h(oe,V,ce),h(oe,x,ce),D(M,oe,ce),h(oe,O,ce),D(H,oe,ce),h(oe,k,ce),D(N,oe,ce),h(oe,Q,ce),h(oe,X,ce),h(oe,Z,ce),h(oe,K,ce),h(oe,W,ce),D(q,oe,ce),h(oe,U,ce),D(te,oe,ce),h(oe,ee,ce),h(oe,se,ce),h(oe,ie,ce),D(ae,oe,ce),h(oe,J,ce),D(pe,oe,ce),h(oe,Se,ce),D(de,oe,ce),h(oe,me,ce),D(De,oe,ce),h(oe,_e,ce),h(oe,ne,ce),h(oe,le,ce),h(oe,ge,ce),h(oe,we,ce),o(we,Pe),h(oe,Be,ce),D(Ie,oe,ce),h(oe,re,ce),D(he,oe,ce),h(oe,Le,ce),Oe=!0},p(oe,[ce]){const Ae={};ce&1&&(Ae.$$scope={dirty:ce,ctx:oe}),s.$set(Ae);const ye={};ce&1&&(ye.$$scope={dirty:ce,ctx:oe}),u.$set(ye);const Fe={};ce&1&&(Fe.$$scope={dirty:ce,ctx:oe}),m.$set(Fe);const Ve={};ce&1&&(Ve.$$scope={dirty:ce,ctx:oe}),v.$set(Ve);const Ge={};ce&1&&(Ge.$$scope={dirty:ce,ctx:oe}),R.$set(Ge);const He={};ce&1&&(He.$$scope={dirty:ce,ctx:oe}),T.$set(He);const ze={};ce&1&&(ze.$$scope={dirty:ce,ctx:oe}),B.$set(ze);const xe={};ce&1&&(xe.$$scope={dirty:ce,ctx:oe}),M.$set(xe);const Ne={};ce&1&&(Ne.$$scope={dirty:ce,ctx:oe}),H.$set(Ne);const Te={};ce&1&&(Te.$$scope={dirty:ce,ctx:oe}),N.$set(Te);const qe={};ce&1&&(qe.$$scope={dirty:ce,ctx:oe}),q.$set(qe);const Ke={};ce&1&&(Ke.$$scope={dirty:ce,ctx:oe}),te.$set(Ke);const je={};ce&1&&(je.$$scope={dirty:ce,ctx:oe}),ae.$set(je);const rt={};ce&1&&(rt.$$scope={dirty:ce,ctx:oe}),pe.$set(rt);const Me={};ce&1&&(Me.$$scope={dirty:ce,ctx:oe}),de.$set(Me);const Ue={};ce&1&&(Ue.$$scope={dirty:ce,ctx:oe}),De.$set(Ue);const $t={};ce&1&&($t.$$scope={dirty:ce,ctx:oe}),Ie.$set($t);const ut={};ce&1&&(ut.$$scope={dirty:ce,ctx:oe}),he.$set(ut)},i(oe){Oe||(b(e.$$.fragment,oe),b(s.$$.fragment,oe),b(u.$$.fragment,oe),b(m.$$.fragment,oe),b(v.$$.fragment,oe),b(R.$$.fragment,oe),b(T.$$.fragment,oe),b(B.$$.fragment,oe),b(M.$$.fragment,oe),b(H.$$.fragment,oe),b(N.$$.fragment,oe),b(q.$$.fragment,oe),b(te.$$.fragment,oe),b(ae.$$.fragment,oe),b(pe.$$.fragment,oe),b(de.$$.fragment,oe),b(De.$$.fragment,oe),b(Ie.$$.fragment,oe),b(he.$$.fragment,oe),Oe=!0)},o(oe){w(e.$$.fragment,oe),w(s.$$.fragment,oe),w(u.$$.fragment,oe),w(m.$$.fragment,oe),w(v.$$.fragment,oe),w(R.$$.fragment,oe),w(T.$$.fragment,oe),w(B.$$.fragment,oe),w(M.$$.fragment,oe),w(H.$$.fragment,oe),w(N.$$.fragment,oe),w(q.$$.fragment,oe),w(te.$$.fragment,oe),w(ae.$$.fragment,oe),w(pe.$$.fragment,oe),w(de.$$.fragment,oe),w(De.$$.fragment,oe),w(Ie.$$.fragment,oe),w(he.$$.fragment,oe),Oe=!1},d(oe){C(e,oe),oe&&l(t),oe&&l(r),oe&&l(n),C(s,oe),oe&&l(a),C(u,oe),oe&&l(p),C(m,oe),oe&&l(_),C(v,oe),oe&&l(P),C(R,oe),oe&&l(A),C(T,oe),oe&&l(F),C(B,oe),oe&&l(y),oe&&l(V),oe&&l(x),C(M,oe),oe&&l(O),C(H,oe),oe&&l(k),C(N,oe),oe&&l(Q),oe&&l(X),oe&&l(Z),oe&&l(K),oe&&l(W),C(q,oe),oe&&l(U),C(te,oe),oe&&l(ee),oe&&l(se),oe&&l(ie),C(ae,oe),oe&&l(J),C(pe,oe),oe&&l(Se),C(de,oe),oe&&l(me),C(De,oe),oe&&l(_e),oe&&l(ne),oe&&l(le),oe&&l(ge),oe&&l(we),oe&&l(Be),C(Ie,oe),oe&&l(re),C(he,oe),oe&&l(Le)}}}class m2 extends ve{constructor(e){super(),Ee(this,e,null,p2,be,{})}}function h2(c){let e;return{c(){e=i("createShaderModule")},l(t){e=f(t,"createShaderModule")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d2(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.FILLCAN_createShaderModule,$$slots:{default:[h2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Shader Module."),r=d("br"),$=i(`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(` instead.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Shader Module."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p,` instead.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function g2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _2(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v2(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E2(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b2(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function w2(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I2(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D2(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function C2(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[g2]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[_2]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[v2]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[E2]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[b2]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[w2]},$$scope:{ctx:c}}}),ie=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[I2]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[D2]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Shader Module."),p=Y(),m=d("li"),_=d("code"),v=i("code"),P=d("br"),R=i(`
            The SPIR-V code.`),A=Y(),T=d("li"),F=d("code"),B=i("upDescriptorSetLayouts"),y=d("br"),V=i(`
            A list of `),I(x.$$.fragment),M=i(" to the "),I(O.$$.fragment),H=i(" describing the "),I(k.$$.fragment),N=i(` that expose resources to the shader. Ownerships needs to be transferred
            using `),I(Q.$$.fragment),X=i("."),Z=Y(),K=d("li"),W=d("code"),q=i("upDescriptorPool"),U=d("br"),te=i(`
            A `),I(ee.$$.fragment),se=i(" to a "),I(ie.$$.fragment),ae=i(` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),I(J.$$.fragment),pe=i("."),Se=Y(),this.h()},l(me){e=g(me,"DIV",{slot:!0});var De=E(e);t=g(De,"LI",{});var _e=E(t);r=g(_e,"CODE",{});var ne=E(r);$=f(ne,"pLogicalDevice"),ne.forEach(l),n=g(_e,"BR",{}),s=f(_e,`
            A pointer to the `),S(a.$$.fragment,_e),u=f(_e," that owns the Shader Module."),_e.forEach(l),p=j(De),m=g(De,"LI",{});var le=E(m);_=g(le,"CODE",{});var ge=E(_);v=f(ge,"code"),ge.forEach(l),P=g(le,"BR",{}),R=f(le,`
            The SPIR-V code.`),le.forEach(l),A=j(De),T=g(De,"LI",{});var we=E(T);F=g(we,"CODE",{});var Pe=E(F);B=f(Pe,"upDescriptorSetLayouts"),Pe.forEach(l),y=g(we,"BR",{}),V=f(we,`
            A list of `),S(x.$$.fragment,we),M=f(we," to the "),S(O.$$.fragment,we),H=f(we," describing the "),S(k.$$.fragment,we),N=f(we,` that expose resources to the shader. Ownerships needs to be transferred
            using `),S(Q.$$.fragment,we),X=f(we,"."),we.forEach(l),Z=j(De),K=g(De,"LI",{});var Be=E(K);W=g(Be,"CODE",{});var Ie=E(W);q=f(Ie,"upDescriptorPool"),Ie.forEach(l),U=g(Be,"BR",{}),te=f(Be,`
            A `),S(ee.$$.fragment,Be),se=f(Be," to a "),S(ie.$$.fragment,Be),ae=f(Be,` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),S(J.$$.fragment,Be),pe=f(Be,"."),Be.forEach(l),Se=j(De),De.forEach(l),this.h()},h(){z(e,"slot","params")},m(me,De){h(me,e,De),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),D(O,T,null),o(T,H),D(k,T,null),o(T,N),D(Q,T,null),o(T,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),D(ee,K,null),o(K,se),D(ie,K,null),o(K,ae),D(J,K,null),o(K,pe),o(e,Se),de=!0},p(me,De){const _e={};De&1&&(_e.$$scope={dirty:De,ctx:me}),a.$set(_e);const ne={};De&1&&(ne.$$scope={dirty:De,ctx:me}),x.$set(ne);const le={};De&1&&(le.$$scope={dirty:De,ctx:me}),O.$set(le);const ge={};De&1&&(ge.$$scope={dirty:De,ctx:me}),k.$set(ge);const we={};De&1&&(we.$$scope={dirty:De,ctx:me}),Q.$set(we);const Pe={};De&1&&(Pe.$$scope={dirty:De,ctx:me}),ee.$set(Pe);const Be={};De&1&&(Be.$$scope={dirty:De,ctx:me}),ie.$set(Be);const Ie={};De&1&&(Ie.$$scope={dirty:De,ctx:me}),J.$set(Ie)},i(me){de||(b(a.$$.fragment,me),b(x.$$.fragment,me),b(O.$$.fragment,me),b(k.$$.fragment,me),b(Q.$$.fragment,me),b(ee.$$.fragment,me),b(ie.$$.fragment,me),b(J.$$.fragment,me),de=!0)},o(me){w(a.$$.fragment,me),w(x.$$.fragment,me),w(O.$$.fragment,me),w(k.$$.fragment,me),w(Q.$$.fragment,me),w(ee.$$.fragment,me),w(ie.$$.fragment,me),w(J.$$.fragment,me),de=!1},d(me){me&&l(e),C(a),C(x),C(O),C(k),C(Q),C(ee),C(ie),C(J)}}}function S2(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P2(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[S2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(` couldn't be created.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,` couldn't be created.
    `),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function A2(c){let e;return{c(){e=i("createShaderModule")},l(t){e=f(t,"createShaderModule")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R2(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.FILLCAN_createShaderModule,$$slots:{default:[A2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Shader Module."),r=d("br"),$=i(`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Shader Module."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Shader Module by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function B2(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L2(c){let e;return{c(){e=i("unique pointers")},l(t){e=f(t,"unique pointers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k2(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T2(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V2(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function O2(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F2(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y2(c){let e,t;return{c(){e=d("code"),t=i("std::move")},l(r){e=g(r,"CODE",{});var $=E(e);t=f($,"std::move"),$.forEach(l)},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function M2(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[B2]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[L2]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[k2]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[T2]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[V2]},$$scope:{ctx:c}}}),ee=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[O2]},$$scope:{ctx:c}}}),ie=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[F2]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[y2]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" that owns the Shader Module."),p=Y(),m=d("li"),_=d("code"),v=i("code"),P=d("br"),R=i(`
            The SPIR-V code.`),A=Y(),T=d("li"),F=d("code"),B=i("upDescriptorSetLayouts"),y=d("br"),V=i(`
            A list of `),I(x.$$.fragment),M=i(" to the "),I(O.$$.fragment),H=i(" describing the "),I(k.$$.fragment),N=i(` that expose resources to the shader. Ownerships needs to be transferred
            using `),I(Q.$$.fragment),X=i("."),Z=Y(),K=d("li"),W=d("code"),q=i("upDescriptorPool"),U=d("br"),te=i(`
            A `),I(ee.$$.fragment),se=i(" to a "),I(ie.$$.fragment),ae=i(` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),I(J.$$.fragment),pe=i("."),this.h()},l(de){e=g(de,"DIV",{slot:!0});var me=E(e);t=g(me,"LI",{});var De=E(t);r=g(De,"CODE",{});var _e=E(r);$=f(_e,"pLogicalDevice"),_e.forEach(l),n=g(De,"BR",{}),s=f(De,`
            A pointer to the `),S(a.$$.fragment,De),u=f(De," that owns the Shader Module."),De.forEach(l),p=j(me),m=g(me,"LI",{});var ne=E(m);_=g(ne,"CODE",{});var le=E(_);v=f(le,"code"),le.forEach(l),P=g(ne,"BR",{}),R=f(ne,`
            The SPIR-V code.`),ne.forEach(l),A=j(me),T=g(me,"LI",{});var ge=E(T);F=g(ge,"CODE",{});var we=E(F);B=f(we,"upDescriptorSetLayouts"),we.forEach(l),y=g(ge,"BR",{}),V=f(ge,`
            A list of `),S(x.$$.fragment,ge),M=f(ge," to the "),S(O.$$.fragment,ge),H=f(ge," describing the "),S(k.$$.fragment,ge),N=f(ge,` that expose resources to the shader. Ownerships needs to be transferred
            using `),S(Q.$$.fragment,ge),X=f(ge,"."),ge.forEach(l),Z=j(me),K=g(me,"LI",{});var Pe=E(K);W=g(Pe,"CODE",{});var Be=E(W);q=f(Be,"upDescriptorPool"),Be.forEach(l),U=g(Pe,"BR",{}),te=f(Pe,`
            A `),S(ee.$$.fragment,Pe),se=f(Pe," to a "),S(ie.$$.fragment,Pe),ae=f(Pe,` from which the descriptor sets will be allocated. Ownership needs to
            be transferred using `),S(J.$$.fragment,Pe),pe=f(Pe,"."),Pe.forEach(l),me.forEach(l),this.h()},h(){z(e,"slot","params")},m(de,me){h(de,e,me),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),D(O,T,null),o(T,H),D(k,T,null),o(T,N),D(Q,T,null),o(T,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),D(ee,K,null),o(K,se),D(ie,K,null),o(K,ae),D(J,K,null),o(K,pe),Se=!0},p(de,me){const De={};me&1&&(De.$$scope={dirty:me,ctx:de}),a.$set(De);const _e={};me&1&&(_e.$$scope={dirty:me,ctx:de}),x.$set(_e);const ne={};me&1&&(ne.$$scope={dirty:me,ctx:de}),O.$set(ne);const le={};me&1&&(le.$$scope={dirty:me,ctx:de}),k.$set(le);const ge={};me&1&&(ge.$$scope={dirty:me,ctx:de}),Q.$set(ge);const we={};me&1&&(we.$$scope={dirty:me,ctx:de}),ee.$set(we);const Pe={};me&1&&(Pe.$$scope={dirty:me,ctx:de}),ie.$set(Pe);const Be={};me&1&&(Be.$$scope={dirty:me,ctx:de}),J.$set(Be)},i(de){Se||(b(a.$$.fragment,de),b(x.$$.fragment,de),b(O.$$.fragment,de),b(k.$$.fragment,de),b(Q.$$.fragment,de),b(ee.$$.fragment,de),b(ie.$$.fragment,de),b(J.$$.fragment,de),Se=!0)},o(de){w(a.$$.fragment,de),w(x.$$.fragment,de),w(O.$$.fragment,de),w(k.$$.fragment,de),w(Q.$$.fragment,de),w(ee.$$.fragment,de),w(ie.$$.fragment,de),w(J.$$.fragment,de),Se=!1},d(de){de&&l(e),C(a),C(x),C(O),C(k),C(Q),C(ee),C(ie),C(J)}}}function x2(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N2(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[x2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function U2(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:`ShaderModule(
    LogicalDevice* pLogicalDevice, 
    std::vector<char>& code, 
    std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
    std::unique_ptr<DescriptorPool> upDescriptorPool
);`}}),r=new Ce({props:{$$slots:{throws:[P2],params:[C2],details:[d2]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`ShaderModule(
    LogicalDevice* pLogicalDevice, 
    std::vector<uint32_t>& code, 
    std::vector<std::unique_ptr<DescriptorSetLayout>> upDescriptorSetLayouts,
    std::unique_ptr<DescriptorPool> upDescriptorPool
);`}}),u=new Ce({props:{$$slots:{throws:[N2],params:[M2],details:[R2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class G2 extends ve{constructor(e){super(),Ee(this,e,null,U2,be,{})}}function H2(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[H2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function W2(c){let e;return{c(){e=i("Vulkan Shader Module")},l(t){e=f(t,"Vulkan Shader Module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q2(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[W2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function K2(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkShaderModule getShaderModuleHandle() const;"}}),r=new Ce({props:{$$slots:{return:[Q2],details:[q2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class z2 extends ve{constructor(e){super(),Ee(this,e,null,K2,be,{})}}function Y2(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j2(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[Y2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function X2(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z2(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[X2]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function J2(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<DescriptorSetLayout*> getDescriptorSetLayouts();"}}),r=new Ce({props:{$$slots:{return:[Z2],details:[j2]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eF extends ve{constructor(e){super(),Ee(this,e,null,J2,be,{})}}function tF(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rF(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[tF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function nF(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sF(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[nF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorPool* getDescriptorPool();"}}),r=new Ce({props:{$$slots:{return:[sF],details:[rF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class oF extends ve{constructor(e){super(),Ee(this,e,null,aF,be,{})}}function lF(c){return{name:"GLSL",keywords:{keyword:"break continue discard do else for if return while switch case default attribute binding buffer ccw centroid centroid varying coherent column_major const cw depth_any depth_greater depth_less depth_unchanged early_fragment_tests equal_spacing flat fractional_even_spacing fractional_odd_spacing highp in index inout invariant invocations isolines layout line_strip lines lines_adjacency local_size_x local_size_y local_size_z location lowp max_vertices mediump noperspective offset origin_upper_left out packed patch pixel_center_integer point_mode points precise precision quads r11f_g11f_b10f r16 r16_snorm r16f r16i r16ui r32f r32i r32ui r8 r8_snorm r8i r8ui readonly restrict rg16 rg16_snorm rg16f rg16i rg16ui rg32f rg32i rg32ui rg8 rg8_snorm rg8i rg8ui rgb10_a2 rgb10_a2ui rgba16 rgba16_snorm rgba16f rgba16i rgba16ui rgba32f rgba32i rgba32ui rgba8 rgba8_snorm rgba8i rgba8ui row_major sample shared smooth std140 std430 stream triangle_strip triangles triangles_adjacency uniform varying vertices volatile writeonly",type:"atomic_uint bool bvec2 bvec3 bvec4 dmat2 dmat2x2 dmat2x3 dmat2x4 dmat3 dmat3x2 dmat3x3 dmat3x4 dmat4 dmat4x2 dmat4x3 dmat4x4 double dvec2 dvec3 dvec4 float iimage1D iimage1DArray iimage2D iimage2DArray iimage2DMS iimage2DMSArray iimage2DRect iimage3D iimageBuffer iimageCube iimageCubeArray image1D image1DArray image2D image2DArray image2DMS image2DMSArray image2DRect image3D imageBuffer imageCube imageCubeArray int isampler1D isampler1DArray isampler2D isampler2DArray isampler2DMS isampler2DMSArray isampler2DRect isampler3D isamplerBuffer isamplerCube isamplerCubeArray ivec2 ivec3 ivec4 mat2 mat2x2 mat2x3 mat2x4 mat3 mat3x2 mat3x3 mat3x4 mat4 mat4x2 mat4x3 mat4x4 sampler1D sampler1DArray sampler1DArrayShadow sampler1DShadow sampler2D sampler2DArray sampler2DArrayShadow sampler2DMS sampler2DMSArray sampler2DRect sampler2DRectShadow sampler2DShadow sampler3D samplerBuffer samplerCube samplerCubeArray samplerCubeArrayShadow samplerCubeShadow image1D uimage1DArray uimage2D uimage2DArray uimage2DMS uimage2DMSArray uimage2DRect uimage3D uimageBuffer uimageCube uimageCubeArray uint usampler1D usampler1DArray usampler2D usampler2DArray usampler2DMS usampler2DMSArray usampler2DRect usampler3D samplerBuffer usamplerCube usamplerCubeArray uvec2 uvec3 uvec4 vec2 vec3 vec4 void",built_in:"gl_MaxAtomicCounterBindings gl_MaxAtomicCounterBufferSize gl_MaxClipDistances gl_MaxClipPlanes gl_MaxCombinedAtomicCounterBuffers gl_MaxCombinedAtomicCounters gl_MaxCombinedImageUniforms gl_MaxCombinedImageUnitsAndFragmentOutputs gl_MaxCombinedTextureImageUnits gl_MaxComputeAtomicCounterBuffers gl_MaxComputeAtomicCounters gl_MaxComputeImageUniforms gl_MaxComputeTextureImageUnits gl_MaxComputeUniformComponents gl_MaxComputeWorkGroupCount gl_MaxComputeWorkGroupSize gl_MaxDrawBuffers gl_MaxFragmentAtomicCounterBuffers gl_MaxFragmentAtomicCounters gl_MaxFragmentImageUniforms gl_MaxFragmentInputComponents gl_MaxFragmentInputVectors gl_MaxFragmentUniformComponents gl_MaxFragmentUniformVectors gl_MaxGeometryAtomicCounterBuffers gl_MaxGeometryAtomicCounters gl_MaxGeometryImageUniforms gl_MaxGeometryInputComponents gl_MaxGeometryOutputComponents gl_MaxGeometryOutputVertices gl_MaxGeometryTextureImageUnits gl_MaxGeometryTotalOutputComponents gl_MaxGeometryUniformComponents gl_MaxGeometryVaryingComponents gl_MaxImageSamples gl_MaxImageUnits gl_MaxLights gl_MaxPatchVertices gl_MaxProgramTexelOffset gl_MaxTessControlAtomicCounterBuffers gl_MaxTessControlAtomicCounters gl_MaxTessControlImageUniforms gl_MaxTessControlInputComponents gl_MaxTessControlOutputComponents gl_MaxTessControlTextureImageUnits gl_MaxTessControlTotalOutputComponents gl_MaxTessControlUniformComponents gl_MaxTessEvaluationAtomicCounterBuffers gl_MaxTessEvaluationAtomicCounters gl_MaxTessEvaluationImageUniforms gl_MaxTessEvaluationInputComponents gl_MaxTessEvaluationOutputComponents gl_MaxTessEvaluationTextureImageUnits gl_MaxTessEvaluationUniformComponents gl_MaxTessGenLevel gl_MaxTessPatchComponents gl_MaxTextureCoords gl_MaxTextureImageUnits gl_MaxTextureUnits gl_MaxVaryingComponents gl_MaxVaryingFloats gl_MaxVaryingVectors gl_MaxVertexAtomicCounterBuffers gl_MaxVertexAtomicCounters gl_MaxVertexAttribs gl_MaxVertexImageUniforms gl_MaxVertexOutputComponents gl_MaxVertexOutputVectors gl_MaxVertexTextureImageUnits gl_MaxVertexUniformComponents gl_MaxVertexUniformVectors gl_MaxViewports gl_MinProgramTexelOffset gl_BackColor gl_BackLightModelProduct gl_BackLightProduct gl_BackMaterial gl_BackSecondaryColor gl_ClipDistance gl_ClipPlane gl_ClipVertex gl_Color gl_DepthRange gl_EyePlaneQ gl_EyePlaneR gl_EyePlaneS gl_EyePlaneT gl_Fog gl_FogCoord gl_FogFragCoord gl_FragColor gl_FragCoord gl_FragData gl_FragDepth gl_FrontColor gl_FrontFacing gl_FrontLightModelProduct gl_FrontLightProduct gl_FrontMaterial gl_FrontSecondaryColor gl_GlobalInvocationID gl_InstanceID gl_InvocationID gl_Layer gl_LightModel gl_LightSource gl_LocalInvocationID gl_LocalInvocationIndex gl_ModelViewMatrix gl_ModelViewMatrixInverse gl_ModelViewMatrixInverseTranspose gl_ModelViewMatrixTranspose gl_ModelViewProjectionMatrix gl_ModelViewProjectionMatrixInverse gl_ModelViewProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixTranspose gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_Normal gl_NormalMatrix gl_NormalScale gl_NumSamples gl_NumWorkGroups gl_ObjectPlaneQ gl_ObjectPlaneR gl_ObjectPlaneS gl_ObjectPlaneT gl_PatchVerticesIn gl_Point gl_PointCoord gl_PointSize gl_Position gl_PrimitiveID gl_PrimitiveIDIn gl_ProjectionMatrix gl_ProjectionMatrixInverse gl_ProjectionMatrixInverseTranspose gl_ProjectionMatrixTranspose gl_SampleID gl_SampleMask gl_SampleMaskIn gl_SamplePosition gl_SecondaryColor gl_TessCoord gl_TessLevelInner gl_TessLevelOuter gl_TexCoord gl_TextureEnvColor gl_TextureMatrix gl_TextureMatrixInverse gl_TextureMatrixInverseTranspose gl_TextureMatrixTranspose gl_Vertex gl_VertexID gl_ViewportIndex gl_WorkGroupID gl_WorkGroupSize gl_in gl_out EmitStreamVertex EmitVertex EndPrimitive EndStreamPrimitive abs acos acosh all any asin asinh atan atanh atomicAdd atomicAnd atomicCompSwap atomicCounter atomicCounterDecrement atomicCounterIncrement atomicExchange atomicMax atomicMin atomicOr atomicXor barrier bitCount bitfieldExtract bitfieldInsert bitfieldReverse ceil clamp cos cosh cross dFdx dFdy degrees determinant distance dot equal exp exp2 faceforward findLSB findMSB floatBitsToInt floatBitsToUint floor fma fract frexp ftransform fwidth greaterThan greaterThanEqual groupMemoryBarrier imageAtomicAdd imageAtomicAnd imageAtomicCompSwap imageAtomicExchange imageAtomicMax imageAtomicMin imageAtomicOr imageAtomicXor imageLoad imageSize imageStore imulExtended intBitsToFloat interpolateAtCentroid interpolateAtOffset interpolateAtSample inverse inversesqrt isinf isnan ldexp length lessThan lessThanEqual log log2 matrixCompMult max memoryBarrier memoryBarrierAtomicCounter memoryBarrierBuffer memoryBarrierImage memoryBarrierShared min mix mod modf noise1 noise2 noise3 noise4 normalize not notEqual outerProduct packDouble2x32 packHalf2x16 packSnorm2x16 packSnorm4x8 packUnorm2x16 packUnorm4x8 pow radians reflect refract round roundEven shadow1D shadow1DLod shadow1DProj shadow1DProjLod shadow2D shadow2DLod shadow2DProj shadow2DProjLod sign sin sinh smoothstep sqrt step tan tanh texelFetch texelFetchOffset texture texture1D texture1DLod texture1DProj texture1DProjLod texture2D texture2DLod texture2DProj texture2DProjLod texture3D texture3DLod texture3DProj texture3DProjLod textureCube textureCubeLod textureGather textureGatherOffset textureGatherOffsets textureGrad textureGradOffset textureLod textureLodOffset textureOffset textureProj textureProjGrad textureProjGradOffset textureProjLod textureProjLodOffset textureProjOffset textureQueryLevels textureQueryLod textureSize transpose trunc uaddCarry uintBitsToFloat umulExtended unpackDouble2x32 unpackHalf2x16 unpackSnorm2x16 unpackSnorm4x8 unpackUnorm2x16 unpackUnorm4x8 usubBorrow",literal:"true false"},illegal:'"',contains:[c.C_LINE_COMMENT_MODE,c.C_BLOCK_COMMENT_MODE,c.C_NUMBER_MODE,{className:"meta",begin:"#",end:"$"}]}}const iF={name:"glsl",register:lF};var hn=iF;function fF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout Bindings")},l(t){e=f(t,"Vulkan Descriptor Set Layout Bindings")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $F(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uF(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pF(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mF(c){let e;return{c(){e=i("texelFetch")},l(t){e=f(t,"texelFetch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hF(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dF(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gF(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,Ft,mt,Vt,Rt,Tt,vt,gt,kt,Mt,yt,Ht,$r,Ut,or,Xt,Ot,Zt,Ar,br,ur,Qt,Or,rr,Kr,lr,gr,Fr,Kt,ir,yr;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/descriptor_set_layout.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[fF]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[cF]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[$F]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.BUFFER,$$slots:{default:[uF]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.BUFFER,$$slots:{default:[pF]},$$scope:{ctx:c}}}),W=new $e({props:{language:hn,code:`#version 450 core

layout (set = 0, binding = 1) uniform UniformBlock
{
    float float_value;
    vec4 vec4_value;
} uniform_buffer;

layout (set = 0, binding = 2) buffer StorageBlock
{
    float float_value;
    vec4 vec4_value
} storage_buffer;
`}}),te=new $e({props:{language:hn,code:`storage_qualifier block_name
{
    <define members here>
} instance_name;
`}}),ct=new $e({props:{language:hn,code:`// With interface name
uniform MatrixBlock
{
    mat4 projection;
    mat4 modelView;
} matrices;
// To access projection, use matrices.projection

uniform vec3 modelView; // Allowed
`}}),We=new $e({props:{language:hn,code:`// Without interface name
uniform MatrixBlock
{
    mat4 projection;
    mat4 modelView;
};
// To access projection, use projection

uniform vec3 modelView; // Redefining variable. Compile error.
`}}),ot=new $e({props:{language:hn,code:`layout (set = 0, binding = 3) uniform samplerBuffer floatTexelBuffer;
layout (set = 0, binding = 4) uniform isamplerBuffer signedTexelBuffer;
layout (set = 0, binding = 5) uniform usamplerBuffer unsignedTexelBuffer;
`}}),it=new fe({props:{href:"https://registry.khronos.org/OpenGL-Refpages/gl4/html/texelFetch.xhtml",target:"_blank",$$slots:{default:[mF]},$$scope:{ctx:c}}}),br=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[hF]},$$scope:{ctx:c}}}),gr=new $e({props:{language:hn,code:`layout (push_constant) uniform block_name 
{
    <define members here>
} interface_name;

// Example
layout (push_constant) uniform PushConstant 
{
    int var1;
    vec3 var2;
    mat4 var3;
} push_constant;
`}}),Kt=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[dF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Descriptor Set Layout"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along a list of "),I(u.$$.fragment),p=i(" and uses this information to construct a "),I(m.$$.fragment),_=i("."),v=d("br"),P=i(`

The shaders in the application consume and produce data in two ways. The first
is by interacting with fixed function hardware and the second is by directly
reading and writing resources. Shaders can access the contents of the buffer
memory directly from three types of sources:
`),R=d("ul"),A=d("li"),T=i(`Uniform blocks provide quick access to constant (read-only) data stored
        in `),I(F.$$.fragment),B=i(` objects. They
        are declared as if they were structures in a shader and are mapped to memory
        using a buffer resource bound to the descriptor set.`),y=Y(),V=d("li"),x=i("Storage blocks provide read-write access to "),I(M.$$.fragment),O=i(` objects. Declared in the same way as uniform blocks, data is arranged as
        if it were a structure, but can be written to. Shader storage blocks also
        support atomic operations.`),H=Y(),k=d("li"),N=i(`Texel buffers provide access to long, linear arrays of formatted Texel
        data. They are read-only and a texel buffer binding performs format
        conversion from the underlying data format to the floating-point
        representation that the shader expects when the buffer is read.`),Q=i(`
The type of resource used depends on how it is to be accessed. The maximum size of
a uniform block is often limited, while access to it is generally very fast. On the
other hand, the maximum size of a shader storage block is very large, but in some
implementations access to it can be slower, especially if writes are enabled. For
accessing large arrays of formatted data, a texel buffer is probably the best choice.`),X=d("br"),Z=d("br"),K=i(`
To declare a uniform block in GLSL, the uniform keyword is used. A shader storage
block is declared in the same way, except that the uniform keyword is omitted and
the buffer keyword is used instead.
`),I(W.$$.fragment),q=d("br"),U=i(`
An interface block has the following definition. although it looks like a structure
definition, it is not:
`),I(te.$$.fragment),ee=i(`
The storage qualifier (`),se=d("code"),ie=i("storage_qualifier"),ae=i(`) defines what kind of
interface block is created. `),J=d("code"),pe=i("storage_qualifier"),Se=i(` can be the following:
`),de=d("ul"),me=d("li"),De=d("code"),_e=i("uniform"),ne=i(`. A uniform is a global shader variable declared
        with the storage qualifier uniform. They are so named because they do
        not change from one shader call to the next within a given rendering
        call, so their value is uniform among all calls`),le=Y(),ge=d("li"),we=d("code"),Pe=i("in"),Be=i(`. Global variables declared with the
        `),Ie=d("code"),re=i("in"),he=i(`-qualifier are input variables of the shader stage. These
        variables are given values by the previous stage. These variables are
        not constant (in the sense of `),Le=d("code"),Oe=i("const"),oe=i(`), but cannot be changed
        by user code.`),ce=Y(),Ae=d("li"),ye=d("code"),Fe=i("out"),Ve=i(`. Global variables declared with the
        `),Ge=d("code"),He=i("out"),ze=i(`-qualifier are shader stage output variables. These
        values are passed to the next stage of the pipeline. The shader must set
        all output variables at some point during execution; there are only two
        exceptions to this:
        `),xe=d("ol"),Ne=d("li"),Te=i("The shader is a Fragment Shader that executes the "),qe=d("code"),Ke=i("discard"),je=i(`
                statement.`),rt=Y(),Me=d("li"),Ue=i(`The output variables that are not written are not read by the
                next shader stage or pipeline process. This includes writes to
                fragment shader outputs that are masked.`),$t=Y(),ut=d("li"),ht=d("code"),Je=i("buffer"),dt=i(`. The storage for the contents of the block comes
        from a buffer object, similar to Uniform Buffer Objects and Uniform
        Blocks. Unlike UBOs, storage blocks can be written to.`),et=Y(),Ze=d("code"),nt=i("block_name"),Qe=i(` is the real name for the interface block. This is the
name used to refer to it. A shader cannot have multiple blocks that have the
same block_name and the same storage_qualifier. instance_name is a GLSL name for
one or more instances of the block named block_name. It's optional; if it is
present, all GLSL variables defined in the block must be qualified with the
instance name when referenced in the GLSL code.
`),I(ct.$$.fragment),st=Y(),I(We.$$.fragment),at=d("br"),bt=i(`
A texel buffer is a special type of buffer binding used in a shader that can perform
format conversion when the data is read. Texel buffers are read-only and are declared
in GLSL using a `),wt=d("code"),St=i("samplerBuffer"),tt=i(`-type variable. Sampler buffers can
return floating-point data or integers (signed or unsigned) to the shader.

`),I(ot.$$.fragment),At=i(`
To fetch a texel from a texelbuffer in GLSL, the `),I(it.$$.fragment),Xe=i(" function is used with the sampler variable ("),Dt=d("code"),Ct=i("floatTexelBuffer"),pt=i(`,
`),Ft=d("code"),mt=i("signedTexelBuffer"),Vt=i(`
or `),Rt=d("code"),Tt=i("unsignedTexelBuffer"),vt=i(`) to read individual texels. A
`),gt=d("code"),kt=i("samplerBuffer"),Mt=i(`
(or the corresponding `),yt=d("code"),Ht=i("isamplerBuffer"),$r=i(` and
`),Ut=d("code"),or=i("usamplerBuffer"),Xt=i(`) can be seen as a 1D texture that only supports
point sampling (because only one texel can be queried). However, the maximum
size of a texel buffer associated with one of these variables is generally much
larger than the maximum size of a 1D structure. For example, the minimum
required upper bound for a texel buffer in Vulkan is 65,535 elements, while the
minimum required size for a 1D texture is only 4,096 texels. In some cases
implementations will support texel buffers that are gigabytes in size.`),Ot=d("br"),Zt=d("br"),Ar=i(`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants are logically
considered part of the pipeline's resources and therefore are declared along with
the other resources in the `),I(br.$$.fragment),ur=i(" used to create pipeline objects."),Qt=d("br"),Or=i(`
To declare a push constant in GLSL, the `),rr=d("code"),Kr=i("push_constant"),lr=i(` layout
qualifier can be used.
`),I(gr.$$.fragment),Fr=i(`
Push constants become part of the `),I(Kt.$$.fragment),ir=i(` that will use them. When push constants are pipelined, they can consume some of
the resources Vulkan would otherwise use to track pipeline or descriptor bindings.
Therefore, push constants should be considered relatively precious resources.`)},l(Re){S(e.$$.fragment,Re),t=f(Re,`

The `),r=g(Re,"CODE",{});var lt=E(r);$=f(lt,"Descriptor Set Layout"),lt.forEach(l),n=f(Re," class takes a pointer to a "),S(s.$$.fragment,Re),a=f(Re," along a list of "),S(u.$$.fragment,Re),p=f(Re," and uses this information to construct a "),S(m.$$.fragment,Re),_=f(Re,"."),v=g(Re,"BR",{}),P=f(Re,`

The shaders in the application consume and produce data in two ways. The first
is by interacting with fixed function hardware and the second is by directly
reading and writing resources. Shaders can access the contents of the buffer
memory directly from three types of sources:
`),R=g(Re,"UL",{});var Jt=E(R);A=g(Jt,"LI",{});var _r=E(A);T=f(_r,`Uniform blocks provide quick access to constant (read-only) data stored
        in `),S(F.$$.fragment,_r),B=f(_r,` objects. They
        are declared as if they were structures in a shader and are mapped to memory
        using a buffer resource bound to the descriptor set.`),_r.forEach(l),y=j(Jt),V=g(Jt,"LI",{});var Yt=E(V);x=f(Yt,"Storage blocks provide read-write access to "),S(M.$$.fragment,Yt),O=f(Yt,` objects. Declared in the same way as uniform blocks, data is arranged as
        if it were a structure, but can be written to. Shader storage blocks also
        support atomic operations.`),Yt.forEach(l),H=j(Jt),k=g(Jt,"LI",{});var nr=E(k);N=f(nr,`Texel buffers provide access to long, linear arrays of formatted Texel
        data. They are read-only and a texel buffer binding performs format
        conversion from the underlying data format to the floating-point
        representation that the shader expects when the buffer is read.`),nr.forEach(l),Jt.forEach(l),Q=f(Re,`
The type of resource used depends on how it is to be accessed. The maximum size of
a uniform block is often limited, while access to it is generally very fast. On the
other hand, the maximum size of a shader storage block is very large, but in some
implementations access to it can be slower, especially if writes are enabled. For
accessing large arrays of formatted data, a texel buffer is probably the best choice.`),X=g(Re,"BR",{}),Z=g(Re,"BR",{}),K=f(Re,`
To declare a uniform block in GLSL, the uniform keyword is used. A shader storage
block is declared in the same way, except that the uniform keyword is omitted and
the buffer keyword is used instead.
`),S(W.$$.fragment,Re),q=g(Re,"BR",{}),U=f(Re,`
An interface block has the following definition. although it looks like a structure
definition, it is not:
`),S(te.$$.fragment,Re),ee=f(Re,`
The storage qualifier (`),se=g(Re,"CODE",{});var vr=E(se);ie=f(vr,"storage_qualifier"),vr.forEach(l),ae=f(Re,`) defines what kind of
interface block is created. `),J=g(Re,"CODE",{});var Tr=E(J);pe=f(Tr,"storage_qualifier"),Tr.forEach(l),Se=f(Re,` can be the following:
`),de=g(Re,"UL",{});var fr=E(de);me=g(fr,"LI",{});var cr=E(me);De=g(cr,"CODE",{});var sr=E(De);_e=f(sr,"uniform"),sr.forEach(l),ne=f(cr,`. A uniform is a global shader variable declared
        with the storage qualifier uniform. They are so named because they do
        not change from one shader call to the next within a given rendering
        call, so their value is uniform among all calls`),cr.forEach(l),le=j(fr),ge=g(fr,"LI",{});var er=E(ge);we=g(er,"CODE",{});var zr=E(we);Pe=f(zr,"in"),zr.forEach(l),Be=f(er,`. Global variables declared with the
        `),Ie=g(er,"CODE",{});var _t=E(Ie);re=f(_t,"in"),_t.forEach(l),he=f(er,`-qualifier are input variables of the shader stage. These
        variables are given values by the previous stage. These variables are
        not constant (in the sense of `),Le=g(er,"CODE",{});var ft=E(Le);Oe=f(ft,"const"),ft.forEach(l),oe=f(er,`), but cannot be changed
        by user code.`),er.forEach(l),ce=j(fr),Ae=g(fr,"LI",{});var qt=E(Ae);ye=g(qt,"CODE",{});var Mr=E(ye);Fe=f(Mr,"out"),Mr.forEach(l),Ve=f(qt,`. Global variables declared with the
        `),Ge=g(qt,"CODE",{});var wr=E(Ge);He=f(wr,"out"),wr.forEach(l),ze=f(qt,`-qualifier are shader stage output variables. These
        values are passed to the next stage of the pipeline. The shader must set
        all output variables at some point during execution; there are only two
        exceptions to this:
        `),xe=g(qt,"OL",{});var Nt=E(xe);Ne=g(Nt,"LI",{});var Wt=E(Ne);Te=f(Wt,"The shader is a Fragment Shader that executes the "),qe=g(Wt,"CODE",{});var xr=E(qe);Ke=f(xr,"discard"),xr.forEach(l),je=f(Wt,`
                statement.`),Wt.forEach(l),rt=j(Nt),Me=g(Nt,"LI",{});var pr=E(Me);Ue=f(pr,`The output variables that are not written are not read by the
                next shader stage or pipeline process. This includes writes to
                fragment shader outputs that are masked.`),pr.forEach(l),Nt.forEach(l),qt.forEach(l),$t=j(fr),ut=g(fr,"LI",{});var Vr=E(ut);ht=g(Vr,"CODE",{});var jt=E(ht);Je=f(jt,"buffer"),jt.forEach(l),dt=f(Vr,`. The storage for the contents of the block comes
        from a buffer object, similar to Uniform Buffer Objects and Uniform
        Blocks. Unlike UBOs, storage blocks can be written to.`),Vr.forEach(l),fr.forEach(l),et=j(Re),Ze=g(Re,"CODE",{});var Rr=E(Ze);nt=f(Rr,"block_name"),Rr.forEach(l),Qe=f(Re,` is the real name for the interface block. This is the
name used to refer to it. A shader cannot have multiple blocks that have the
same block_name and the same storage_qualifier. instance_name is a GLSL name for
one or more instances of the block named block_name. It's optional; if it is
present, all GLSL variables defined in the block must be qualified with the
instance name when referenced in the GLSL code.
`),S(ct.$$.fragment,Re),st=j(Re),S(We.$$.fragment,Re),at=g(Re,"BR",{}),bt=f(Re,`
A texel buffer is a special type of buffer binding used in a shader that can perform
format conversion when the data is read. Texel buffers are read-only and are declared
in GLSL using a `),wt=g(Re,"CODE",{});var Ir=E(wt);St=f(Ir,"samplerBuffer"),Ir.forEach(l),tt=f(Re,`-type variable. Sampler buffers can
return floating-point data or integers (signed or unsigned) to the shader.

`),S(ot.$$.fragment,Re),At=f(Re,`
To fetch a texel from a texelbuffer in GLSL, the `),S(it.$$.fragment,Re),Xe=f(Re," function is used with the sampler variable ("),Dt=g(Re,"CODE",{});var Nr=E(Dt);Ct=f(Nr,"floatTexelBuffer"),Nr.forEach(l),pt=f(Re,`,
`),Ft=g(Re,"CODE",{});var mr=E(Ft);mt=f(mr,"signedTexelBuffer"),mr.forEach(l),Vt=f(Re,`
or `),Rt=g(Re,"CODE",{});var Dr=E(Rt);Tt=f(Dr,"unsignedTexelBuffer"),Dr.forEach(l),vt=f(Re,`) to read individual texels. A
`),gt=g(Re,"CODE",{});var hr=E(gt);kt=f(hr,"samplerBuffer"),hr.forEach(l),Mt=f(Re,`
(or the corresponding `),yt=g(Re,"CODE",{});var Br=E(yt);Ht=f(Br,"isamplerBuffer"),Br.forEach(l),$r=f(Re,` and
`),Ut=g(Re,"CODE",{});var Cr=E(Ut);or=f(Cr,"usamplerBuffer"),Cr.forEach(l),Xt=f(Re,`) can be seen as a 1D texture that only supports
point sampling (because only one texel can be queried). However, the maximum
size of a texel buffer associated with one of these variables is generally much
larger than the maximum size of a 1D structure. For example, the minimum
required upper bound for a texel buffer in Vulkan is 65,535 elements, while the
minimum required size for a 1D texture is only 4,096 texels. In some cases
implementations will support texel buffers that are gigabytes in size.`),Ot=g(Re,"BR",{}),Zt=g(Re,"BR",{}),Ar=f(Re,`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants are logically
considered part of the pipeline's resources and therefore are declared along with
the other resources in the `),S(br.$$.fragment,Re),ur=f(Re," used to create pipeline objects."),Qt=g(Re,"BR",{}),Or=f(Re,`
To declare a push constant in GLSL, the `),rr=g(Re,"CODE",{});var en=E(rr);Kr=f(en,"push_constant"),en.forEach(l),lr=f(Re,` layout
qualifier can be used.
`),S(gr.$$.fragment,Re),Fr=f(Re,`
Push constants become part of the `),S(Kt.$$.fragment,Re),ir=f(Re,` that will use them. When push constants are pipelined, they can consume some of
the resources Vulkan would otherwise use to track pipeline or descriptor bindings.
Therefore, push constants should be considered relatively precious resources.`)},m(Re,lt){D(e,Re,lt),h(Re,t,lt),h(Re,r,lt),o(r,$),h(Re,n,lt),D(s,Re,lt),h(Re,a,lt),D(u,Re,lt),h(Re,p,lt),D(m,Re,lt),h(Re,_,lt),h(Re,v,lt),h(Re,P,lt),h(Re,R,lt),o(R,A),o(A,T),D(F,A,null),o(A,B),o(R,y),o(R,V),o(V,x),D(M,V,null),o(V,O),o(R,H),o(R,k),o(k,N),h(Re,Q,lt),h(Re,X,lt),h(Re,Z,lt),h(Re,K,lt),D(W,Re,lt),h(Re,q,lt),h(Re,U,lt),D(te,Re,lt),h(Re,ee,lt),h(Re,se,lt),o(se,ie),h(Re,ae,lt),h(Re,J,lt),o(J,pe),h(Re,Se,lt),h(Re,de,lt),o(de,me),o(me,De),o(De,_e),o(me,ne),o(de,le),o(de,ge),o(ge,we),o(we,Pe),o(ge,Be),o(ge,Ie),o(Ie,re),o(ge,he),o(ge,Le),o(Le,Oe),o(ge,oe),o(de,ce),o(de,Ae),o(Ae,ye),o(ye,Fe),o(Ae,Ve),o(Ae,Ge),o(Ge,He),o(Ae,ze),o(Ae,xe),o(xe,Ne),o(Ne,Te),o(Ne,qe),o(qe,Ke),o(Ne,je),o(xe,rt),o(xe,Me),o(Me,Ue),o(de,$t),o(de,ut),o(ut,ht),o(ht,Je),o(ut,dt),h(Re,et,lt),h(Re,Ze,lt),o(Ze,nt),h(Re,Qe,lt),D(ct,Re,lt),h(Re,st,lt),D(We,Re,lt),h(Re,at,lt),h(Re,bt,lt),h(Re,wt,lt),o(wt,St),h(Re,tt,lt),D(ot,Re,lt),h(Re,At,lt),D(it,Re,lt),h(Re,Xe,lt),h(Re,Dt,lt),o(Dt,Ct),h(Re,pt,lt),h(Re,Ft,lt),o(Ft,mt),h(Re,Vt,lt),h(Re,Rt,lt),o(Rt,Tt),h(Re,vt,lt),h(Re,gt,lt),o(gt,kt),h(Re,Mt,lt),h(Re,yt,lt),o(yt,Ht),h(Re,$r,lt),h(Re,Ut,lt),o(Ut,or),h(Re,Xt,lt),h(Re,Ot,lt),h(Re,Zt,lt),h(Re,Ar,lt),D(br,Re,lt),h(Re,ur,lt),h(Re,Qt,lt),h(Re,Or,lt),h(Re,rr,lt),o(rr,Kr),h(Re,lr,lt),D(gr,Re,lt),h(Re,Fr,lt),D(Kt,Re,lt),h(Re,ir,lt),yr=!0},p(Re,[lt]){const Jt={};lt&1&&(Jt.$$scope={dirty:lt,ctx:Re}),s.$set(Jt);const _r={};lt&1&&(_r.$$scope={dirty:lt,ctx:Re}),u.$set(_r);const Yt={};lt&1&&(Yt.$$scope={dirty:lt,ctx:Re}),m.$set(Yt);const nr={};lt&1&&(nr.$$scope={dirty:lt,ctx:Re}),F.$set(nr);const vr={};lt&1&&(vr.$$scope={dirty:lt,ctx:Re}),M.$set(vr);const Tr={};lt&1&&(Tr.$$scope={dirty:lt,ctx:Re}),it.$set(Tr);const fr={};lt&1&&(fr.$$scope={dirty:lt,ctx:Re}),br.$set(fr);const cr={};lt&1&&(cr.$$scope={dirty:lt,ctx:Re}),Kt.$set(cr)},i(Re){yr||(b(e.$$.fragment,Re),b(s.$$.fragment,Re),b(u.$$.fragment,Re),b(m.$$.fragment,Re),b(F.$$.fragment,Re),b(M.$$.fragment,Re),b(W.$$.fragment,Re),b(te.$$.fragment,Re),b(ct.$$.fragment,Re),b(We.$$.fragment,Re),b(ot.$$.fragment,Re),b(it.$$.fragment,Re),b(br.$$.fragment,Re),b(gr.$$.fragment,Re),b(Kt.$$.fragment,Re),yr=!0)},o(Re){w(e.$$.fragment,Re),w(s.$$.fragment,Re),w(u.$$.fragment,Re),w(m.$$.fragment,Re),w(F.$$.fragment,Re),w(M.$$.fragment,Re),w(W.$$.fragment,Re),w(te.$$.fragment,Re),w(ct.$$.fragment,Re),w(We.$$.fragment,Re),w(ot.$$.fragment,Re),w(it.$$.fragment,Re),w(br.$$.fragment,Re),w(gr.$$.fragment,Re),w(Kt.$$.fragment,Re),yr=!1},d(Re){C(e,Re),Re&&l(t),Re&&l(r),Re&&l(n),C(s,Re),Re&&l(a),C(u,Re),Re&&l(p),C(m,Re),Re&&l(_),Re&&l(v),Re&&l(P),Re&&l(R),C(F),C(M),Re&&l(Q),Re&&l(X),Re&&l(Z),Re&&l(K),C(W,Re),Re&&l(q),Re&&l(U),C(te,Re),Re&&l(ee),Re&&l(se),Re&&l(ae),Re&&l(J),Re&&l(Se),Re&&l(de),Re&&l(et),Re&&l(Ze),Re&&l(Qe),C(ct,Re),Re&&l(st),C(We,Re),Re&&l(at),Re&&l(bt),Re&&l(wt),Re&&l(tt),C(ot,Re),Re&&l(At),C(it,Re),Re&&l(Xe),Re&&l(Dt),Re&&l(pt),Re&&l(Ft),Re&&l(Vt),Re&&l(Rt),Re&&l(vt),Re&&l(gt),Re&&l(Mt),Re&&l(yt),Re&&l($r),Re&&l(Ut),Re&&l(Xt),Re&&l(Ot),Re&&l(Zt),Re&&l(Ar),C(br,Re),Re&&l(ur),Re&&l(Qt),Re&&l(Or),Re&&l(rr),Re&&l(lr),C(gr,Re),Re&&l(Fr),C(Kt,Re),Re&&l(ir)}}}class _F extends ve{constructor(e){super(),Ee(this,e,null,gF,be,{})}}function vF(c){let e;return{c(){e=i("Descriptor Set Layout Builder")},l(t){e=f(t,"Descriptor Set Layout Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EF(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[vF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Set Layout."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Set Layout by it's Constructor,
        but to use a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Set Layout."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Set Layout by it's Constructor,
        but to use a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function bF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wF(c){let e;return{c(){e=i("VkDescriptorSetLayoutBinding")},l(t){e=f(t,"VkDescriptorSetLayoutBinding")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IF(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[bF]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[wF]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Descriptor Set Layout should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("bindings"),P=d("br"),R=i(`
            A list of `),I(A.$$.fragment),T=i("-structures."),F=d("br"),B=i(`
            Resources are bound by binding points in the descriptor set. Each member
            of the supplied list provides a description of a descriptor set layout
            binding.`),this.h()},l(V){e=g(V,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var M=E(t);r=g(M,"CODE",{});var O=E(r);$=f(O,"pLogicalDevice"),O.forEach(l),n=g(M,"BR",{}),s=f(M,`
            A pointer to the `),S(a.$$.fragment,M),u=f(M," the Descriptor Set Layout should be associated with."),M.forEach(l),p=j(x),m=g(x,"LI",{});var H=E(m);_=g(H,"CODE",{});var k=E(_);v=f(k,"bindings"),k.forEach(l),P=g(H,"BR",{}),R=f(H,`
            A list of `),S(A.$$.fragment,H),T=f(H,"-structures."),F=g(H,"BR",{}),B=f(H,`
            Resources are bound by binding points in the descriptor set. Each member
            of the supplied list provides a description of a descriptor set layout
            binding.`),H.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,x){h(V,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(m,F),o(m,B),y=!0},p(V,x){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),a.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),A.$set(O)},i(V){y||(b(a.$$.fragment,V),b(A.$$.fragment,V),y=!0)},o(V){w(a.$$.fragment,V),w(A.$$.fragment,V),y=!1},d(V){V&&l(e),C(a),C(A)}}}function DF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CF(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[DF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function SF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSetLayout(LogicalDevice* pLogicalDevice, std::vector<VkDescriptorSetLayoutBinding> bindings);"}}),r=new Ce({props:{$$slots:{throws:[CF],params:[IF],details:[EF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class PF extends ve{constructor(e){super(),Ee(this,e,null,SF,be,{})}}function AF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RF(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[AF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function BF(c){let e;return{c(){e=i("Vulkan Descriptor Set Layout")},l(t){e=f(t,"Vulkan Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LF(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html",target:"_blank",$$slots:{default:[BF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function kF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkDescriptorSetLayout getDescriptorSetLayoutHandle() const;"}}),r=new Ce({props:{$$slots:{return:[LF],details:[RF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TF extends ve{constructor(e){super(),Ee(this,e,null,kF,be,{})}}function VF(c){let e,t;return{c(){e=d("span"),t=i("Get a list of the Descriptor Set Layout Bindings.."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get a list of the Descriptor Set Layout Bindings.."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function OF(c){let e,t;return{c(){e=d("span"),t=i("A list of the Descriptor Set Layout Bindings.."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"A list of the Descriptor Set Layout Bindings.."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function FF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkDescriptorSetLayoutBinding>& getBindings() const;"}}),r=new Ce({props:{$$slots:{return:[OF],details:[VF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yF extends ve{constructor(e){super(),Ee(this,e,null,FF,be,{})}}function MF(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/descriptor_set_layout_builder.hpp>"}}),m=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
std::vector<VkDescriptorSetLayoutBinding> bindings = {};`}}),P=new $e({props:{language:hn,code:`#version 450 core

layout (local_size_x=256, local_size_y=1, local_size_z=1) in;

layout (set=0, binding=0) uniform Config
{
    int transform;
    int integerCount;
} configData;

layout (set=0, binding=1) readonly buffer InputBuffer
{
    int integers[4096];
} inputData;

layout (set=0, binding=2) buffer OutputBuffer
{
    int integers[4096];
} outputData;

void main(void)
{
    // Grab global ID
    uint globalID = gl_GlobalInvocationID.x;

    // Don't access past the buffer size
    if (globalID < configData.integerCount)
    {
        // Perform some calculations
        outputData.integers[globalID] = inputData.integers[globalID] * configData.transform;
    }
}
`}}),A=new $e({props:{language:ue,code:`fillcan::DescriptorSetLayoutBuilder descriptorSetLayoutBuilder{};
descriptorSetLayoutBuilder.setLogicalDevice(fillcan.getCurrentDevice());

// Config
descriptorSetLayoutBuilder.addBinding(0, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

// InputBuffer
descriptorSetLayoutBuilder.addBinding(1, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

// OutputBuffer
descriptorSetLayoutBuilder.addBinding(2, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_COMPUTE_BIT);

fillcan::DescriptorSetLayout descriptorSetLayout = descriptorSetLayoutBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Set Layout Builder"),n=i(` class is part of the creational
design pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(P.$$.fragment),R=Y(),I(A.$$.fragment)},l(F){S(e.$$.fragment,F),t=f(F,`
The `),r=g(F,"CODE",{});var B=E(r);$=f(B,"Descriptor Set Layout Builder"),B.forEach(l),n=f(F,` class is part of the creational
design pattern to construct complex objects step by step.`),s=g(F,"BR",{}),a=f(F,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(F,"BR",{}),p=f(F,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,F),_=g(F,"BR",{}),v=f(F,`
Example:
`),S(P.$$.fragment,F),R=j(F),S(A.$$.fragment,F)},m(F,B){D(e,F,B),h(F,t,B),h(F,r,B),o(r,$),h(F,n,B),h(F,s,B),h(F,a,B),h(F,u,B),h(F,p,B),D(m,F,B),h(F,_,B),h(F,v,B),D(P,F,B),h(F,R,B),D(A,F,B),T=!0},p:ke,i(F){T||(b(e.$$.fragment,F),b(m.$$.fragment,F),b(P.$$.fragment,F),b(A.$$.fragment,F),T=!0)},o(F){w(e.$$.fragment,F),w(m.$$.fragment,F),w(P.$$.fragment,F),w(A.$$.fragment,F),T=!1},d(F){C(e,F),F&&l(t),F&&l(r),F&&l(n),F&&l(s),F&&l(a),F&&l(u),F&&l(p),C(m,F),F&&l(_),F&&l(v),C(P,F),F&&l(R),C(A,F)}}}class xF extends ve{constructor(e){super(),Ee(this,e,null,MF,be,{})}}function NF(c){let e,t;return{c(){e=d("span"),t=i("Create a new Descriptor Set Layout Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Descriptor Set Layout Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function UF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSetLayoutBuilder();"}}),r=new Ce({props:{$$slots:{details:[NF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GF extends ve{constructor(e){super(),Ee(this,e,null,UF,be,{})}}function HF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qF(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WF(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[HF]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[qF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function QF(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KF(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zF(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[QF]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[KF]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R," should be associated with."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function YF(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[zF],details:[WF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class jF extends ve{constructor(e){super(),Ee(this,e,null,YF,be,{})}}function XF(c){let e;return{c(){e=i("descriptor set layout binding")},l(t){e=f(t,"descriptor set layout binding")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZF(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JF(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html",target:"_blank",$$slots:{default:[XF]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[ZF]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Add a "),I(r.$$.fragment),$=i(". Resources are bound by binding points in the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Add a "),S(r.$$.fragment,p),$=f(p,". Resources are bound by binding points in the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function ey(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ty(c){let e;return{c(){e=i("VkDescriptorType")},l(t){e=f(t,"VkDescriptorType")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ry(c){let e;return{c(){e=i("VkShaderStageFlagBits")},l(t){e=f(t,"VkShaderStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ny(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sy(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ay(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oy(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ly(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iy(c){let e;return{c(){e=i("samplers")},l(t){e=f(t,"samplers")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fy(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cy(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[ey]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorType.html",target:"_blank",$$slots:{default:[ty]},$$scope:{ctx:c}}}),De=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html",target:"_blank",$$slots:{default:[ry]},$$scope:{ctx:c}}}),Ie=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[ny]},$$scope:{ctx:c}}}),xe=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[sy]},$$scope:{ctx:c}}}),Te=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[ay]},$$scope:{ctx:c}}}),Me=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[oy]},$$scope:{ctx:c}}}),Je=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[ly]},$$scope:{ctx:c}}}),et=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[iy]},$$scope:{ctx:c}}}),nt=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[fy]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            Each resource accessible to a shader is assigned a binding number. The
            bindings used in a `),I(a.$$.fragment),u=i(` do not have to be contiguous and there may be gaps (unused binding
            numbers) in a set. However, it is recommended that sparsely populated
            sets are not created as this can waste resources in the device.`),p=Y(),m=d("li"),_=d("code"),v=i("descriptorType"),P=d("br"),R=i(`
            The type descriptor on this binding point. This is a member of the `),I(A.$$.fragment),T=i("-enumerator."),F=Y(),B=d("li"),y=d("code"),V=i("descriptorCount"),x=d("br"),M=i(`
            The number of descriptors in the binding, accessible in a shader as an
            array, unless `),O=d("code"),H=i("descriptorType"),k=i(` is
            `),N=d("code"),Q=i("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),X=i(`. In that case,
            `),Z=d("code"),K=i("descriptorCount"),W=i(` is the size in bytes of the inline
            uniform block. If
            `),q=d("code"),U=i("descriptorCount"),te=i(" is "),ee=d("code"),se=i("0"),ie=i(`, this binding entry
            is reserved and the resource should not be accessed from any stage
            through this binding within a pipeline with the layout set.`),ae=Y(),J=d("li"),pe=d("code"),Se=i("stageFlags"),de=d("br"),me=i(`
            A bitmask of the `),I(De.$$.fragment),_e=i(`-enumerant that specifies which pipeline shader stages can access a
            resource for this binding.`),ne=Y(),le=d("li"),ge=d("code"),we=i("immutableSamplers"),Pe=d("br"),Be=i(`
            Affects `),I(Ie.$$.fragment),re=i(`
            initialization. If `),he=d("code"),Le=i("descriptorType"),Oe=i(`
            specifies a
            `),oe=d("code"),ce=i("VK_DESCRIPTOR_TYPE_SAMPLER"),Ae=i(`
            or `),ye=d("code"),Fe=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Ve=i(` type
            descriptor, then `),Ge=d("code"),He=i("pImmutableSamplers"),ze=i(` can be used to
            initialize a set of immutable `),I(xe.$$.fragment),Ne=i(". Immutable "),I(Te.$$.fragment),qe=i(` are permanently embedded in the set layout and should not be modified;
            updating a
            `),Ke=d("code"),je=i("VK_DESCRIPTOR_TYPE_SAMPLER"),rt=i(` descriptor with immutable
            `),I(Me.$$.fragment),Ue=i(` is not
            allowed and updates of a
            `),$t=d("code"),ut=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),ht=i(`
            descriptor with immutable `),I(Je.$$.fragment),dt=i(" do not change the "),I(et.$$.fragment),Ze=i(" (the image views are updated, but the "),I(nt.$$.fragment),Qe=i(" updates are ignored)."),this.h()},l(st){e=g(st,"DIV",{slot:!0});var We=E(e);t=g(We,"LI",{});var at=E(t);r=g(at,"CODE",{});var bt=E(r);$=f(bt,"binding"),bt.forEach(l),n=g(at,"BR",{}),s=f(at,`
            Each resource accessible to a shader is assigned a binding number. The
            bindings used in a `),S(a.$$.fragment,at),u=f(at,` do not have to be contiguous and there may be gaps (unused binding
            numbers) in a set. However, it is recommended that sparsely populated
            sets are not created as this can waste resources in the device.`),at.forEach(l),p=j(We),m=g(We,"LI",{});var wt=E(m);_=g(wt,"CODE",{});var St=E(_);v=f(St,"descriptorType"),St.forEach(l),P=g(wt,"BR",{}),R=f(wt,`
            The type descriptor on this binding point. This is a member of the `),S(A.$$.fragment,wt),T=f(wt,"-enumerator."),wt.forEach(l),F=j(We),B=g(We,"LI",{});var tt=E(B);y=g(tt,"CODE",{});var ot=E(y);V=f(ot,"descriptorCount"),ot.forEach(l),x=g(tt,"BR",{}),M=f(tt,`
            The number of descriptors in the binding, accessible in a shader as an
            array, unless `),O=g(tt,"CODE",{});var At=E(O);H=f(At,"descriptorType"),At.forEach(l),k=f(tt,` is
            `),N=g(tt,"CODE",{});var it=E(N);Q=f(it,"VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),it.forEach(l),X=f(tt,`. In that case,
            `),Z=g(tt,"CODE",{});var Xe=E(Z);K=f(Xe,"descriptorCount"),Xe.forEach(l),W=f(tt,` is the size in bytes of the inline
            uniform block. If
            `),q=g(tt,"CODE",{});var Dt=E(q);U=f(Dt,"descriptorCount"),Dt.forEach(l),te=f(tt," is "),ee=g(tt,"CODE",{});var Ct=E(ee);se=f(Ct,"0"),Ct.forEach(l),ie=f(tt,`, this binding entry
            is reserved and the resource should not be accessed from any stage
            through this binding within a pipeline with the layout set.`),tt.forEach(l),ae=j(We),J=g(We,"LI",{});var pt=E(J);pe=g(pt,"CODE",{});var Ft=E(pe);Se=f(Ft,"stageFlags"),Ft.forEach(l),de=g(pt,"BR",{}),me=f(pt,`
            A bitmask of the `),S(De.$$.fragment,pt),_e=f(pt,`-enumerant that specifies which pipeline shader stages can access a
            resource for this binding.`),pt.forEach(l),ne=j(We),le=g(We,"LI",{});var mt=E(le);ge=g(mt,"CODE",{});var Vt=E(ge);we=f(Vt,"immutableSamplers"),Vt.forEach(l),Pe=g(mt,"BR",{}),Be=f(mt,`
            Affects `),S(Ie.$$.fragment,mt),re=f(mt,`
            initialization. If `),he=g(mt,"CODE",{});var Rt=E(he);Le=f(Rt,"descriptorType"),Rt.forEach(l),Oe=f(mt,`
            specifies a
            `),oe=g(mt,"CODE",{});var Tt=E(oe);ce=f(Tt,"VK_DESCRIPTOR_TYPE_SAMPLER"),Tt.forEach(l),Ae=f(mt,`
            or `),ye=g(mt,"CODE",{});var vt=E(ye);Fe=f(vt,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),vt.forEach(l),Ve=f(mt,` type
            descriptor, then `),Ge=g(mt,"CODE",{});var gt=E(Ge);He=f(gt,"pImmutableSamplers"),gt.forEach(l),ze=f(mt,` can be used to
            initialize a set of immutable `),S(xe.$$.fragment,mt),Ne=f(mt,". Immutable "),S(Te.$$.fragment,mt),qe=f(mt,` are permanently embedded in the set layout and should not be modified;
            updating a
            `),Ke=g(mt,"CODE",{});var kt=E(Ke);je=f(kt,"VK_DESCRIPTOR_TYPE_SAMPLER"),kt.forEach(l),rt=f(mt,` descriptor with immutable
            `),S(Me.$$.fragment,mt),Ue=f(mt,` is not
            allowed and updates of a
            `),$t=g(mt,"CODE",{});var Mt=E($t);ut=f(Mt,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Mt.forEach(l),ht=f(mt,`
            descriptor with immutable `),S(Je.$$.fragment,mt),dt=f(mt," do not change the "),S(et.$$.fragment,mt),Ze=f(mt," (the image views are updated, but the "),S(nt.$$.fragment,mt),Qe=f(mt," updates are ignored)."),mt.forEach(l),We.forEach(l),this.h()},h(){z(e,"slot","params")},m(st,We){h(st,e,We),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),o(B,O),o(O,H),o(B,k),o(B,N),o(N,Q),o(B,X),o(B,Z),o(Z,K),o(B,W),o(B,q),o(q,U),o(B,te),o(B,ee),o(ee,se),o(B,ie),o(e,ae),o(e,J),o(J,pe),o(pe,Se),o(J,de),o(J,me),D(De,J,null),o(J,_e),o(e,ne),o(e,le),o(le,ge),o(ge,we),o(le,Pe),o(le,Be),D(Ie,le,null),o(le,re),o(le,he),o(he,Le),o(le,Oe),o(le,oe),o(oe,ce),o(le,Ae),o(le,ye),o(ye,Fe),o(le,Ve),o(le,Ge),o(Ge,He),o(le,ze),D(xe,le,null),o(le,Ne),D(Te,le,null),o(le,qe),o(le,Ke),o(Ke,je),o(le,rt),D(Me,le,null),o(le,Ue),o(le,$t),o($t,ut),o(le,ht),D(Je,le,null),o(le,dt),D(et,le,null),o(le,Ze),D(nt,le,null),o(le,Qe),ct=!0},p(st,We){const at={};We&1&&(at.$$scope={dirty:We,ctx:st}),a.$set(at);const bt={};We&1&&(bt.$$scope={dirty:We,ctx:st}),A.$set(bt);const wt={};We&1&&(wt.$$scope={dirty:We,ctx:st}),De.$set(wt);const St={};We&1&&(St.$$scope={dirty:We,ctx:st}),Ie.$set(St);const tt={};We&1&&(tt.$$scope={dirty:We,ctx:st}),xe.$set(tt);const ot={};We&1&&(ot.$$scope={dirty:We,ctx:st}),Te.$set(ot);const At={};We&1&&(At.$$scope={dirty:We,ctx:st}),Me.$set(At);const it={};We&1&&(it.$$scope={dirty:We,ctx:st}),Je.$set(it);const Xe={};We&1&&(Xe.$$scope={dirty:We,ctx:st}),et.$set(Xe);const Dt={};We&1&&(Dt.$$scope={dirty:We,ctx:st}),nt.$set(Dt)},i(st){ct||(b(a.$$.fragment,st),b(A.$$.fragment,st),b(De.$$.fragment,st),b(Ie.$$.fragment,st),b(xe.$$.fragment,st),b(Te.$$.fragment,st),b(Me.$$.fragment,st),b(Je.$$.fragment,st),b(et.$$.fragment,st),b(nt.$$.fragment,st),ct=!0)},o(st){w(a.$$.fragment,st),w(A.$$.fragment,st),w(De.$$.fragment,st),w(Ie.$$.fragment,st),w(xe.$$.fragment,st),w(Te.$$.fragment,st),w(Me.$$.fragment,st),w(Je.$$.fragment,st),w(et.$$.fragment,st),w(nt.$$.fragment,st),ct=!1},d(st){st&&l(e),C(a),C(A),C(De),C(Ie),C(xe),C(Te),C(Me),C(Je),C(et),C(nt)}}}function $y(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void addBinding(
    unsigned int binding, 
    VkDescriptorType descriptorType, 
    unsigned int descriptorCount, 
    VkShaderStageFlags stageFlags,
    std::vector<VkSampler> immutableSamplers = {}
);`}}),r=new Ce({props:{$$slots:{params:[cy],details:[JF]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uy extends ve{constructor(e){super(),Ee(this,e,null,$y,be,{})}}function py(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function my(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[py]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hy(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dy(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gy(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[hy]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[dy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function _y(c){let e;return{c(){e=i("Descriptor Set Layout")},l(t){e=f(t,"Descriptor Set Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vy(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[_y]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Ey(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<DescriptorSetLayout> getResult();"}}),r=new Ce({props:{$$slots:{throws:[vy],return:[gy],details:[my]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class by extends ve{constructor(e){super(),Ee(this,e,null,Ey,be,{})}}function wy(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iy(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Dy(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[Iy],default:[wy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Cy extends ve{constructor(e){super(),Ee(this,e,null,Dy,be,{})}}function Sy(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Py(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ay(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ry(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function By(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/descriptor_pool.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Sy]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Py]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[Ay]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Ry]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Descriptor Pool"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with flags describing the supported operations and information about the
`),I(u.$$.fragment),p=i(` to be
allocated and uses this information to construct a `),I(m.$$.fragment),_=i(" from which it can allocate "),I(v.$$.fragment),P=i("."),R=d("br"),A=d("br"),T=i(`
Resources are represented by descriptors and are bound to the pipeline by first binding
their descriptors into sets and then binding those descriptor sets to the pipeline.
This allows a large number of resources to be bound with very little processing time,
as the exact set of resources used by a particular drawing command can be predetermined
and the descriptor set containing them can be pre-created.`),F=d("br"),B=i(`
The descriptors are allocated from descriptor pools. Descriptors for different types of resources are likely to
have similar data structures in a given implementation. Pooling the mappings used
to store descriptors allows drivers to make efficient use of memory.`)},l(V){S(e.$$.fragment,V),t=f(V,`

The `),r=g(V,"CODE",{});var x=E(r);$=f(x,"Descriptor Pool"),x.forEach(l),n=f(V," class takes a pointer to a "),S(s.$$.fragment,V),a=f(V,` along with flags describing the supported operations and information about the
`),S(u.$$.fragment,V),p=f(V,` to be
allocated and uses this information to construct a `),S(m.$$.fragment,V),_=f(V," from which it can allocate "),S(v.$$.fragment,V),P=f(V,"."),R=g(V,"BR",{}),A=g(V,"BR",{}),T=f(V,`
Resources are represented by descriptors and are bound to the pipeline by first binding
their descriptors into sets and then binding those descriptor sets to the pipeline.
This allows a large number of resources to be bound with very little processing time,
as the exact set of resources used by a particular drawing command can be predetermined
and the descriptor set containing them can be pre-created.`),F=g(V,"BR",{}),B=f(V,`
The descriptors are allocated from descriptor pools. Descriptors for different types of resources are likely to
have similar data structures in a given implementation. Pooling the mappings used
to store descriptors allows drivers to make efficient use of memory.`)},m(V,x){D(e,V,x),h(V,t,x),h(V,r,x),o(r,$),h(V,n,x),D(s,V,x),h(V,a,x),D(u,V,x),h(V,p,x),D(m,V,x),h(V,_,x),D(v,V,x),h(V,P,x),h(V,R,x),h(V,A,x),h(V,T,x),h(V,F,x),h(V,B,x),y=!0},p(V,[x]){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),s.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),u.$set(O);const H={};x&1&&(H.$$scope={dirty:x,ctx:V}),m.$set(H);const k={};x&1&&(k.$$scope={dirty:x,ctx:V}),v.$set(k)},i(V){y||(b(e.$$.fragment,V),b(s.$$.fragment,V),b(u.$$.fragment,V),b(m.$$.fragment,V),b(v.$$.fragment,V),y=!0)},o(V){w(e.$$.fragment,V),w(s.$$.fragment,V),w(u.$$.fragment,V),w(m.$$.fragment,V),w(v.$$.fragment,V),y=!1},d(V){C(e,V),V&&l(t),V&&l(r),V&&l(n),C(s,V),V&&l(a),C(u,V),V&&l(p),C(m,V),V&&l(_),C(v,V),V&&l(P),V&&l(R),V&&l(A),V&&l(T),V&&l(F),V&&l(B)}}}class Ly extends ve{constructor(e){super(),Ee(this,e,null,By,be,{})}}function ky(c){let e;return{c(){e=i("Descriptor Pool Builder")},l(t){e=f(t,"Descriptor Pool Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ty(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.DESCRIPTOR_POOL_BUILDER,$$slots:{default:[ky]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Pool."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Pool by it's Constructor, but
        to use a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Pool."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Pool by it's Constructor, but
        to use a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Vy(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Oy(c){let e;return{c(){e=i("VkDescriptorPoolCreateFlagBits")},l(t){e=f(t,"VkDescriptorPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fy(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yy(c){let e;return{c(){e=i("VkDescriptorPoolSize")},l(t){e=f(t,"VkDescriptorPoolSize")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function My(c){let e;return{c(){e=i("VkDescriptorPoolSize")},l(t){e=f(t,"VkDescriptorPoolSize")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xy(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Vy]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[Oy]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Fy]},$$scope:{ctx:c}}}),W=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html",target:"_blank",$$slots:{default:[yy]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html",target:"_blank",$$slots:{default:[My]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Descriptor Pool should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(` that specify additional information about the allocation strategy to
            use to manage the resources consumed by the pool.`),F=Y(),B=d("li"),y=d("code"),V=i("maxSets"),x=d("br"),M=i(`
            The maximum total number of `),I(O.$$.fragment),H=i(" that can be allocated from the pool."),k=Y(),N=d("li"),Q=d("code"),X=i("poolSizes"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),q=i(`-structures where each structure specifies the number of
            descriptors of a particular type that can be allocated from the
            pool.`),U=d("br"),te=i(`
            If no element in the list specifies a particular type of resource, then
            no descriptors of that type can be allocated from the resulting pool. If
            a particular resource type appears twice in the array, the sum of all
            their
            `),ee=d("code"),se=i("descriptorCount"),ie=i(`
            fields (of the `),I(ae.$$.fragment),J=i(`-structure) is used to determine the pool for that resource type.
            The total number of resources in the pool is distributed across the
            sets allocated from the pool.`),this.h()},l(Se){e=g(Se,"DIV",{slot:!0});var de=E(e);t=g(de,"LI",{});var me=E(t);r=g(me,"CODE",{});var De=E(r);$=f(De,"pLogicalDevice"),De.forEach(l),n=g(me,"BR",{}),s=f(me,`
            A pointer to the `),S(a.$$.fragment,me),u=f(me," the Descriptor Pool should be associated with."),me.forEach(l),p=j(de),m=g(de,"LI",{});var _e=E(m);_=g(_e,"CODE",{});var ne=E(_);v=f(ne,"flags"),ne.forEach(l),P=g(_e,"BR",{}),R=f(_e,`
            A bitmask of `),S(A.$$.fragment,_e),T=f(_e,` that specify additional information about the allocation strategy to
            use to manage the resources consumed by the pool.`),_e.forEach(l),F=j(de),B=g(de,"LI",{});var le=E(B);y=g(le,"CODE",{});var ge=E(y);V=f(ge,"maxSets"),ge.forEach(l),x=g(le,"BR",{}),M=f(le,`
            The maximum total number of `),S(O.$$.fragment,le),H=f(le," that can be allocated from the pool."),le.forEach(l),k=j(de),N=g(de,"LI",{});var we=E(N);Q=g(we,"CODE",{});var Pe=E(Q);X=f(Pe,"poolSizes"),Pe.forEach(l),Z=g(we,"BR",{}),K=f(we,`
            A list of `),S(W.$$.fragment,we),q=f(we,`-structures where each structure specifies the number of
            descriptors of a particular type that can be allocated from the
            pool.`),U=g(we,"BR",{}),te=f(we,`
            If no element in the list specifies a particular type of resource, then
            no descriptors of that type can be allocated from the resulting pool. If
            a particular resource type appears twice in the array, the sum of all
            their
            `),ee=g(we,"CODE",{});var Be=E(ee);se=f(Be,"descriptorCount"),Be.forEach(l),ie=f(we,`
            fields (of the `),S(ae.$$.fragment,we),J=f(we,`-structure) is used to determine the pool for that resource type.
            The total number of resources in the pool is distributed across the
            sets allocated from the pool.`),we.forEach(l),de.forEach(l),this.h()},h(){z(e,"slot","params")},m(Se,de){h(Se,e,de),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(N,U),o(N,te),o(N,ee),o(ee,se),o(N,ie),D(ae,N,null),o(N,J),pe=!0},p(Se,de){const me={};de&1&&(me.$$scope={dirty:de,ctx:Se}),a.$set(me);const De={};de&1&&(De.$$scope={dirty:de,ctx:Se}),A.$set(De);const _e={};de&1&&(_e.$$scope={dirty:de,ctx:Se}),O.$set(_e);const ne={};de&1&&(ne.$$scope={dirty:de,ctx:Se}),W.$set(ne);const le={};de&1&&(le.$$scope={dirty:de,ctx:Se}),ae.$set(le)},i(Se){pe||(b(a.$$.fragment,Se),b(A.$$.fragment,Se),b(O.$$.fragment,Se),b(W.$$.fragment,Se),b(ae.$$.fragment,Se),pe=!0)},o(Se){w(a.$$.fragment,Se),w(A.$$.fragment,Se),w(O.$$.fragment,Se),w(W.$$.fragment,Se),w(ae.$$.fragment,Se),pe=!1},d(Se){Se&&l(e),C(a),C(A),C(O),C(W),C(ae)}}}function Ny(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uy(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html",target:"_blank",$$slots:{default:[Ny]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Gy(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSetLayout(LogicalDevice* pLogicalDevice, std::vector<VkDescriptorSetLayoutBinding> bindings);"}}),r=new Ce({props:{$$slots:{throws:[Uy],params:[xy],details:[Ty]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Hy extends ve{constructor(e){super(),Ee(this,e,null,Gy,be,{})}}function qy(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wy(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[qy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Qy(c){let e;return{c(){e=i("Vulkan Descriptor Pool")},l(t){e=f(t,"Vulkan Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ky(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html",target:"_blank",$$slots:{default:[Qy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function zy(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkDescriptorPool getDescriptorPoolHandle() const;"}}),r=new Ce({props:{$$slots:{return:[Ky],details:[Wy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Yy extends ve{constructor(e){super(),Ee(this,e,null,zy,be,{})}}function jy(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Xy(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zy(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jy(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[jy]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Xy]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[Zy]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Allocate a single "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Assigns a block with descriptors from the pool by creating a new `),I(a.$$.fragment),u=i(". The given "),p=d("code"),m=i("name"),_=i(` can be used as an identifier to retrieve
        and identify the allocated
        `),I(v.$$.fragment),P=i("."),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=f(T,"Allocate a single "),S(r.$$.fragment,T),$=f(T,"."),n=g(T,"BR",{}),s=f(T,`
        Assigns a block with descriptors from the pool by creating a new `),S(a.$$.fragment,T),u=f(T,". The given "),p=g(T,"CODE",{});var F=E(p);m=f(F,"name"),F.forEach(l),_=f(T,` can be used as an identifier to retrieve
        and identify the allocated
        `),S(v.$$.fragment,T),P=f(T,"."),T.forEach(l),this.h()},h(){z(e,"slot","details")},m(A,T){h(A,e,T),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,P),R=!0},p(A,T){const F={};T&1&&(F.$$scope={dirty:T,ctx:A}),r.$set(F);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),a.$set(B);const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),v.$set(y)},i(A){R||(b(r.$$.fragment,A),b(a.$$.fragment,A),b(v.$$.fragment,A),R=!0)},o(A){w(r.$$.fragment,A),w(a.$$.fragment,A),w(v.$$.fragment,A),R=!1},d(A){A&&l(e),C(r),C(a),C(v)}}}function eM(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nM(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y;return a=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[eM]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[tM]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[rM]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSetLayout"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" describing the "),I(p.$$.fragment),m=i("."),_=Y(),v=d("li"),P=d("code"),R=i("name"),A=d("br"),T=i(`
            The identifying name of the `),I(F.$$.fragment),B=i("."),this.h()},l(V){e=g(V,"DIV",{slot:!0});var x=E(e);t=g(x,"LI",{});var M=E(t);r=g(M,"CODE",{});var O=E(r);$=f(O,"pDescriptorSetLayout"),O.forEach(l),n=g(M,"BR",{}),s=f(M,`
            A pointer to the `),S(a.$$.fragment,M),u=f(M," describing the "),S(p.$$.fragment,M),m=f(M,"."),M.forEach(l),_=j(x),v=g(x,"LI",{});var H=E(v);P=g(H,"CODE",{});var k=E(P);R=f(k,"name"),k.forEach(l),A=g(H,"BR",{}),T=f(H,`
            The identifying name of the `),S(F.$$.fragment,H),B=f(H,"."),H.forEach(l),x.forEach(l),this.h()},h(){z(e,"slot","params")},m(V,x){h(V,e,x),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),y=!0},p(V,x){const M={};x&1&&(M.$$scope={dirty:x,ctx:V}),a.$set(M);const O={};x&1&&(O.$$scope={dirty:x,ctx:V}),p.$set(O);const H={};x&1&&(H.$$scope={dirty:x,ctx:V}),F.$set(H)},i(V){y||(b(a.$$.fragment,V),b(p.$$.fragment,V),b(F.$$.fragment,V),y=!0)},o(V){w(a.$$.fragment,V),w(p.$$.fragment,V),w(F.$$.fragment,V),y=!1},d(V){V&&l(e),C(a),C(p),C(F)}}}function sM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aM(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[sM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the created "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the created "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function oM(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lM(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[oM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" failed to be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," failed to be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function iM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSet* allocateDescriptorSet(DescriptorSetLayout* pDescriptorSetLayout, std::string name);"}}),r=new Ce({props:{$$slots:{throws:[lM],return:[aM],params:[nM],details:[Jy]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fM extends ve{constructor(e){super(),Ee(this,e,null,iM,be,{})}}function cM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $M(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[cM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function uM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pM(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[uM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to the allocated "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of pointers to the allocated "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function mM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<DescriptorSet*> getDescriptorSets();"}}),r=new Ce({props:{$$slots:{return:[pM],details:[$M]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hM extends ve{constructor(e){super(),Ee(this,e,null,mM,be,{})}}function dM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gM(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[dM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get an allocated "),I(r.$$.fragment),$=i(" by name."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get an allocated "),S(r.$$.fragment,a),$=f(a," by name."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _M(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vM(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[_M]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"name"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The name of the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function EM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bM(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wM(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[EM]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[bM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the requested "),I(r.$$.fragment),$=i(" or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" with the given name was found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the requested "),S(r.$$.fragment,v),$=f(v," or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," with the given name was found."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function IM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSet* getDescriptorSet(std::string name);"}}),r=new Ce({props:{$$slots:{return:[wM],params:[vM],details:[gM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DM extends ve{constructor(e){super(),Ee(this,e,null,IM,be,{})}}function CM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PM(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[CM]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[SM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free all the allocated "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        If the descriptor pool was created with the `),a=d("code"),u=i("flags"),p=i(` field set
        to `),m=d("code"),_=i("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),v=i(`,
        `),I(P.$$.fragment),R=i(` can be returned to the pool by freeing them.
    `),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var F=E(e);t=f(F,"Free all the allocated "),S(r.$$.fragment,F),$=f(F,"."),n=g(F,"BR",{}),s=f(F,`
        If the descriptor pool was created with the `),a=g(F,"CODE",{});var B=E(a);u=f(B,"flags"),B.forEach(l),p=f(F,` field set
        to `),m=g(F,"CODE",{});var y=E(m);_=f(y,"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),y.forEach(l),v=f(F,`,
        `),S(P.$$.fragment,F),R=f(F,` can be returned to the pool by freeing them.
    `),F.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,F){h(T,e,F),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(P,e,null),o(e,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),r.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),P.$set(y)},i(T){A||(b(r.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(P)}}}function AM(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the descriptor sets were succesfully freed.
        `),n=d("code"),s=i("false"),a=i(" if not all descriptor sets could be freed."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the descriptor sets were succesfully freed.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all descriptor sets could be freed."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function RM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LM(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[RM]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[BM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Free all the given allocated "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        If the descriptor pool was created with the `),a=d("code"),u=i("flags"),p=i(` field set
        to `),m=d("code"),_=i("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),v=i(`,
        `),I(P.$$.fragment),R=i(" can be returned to the pool by freeing them."),this.h()},l(T){e=g(T,"SPAN",{slot:!0});var F=E(e);t=f(F,"Free all the given allocated "),S(r.$$.fragment,F),$=f(F,"."),n=g(F,"BR",{}),s=f(F,`
        If the descriptor pool was created with the `),a=g(F,"CODE",{});var B=E(a);u=f(B,"flags"),B.forEach(l),p=f(F,` field set
        to `),m=g(F,"CODE",{});var y=E(m);_=f(y,"VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),y.forEach(l),v=f(F,`,
        `),S(P.$$.fragment,F),R=f(F," can be returned to the pool by freeing them."),F.forEach(l),this.h()},h(){z(e,"slot","details")},m(T,F){h(T,e,F),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(P,e,null),o(e,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),r.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),P.$set(y)},i(T){A||(b(r.$$.fragment,T),b(P.$$.fragment,T),A=!0)},o(T){w(r.$$.fragment,T),w(P.$$.fragment,T),A=!1},d(T){T&&l(e),C(r),C(P)}}}function kM(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TM(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[kM]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSets"),n=d("br"),s=i(`
            A list of pointers to `),I(a.$$.fragment),u=i(" to be freed."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pDescriptorSets"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A list of pointers to `),S(a.$$.fragment,v),u=f(v," to be freed."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function VM(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if all the descriptor sets were succesfully freed.
        `),n=d("code"),s=i("false"),a=i(" if not all descriptor sets could be freed."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if all the descriptor sets were succesfully freed.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if not all descriptor sets could be freed."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function OM(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"bool freeDescriptorSets();"}}),r=new Ce({props:{$$slots:{return:[AM],details:[PM]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:"bool freeDescriptorSets(std::vector<DescriptorSet*> pDescriptorSets);"}}),u=new Ce({props:{$$slots:{return:[VM],params:[TM],details:[LM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class FM extends ve{constructor(e){super(),Ee(this,e,null,OM,be,{})}}function yM(c){let e,t;return{c(){e=d("span"),t=i("Reset the descriptor pool."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the descriptor pool."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function MM(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=d("code"),r=i("true"),$=i(` if the descriptor pool was succesfully reset.
        `),n=d("code"),s=i("false"),a=i(" if the descriptor pool failed to reset. >"),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"true"),m.forEach(l),$=f(p,` if the descriptor pool was succesfully reset.
        `),n=g(p,"CODE",{});var _=E(n);s=f(_,"false"),_.forEach(l),a=f(p," if the descriptor pool failed to reset. >"),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function xM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"bool reset();"}}),r=new Ce({props:{$$slots:{return:[MM],details:[yM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class NM extends ve{constructor(e){super(),Ee(this,e,null,xM,be,{})}}function UM(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/descriptor_pool_builder.hpp>"}}),m=new $e({props:{language:ue,code:`struct DescriptorSetInfo {
    std::string name = "undefined";
    DescriptorSetLayout* pLayout = nullptr;
    std::vector<VkDescriptorPoolSize> poolSizes = {};
};
LogicalDevice* pLogicalDevice = nullptr;
VkDescriptorPoolCreateFlags flags = 0;
unsigned int maxSets = 0;
std::vector<DescriptorSetLayout*> pDescriptorSetLayouts = {};
std::vector<DescriptorSetInfo> descriptorSetInfos = {};`}}),P=new $e({props:{language:ue,code:`// Prepare some descriptor set layouts
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample1 = descriptorSetLayoutBuilder.getResult();
descriptorSetLayoutBuilder.reset();
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample2 = descriptorSetLayoutBuilder.getResult();
descriptorSetLayoutBuilder.reset();
...
fillcan::DescriptorSetLayout descriptorSetLayoutExample3 = descriptorSetLayoutBuilder.getResult();

// Create descriptor pool
fillcan::DescriptorPoolBuilder descriptorPoolBuilder{};

descriptorPoolBuilder.setLogicalDevice(fillcan.getCurrentDevice());

descriptorPoolBuilder.addSet(descriptorSetLayoutExample1, "DescriptorSetExample1");
descriptorPoolBuilder.addSet(descriptorSetLayoutExample2, "DescriptorSetExample2");
descriptorPoolBuilder.addSet(descriptorSetLayoutExample3, "DescriptorSetExample3");

fillcan::DescriptorPool descriptorPool = descriptorPoolBuilder.getResult();
`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Pool Builder"),n=i(` class is part of the creational design
pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(P.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Descriptor Pool Builder"),T.forEach(l),n=f(A,` class is part of the creational design
pattern to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(P.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(P,A,T),R=!0},p:ke,i(A){R||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(P.$$.fragment,A),R=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(P.$$.fragment,A),R=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(P,A)}}}class GM extends ve{constructor(e){super(),Ee(this,e,null,UM,be,{})}}function HM(c){let e,t;return{c(){e=d("span"),t=i("Create a new Descriptor Pool Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Descriptor Pool Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function qM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorPoolBuilder();"}}),r=new Ce({props:{$$slots:{details:[HM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class WM extends ve{constructor(e){super(),Ee(this,e,null,qM,be,{})}}function QM(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KM(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zM(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[QM]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[KM]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function YM(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jM(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XM(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YM]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[jM]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R," should be associated with."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function ZM(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[XM],details:[zM]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class JM extends ve{constructor(e){super(),Ee(this,e,null,ZM,be,{})}}function ex(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tx(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[ex]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rx(c){let e;return{c(){e=i("VkDescriptorPoolCreateFlagBits")},l(t){e=f(t,"VkDescriptorPoolCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nx(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sx(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html",target:"_blank",$$slots:{default:[rx]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[nx]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" that specify certain supported operations on the "),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"flags"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A bitmask of `),S(a.$$.fragment,R),u=f(R," that specify certain supported operations on the "),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function ax(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFlags(VkDescriptorPoolCreateFlags flags);"}}),r=new Ce({props:{$$slots:{params:[sx],details:[tx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ox extends ve{constructor(e){super(),Ee(this,e,null,ax,be,{})}}function lx(c){let e,t;return{c(){e=d("span"),t=i(`Specify a set of descriptors of a certain type that should be
        allocatable from the pool.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Specify a set of descriptors of a certain type that should be
        allocatable from the pool.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ix(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fx(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cx(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT_BUILDER,$$slots:{default:[ix]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[fx]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSetLayout"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(` describing the order and types of resources in the set. Two sets with
            the same layout are considered compatible and interchangeable.`),p=Y(),m=d("li"),_=d("code"),v=i("name"),P=d("br"),R=i(`
            The identifying name of the `),I(A.$$.fragment),T=i("."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"pDescriptorSetLayout"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The `),S(a.$$.fragment,V),u=f(V,` describing the order and types of resources in the set. Two sets with
            the same layout are considered compatible and interchangeable.`),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"name"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            The identifying name of the `),S(A.$$.fragment,M),T=f(M,"."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function $x(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFlags(VkDescriptorPoolCreateFlags flags);"}}),r=new Ce({props:{$$slots:{params:[cx],details:[lx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class ux extends ve{constructor(e){super(),Ee(this,e,null,$x,be,{})}}function px(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mx(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[px]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hx(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dx(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[hx]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("allocate"),n=d("br"),s=i(`
            Whether to automatically allocate the `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"allocate"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            Whether to automatically allocate the `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function gx(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _x(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vx(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[gx]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[_x]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Ex(c){let e;return{c(){e=i("Descriptor Pool")},l(t){e=f(t,"Descriptor Pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bx(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wx(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return n=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[Ex]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[bx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created. Also throws "),a=d("code"),u=i("std::runtime_error"),p=i(` if
        `),m=d("code"),_=i("allocate"),v=i(`
        is `),P=d("code"),R=i("true"),A=i(" and the "),I(T.$$.fragment),F=i(" failed to be created."),this.h()},l(y){e=g(y,"SPAN",{slot:!0});var V=E(e);t=g(V,"CODE",{});var x=E(t);r=f(x,"std::runtime_error"),x.forEach(l),$=f(V," if the "),S(n.$$.fragment,V),s=f(V," couldn't be created. Also throws "),a=g(V,"CODE",{});var M=E(a);u=f(M,"std::runtime_error"),M.forEach(l),p=f(V,` if
        `),m=g(V,"CODE",{});var O=E(m);_=f(O,"allocate"),O.forEach(l),v=f(V,`
        is `),P=g(V,"CODE",{});var H=E(P);R=f(H,"true"),H.forEach(l),A=f(V," and the "),S(T.$$.fragment,V),F=f(V," failed to be created."),V.forEach(l),this.h()},h(){z(e,"slot","throws")},m(y,V){h(y,e,V),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),o(e,P),o(P,R),o(e,A),D(T,e,null),o(e,F),B=!0},p(y,V){const x={};V&1&&(x.$$scope={dirty:V,ctx:y}),n.$set(x);const M={};V&1&&(M.$$scope={dirty:V,ctx:y}),T.$set(M)},i(y){B||(b(n.$$.fragment,y),b(T.$$.fragment,y),B=!0)},o(y){w(n.$$.fragment,y),w(T.$$.fragment,y),B=!1},d(y){y&&l(e),C(n),C(T)}}}function Ix(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<DescriptorPool> getResult(bool allocate = true);"}}),r=new Ce({props:{$$slots:{throws:[wx],return:[vx],params:[dx],details:[mx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Dx extends ve{constructor(e){super(),Ee(this,e,null,Ix,be,{})}}function Cx(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sx(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Px(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[Sx],default:[Cx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Ax extends ve{constructor(e){super(),Ee(this,e,null,Px,be,{})}}function Rx(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bx(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Lx(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kx(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Tx(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Vx(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ox(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fx(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yx(c){let e;return{c(){e=i("layout")},l(t){e=f(t,"layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mx(c){let e;return{c(){e=i("layout")},l(t){e=f(t,"layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xx(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Nx(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ux(c){let e;return{c(){e=i("Pipelines")},l(t){e=f(t,"Pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Gx(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Hx(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/descriptor_set.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Rx]},$$scope:{ctx:c}}}),u=new fe({props:{href:"",target:"_blank",$$slots:{default:[Bx]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[Lx]},$$scope:{ctx:c}}}),F=new fe({props:{href:"",target:"_blank",$$slots:{default:[kx]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.BUFFER,$$slots:{default:[Tx]},$$scope:{ctx:c}}}),H=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Vx]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[Ox]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[Fx]},$$scope:{ctx:c}}}),U=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[yx]},$$scope:{ctx:c}}}),ee=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[Mx]},$$scope:{ctx:c}}}),ie=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[xx]},$$scope:{ctx:c}}}),J=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[Nx]},$$scope:{ctx:c}}}),Se=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[Ux]},$$scope:{ctx:c}}}),me=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[Gx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Descriptor Set"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a handle to the "),I(u.$$.fragment),p=i(" which it will wrap around and the "),I(m.$$.fragment),_=i(" which describes it's bindings"),v=d("br"),P=i(`
The `),R=d("code"),A=i("Descriptor Set"),T=i(" class acts as a wrapper around the "),I(F.$$.fragment),B=i(" for updating and copying it's contents."),y=d("br"),V=d("br"),x=i(`
A descriptor is a special opaque shader variable used by shaders to indirectly access
`),I(M.$$.fragment),O=i(" and "),I(H.$$.fragment),k=i(` resources. It can be seen as a "pointer" to a resource. The Vulkan API allows these
variables to be changed between drawing operations so that the shaders have access
to different resources for each rendering. A descriptor set is called a "set" because
it can refer to a set of homogeneous resources that can be described with the same
layout binding.`),N=d("br"),Q=d("br"),X=i(`
A descriptor set is a set of resources tied to the `),I(Z.$$.fragment),K=i(" as a group. Multiple sets can be tied to a "),I(W.$$.fragment),q=i(" at the same time. Each set has a "),I(U.$$.fragment),te=i(`, which describes the order and types of resources in the set. Two sets with
the same layout are considered compatible and interchangeable. The `),I(ee.$$.fragment),se=i(` of the descriptor set is represented by an object and sets are created with respect
to this object. Furthermore, the set of sets accessible to a `),I(ie.$$.fragment),ae=i(" is grouped together in another object: the "),I(J.$$.fragment),pe=i(". "),I(Se.$$.fragment),de=i(` are created in
relation to this `),I(me.$$.fragment),De=i(" object.")},l(ne){S(e.$$.fragment,ne),t=f(ne,`
The `),r=g(ne,"CODE",{});var le=E(r);$=f(le,"Descriptor Set"),le.forEach(l),n=f(ne," class takes a pointer to a "),S(s.$$.fragment,ne),a=f(ne,", a handle to the "),S(u.$$.fragment,ne),p=f(ne," which it will wrap around and the "),S(m.$$.fragment,ne),_=f(ne," which describes it's bindings"),v=g(ne,"BR",{}),P=f(ne,`
The `),R=g(ne,"CODE",{});var ge=E(R);A=f(ge,"Descriptor Set"),ge.forEach(l),T=f(ne," class acts as a wrapper around the "),S(F.$$.fragment,ne),B=f(ne," for updating and copying it's contents."),y=g(ne,"BR",{}),V=g(ne,"BR",{}),x=f(ne,`
A descriptor is a special opaque shader variable used by shaders to indirectly access
`),S(M.$$.fragment,ne),O=f(ne," and "),S(H.$$.fragment,ne),k=f(ne,` resources. It can be seen as a "pointer" to a resource. The Vulkan API allows these
variables to be changed between drawing operations so that the shaders have access
to different resources for each rendering. A descriptor set is called a "set" because
it can refer to a set of homogeneous resources that can be described with the same
layout binding.`),N=g(ne,"BR",{}),Q=g(ne,"BR",{}),X=f(ne,`
A descriptor set is a set of resources tied to the `),S(Z.$$.fragment,ne),K=f(ne," as a group. Multiple sets can be tied to a "),S(W.$$.fragment,ne),q=f(ne," at the same time. Each set has a "),S(U.$$.fragment,ne),te=f(ne,`, which describes the order and types of resources in the set. Two sets with
the same layout are considered compatible and interchangeable. The `),S(ee.$$.fragment,ne),se=f(ne,` of the descriptor set is represented by an object and sets are created with respect
to this object. Furthermore, the set of sets accessible to a `),S(ie.$$.fragment,ne),ae=f(ne," is grouped together in another object: the "),S(J.$$.fragment,ne),pe=f(ne,". "),S(Se.$$.fragment,ne),de=f(ne,` are created in
relation to this `),S(me.$$.fragment,ne),De=f(ne," object.")},m(ne,le){D(e,ne,le),h(ne,t,le),h(ne,r,le),o(r,$),h(ne,n,le),D(s,ne,le),h(ne,a,le),D(u,ne,le),h(ne,p,le),D(m,ne,le),h(ne,_,le),h(ne,v,le),h(ne,P,le),h(ne,R,le),o(R,A),h(ne,T,le),D(F,ne,le),h(ne,B,le),h(ne,y,le),h(ne,V,le),h(ne,x,le),D(M,ne,le),h(ne,O,le),D(H,ne,le),h(ne,k,le),h(ne,N,le),h(ne,Q,le),h(ne,X,le),D(Z,ne,le),h(ne,K,le),D(W,ne,le),h(ne,q,le),D(U,ne,le),h(ne,te,le),D(ee,ne,le),h(ne,se,le),D(ie,ne,le),h(ne,ae,le),D(J,ne,le),h(ne,pe,le),D(Se,ne,le),h(ne,de,le),D(me,ne,le),h(ne,De,le),_e=!0},p(ne,[le]){const ge={};le&1&&(ge.$$scope={dirty:le,ctx:ne}),s.$set(ge);const we={};le&1&&(we.$$scope={dirty:le,ctx:ne}),u.$set(we);const Pe={};le&1&&(Pe.$$scope={dirty:le,ctx:ne}),m.$set(Pe);const Be={};le&1&&(Be.$$scope={dirty:le,ctx:ne}),F.$set(Be);const Ie={};le&1&&(Ie.$$scope={dirty:le,ctx:ne}),M.$set(Ie);const re={};le&1&&(re.$$scope={dirty:le,ctx:ne}),H.$set(re);const he={};le&1&&(he.$$scope={dirty:le,ctx:ne}),Z.$set(he);const Le={};le&1&&(Le.$$scope={dirty:le,ctx:ne}),W.$set(Le);const Oe={};le&1&&(Oe.$$scope={dirty:le,ctx:ne}),U.$set(Oe);const oe={};le&1&&(oe.$$scope={dirty:le,ctx:ne}),ee.$set(oe);const ce={};le&1&&(ce.$$scope={dirty:le,ctx:ne}),ie.$set(ce);const Ae={};le&1&&(Ae.$$scope={dirty:le,ctx:ne}),J.$set(Ae);const ye={};le&1&&(ye.$$scope={dirty:le,ctx:ne}),Se.$set(ye);const Fe={};le&1&&(Fe.$$scope={dirty:le,ctx:ne}),me.$set(Fe)},i(ne){_e||(b(e.$$.fragment,ne),b(s.$$.fragment,ne),b(u.$$.fragment,ne),b(m.$$.fragment,ne),b(F.$$.fragment,ne),b(M.$$.fragment,ne),b(H.$$.fragment,ne),b(Z.$$.fragment,ne),b(W.$$.fragment,ne),b(U.$$.fragment,ne),b(ee.$$.fragment,ne),b(ie.$$.fragment,ne),b(J.$$.fragment,ne),b(Se.$$.fragment,ne),b(me.$$.fragment,ne),_e=!0)},o(ne){w(e.$$.fragment,ne),w(s.$$.fragment,ne),w(u.$$.fragment,ne),w(m.$$.fragment,ne),w(F.$$.fragment,ne),w(M.$$.fragment,ne),w(H.$$.fragment,ne),w(Z.$$.fragment,ne),w(W.$$.fragment,ne),w(U.$$.fragment,ne),w(ee.$$.fragment,ne),w(ie.$$.fragment,ne),w(J.$$.fragment,ne),w(Se.$$.fragment,ne),w(me.$$.fragment,ne),_e=!1},d(ne){C(e,ne),ne&&l(t),ne&&l(r),ne&&l(n),C(s,ne),ne&&l(a),C(u,ne),ne&&l(p),C(m,ne),ne&&l(_),ne&&l(v),ne&&l(P),ne&&l(R),ne&&l(T),C(F,ne),ne&&l(B),ne&&l(y),ne&&l(V),ne&&l(x),C(M,ne),ne&&l(O),C(H,ne),ne&&l(k),ne&&l(N),ne&&l(Q),ne&&l(X),C(Z,ne),ne&&l(K),C(W,ne),ne&&l(q),C(U,ne),ne&&l(te),C(ee,ne),ne&&l(se),C(ie,ne),ne&&l(ae),C(J,ne),ne&&l(pe),C(Se,ne),ne&&l(de),C(me,ne),ne&&l(De)}}}class qx extends ve{constructor(e){super(),Ee(this,e,null,Hx,be,{})}}function Wx(c){let e;return{c(){e=i("allocateDescriptorSet")},l(t){e=f(t,"allocateDescriptorSet")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qx(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.DESCRIPTOR_POOL_allocateDescriptorSet,$$slots:{default:[Wx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Descriptor Set."),r=d("br"),$=i(`
        It is recommended to not create a Descriptor Set by it's Constructor, but
        to use
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Descriptor Set."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Descriptor Set by it's Constructor, but
        to use
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Kx(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zx(c){let e;return{c(){e=i("descriptor pool")},l(t){e=f(t,"descriptor pool")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Yx(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jx(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Kx]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.DESCRIPTOR_POOL,$$slots:{default:[zx]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[Yx]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the descriptor set should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("pDescriptorPool"),P=d("br"),R=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" to allocate from."),F=Y(),B=d("li"),y=d("code"),V=i("pDescriptorSetLayout"),x=d("br"),M=i(`
            A pointer to the `),I(O.$$.fragment),H=i(" describing the bindings."),k=Y(),N=d("li"),Q=d("code"),X=i("name"),Z=d("br"),K=i(`
            The identifying name of the descriptor set.`),this.h()},l(q){e=g(q,"DIV",{slot:!0});var U=E(e);t=g(U,"LI",{});var te=E(t);r=g(te,"CODE",{});var ee=E(r);$=f(ee,"pLogicalDevice"),ee.forEach(l),n=g(te,"BR",{}),s=f(te,`
            A pointer to the `),S(a.$$.fragment,te),u=f(te," the descriptor set should be associated with."),te.forEach(l),p=j(U),m=g(U,"LI",{});var se=E(m);_=g(se,"CODE",{});var ie=E(_);v=f(ie,"pDescriptorPool"),ie.forEach(l),P=g(se,"BR",{}),R=f(se,`
            A pointer to the `),S(A.$$.fragment,se),T=f(se," to allocate from."),se.forEach(l),F=j(U),B=g(U,"LI",{});var ae=E(B);y=g(ae,"CODE",{});var J=E(y);V=f(J,"pDescriptorSetLayout"),J.forEach(l),x=g(ae,"BR",{}),M=f(ae,`
            A pointer to the `),S(O.$$.fragment,ae),H=f(ae," describing the bindings."),ae.forEach(l),k=j(U),N=g(U,"LI",{});var pe=E(N);Q=g(pe,"CODE",{});var Se=E(Q);X=f(Se,"name"),Se.forEach(l),Z=g(pe,"BR",{}),K=f(pe,`
            The identifying name of the descriptor set.`),pe.forEach(l),U.forEach(l),this.h()},h(){z(e,"slot","params")},m(q,U){h(q,e,U),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),W=!0},p(q,U){const te={};U&1&&(te.$$scope={dirty:U,ctx:q}),a.$set(te);const ee={};U&1&&(ee.$$scope={dirty:U,ctx:q}),A.$set(ee);const se={};U&1&&(se.$$scope={dirty:U,ctx:q}),O.$set(se)},i(q){W||(b(a.$$.fragment,q),b(A.$$.fragment,q),b(O.$$.fragment,q),W=!0)},o(q){w(a.$$.fragment,q),w(A.$$.fragment,q),w(O.$$.fragment,q),W=!1},d(q){q&&l(e),C(a),C(A),C(O)}}}function Xx(c){let e;return{c(){e=i("Descriptor Set")},l(t){e=f(t,"Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zx(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[Xx]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" failed to be allocated."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," failed to be allocated."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Jx(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`DescriptorSet(
    LogicalDevice* pLogicalDevice, 
    VkDescriptorSet hDescriptorSet, 
    DescriptorSetLayout* pDescriptorSetLayout
);`}}),r=new Ce({props:{$$slots:{throws:[Zx],params:[jx],details:[Qx]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class eN extends ve{constructor(e){super(),Ee(this,e,null,Jx,be,{})}}function tN(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rN(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[tN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function nN(c){let e;return{c(){e=i("Vulkan Descriptor Set")},l(t){e=f(t,"Vulkan Descriptor Set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sN(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html",target:"_blank",$$slots:{default:[nN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function aN(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkDescriptorSet getDescriptorSetHandle() const;"}}),r=new Ce({props:{$$slots:{return:[sN],details:[rN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class oN extends ve{constructor(e){super(),Ee(this,e,null,aN,be,{})}}function lN(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iN(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[lN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" this descriptor set is associated with."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," this descriptor set is associated with."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function fN(c){let e;return{c(){e=i("descriptor set layout")},l(t){e=f(t,"descriptor set layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cN(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[fN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i(" this descriptor set is associated with."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a," this descriptor set is associated with."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function $N(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSetLayout* DescriptorSet::getLayout() { return this->pDescriptorSetLayout; }"}}),r=new Ce({props:{$$slots:{return:[cN],details:[iN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class uN extends ve{constructor(e){super(),Ee(this,e,null,$N,be,{})}}function pN(c){let e,t;return{c(){e=d("span"),t=i("Get the identifying name of the descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the identifying name of the descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function mN(c){let e,t;return{c(){e=d("span"),t=i("The identifying name of the descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The identifying name of the descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function hN(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::string DescriptorSet::getName() { return this->name; }"}}),r=new Ce({props:{$$slots:{return:[mN],details:[pN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dN extends ve{constructor(e){super(),Ee(this,e,null,hN,be,{})}}function gN(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _N(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[gN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind an "),I(r.$$.fragment),$=i(` to a given
        binding of the descriptor set.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind an "),S(r.$$.fragment,a),$=f(a,` to a given
        binding of the descriptor set.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function vN(c){let e;return{c(){e=i("image view")},l(t){e=f(t,"image view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EN(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bN(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wN(c){let e;return{c(){e=i("VkImageLayout")},l(t){e=f(t,"VkImageLayout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IN(c){let e;return{c(){e=i("image view")},l(t){e=f(t,"image view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DN(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CN(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne;return P=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[vN]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.IMAGE,$$slots:{default:[EN]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.IMAGE,$$slots:{default:[bN]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html",target:"_blank",$$slots:{default:[wN]},$$scope:{ctx:c}}}),se=new G({props:{sectionID:L.IMAGE_VIEW,$$slots:{default:[IN]},$$scope:{ctx:c}}}),ae=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[DN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=Y(),u=d("li"),p=d("code"),m=i("pImageView"),_=d("br"),v=i(`
            A pointer to the `),I(P.$$.fragment),R=i(" of the "),I(A.$$.fragment),T=i(` to
            be bound in the descriptor set.`),F=Y(),B=d("li"),y=d("code"),V=i("imageLayout"),x=d("br"),M=i(`
            The layout in which the `),I(O.$$.fragment),H=i(` is expected to be when used in the descriptor set. This is a member
            of the `),I(k.$$.fragment),N=i("-enumerant."),Q=Y(),X=d("li"),Z=d("code"),K=i("pSampler"),W=d("br"),q=i(`
            If the descriptor set was created with the descriptor type set to
            `),U=d("code"),te=i("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),ee=i(`, A pointer to
            the the corresponding `),I(se.$$.fragment),ie=i(`'s
            `),I(ae.$$.fragment),J=i(` (given in
            the `),pe=d("code"),Se=i("pImageView"),de=i(" field) is specified here."),me=Y(),De=d("li"),_e=d("code"),ne=i("dstArrayElement"),le=d("br"),ge=i(`
            If the binding in the set references an array of resources,
            `),we=d("code"),Pe=i("dstArrayElement"),Be=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),Ie=d("code"),re=i("0"),he=i("."),Le=Y(),Oe=d("li"),oe=d("code"),ce=i("descriptorCount"),Ae=d("br"),ye=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Fe=d("code"),Ve=i("dstArrayElement"),Ge=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),He=d("code"),ze=i("1"),xe=i("."),this.h()},l(Te){e=g(Te,"DIV",{slot:!0});var qe=E(e);t=g(qe,"LI",{});var Ke=E(t);r=g(Ke,"CODE",{});var je=E(r);$=f(je,"binding"),je.forEach(l),n=g(Ke,"BR",{}),s=f(Ke,`
            The binding-index of the descriptor set the resource should be bound
            to.`),Ke.forEach(l),a=j(qe),u=g(qe,"LI",{});var rt=E(u);p=g(rt,"CODE",{});var Me=E(p);m=f(Me,"pImageView"),Me.forEach(l),_=g(rt,"BR",{}),v=f(rt,`
            A pointer to the `),S(P.$$.fragment,rt),R=f(rt," of the "),S(A.$$.fragment,rt),T=f(rt,` to
            be bound in the descriptor set.`),rt.forEach(l),F=j(qe),B=g(qe,"LI",{});var Ue=E(B);y=g(Ue,"CODE",{});var $t=E(y);V=f($t,"imageLayout"),$t.forEach(l),x=g(Ue,"BR",{}),M=f(Ue,`
            The layout in which the `),S(O.$$.fragment,Ue),H=f(Ue,` is expected to be when used in the descriptor set. This is a member
            of the `),S(k.$$.fragment,Ue),N=f(Ue,"-enumerant."),Ue.forEach(l),Q=j(qe),X=g(qe,"LI",{});var ut=E(X);Z=g(ut,"CODE",{});var ht=E(Z);K=f(ht,"pSampler"),ht.forEach(l),W=g(ut,"BR",{}),q=f(ut,`
            If the descriptor set was created with the descriptor type set to
            `),U=g(ut,"CODE",{});var Je=E(U);te=f(Je,"VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),Je.forEach(l),ee=f(ut,`, A pointer to
            the the corresponding `),S(se.$$.fragment,ut),ie=f(ut,`'s
            `),S(ae.$$.fragment,ut),J=f(ut,` (given in
            the `),pe=g(ut,"CODE",{});var dt=E(pe);Se=f(dt,"pImageView"),dt.forEach(l),de=f(ut," field) is specified here."),ut.forEach(l),me=j(qe),De=g(qe,"LI",{});var et=E(De);_e=g(et,"CODE",{});var Ze=E(_e);ne=f(Ze,"dstArrayElement"),Ze.forEach(l),le=g(et,"BR",{}),ge=f(et,`
            If the binding in the set references an array of resources,
            `),we=g(et,"CODE",{});var nt=E(we);Pe=f(nt,"dstArrayElement"),nt.forEach(l),Be=f(et,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),Ie=g(et,"CODE",{});var Qe=E(Ie);re=f(Qe,"0"),Qe.forEach(l),he=f(et,"."),et.forEach(l),Le=j(qe),Oe=g(qe,"LI",{});var ct=E(Oe);oe=g(ct,"CODE",{});var st=E(oe);ce=f(st,"descriptorCount"),st.forEach(l),Ae=g(ct,"BR",{}),ye=f(ct,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Fe=g(ct,"CODE",{});var We=E(Fe);Ve=f(We,"dstArrayElement"),We.forEach(l),Ge=f(ct,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),He=g(ct,"CODE",{});var at=E(He);ze=f(at,"1"),at.forEach(l),xe=f(ct,"."),ct.forEach(l),qe.forEach(l),this.h()},h(){z(e,"slot","params")},m(Te,qe){h(Te,e,qe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),D(A,u,null),o(u,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),o(X,U),o(U,te),o(X,ee),D(se,X,null),o(X,ie),D(ae,X,null),o(X,J),o(X,pe),o(pe,Se),o(X,de),o(e,me),o(e,De),o(De,_e),o(_e,ne),o(De,le),o(De,ge),o(De,we),o(we,Pe),o(De,Be),o(De,Ie),o(Ie,re),o(De,he),o(e,Le),o(e,Oe),o(Oe,oe),o(oe,ce),o(Oe,Ae),o(Oe,ye),o(Oe,Fe),o(Fe,Ve),o(Oe,Ge),o(Oe,He),o(He,ze),o(Oe,xe),Ne=!0},p(Te,qe){const Ke={};qe&1&&(Ke.$$scope={dirty:qe,ctx:Te}),P.$set(Ke);const je={};qe&1&&(je.$$scope={dirty:qe,ctx:Te}),A.$set(je);const rt={};qe&1&&(rt.$$scope={dirty:qe,ctx:Te}),O.$set(rt);const Me={};qe&1&&(Me.$$scope={dirty:qe,ctx:Te}),k.$set(Me);const Ue={};qe&1&&(Ue.$$scope={dirty:qe,ctx:Te}),se.$set(Ue);const $t={};qe&1&&($t.$$scope={dirty:qe,ctx:Te}),ae.$set($t)},i(Te){Ne||(b(P.$$.fragment,Te),b(A.$$.fragment,Te),b(O.$$.fragment,Te),b(k.$$.fragment,Te),b(se.$$.fragment,Te),b(ae.$$.fragment,Te),Ne=!0)},o(Te){w(P.$$.fragment,Te),w(A.$$.fragment,Te),w(O.$$.fragment,Te),w(k.$$.fragment,Te),w(se.$$.fragment,Te),w(ae.$$.fragment,Te),Ne=!1},d(Te){Te&&l(e),C(P),C(A),C(O),C(k),C(se),C(ae)}}}function SN(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void writeImage(
    VkDescriptorSetLayoutBinding binding, 
    ImageView* pImageView, 
    VkImageLayout imageLayout, 
    Sampler* pSampler,
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Ce({props:{$$slots:{params:[CN],details:[_N]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class PN extends ve{constructor(e){super(),Ee(this,e,null,SN,be,{})}}function AN(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RN(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER,$$slots:{default:[AN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind a "),I(r.$$.fragment),$=i(` to a given
        binding of the descriptor set.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind a "),S(r.$$.fragment,a),$=f(a,` to a given
        binding of the descriptor set.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function BN(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LN(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kN(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TN(c){let e;return{c(){e=i("buffer")},l(t){e=f(t,"buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VN(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe;return P=new G({props:{sectionID:L.BUFFER,$$slots:{default:[BN]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.BUFFER,$$slots:{default:[LN]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.BUFFER,$$slots:{default:[kN]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.BUFFER,$$slots:{default:[TN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=Y(),u=d("li"),p=d("code"),m=i("pBuffer"),_=d("br"),v=i(`
            A pointer to the  `),I(P.$$.fragment),R=i(` to be
            bound in the descriptor set.`),A=Y(),T=d("li"),F=d("code"),B=i("offset"),y=d("br"),V=i(`
            From which point in the `),I(x.$$.fragment),M=i(" to bind. The offset of the binding in bytes."),O=Y(),H=d("li"),k=d("code"),N=i("range"),Q=d("br"),X=i(`
            How much of the `),I(Z.$$.fragment),K=i(` to bind. The size of the binding in bytes. The bound range must be
            completely within the `),I(W.$$.fragment),q=i(" object."),U=Y(),te=d("li"),ee=d("code"),se=i("dstArrayElement"),ie=d("br"),ae=i(`
            If the binding in the set references an array of resources,
            `),J=d("code"),pe=i("dstArrayElement"),Se=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),de=d("code"),me=i("0"),De=i("."),_e=Y(),ne=d("li"),le=d("code"),ge=i("descriptorCount"),we=d("br"),Pe=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Be=d("code"),Ie=i("dstArrayElement"),re=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),he=d("code"),Le=i("1"),Oe=i("."),this.h()},l(ce){e=g(ce,"DIV",{slot:!0});var Ae=E(e);t=g(Ae,"LI",{});var ye=E(t);r=g(ye,"CODE",{});var Fe=E(r);$=f(Fe,"binding"),Fe.forEach(l),n=g(ye,"BR",{}),s=f(ye,`
            The binding-index of the descriptor set the resource should be bound
            to.`),ye.forEach(l),a=j(Ae),u=g(Ae,"LI",{});var Ve=E(u);p=g(Ve,"CODE",{});var Ge=E(p);m=f(Ge,"pBuffer"),Ge.forEach(l),_=g(Ve,"BR",{}),v=f(Ve,`
            A pointer to the  `),S(P.$$.fragment,Ve),R=f(Ve,` to be
            bound in the descriptor set.`),Ve.forEach(l),A=j(Ae),T=g(Ae,"LI",{});var He=E(T);F=g(He,"CODE",{});var ze=E(F);B=f(ze,"offset"),ze.forEach(l),y=g(He,"BR",{}),V=f(He,`
            From which point in the `),S(x.$$.fragment,He),M=f(He," to bind. The offset of the binding in bytes."),He.forEach(l),O=j(Ae),H=g(Ae,"LI",{});var xe=E(H);k=g(xe,"CODE",{});var Ne=E(k);N=f(Ne,"range"),Ne.forEach(l),Q=g(xe,"BR",{}),X=f(xe,`
            How much of the `),S(Z.$$.fragment,xe),K=f(xe,` to bind. The size of the binding in bytes. The bound range must be
            completely within the `),S(W.$$.fragment,xe),q=f(xe," object."),xe.forEach(l),U=j(Ae),te=g(Ae,"LI",{});var Te=E(te);ee=g(Te,"CODE",{});var qe=E(ee);se=f(qe,"dstArrayElement"),qe.forEach(l),ie=g(Te,"BR",{}),ae=f(Te,`
            If the binding in the set references an array of resources,
            `),J=g(Te,"CODE",{});var Ke=E(J);pe=f(Ke,"dstArrayElement"),Ke.forEach(l),Se=f(Te,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),de=g(Te,"CODE",{});var je=E(de);me=f(je,"0"),je.forEach(l),De=f(Te,"."),Te.forEach(l),_e=j(Ae),ne=g(Ae,"LI",{});var rt=E(ne);le=g(rt,"CODE",{});var Me=E(le);ge=f(Me,"descriptorCount"),Me.forEach(l),we=g(rt,"BR",{}),Pe=f(rt,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),Be=g(rt,"CODE",{});var Ue=E(Be);Ie=f(Ue,"dstArrayElement"),Ue.forEach(l),re=f(rt,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),he=g(rt,"CODE",{});var $t=E(he);Le=f($t,"1"),$t.forEach(l),Oe=f(rt,"."),rt.forEach(l),Ae.forEach(l),this.h()},h(){z(e,"slot","params")},m(ce,Ae){h(ce,e,Ae),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),o(e,O),o(e,H),o(H,k),o(k,N),o(H,Q),o(H,X),D(Z,H,null),o(H,K),D(W,H,null),o(H,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),o(te,J),o(J,pe),o(te,Se),o(te,de),o(de,me),o(te,De),o(e,_e),o(e,ne),o(ne,le),o(le,ge),o(ne,we),o(ne,Pe),o(ne,Be),o(Be,Ie),o(ne,re),o(ne,he),o(he,Le),o(ne,Oe),oe=!0},p(ce,Ae){const ye={};Ae&1&&(ye.$$scope={dirty:Ae,ctx:ce}),P.$set(ye);const Fe={};Ae&1&&(Fe.$$scope={dirty:Ae,ctx:ce}),x.$set(Fe);const Ve={};Ae&1&&(Ve.$$scope={dirty:Ae,ctx:ce}),Z.$set(Ve);const Ge={};Ae&1&&(Ge.$$scope={dirty:Ae,ctx:ce}),W.$set(Ge)},i(ce){oe||(b(P.$$.fragment,ce),b(x.$$.fragment,ce),b(Z.$$.fragment,ce),b(W.$$.fragment,ce),oe=!0)},o(ce){w(P.$$.fragment,ce),w(x.$$.fragment,ce),w(Z.$$.fragment,ce),w(W.$$.fragment,ce),oe=!1},d(ce){ce&&l(e),C(P),C(x),C(Z),C(W)}}}function ON(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void writeBuffer(
    VkDescriptorSetLayoutBinding binding, 
    Buffer* pBuffer, 
    VkDeviceSize offset = 0, 
    VkDeviceSize range = VK_WHOLE_SIZE,
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Ce({props:{$$slots:{params:[VN],details:[RN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class FN extends ve{constructor(e){super(),Ee(this,e,null,ON,be,{})}}function yN(c){let e;return{c(){e=i("texel buffer view")},l(t){e=f(t,"texel buffer view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MN(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[yN]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind a "),I(r.$$.fragment),$=i(" to a given binding of the descriptor set."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Bind a "),S(r.$$.fragment,a),$=f(a," to a given binding of the descriptor set."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function xN(c){let e;return{c(){e=i("texel buffer view")},l(t){e=f(t,"texel buffer view")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NN(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J;return P=new G({props:{sectionID:L.BUFFER_VIEW,$$slots:{default:[xN]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("binding"),n=d("br"),s=i(`
            The binding-index of the descriptor set the resource should be bound
            to.`),a=Y(),u=d("li"),p=d("code"),m=i("pBufferView"),_=d("br"),v=i(`
            A pointer to the `),I(P.$$.fragment),R=i(" to be bound in the descriptor set."),A=Y(),T=d("li"),F=d("code"),B=i("dstArrayElement"),y=d("br"),V=i(`
            If the binding in the set references an array of resources,
            `),x=d("code"),M=i("dstArrayElement"),O=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),H=d("code"),k=i("0"),N=i("."),Q=Y(),X=d("li"),Z=d("code"),K=i("descriptorCount"),W=d("br"),q=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),U=d("code"),te=i("dstArrayElement"),ee=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),se=d("code"),ie=i("1"),ae=i("."),this.h()},l(pe){e=g(pe,"DIV",{slot:!0});var Se=E(e);t=g(Se,"LI",{});var de=E(t);r=g(de,"CODE",{});var me=E(r);$=f(me,"binding"),me.forEach(l),n=g(de,"BR",{}),s=f(de,`
            The binding-index of the descriptor set the resource should be bound
            to.`),de.forEach(l),a=j(Se),u=g(Se,"LI",{});var De=E(u);p=g(De,"CODE",{});var _e=E(p);m=f(_e,"pBufferView"),_e.forEach(l),_=g(De,"BR",{}),v=f(De,`
            A pointer to the `),S(P.$$.fragment,De),R=f(De," to be bound in the descriptor set."),De.forEach(l),A=j(Se),T=g(Se,"LI",{});var ne=E(T);F=g(ne,"CODE",{});var le=E(F);B=f(le,"dstArrayElement"),le.forEach(l),y=g(ne,"BR",{}),V=f(ne,`
            If the binding in the set references an array of resources,
            `),x=g(ne,"CODE",{});var ge=E(x);M=f(ge,"dstArrayElement"),ge.forEach(l),O=f(ne,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),H=g(ne,"CODE",{});var we=E(H);k=f(we,"0"),we.forEach(l),N=f(ne,"."),ne.forEach(l),Q=j(Se),X=g(Se,"LI",{});var Pe=E(X);Z=g(Pe,"CODE",{});var Be=E(Z);K=f(Be,"descriptorCount"),Be.forEach(l),W=g(Pe,"BR",{}),q=f(Pe,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),U=g(Pe,"CODE",{});var Ie=E(U);te=f(Ie,"dstArrayElement"),Ie.forEach(l),ee=f(Pe,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),se=g(Pe,"CODE",{});var re=E(se);ie=f(re,"1"),re.forEach(l),ae=f(Pe,"."),Pe.forEach(l),Se.forEach(l),this.h()},h(){z(e,"slot","params")},m(pe,Se){h(pe,e,Se),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),o(T,x),o(x,M),o(T,O),o(T,H),o(H,k),o(T,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),o(X,U),o(U,te),o(X,ee),o(X,se),o(se,ie),o(X,ae),J=!0},p(pe,Se){const de={};Se&1&&(de.$$scope={dirty:Se,ctx:pe}),P.$set(de)},i(pe){J||(b(P.$$.fragment,pe),J=!0)},o(pe){w(P.$$.fragment,pe),J=!1},d(pe){pe&&l(e),C(P)}}}function UN(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void writeTexelBufferView(
    VkDescriptorSetLayoutBinding binding, 
    BufferView* pTexelBufferView, 
    unsigned int dstArrayElement = 0,
    unsigned int descriptorCount = 1
);`}}),r=new Ce({props:{$$slots:{params:[NN],details:[MN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GN extends ve{constructor(e){super(),Ee(this,e,null,UN,be,{})}}function HN(c){let e,t;return{c(){e=d("span"),t=i("Copy this descriptor set to another descriptor set."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Copy this descriptor set to another descriptor set."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function qN(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("srcDescriptorSetBinding"),n=d("br"),s=i(`
            The binding index of the descriptor within the set to copy from.`),a=Y(),u=d("li"),p=d("code"),m=i("pDstDescriptorSet"),_=d("br"),v=i(`
            A pointer to the descriptor set to copy to.`),P=Y(),R=d("li"),A=d("code"),T=i("dstDescriptorSetBinding"),F=d("br"),B=i(`
            The binding index of the descriptor within the set to copy to.`),y=Y(),V=d("li"),x=d("code"),M=i("dstArrayElement"),O=d("br"),H=i(`
            If the binding in the set references an array of resources,
            `),k=d("code"),N=i("dstArrayElement"),Q=i(`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),X=d("code"),Z=i("0"),K=i("."),W=Y(),q=d("li"),U=d("code"),te=i("descriptorCount"),ee=d("br"),se=i(`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),ie=d("code"),ae=i("dstArrayElement"),J=i(` field, to be updated. If
            the target binding is not an array, it should be set to
            `),pe=d("code"),Se=i("1"),de=i("."),this.h()},l(me){e=g(me,"DIV",{slot:!0});var De=E(e);t=g(De,"LI",{});var _e=E(t);r=g(_e,"CODE",{});var ne=E(r);$=f(ne,"srcDescriptorSetBinding"),ne.forEach(l),n=g(_e,"BR",{}),s=f(_e,`
            The binding index of the descriptor within the set to copy from.`),_e.forEach(l),a=j(De),u=g(De,"LI",{});var le=E(u);p=g(le,"CODE",{});var ge=E(p);m=f(ge,"pDstDescriptorSet"),ge.forEach(l),_=g(le,"BR",{}),v=f(le,`
            A pointer to the descriptor set to copy to.`),le.forEach(l),P=j(De),R=g(De,"LI",{});var we=E(R);A=g(we,"CODE",{});var Pe=E(A);T=f(Pe,"dstDescriptorSetBinding"),Pe.forEach(l),F=g(we,"BR",{}),B=f(we,`
            The binding index of the descriptor within the set to copy to.`),we.forEach(l),y=j(De),V=g(De,"LI",{});var Be=E(V);x=g(Be,"CODE",{});var Ie=E(x);M=f(Ie,"dstArrayElement"),Ie.forEach(l),O=g(Be,"BR",{}),H=f(Be,`
            If the binding in the set references an array of resources,
            `),k=g(Be,"CODE",{});var re=E(k);N=f(re,"dstArrayElement"),re.forEach(l),Q=f(Be,`
            is used to specify the update start index. If the target binding is not
            an array, it should be set to `),X=g(Be,"CODE",{});var he=E(X);Z=f(he,"0"),he.forEach(l),K=f(Be,"."),Be.forEach(l),W=j(De),q=g(De,"LI",{});var Le=E(q);U=g(Le,"CODE",{});var Oe=E(U);te=f(Oe,"descriptorCount"),Oe.forEach(l),ee=g(Le,"BR",{}),se=f(Le,`
            Used to specify the number of consecutive descriptors, after the specified
            index in the `),ie=g(Le,"CODE",{});var oe=E(ie);ae=f(oe,"dstArrayElement"),oe.forEach(l),J=f(Le,` field, to be updated. If
            the target binding is not an array, it should be set to
            `),pe=g(Le,"CODE",{});var ce=E(pe);Se=f(ce,"1"),ce.forEach(l),de=f(Le,"."),Le.forEach(l),De.forEach(l),this.h()},h(){z(e,"slot","params")},m(me,De){h(me,e,De),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),o(V,k),o(k,N),o(V,Q),o(V,X),o(X,Z),o(V,K),o(e,W),o(e,q),o(q,U),o(U,te),o(q,ee),o(q,se),o(q,ie),o(ie,ae),o(q,J),o(q,pe),o(pe,Se),o(q,de)},p:ke,d(me){me&&l(e)}}}function WN(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void copy(
    VkDescriptorSetLayoutBinding srcDescriptorSetBinding, 
    DescriptorSet* pDstDescriptorSet,
    VkDescriptorSetLayoutBinding dstDescriptorSetBinding, 
    unsigned int dstArrayElement = 0, 
    unsigned int descriptorCount = 1
);`}}),r=new Ce({props:{$$slots:{params:[qN],details:[HN]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class QN extends ve{constructor(e){super(),Ee(this,e,null,WN,be,{})}}function KN(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zN(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YN(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jN(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XN(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZN(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JN(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eU(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tU(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/pipeline_layout.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[KN]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[zN]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[YN]},$$scope:{ctx:c}}}),v=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[jN]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[XN]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[ZN]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[JN]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[eU]},$$scope:{ctx:c}}}),k=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[tU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline Layout"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(" along with a list of "),I(u.$$.fragment),p=i(" and a list of "),I(m.$$.fragment),_=i(" and uses this information to construct a "),I(v.$$.fragment),P=i(" which can be used to bind multiple "),I(R.$$.fragment),A=i(" to a "),I(T.$$.fragment),F=i("."),B=d("br"),y=d("br"),V=i(`
Multiple descriptor set layouts can be used in a single `),I(x.$$.fragment),M=i(". To group two or more descriptor sets into something that the "),I(O.$$.fragment),H=i(" can use, they must be merged into a "),I(k.$$.fragment),N=i(" object.")},l(X){S(e.$$.fragment,X),t=f(X,`

The `),r=g(X,"CODE",{});var Z=E(r);$=f(Z,"Pipeline Layout"),Z.forEach(l),n=f(X," class takes a pointer to a "),S(s.$$.fragment,X),a=f(X," along with a list of "),S(u.$$.fragment,X),p=f(X," and a list of "),S(m.$$.fragment,X),_=f(X," and uses this information to construct a "),S(v.$$.fragment,X),P=f(X," which can be used to bind multiple "),S(R.$$.fragment,X),A=f(X," to a "),S(T.$$.fragment,X),F=f(X,"."),B=g(X,"BR",{}),y=g(X,"BR",{}),V=f(X,`
Multiple descriptor set layouts can be used in a single `),S(x.$$.fragment,X),M=f(X,". To group two or more descriptor sets into something that the "),S(O.$$.fragment,X),H=f(X," can use, they must be merged into a "),S(k.$$.fragment,X),N=f(X," object.")},m(X,Z){D(e,X,Z),h(X,t,Z),h(X,r,Z),o(r,$),h(X,n,Z),D(s,X,Z),h(X,a,Z),D(u,X,Z),h(X,p,Z),D(m,X,Z),h(X,_,Z),D(v,X,Z),h(X,P,Z),D(R,X,Z),h(X,A,Z),D(T,X,Z),h(X,F,Z),h(X,B,Z),h(X,y,Z),h(X,V,Z),D(x,X,Z),h(X,M,Z),D(O,X,Z),h(X,H,Z),D(k,X,Z),h(X,N,Z),Q=!0},p(X,[Z]){const K={};Z&1&&(K.$$scope={dirty:Z,ctx:X}),s.$set(K);const W={};Z&1&&(W.$$scope={dirty:Z,ctx:X}),u.$set(W);const q={};Z&1&&(q.$$scope={dirty:Z,ctx:X}),m.$set(q);const U={};Z&1&&(U.$$scope={dirty:Z,ctx:X}),v.$set(U);const te={};Z&1&&(te.$$scope={dirty:Z,ctx:X}),R.$set(te);const ee={};Z&1&&(ee.$$scope={dirty:Z,ctx:X}),T.$set(ee);const se={};Z&1&&(se.$$scope={dirty:Z,ctx:X}),x.$set(se);const ie={};Z&1&&(ie.$$scope={dirty:Z,ctx:X}),O.$set(ie);const ae={};Z&1&&(ae.$$scope={dirty:Z,ctx:X}),k.$set(ae)},i(X){Q||(b(e.$$.fragment,X),b(s.$$.fragment,X),b(u.$$.fragment,X),b(m.$$.fragment,X),b(v.$$.fragment,X),b(R.$$.fragment,X),b(T.$$.fragment,X),b(x.$$.fragment,X),b(O.$$.fragment,X),b(k.$$.fragment,X),Q=!0)},o(X){w(e.$$.fragment,X),w(s.$$.fragment,X),w(u.$$.fragment,X),w(m.$$.fragment,X),w(v.$$.fragment,X),w(R.$$.fragment,X),w(T.$$.fragment,X),w(x.$$.fragment,X),w(O.$$.fragment,X),w(k.$$.fragment,X),Q=!1},d(X){C(e,X),X&&l(t),X&&l(r),X&&l(n),C(s,X),X&&l(a),C(u,X),X&&l(p),C(m,X),X&&l(_),C(v,X),X&&l(P),C(R,X),X&&l(A),C(T,X),X&&l(F),X&&l(B),X&&l(y),X&&l(V),C(x,X),X&&l(M),C(O,X),X&&l(H),C(k,X),X&&l(N)}}}class nU extends ve{constructor(e){super(),Ee(this,e,null,rU,be,{})}}function sU(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aU(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[sU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Pipeline Layout."),r=d("br"),$=i(`
        It is recommended to not create a Pipeline Layout by it's Constructor as
        a `),I(n.$$.fragment),s=i(` will create
        a Pipeline Layout as part of it's construction.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Pipeline Layout."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Pipeline Layout by it's Constructor as
        a `),S(n.$$.fragment,p),s=f(p,` will create
        a Pipeline Layout as part of it's construction.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function oU(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lU(c){let e;return{c(){e=i("descriptor set layouts")},l(t){e=f(t,"descriptor set layouts")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iU(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[oU]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.DESCRIPTOR_SET_LAYOUT,$$slots:{default:[lU]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[iU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline Layout should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("pDescriptorSetLayouts"),P=d("br"),R=i(`
            A list of pointers to `),I(A.$$.fragment),T=i(" to be bound in the pipeline layout."),F=Y(),B=d("li"),y=d("code"),V=i("pushConstants"),x=d("br"),M=i(`
            A list of `),I(O.$$.fragment),H=i(" to be bound in the pipeline layout."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"pLogicalDevice"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            A pointer to the `),S(a.$$.fragment,X),u=f(X," the Pipeline Layout should be associated with."),X.forEach(l),p=j(Q),m=g(Q,"LI",{});var K=E(m);_=g(K,"CODE",{});var W=E(_);v=f(W,"pDescriptorSetLayouts"),W.forEach(l),P=g(K,"BR",{}),R=f(K,`
            A list of pointers to `),S(A.$$.fragment,K),T=f(K," to be bound in the pipeline layout."),K.forEach(l),F=j(Q),B=g(Q,"LI",{});var q=E(B);y=g(q,"CODE",{});var U=E(y);V=f(U,"pushConstants"),U.forEach(l),x=g(q,"BR",{}),M=f(q,`
            A list of `),S(O.$$.fragment,q),H=f(q," to be bound in the pipeline layout."),q.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),A.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),O.$set(K)},i(N){k||(b(a.$$.fragment,N),b(A.$$.fragment,N),b(O.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(A.$$.fragment,N),w(O.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(A),C(O)}}}function cU(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $U(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[cU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function uU(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`PipelineLayout(
    LogicalDevice* pLogicalDevice, 
    std::vector<DescriptorSetLayout*>& pDescriptorSetLayouts,
    std::vector<PushConstant> pushConstants
);`}}),r=new Ce({props:{$$slots:{throws:[$U],params:[fU],details:[aU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class pU extends ve{constructor(e){super(),Ee(this,e,null,uU,be,{})}}function mU(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hU(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[mU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function dU(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gU(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[dU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _U(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPipelineLayout getPipelineLayoutHandle() const;"}}),r=new Ce({props:{$$slots:{return:[gU],details:[hU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class vU extends ve{constructor(e){super(),Ee(this,e,null,_U,be,{})}}function EU(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bU(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[EU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Update the value of a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Update the value of a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function wU(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function IU(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DU(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CU(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SU(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[wU]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[IU]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[DU]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[CU]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[SU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            A pointer to a `),I(a.$$.fragment),u=i(" to execute the update with."),p=Y(),m=d("li"),_=d("code"),v=i("name"),P=d("br"),R=i(`
            The name of the `),I(A.$$.fragment),T=i(" to update."),F=Y(),B=d("li"),y=d("code"),V=i("upPushConstantData"),x=d("br"),M=i(`
            A `),I(O.$$.fragment),H=i(" to the new value of the "),I(k.$$.fragment),N=i(", please use "),I(Q.$$.fragment),X=i(" to transfer ownership."),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var q=E(t);r=g(q,"CODE",{});var U=E(r);$=f(U,"pCommandBuffer"),U.forEach(l),n=g(q,"BR",{}),s=f(q,`
            A pointer to a `),S(a.$$.fragment,q),u=f(q," to execute the update with."),q.forEach(l),p=j(W),m=g(W,"LI",{});var te=E(m);_=g(te,"CODE",{});var ee=E(_);v=f(ee,"name"),ee.forEach(l),P=g(te,"BR",{}),R=f(te,`
            The name of the `),S(A.$$.fragment,te),T=f(te," to update."),te.forEach(l),F=j(W),B=g(W,"LI",{});var se=E(B);y=g(se,"CODE",{});var ie=E(y);V=f(ie,"upPushConstantData"),ie.forEach(l),x=g(se,"BR",{}),M=f(se,`
            A `),S(O.$$.fragment,se),H=f(se," to the new value of the "),S(k.$$.fragment,se),N=f(se,", please use "),S(Q.$$.fragment,se),X=f(se," to transfer ownership."),se.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),D(k,B,null),o(B,N),D(Q,B,null),o(B,X),Z=!0},p(K,W){const q={};W&1&&(q.$$scope={dirty:W,ctx:K}),a.$set(q);const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),A.$set(U);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),O.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),k.$set(ee);const se={};W&1&&(se.$$scope={dirty:W,ctx:K}),Q.$set(se)},i(K){Z||(b(a.$$.fragment,K),b(A.$$.fragment,K),b(O.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(a.$$.fragment,K),w(A.$$.fragment,K),w(O.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){K&&l(e),C(a),C(A),C(O),C(k),C(Q)}}}function AU(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RU(c){let e,t,r,$,n,s,a,u,p,m;return n=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[AU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no "),I(n.$$.fragment),s=i(" with the requested "),a=d("code"),u=i("name"),p=i(" could be found."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=g(v,"CODE",{});var P=E(t);r=f(P,"std::runtime_error"),P.forEach(l),$=f(v," if no "),S(n.$$.fragment,v),s=f(v," with the requested "),a=g(v,"CODE",{});var R=E(a);u=f(R,"name"),R.forEach(l),p=f(v," could be found."),v.forEach(l),this.h()},h(){z(e,"slot","throws")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),n.$set(P)},i(_){m||(b(n.$$.fragment,_),m=!0)},o(_){w(n.$$.fragment,_),m=!1},d(_){_&&l(e),C(n)}}}function BU(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void pushConstantData(
    CommandBuffer* pCommandBuffer, 
    std::string name, 
    std::unique_ptr<PushConstantData> upPushConstantData
);`}}),r=new Ce({props:{$$slots:{throws:[RU],params:[PU],details:[bU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LU extends ve{constructor(e){super(),Ee(this,e,null,BU,be,{})}}function kU(c){let e;return{c(){e=i("Pipeline Layout Builder")},l(t){e=f(t,"Pipeline Layout Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TU(c){let e;return{c(){e=i("addPushConstant")},l(t){e=f(t,"addPushConstant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VU(c){let e;return{c(){e=i("pushConstantData")},l(t){e=f(t,"pushConstantData")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OU(c){let e;return{c(){e=i("VkPushConstantRange")},l(t){e=f(t,"VkPushConstantRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FU(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X;return a=new G({props:{sectionID:L.PIPELINE_LAYOUT_pushConstantData,$$slots:{default:[VU]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html",target:"_blank",$$slots:{default:[OU]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[FU]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The identifying name of the push constant. Can be used to push the data
            using `),I(a.$$.fragment),u=i("."),p=Y(),m=d("li"),_=d("code"),v=i("range"),P=d("br"),R=i(`
            A `),I(A.$$.fragment),T=i("-structure defining the size and offset of the push constant."),F=Y(),B=d("li"),y=d("code"),V=i("upData"),x=d("br"),M=i(`
            A `),I(O.$$.fragment),H=i(" to the "),k=d("code"),N=i("PushConstantData"),Q=i(` defining the data of the push
            constant.`),this.h()},l(Z){e=g(Z,"SPAN",{slot:!0});var K=E(e);t=g(K,"LI",{});var W=E(t);r=g(W,"CODE",{});var q=E(r);$=f(q,"name"),q.forEach(l),n=g(W,"BR",{}),s=f(W,`
            The identifying name of the push constant. Can be used to push the data
            using `),S(a.$$.fragment,W),u=f(W,"."),W.forEach(l),p=j(K),m=g(K,"LI",{});var U=E(m);_=g(U,"CODE",{});var te=E(_);v=f(te,"range"),te.forEach(l),P=g(U,"BR",{}),R=f(U,`
            A `),S(A.$$.fragment,U),T=f(U,"-structure defining the size and offset of the push constant."),U.forEach(l),F=j(K),B=g(K,"LI",{});var ee=E(B);y=g(ee,"CODE",{});var se=E(y);V=f(se,"upData"),se.forEach(l),x=g(ee,"BR",{}),M=f(ee,`
            A `),S(O.$$.fragment,ee),H=f(ee," to the "),k=g(ee,"CODE",{});var ie=E(k);N=f(ie,"PushConstantData"),ie.forEach(l),Q=f(ee,` defining the data of the push
            constant.`),ee.forEach(l),K.forEach(l),this.h()},h(){z(e,"slot","params")},m(Z,K){h(Z,e,K),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(B,k),o(k,N),o(B,Q),X=!0},p(Z,K){const W={};K&1&&(W.$$scope={dirty:K,ctx:Z}),a.$set(W);const q={};K&1&&(q.$$scope={dirty:K,ctx:Z}),A.$set(q);const U={};K&1&&(U.$$scope={dirty:K,ctx:Z}),O.$set(U)},i(Z){X||(b(a.$$.fragment,Z),b(A.$$.fragment,Z),b(O.$$.fragment,Z),X=!0)},o(Z){w(a.$$.fragment,Z),w(A.$$.fragment,Z),w(O.$$.fragment,Z),X=!1},d(Z){Z&&l(e),C(a),C(A),C(O)}}}function MU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k;return e=new $e({props:{language:ue,code:`struct PushConstantData {};

struct PushConstant {
    std::string name = "undefined";
    VkPushConstantRange range;
    std::unique_ptr<PushConstantData> upData = nullptr;
};`}}),V=new G({props:{sectionID:L.PIPELINE_BUILDER,$$slots:{default:[kU]},$$scope:{ctx:c}}}),M=new G({props:{sectionID:L.PIPELINE_BUILDER_addPushConstant,$$slots:{default:[TU]},$$scope:{ctx:c}}}),H=new Ce({props:{$$slots:{params:[yU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Push Constant"),n=i(` structure is used by the Pipeline Layout to keep
track of the information needed for pushing data to push constants.`),s=d("br"),a=i(`
The `),u=d("code"),p=i("Push Constant Data"),m=i(` structure can be extended and expanded with
any data the push constant should contain.`),_=d("br"),v=d("br"),P=i(`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants become
part of the layout of the pipeline that will use them. When pipelined push constants,
they can consume some of the resources Vulkan would otherwise use to track pipeline
or descriptor bindings. Therefore, push constants should be considered relatively
precious resources.`),R=d("br"),A=d("br"),T=i(`
It is recommended to not create the `),F=d("code"),B=i("Push Constant"),y=i(` structure
directly, but to add it to the Pipeline Layout using the `),I(V.$$.fragment),x=i("'s "),I(M.$$.fragment),O=i(` method.
`),I(H.$$.fragment)},l(N){S(e.$$.fragment,N),t=f(N,`

The `),r=g(N,"CODE",{});var Q=E(r);$=f(Q,"Push Constant"),Q.forEach(l),n=f(N,` structure is used by the Pipeline Layout to keep
track of the information needed for pushing data to push constants.`),s=g(N,"BR",{}),a=f(N,`
The `),u=g(N,"CODE",{});var X=E(u);p=f(X,"Push Constant Data"),X.forEach(l),m=f(N,` structure can be extended and expanded with
any data the push constant should contain.`),_=g(N,"BR",{}),v=g(N,"BR",{}),P=f(N,`
A push constant is a uniform variable in a shader that can be used just like a member
of a unified block, but instead of being backed up by memory, it's owned and updated
by Vulkan itself. As a result, new values for these constants can be pushed directly
into the pipeline from the command buffer, hence the term. Push constants become
part of the layout of the pipeline that will use them. When pipelined push constants,
they can consume some of the resources Vulkan would otherwise use to track pipeline
or descriptor bindings. Therefore, push constants should be considered relatively
precious resources.`),R=g(N,"BR",{}),A=g(N,"BR",{}),T=f(N,`
It is recommended to not create the `),F=g(N,"CODE",{});var Z=E(F);B=f(Z,"Push Constant"),Z.forEach(l),y=f(N,` structure
directly, but to add it to the Pipeline Layout using the `),S(V.$$.fragment,N),x=f(N,"'s "),S(M.$$.fragment,N),O=f(N,` method.
`),S(H.$$.fragment,N)},m(N,Q){D(e,N,Q),h(N,t,Q),h(N,r,Q),o(r,$),h(N,n,Q),h(N,s,Q),h(N,a,Q),h(N,u,Q),o(u,p),h(N,m,Q),h(N,_,Q),h(N,v,Q),h(N,P,Q),h(N,R,Q),h(N,A,Q),h(N,T,Q),h(N,F,Q),o(F,B),h(N,y,Q),D(V,N,Q),h(N,x,Q),D(M,N,Q),h(N,O,Q),D(H,N,Q),k=!0},p(N,[Q]){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),V.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),M.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),H.$set(K)},i(N){k||(b(e.$$.fragment,N),b(V.$$.fragment,N),b(M.$$.fragment,N),b(H.$$.fragment,N),k=!0)},o(N){w(e.$$.fragment,N),w(V.$$.fragment,N),w(M.$$.fragment,N),w(H.$$.fragment,N),k=!1},d(N){C(e,N),N&&l(t),N&&l(r),N&&l(n),N&&l(s),N&&l(a),N&&l(u),N&&l(m),N&&l(_),N&&l(v),N&&l(P),N&&l(R),N&&l(A),N&&l(T),N&&l(F),N&&l(y),C(V,N),N&&l(x),C(M,N),N&&l(O),C(H,N)}}}class xU extends ve{constructor(e){super(),Ee(this,e,null,MU,be,{})}}function NU(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UU(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GU(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HU(c){let e;return{c(){e=i("shader modules")},l(t){e=f(t,"shader modules")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qU(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WU(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QU(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/pipeline.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[NU]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[UU]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[GU]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[HU]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[qU]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[WU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with flags controlling how the pipeline is created, a list of shader stages,
a list of push constants and a optionally pipeline cache and a base pipeline, and
uses this information to construct a `),I(u.$$.fragment),p=i(" and a "),I(m.$$.fragment),_=i(" describing it's bound resources."),v=d("br"),P=d("br"),R=i(`
Before `),I(A.$$.fragment),T=i(`
can be used to do useful work on the device, you must create a pipeline. There are
two types of pipelines in Vulkan: "compute" and "graphics". The `),I(F.$$.fragment),B=i(`
is quite complex and contains many phases that have nothing to do with shaders. However,
a `),I(y.$$.fragment),V=i(`
is conceptually much simpler and essentially contains nothing but just the shader
code.`)},l(M){S(e.$$.fragment,M),t=f(M,`

The `),r=g(M,"CODE",{});var O=E(r);$=f(O,"Pipeline"),O.forEach(l),n=f(M," class takes a pointer to a "),S(s.$$.fragment,M),a=f(M,` along with flags controlling how the pipeline is created, a list of shader stages,
a list of push constants and a optionally pipeline cache and a base pipeline, and
uses this information to construct a `),S(u.$$.fragment,M),p=f(M," and a "),S(m.$$.fragment,M),_=f(M," describing it's bound resources."),v=g(M,"BR",{}),P=g(M,"BR",{}),R=f(M,`
Before `),S(A.$$.fragment,M),T=f(M,`
can be used to do useful work on the device, you must create a pipeline. There are
two types of pipelines in Vulkan: "compute" and "graphics". The `),S(F.$$.fragment,M),B=f(M,`
is quite complex and contains many phases that have nothing to do with shaders. However,
a `),S(y.$$.fragment,M),V=f(M,`
is conceptually much simpler and essentially contains nothing but just the shader
code.`)},m(M,O){D(e,M,O),h(M,t,O),h(M,r,O),o(r,$),h(M,n,O),D(s,M,O),h(M,a,O),D(u,M,O),h(M,p,O),D(m,M,O),h(M,_,O),h(M,v,O),h(M,P,O),h(M,R,O),D(A,M,O),h(M,T,O),D(F,M,O),h(M,B,O),D(y,M,O),h(M,V,O),x=!0},p(M,[O]){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),s.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),u.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),m.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),A.$set(Q);const X={};O&1&&(X.$$scope={dirty:O,ctx:M}),F.$set(X);const Z={};O&1&&(Z.$$scope={dirty:O,ctx:M}),y.$set(Z)},i(M){x||(b(e.$$.fragment,M),b(s.$$.fragment,M),b(u.$$.fragment,M),b(m.$$.fragment,M),b(A.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(e.$$.fragment,M),w(s.$$.fragment,M),w(u.$$.fragment,M),w(m.$$.fragment,M),w(A.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){C(e,M),M&&l(t),M&&l(r),M&&l(n),C(s,M),M&&l(a),C(u,M),M&&l(p),C(m,M),M&&l(_),M&&l(v),M&&l(P),M&&l(R),C(A,M),M&&l(T),C(F,M),M&&l(B),C(y,M),M&&l(V)}}}class KU extends ve{constructor(e){super(),Ee(this,e,null,QU,be,{})}}function zU(c){let e,t,r,$,n,s,a;return{c(){e=d("span"),t=i("Create a new Pipeline."),r=d("br"),$=i(`
        The `),n=d("code"),s=i("Pipeline"),a=i(` class is meant to be extended as it only contains
        the generic information and functionality shared by all pipelines.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Pipeline."),r=g(p,"BR",{}),$=f(p,`
        The `),n=g(p,"CODE",{});var m=E(n);s=f(m,"Pipeline"),m.forEach(l),a=f(p,` class is meant to be extended as it only contains
        the generic information and functionality shared by all pipelines.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function YU(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jU(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XU(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZU(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JU(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eG(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[YU]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[jU]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[XU]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[ZU]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[JU]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),F=Y(),B=d("li"),y=d("code"),V=i("shaderStages"),x=d("br"),M=i(`
            A list of `),I(O.$$.fragment),H=i("-structures each of which defining a shader stage of the pipeline."),k=Y(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),q=i(" to be bound to the pipeline."),U=Y(),te=d("li"),ee=d("code"),se=i("pipelineCache"),ie=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),pe=i(" object."),Se=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=Y(),De=d("li"),_e=d("code"),ne=i("pBasePipeline"),le=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Pe=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Le=E(r);$=f(Le,"pLogicalDevice"),Le.forEach(l),n=g(he,"BR",{}),s=f(he,`
            A pointer to the `),S(a.$$.fragment,he),u=f(he," the Pipeline should be associated with."),he.forEach(l),p=j(re),m=g(re,"LI",{});var Oe=E(m);_=g(Oe,"CODE",{});var oe=E(_);v=f(oe,"flags"),oe.forEach(l),P=g(Oe,"BR",{}),R=f(Oe,`
            A bitmask of `),S(A.$$.fragment,Oe),T=f(Oe," controlling how the pipeline is created."),Oe.forEach(l),F=j(re),B=g(re,"LI",{});var ce=E(B);y=g(ce,"CODE",{});var Ae=E(y);V=f(Ae,"shaderStages"),Ae.forEach(l),x=g(ce,"BR",{}),M=f(ce,`
            A list of `),S(O.$$.fragment,ce),H=f(ce,"-structures each of which defining a shader stage of the pipeline."),ce.forEach(l),k=j(re),N=g(re,"LI",{});var ye=E(N);Q=g(ye,"CODE",{});var Fe=E(Q);X=f(Fe,"pushConstants"),Fe.forEach(l),Z=g(ye,"BR",{}),K=f(ye,`
            A list of `),S(W.$$.fragment,ye),q=f(ye," to be bound to the pipeline."),ye.forEach(l),U=j(re),te=g(re,"LI",{});var Ve=E(te);ee=g(Ve,"CODE",{});var Ge=E(ee);se=f(Ge,"pipelineCache"),Ge.forEach(l),ie=g(Ve,"BR",{}),ae=f(Ve,`
            A handle to a `),S(J.$$.fragment,Ve),pe=f(Ve," object."),Se=g(Ve,"BR",{}),de=f(Ve,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),Ve.forEach(l),me=j(re),De=g(re,"LI",{});var He=E(De);_e=g(He,"CODE",{});var ze=E(_e);ne=f(ze,"pBasePipeline"),ze.forEach(l),le=g(He,"BR",{}),ge=f(He,`
            A pointer to the pipeline to derive from.`),we=g(He,"BR",{}),Pe=f(He,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),He.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),D(J,te,null),o(te,pe),o(te,Se),o(te,de),o(e,me),o(e,De),o(De,_e),o(_e,ne),o(De,le),o(De,ge),o(De,we),o(De,Pe),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),a.$set(he);const Le={};re&1&&(Le.$$scope={dirty:re,ctx:Ie}),A.$set(Le);const Oe={};re&1&&(Oe.$$scope={dirty:re,ctx:Ie}),O.$set(Oe);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),W.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),J.$set(ce)},i(Ie){Be||(b(a.$$.fragment,Ie),b(A.$$.fragment,Ie),b(O.$$.fragment,Ie),b(W.$$.fragment,Ie),b(J.$$.fragment,Ie),Be=!0)},o(Ie){w(a.$$.fragment,Ie),w(A.$$.fragment,Ie),w(O.$$.fragment,Ie),w(W.$$.fragment,Ie),w(J.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(a),C(A),C(O),C(W),C(J)}}}function tG(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rG(c){let e,t,r,$,n,s,a;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[tG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function nG(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Pipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags,
    std::vector<PipelineShaderStage> shaderStages, 
    std::vector<PushConstant> pushConstants,
    VkPipelineCache pipelineCache = VK_NULL_HANDLE, 
    Pipeline* pBasePipeline = nullptr
);`}}),r=new Ce({props:{$$slots:{throws:[rG],params:[eG],details:[zU]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class sG extends ve{constructor(e){super(),Ee(this,e,null,nG,be,{})}}function aG(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oG(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[aG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function lG(c){let e;return{c(){e=i("Vulkan Pipeline")},l(t){e=f(t,"Vulkan Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iG(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[lG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function fG(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkPipeline getPipelineHandle() const;"}}),r=new Ce({props:{$$slots:{return:[iG],details:[oG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class cG extends ve{constructor(e){super(),Ee(this,e,null,fG,be,{})}}function $G(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uG(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[$G]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function pG(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mG(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[pG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A pointer to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function hG(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"PipelineLayout* getPipelineLayout();"}}),r=new Ce({props:{$$slots:{return:[mG],details:[uG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class dG extends ve{constructor(e){super(),Ee(this,e,null,hG,be,{})}}function gG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _G(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vG(c){let e,t,r,$,n,s,a,u,p;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[gG]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[_G]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Bind the pipeline to a "),I(r.$$.fragment),$=i("."),n=d("br"),s=i(`
        Before a pipeline can be used, it must be bound to a `),I(a.$$.fragment),u=i(` that executes draw or send commands. This can be done with a command. When
        this command is executed, the current pipeline (and all shaders in it) is
        used to process the commands.`),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=f(_,"Bind the pipeline to a "),S(r.$$.fragment,_),$=f(_,"."),n=g(_,"BR",{}),s=f(_,`
        Before a pipeline can be used, it must be bound to a `),S(a.$$.fragment,_),u=f(_,` that executes draw or send commands. This can be done with a command. When
        this command is executed, the current pipeline (and all shaders in it) is
        used to process the commands.`),_.forEach(l),this.h()},h(){z(e,"slot","details")},m(m,_){h(m,e,_),o(e,t),D(r,e,null),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),a.$set(P)},i(m){p||(b(r.$$.fragment,m),b(a.$$.fragment,m),p=!0)},o(m){w(r.$$.fragment,m),w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(r),C(a)}}}function EG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bG(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[EG]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to bind to."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pCommandBuffer"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A pointer to the `),S(a.$$.fragment,v),u=f(v," to bind to."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function wG(c){let e,t,r,$;return{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set, this
        should be done by the class that extends the pipeline.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=g(s,"CODE",{});var a=E(t);r=f(a,"std::runtime_error"),a.forEach(l),$=f(s,` if the pipeline bindpoint is not set, this
        should be done by the class that extends the pipeline.`),s.forEach(l),this.h()},h(){z(e,"slot","throws")},m(n,s){h(n,e,s),o(e,t),o(t,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function IG(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void bindToCommandBuffer(CommandBuffer* pCommandBuffer);"}}),r=new Ce({props:{$$slots:{throws:[wG],params:[bG],details:[vG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DG extends ve{constructor(e){super(),Ee(this,e,null,IG,be,{})}}function CG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function SG(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[CG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the bound "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the bound "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function PG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function AG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RG(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[PG]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[AG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A pointer to the bound "),I(r.$$.fragment),$=i(", or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(" is bound."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"A pointer to the bound "),S(r.$$.fragment,v),$=f(v,", or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v," is bound."),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function BG(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"CommandBuffer* getCommandBuffer();"}}),r=new Ce({props:{$$slots:{return:[RG],details:[SG]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class LG extends ve{constructor(e){super(),Ee(this,e,null,BG,be,{})}}function kG(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TG(c){let e;return{c(){e=i("shader modules")},l(t){e=f(t,"shader modules")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VG(c){let e;return{c(){e=i("shader stages")},l(t){e=f(t,"shader stages")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NG(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[kG]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[TG]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[VG]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[OG]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[FG]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[yG]},$$scope:{ctx:c}}}),B=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[MG]},$$scope:{ctx:c}}}),V=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[xG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind all the "),I(r.$$.fragment),$=i(" defined within the "),I(n.$$.fragment),s=i(" of the "),I(a.$$.fragment),u=i(" to the bound "),I(p.$$.fragment),m=i("."),_=d("br"),v=d("br"),P=i(`
        To access the resources associated with a `),I(R.$$.fragment),A=i(", the "),I(T.$$.fragment),F=i(" must be bound to the "),I(B.$$.fragment),y=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(V.$$.fragment),x=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.
    `),this.h()},l(O){e=g(O,"SPAN",{slot:!0});var H=E(e);t=f(H,"bind all the "),S(r.$$.fragment,H),$=f(H," defined within the "),S(n.$$.fragment,H),s=f(H," of the "),S(a.$$.fragment,H),u=f(H," to the bound "),S(p.$$.fragment,H),m=f(H,"."),_=g(H,"BR",{}),v=g(H,"BR",{}),P=f(H,`
        To access the resources associated with a `),S(R.$$.fragment,H),A=f(H,", the "),S(T.$$.fragment,H),F=f(H," must be bound to the "),S(B.$$.fragment,H),y=f(H,` that executes the commands that access those descriptors. There are two
        binding points for `),S(V.$$.fragment,H),x=f(H,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.
    `),H.forEach(l),this.h()},h(){z(e,"slot","details")},m(O,H){h(O,e,H),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),D(p,e,null),o(e,m),o(e,_),o(e,v),o(e,P),D(R,e,null),o(e,A),D(T,e,null),o(e,F),D(B,e,null),o(e,y),D(V,e,null),o(e,x),M=!0},p(O,H){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),r.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),n.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),a.$set(Q);const X={};H&1&&(X.$$scope={dirty:H,ctx:O}),p.$set(X);const Z={};H&1&&(Z.$$scope={dirty:H,ctx:O}),R.$set(Z);const K={};H&1&&(K.$$scope={dirty:H,ctx:O}),T.$set(K);const W={};H&1&&(W.$$scope={dirty:H,ctx:O}),B.$set(W);const q={};H&1&&(q.$$scope={dirty:H,ctx:O}),V.$set(q)},i(O){M||(b(r.$$.fragment,O),b(n.$$.fragment,O),b(a.$$.fragment,O),b(p.$$.fragment,O),b(R.$$.fragment,O),b(T.$$.fragment,O),b(B.$$.fragment,O),b(V.$$.fragment,O),M=!0)},o(O){w(r.$$.fragment,O),w(n.$$.fragment,O),w(a.$$.fragment,O),w(p.$$.fragment,O),w(R.$$.fragment,O),w(T.$$.fragment,O),w(B.$$.fragment,O),w(V.$$.fragment,O),M=!1},d(O){O&&l(e),C(r),C(n),C(a),C(p),C(R),C(T),C(B),C(V)}}}function UG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GG(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[UG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(` bound.
    `),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_,` bound.
    `),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function HG(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YG(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[HG]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[qG]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[WG]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[QG]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[KG]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[zG]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind the given "),I(r.$$.fragment),$=i(" to the bound "),I(n.$$.fragment),s=i("."),a=d("br"),u=d("br"),p=i(`
        To access the resources associated with a `),I(m.$$.fragment),_=i(", the "),I(v.$$.fragment),P=i(" must be bound to the "),I(R.$$.fragment),A=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(T.$$.fragment),F=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),this.h()},l(y){e=g(y,"SPAN",{slot:!0});var V=E(e);t=f(V,"bind the given "),S(r.$$.fragment,V),$=f(V," to the bound "),S(n.$$.fragment,V),s=f(V,"."),a=g(V,"BR",{}),u=g(V,"BR",{}),p=f(V,`
        To access the resources associated with a `),S(m.$$.fragment,V),_=f(V,", the "),S(v.$$.fragment,V),P=f(V," must be bound to the "),S(R.$$.fragment,V),A=f(V,` that executes the commands that access those descriptors. There are two
        binding points for `),S(T.$$.fragment,V),F=f(V,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),V.forEach(l),this.h()},h(){z(e,"slot","details")},m(y,V){h(y,e,V),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),D(m,e,null),o(e,_),D(v,e,null),o(e,P),D(R,e,null),o(e,A),D(T,e,null),o(e,F),B=!0},p(y,V){const x={};V&1&&(x.$$scope={dirty:V,ctx:y}),r.$set(x);const M={};V&1&&(M.$$scope={dirty:V,ctx:y}),n.$set(M);const O={};V&1&&(O.$$scope={dirty:V,ctx:y}),m.$set(O);const H={};V&1&&(H.$$scope={dirty:V,ctx:y}),v.$set(H);const k={};V&1&&(k.$$scope={dirty:V,ctx:y}),R.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:y}),T.$set(N)},i(y){B||(b(r.$$.fragment,y),b(n.$$.fragment,y),b(m.$$.fragment,y),b(v.$$.fragment,y),b(R.$$.fragment,y),b(T.$$.fragment,y),B=!0)},o(y){w(r.$$.fragment,y),w(n.$$.fragment,y),w(m.$$.fragment,y),w(v.$$.fragment,y),w(R.$$.fragment,y),w(T.$$.fragment,y),B=!1},d(y){y&&l(e),C(r),C(n),C(m),C(v),C(R),C(T)}}}function jG(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XG(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function ZG(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JG(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[jG]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[XG]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[ZG]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[JG]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pDescriptorSets"),n=d("br"),s=i(`
            A list of pointers to the `),I(a.$$.fragment),u=i(" to bind to the bound "),I(p.$$.fragment),m=i("."),_=Y(),v=d("li"),P=d("code"),R=i("firstSet"),A=d("br"),T=i(`
            The set number of the first `),I(F.$$.fragment),B=i(` to bind. This is used to bind a subset of the sets accessible to the
            `),I(y.$$.fragment),V=i("."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"pDescriptorSets"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            A list of pointers to the `),S(a.$$.fragment,H),u=f(H," to bind to the bound "),S(p.$$.fragment,H),m=f(H,"."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"firstSet"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The set number of the first `),S(F.$$.fragment,N),B=f(N,` to bind. This is used to bind a subset of the sets accessible to the
            `),S(y.$$.fragment,N),V=f(N,"."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function t4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r4(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[t4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(" bound."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_," bound."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function n4(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function o4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[n4]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[s4]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[a4]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[o4]},$$scope:{ctx:c}}}),R=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[l4]},$$scope:{ctx:c}}}),T=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[i4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("bind the given "),I(r.$$.fragment),$=i(" by name to the bound "),I(n.$$.fragment),s=i("."),a=d("br"),u=d("br"),p=i(`
        To access the resources associated with a `),I(m.$$.fragment),_=i(", the "),I(v.$$.fragment),P=i(" must be bound to the "),I(R.$$.fragment),A=i(` that executes the commands that access those descriptors. There are two
        binding points for `),I(T.$$.fragment),F=i(` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),this.h()},l(y){e=g(y,"SPAN",{slot:!0});var V=E(e);t=f(V,"bind the given "),S(r.$$.fragment,V),$=f(V," by name to the bound "),S(n.$$.fragment,V),s=f(V,"."),a=g(V,"BR",{}),u=g(V,"BR",{}),p=f(V,`
        To access the resources associated with a `),S(m.$$.fragment,V),_=f(V,", the "),S(v.$$.fragment,V),P=f(V," must be bound to the "),S(R.$$.fragment,V),A=f(V,` that executes the commands that access those descriptors. There are two
        binding points for `),S(T.$$.fragment,V),F=f(V,` \u2014 one for compute and one for graphics \u2014 these are the sets that can be
        accessed by the appropriate pipelines.`),V.forEach(l),this.h()},h(){z(e,"slot","details")},m(y,V){h(y,e,V),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),o(e,p),D(m,e,null),o(e,_),D(v,e,null),o(e,P),D(R,e,null),o(e,A),D(T,e,null),o(e,F),B=!0},p(y,V){const x={};V&1&&(x.$$scope={dirty:V,ctx:y}),r.$set(x);const M={};V&1&&(M.$$scope={dirty:V,ctx:y}),n.$set(M);const O={};V&1&&(O.$$scope={dirty:V,ctx:y}),m.$set(O);const H={};V&1&&(H.$$scope={dirty:V,ctx:y}),v.$set(H);const k={};V&1&&(k.$$scope={dirty:V,ctx:y}),R.$set(k);const N={};V&1&&(N.$$scope={dirty:V,ctx:y}),T.$set(N)},i(y){B||(b(r.$$.fragment,y),b(n.$$.fragment,y),b(m.$$.fragment,y),b(v.$$.fragment,y),b(R.$$.fragment,y),b(T.$$.fragment,y),B=!0)},o(y){w(r.$$.fragment,y),w(n.$$.fragment,y),w(m.$$.fragment,y),w(v.$$.fragment,y),w(R.$$.fragment,y),w(T.$$.fragment,y),B=!1},d(y){y&&l(e),C(r),C(n),C(m),C(v),C(R),C(T)}}}function c4(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p4(c){let e;return{c(){e=i("pipeline layout")},l(t){e=f(t,"pipeline layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function m4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[c4]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[$4]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[u4]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.PIPELINE_LAYOUT,$$slots:{default:[p4]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("names"),n=d("br"),s=i(`
            A list of names of the `),I(a.$$.fragment),u=i(" to bind to the bound "),I(p.$$.fragment),m=i("."),_=Y(),v=d("li"),P=d("code"),R=i("firstSet"),A=d("br"),T=i(`
            The set number of the first `),I(F.$$.fragment),B=i(` to bind. This is used to bind a subset of the sets accessible to the
            `),I(y.$$.fragment),V=i("."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"names"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            A list of names of the `),S(a.$$.fragment,H),u=f(H," to bind to the bound "),S(p.$$.fragment,H),m=f(H,"."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"firstSet"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The set number of the first `),S(F.$$.fragment,N),B=f(N,` to bind. This is used to bind a subset of the sets accessible to the
            `),S(y.$$.fragment,N),V=f(N,"."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function h4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d4(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[h4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=d("br"),s=i(`
        Also throws std::runtime_error if there is no `),I(a.$$.fragment),u=i(" bound."),this.h()},l(m){e=g(m,"SPAN",{slot:!0});var _=E(e);t=g(_,"CODE",{});var v=E(t);r=f(v,"std::runtime_error"),v.forEach(l),$=f(_,` if the pipeline bindpoint is not set,
        this should be done by the class that extends the pipeline.`),n=g(_,"BR",{}),s=f(_,`
        Also throws std::runtime_error if there is no `),S(a.$$.fragment,_),u=f(_," bound."),_.forEach(l),this.h()},h(){z(e,"slot","throws")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(e,$),o(e,n),o(e,s),D(a,e,null),o(e,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function g4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return e=new $e({props:{language:ue,code:"void bindDescriptorSets();"}}),r=new Ce({props:{$$slots:{throws:[GG],details:[NG]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:"void bindDescriptorSets(std::vector<DescriptorSet*> pDescriptorSets, unsigned int firstSet);"}}),u=new Ce({props:{$$slots:{throws:[r4],params:[e4],details:[YG]},$$scope:{ctx:c}}}),m=new $e({props:{language:ue,code:"void bindDescriptorSets(std::vector<std::string> names, unsigned int firstSet);"}}),v=new Ce({props:{$$slots:{throws:[d4],params:[m4],details:[f4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment),p=Y(),I(m.$$.fragment),_=Y(),I(v.$$.fragment)},l(R){S(e.$$.fragment,R),t=j(R),S(r.$$.fragment,R),$=g(R,"BR",{}),n=j(R),S(s.$$.fragment,R),a=j(R),S(u.$$.fragment,R),p=j(R),S(m.$$.fragment,R),_=j(R),S(v.$$.fragment,R)},m(R,A){D(e,R,A),h(R,t,A),D(r,R,A),h(R,$,A),h(R,n,A),D(s,R,A),h(R,a,A),D(u,R,A),h(R,p,A),D(m,R,A),h(R,_,A),D(v,R,A),P=!0},p(R,[A]){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),r.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),u.$set(F);const B={};A&1&&(B.$$scope={dirty:A,ctx:R}),v.$set(B)},i(R){P||(b(e.$$.fragment,R),b(r.$$.fragment,R),b(s.$$.fragment,R),b(u.$$.fragment,R),b(m.$$.fragment,R),b(v.$$.fragment,R),P=!0)},o(R){w(e.$$.fragment,R),w(r.$$.fragment,R),w(s.$$.fragment,R),w(u.$$.fragment,R),w(m.$$.fragment,R),w(v.$$.fragment,R),P=!1},d(R){C(e,R),R&&l(t),C(r,R),R&&l($),R&&l(n),C(s,R),R&&l(a),C(u,R),R&&l(p),C(m,R),R&&l(_),C(v,R)}}}class _4 extends ve{constructor(e){super(),Ee(this,e,null,g4,be,{})}}function v4(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E4(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[v4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get all the "),I(r.$$.fragment),$=i(" of this pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get all the "),S(r.$$.fragment,a),$=f(a," of this pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function b4(c){let e;return{c(){e=i("descriptor sets")},l(t){e=f(t,"descriptor sets")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w4(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I4(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[b4]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[w4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of pointers to all the "),I(r.$$.fragment),$=i(" of this "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A list of pointers to all the "),S(r.$$.fragment,p),$=f(p," of this "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function D4(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::vector<DescriptorSet*>& getDescriptorSets();"}}),r=new Ce({props:{$$slots:{return:[I4],details:[E4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class C4 extends ve{constructor(e){super(),Ee(this,e,null,D4,be,{})}}function S4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P4(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[S4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get a "),I(r.$$.fragment),$=i(" by name."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get a "),S(r.$$.fragment,a),$=f(a," by name."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function A4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R4(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[A4]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i(" to get."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"name"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The name of the `),S(a.$$.fragment,v),u=f(v," to get."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function B4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L4(c){let e;return{c(){e=i("descriptor set")},l(t){e=f(t,"descriptor set")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k4(c){let e,t,r,$,n,s,a,u,p,m;return r=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[B4]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.DESCRIPTOR_SET,$$slots:{default:[L4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(" with the given name, or "),n=d("code"),s=i("nullptr"),a=i(" if no "),I(u.$$.fragment),p=i(`
        with the given name was found.`),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"The "),S(r.$$.fragment,v),$=f(v," with the given name, or "),n=g(v,"CODE",{});var P=E(n);s=f(P,"nullptr"),P.forEach(l),a=f(v," if no "),S(u.$$.fragment,v),p=f(v,`
        with the given name was found.`),v.forEach(l),this.h()},h(){z(e,"slot","return")},m(_,v){h(_,e,v),o(e,t),D(r,e,null),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),u.$set(R)},i(_){m||(b(r.$$.fragment,_),b(u.$$.fragment,_),m=!0)},o(_){w(r.$$.fragment,_),w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(r),C(u)}}}function T4(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"DescriptorSet* getDescriptorSet(std::string name);"}}),r=new Ce({props:{$$slots:{return:[k4],params:[R4],details:[P4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class V4 extends ve{constructor(e){super(),Ee(this,e,null,T4,be,{})}}function O4(c){let e;return{c(){e=i("VkPipelineShaderStageCreateInfo")},l(t){e=f(t,"VkPipelineShaderStageCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F4(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y4(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M4(c){let e;return{c(){e=i("VkShaderStageFlagBits")},l(t){e=f(t,"VkShaderStageFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x4(c){let e;return{c(){e=i("shader module")},l(t){e=f(t,"shader module")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html",target:"_blank",$$slots:{default:[M4]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.SHADER_MODULE,$$slots:{default:[x4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("li"),r=d("code"),$=i("stage"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i("-enumerant specifying the pipeline stage."),p=Y(),m=d("li"),_=d("code"),v=i("pShaderModule"),P=d("br"),R=i(`
            A pointer to the `),I(A.$$.fragment),T=i(" containing the shader code for this stage or nullptr."),F=Y(),B=d("li"),y=d("code"),V=i("name"),x=d("br"),M=i(`
            The entry point name of the shader of this stage.`),this.h()},l(H){e=g(H,"SPAN",{slot:!0});var k=E(e);t=g(k,"LI",{});var N=E(t);r=g(N,"CODE",{});var Q=E(r);$=f(Q,"stage"),Q.forEach(l),n=g(N,"BR",{}),s=f(N,`
            A member of the `),S(a.$$.fragment,N),u=f(N,"-enumerant specifying the pipeline stage."),N.forEach(l),p=j(k),m=g(k,"LI",{});var X=E(m);_=g(X,"CODE",{});var Z=E(_);v=f(Z,"pShaderModule"),Z.forEach(l),P=g(X,"BR",{}),R=f(X,`
            A pointer to the `),S(A.$$.fragment,X),T=f(X," containing the shader code for this stage or nullptr."),X.forEach(l),F=j(k),B=g(k,"LI",{});var K=E(B);y=g(K,"CODE",{});var W=E(y);V=f(W,"name"),W.forEach(l),x=g(K,"BR",{}),M=f(K,`
            The entry point name of the shader of this stage.`),K.forEach(l),k.forEach(l),this.h()},h(){z(e,"slot","params")},m(H,k){h(H,e,k),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),O=!0},p(H,k){const N={};k&1&&(N.$$scope={dirty:k,ctx:H}),a.$set(N);const Q={};k&1&&(Q.$$scope={dirty:k,ctx:H}),A.$set(Q)},i(H){O||(b(a.$$.fragment,H),b(A.$$.fragment,H),O=!0)},o(H){w(a.$$.fragment,H),w(A.$$.fragment,H),O=!1},d(H){H&&l(e),C(a),C(A)}}}function U4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return e=new $e({props:{language:ue,code:`struct PipelineShaderStage {
    VkShaderStageFlagBits stage;
    ShaderModule* pShaderModule;
    std::string name;
    // TODO: Specialization Constants
};`}}),s=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html",target:"_blank",$$slots:{default:[O4]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[F4]},$$scope:{ctx:c}}}),m=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[y4]},$$scope:{ctx:c}}}),R=new Ce({props:{$$slots:{params:[N4]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Pipeline Shader Stage"),n=i(` structure is used by the Pipeline to
construct the `),I(s.$$.fragment),a=i("-structure which is used by both the "),I(u.$$.fragment),p=i(" and the "),I(m.$$.fragment),_=i("."),v=d("br"),P=Y(),I(R.$$.fragment)},l(T){S(e.$$.fragment,T),t=f(T,`

The `),r=g(T,"CODE",{});var F=E(r);$=f(F,"Pipeline Shader Stage"),F.forEach(l),n=f(T,` structure is used by the Pipeline to
construct the `),S(s.$$.fragment,T),a=f(T,"-structure which is used by both the "),S(u.$$.fragment,T),p=f(T," and the "),S(m.$$.fragment,T),_=f(T,"."),v=g(T,"BR",{}),P=j(T),S(R.$$.fragment,T)},m(T,F){D(e,T,F),h(T,t,F),h(T,r,F),o(r,$),h(T,n,F),D(s,T,F),h(T,a,F),D(u,T,F),h(T,p,F),D(m,T,F),h(T,_,F),h(T,v,F),h(T,P,F),D(R,T,F),A=!0},p(T,[F]){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),s.$set(B);const y={};F&1&&(y.$$scope={dirty:F,ctx:T}),u.$set(y);const V={};F&1&&(V.$$scope={dirty:F,ctx:T}),m.$set(V);const x={};F&1&&(x.$$scope={dirty:F,ctx:T}),R.$set(x)},i(T){A||(b(e.$$.fragment,T),b(s.$$.fragment,T),b(u.$$.fragment,T),b(m.$$.fragment,T),b(R.$$.fragment,T),A=!0)},o(T){w(e.$$.fragment,T),w(s.$$.fragment,T),w(u.$$.fragment,T),w(m.$$.fragment,T),w(R.$$.fragment,T),A=!1},d(T){C(e,T),T&&l(t),T&&l(r),T&&l(n),C(s,T),T&&l(a),C(u,T),T&&l(p),C(m,T),T&&l(_),T&&l(v),T&&l(P),C(R,T)}}}class G4 extends ve{constructor(e){super(),Ee(this,e,null,U4,be,{})}}function H4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W4(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[H4]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[q4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Update the value of a "),I(r.$$.fragment),$=i(" using the bound "),I(n.$$.fragment),s=i(`.
    `),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Update the value of a "),S(r.$$.fragment,p),$=f(p," using the bound "),S(n.$$.fragment,p),s=f(p,`.
    `),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Q4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K4(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function z4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Y4(c){let e;return{c(){e=i("std::move")},l(t){e=f(t,"std::move")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function j4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return a=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[Q4]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[K4]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[z4]},$$scope:{ctx:c}}}),y=new fe({props:{href:"https://en.cppreference.com/w/cpp/utility/move",target:"_blank",$$slots:{default:[Y4]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The name of the `),I(a.$$.fragment),u=i(" to update."),p=Y(),m=d("li"),_=d("code"),v=i("upPushConstantData"),P=d("br"),R=i(`
            A `),I(A.$$.fragment),T=i(" to the new value of the "),I(F.$$.fragment),B=i(", please use "),I(y.$$.fragment),V=i(" to transfer ownership."),x=Y(),this.h()},l(O){e=g(O,"DIV",{slot:!0});var H=E(e);t=g(H,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"name"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            The name of the `),S(a.$$.fragment,k),u=f(k," to update."),k.forEach(l),p=j(H),m=g(H,"LI",{});var Q=E(m);_=g(Q,"CODE",{});var X=E(_);v=f(X,"upPushConstantData"),X.forEach(l),P=g(Q,"BR",{}),R=f(Q,`
            A `),S(A.$$.fragment,Q),T=f(Q," to the new value of the "),S(F.$$.fragment,Q),B=f(Q,", please use "),S(y.$$.fragment,Q),V=f(Q," to transfer ownership."),Q.forEach(l),x=j(H),H.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,H){h(O,e,H),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),D(y,m,null),o(m,V),o(e,x),M=!0},p(O,H){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),a.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),A.$set(N);const Q={};H&1&&(Q.$$scope={dirty:H,ctx:O}),F.$set(Q);const X={};H&1&&(X.$$scope={dirty:H,ctx:O}),y.$set(X)},i(O){M||(b(a.$$.fragment,O),b(A.$$.fragment,O),b(F.$$.fragment,O),b(y.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(A.$$.fragment,O),w(F.$$.fragment,O),w(y.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(A),C(F),C(y)}}}function X4(c){let e;return{c(){e=i("push constant")},l(t){e=f(t,"push constant")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z4(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J4(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return n=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[X4]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[Z4]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if no "),I(n.$$.fragment),s=i(" with the requested "),a=d("code"),u=i("name"),p=i(" could be found."),m=d("br"),_=i(`
        Also throws std::runtime_error if there is no `),I(v.$$.fragment),P=i(` bound.
    `),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=g(T,"CODE",{});var F=E(t);r=f(F,"std::runtime_error"),F.forEach(l),$=f(T," if no "),S(n.$$.fragment,T),s=f(T," with the requested "),a=g(T,"CODE",{});var B=E(a);u=f(B,"name"),B.forEach(l),p=f(T," could be found."),m=g(T,"BR",{}),_=f(T,`
        Also throws std::runtime_error if there is no `),S(v.$$.fragment,T),P=f(T,` bound.
    `),T.forEach(l),this.h()},h(){z(e,"slot","throws")},m(A,T){h(A,e,T),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(e,_),D(v,e,null),o(e,P),R=!0},p(A,T){const F={};T&1&&(F.$$scope={dirty:T,ctx:A}),n.$set(F);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),v.$set(B)},i(A){R||(b(n.$$.fragment,A),b(v.$$.fragment,A),R=!0)},o(A){w(n.$$.fragment,A),w(v.$$.fragment,A),R=!1},d(A){A&&l(e),C(n),C(v)}}}function e5(c){let e,t,r,$,n,s,a;return e=new $e({props:{language:ue,code:`void pushConstantData(
    std::string name, 
    std::unique_ptr<PushConstantData> upPushConstantData
);`}}),r=new Ce({props:{$$slots:{throws:[J4],params:[j4],details:[W4]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct SimplePushConstantData : public fillcan::PushConstantData {
    int exampleValue;
};

SimplePushConstantData data = { .exampleValue = 1 };
std::unique_ptr<SimplePushConstantData> simplePushConstantData = std::make_unique<SimplePushConstantData>(data);
graphicsPipeline.pushConstantData("SimplePushConstant", std::move(simplePushConstantData));`}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=i(`
Example:
`),I(s.$$.fragment)},l(u){S(e.$$.fragment,u),t=j(u),S(r.$$.fragment,u),$=g(u,"BR",{}),n=f(u,`
Example:
`),S(s.$$.fragment,u)},m(u,p){D(e,u,p),h(u,t,p),D(r,u,p),h(u,$,p),h(u,n,p),D(s,u,p),a=!0},p(u,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m)},i(u){a||(b(e.$$.fragment,u),b(r.$$.fragment,u),b(s.$$.fragment,u),a=!0)},o(u){w(e.$$.fragment,u),w(r.$$.fragment,u),w(s.$$.fragment,u),a=!1},d(u){C(e,u),u&&l(t),C(r,u),u&&l($),u&&l(n),C(s,u)}}}class t5 extends ve{constructor(e){super(),Ee(this,e,null,e5,be,{})}}function r5(c){let e,t,r,$,n,s,a,u,p,m,_;return e=new $e({props:{language:ue,code:"#include <fillcan/shader/pipeline_builder.hpp>"}}),m=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
VkPipelineCreateFlags flags = 0;
std::vector<PushConstant> pushConstants = {};
VkPipelineCache pipelineCache = VK_NULL_HANDLE;
Pipeline* pBasePipeline = nullptr;`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Pipeline Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment)},l(v){S(e.$$.fragment,v),t=f(v,`
The `),r=g(v,"CODE",{});var P=E(r);$=f(P,"Pipeline Builder"),P.forEach(l),n=f(v,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(v,"BR",{}),a=f(v,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(v,"BR",{}),p=f(v,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,v)},m(v,P){D(e,v,P),h(v,t,P),h(v,r,P),o(r,$),h(v,n,P),h(v,s,P),h(v,a,P),h(v,u,P),h(v,p,P),D(m,v,P),_=!0},p:ke,i(v){_||(b(e.$$.fragment,v),b(m.$$.fragment,v),_=!0)},o(v){w(e.$$.fragment,v),w(m.$$.fragment,v),_=!1},d(v){C(e,v),v&&l(t),v&&l(r),v&&l(n),v&&l(s),v&&l(a),v&&l(u),v&&l(p),C(m,v)}}}class n5 extends ve{constructor(e){super(),Ee(this,e,null,r5,be,{})}}function s5(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a5(c){let e,t,r,$,n,s,a,u,p,m;return u=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[s5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Pipeline Builder."),r=d("br"),$=i(`
        The `),n=d("code"),s=i("Pipeline Builder"),a=i(` class is meant to be extended as it
        only asks for the generic information shared by all `),I(u.$$.fragment),p=i("."),this.h()},l(_){e=g(_,"SPAN",{slot:!0});var v=E(e);t=f(v,"Create a new Pipeline Builder."),r=g(v,"BR",{}),$=f(v,`
        The `),n=g(v,"CODE",{});var P=E(n);s=f(P,"Pipeline Builder"),P.forEach(l),a=f(v,` class is meant to be extended as it
        only asks for the generic information shared by all `),S(u.$$.fragment,v),p=f(v,"."),v.forEach(l),this.h()},h(){z(e,"slot","details")},m(_,v){h(_,e,v),o(e,t),o(e,r),o(e,$),o(e,n),o(n,s),o(e,a),D(u,e,null),o(e,p),m=!0},p(_,v){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),u.$set(P)},i(_){m||(b(u.$$.fragment,_),m=!0)},o(_){w(u.$$.fragment,_),m=!1},d(_){_&&l(e),C(u)}}}function o5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"PipelineBuilder();"}}),r=new Ce({props:{$$slots:{details:[a5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class l5 extends ve{constructor(e){super(),Ee(this,e,null,o5,be,{})}}function i5(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function f5(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c5(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[i5]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[f5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function $5(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function u5(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p5(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[$5]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[u5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(`
            should be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R,`
            should be associated with.`),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function m5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[p5],details:[c5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class h5 extends ve{constructor(e){super(),Ee(this,e,null,m5,be,{})}}function d5(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function g5(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[d5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the flags for the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the flags for the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function _5(c){let e;return{c(){e=i("VkPipelineCreateFlags")},l(t){e=f(t,"VkPipelineCreateFlags")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v5(c){let e,t,r,$,n,s,a,u,p;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlags.html",target:"_blank",$$slots:{default:[_5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("flags"),n=d("br"),s=i(`
            A bitmask of `),I(a.$$.fragment),u=i(" controlling how the pipeline is created."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"flags"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A bitmask of `),S(a.$$.fragment,v),u=f(v," controlling how the pipeline is created."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function E5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFlags(VkPipelineCreateFlags flags);"}}),r=new Ce({props:{$$slots:{params:[v5],details:[g5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class b5 extends ve{constructor(e){super(),Ee(this,e,null,E5,be,{})}}function w5(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I5(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[w5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," for the pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function D5(c){let e;return{c(){e=i("VkPushConstantRange")},l(t){e=f(t,"VkPushConstantRange")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C5(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return P=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html",target:"_blank",$$slots:{default:[D5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("name"),n=d("br"),s=i(`
            The identifying name for the push constant.`),a=Y(),u=d("li"),p=d("code"),m=i("pushConstantRange"),_=d("br"),v=i(`
            A `),I(P.$$.fragment),R=i("-structure defining the size and offset of the push constant."),this.h()},l(T){e=g(T,"DIV",{slot:!0});var F=E(e);t=g(F,"LI",{});var B=E(t);r=g(B,"CODE",{});var y=E(r);$=f(y,"name"),y.forEach(l),n=g(B,"BR",{}),s=f(B,`
            The identifying name for the push constant.`),B.forEach(l),a=j(F),u=g(F,"LI",{});var V=E(u);p=g(V,"CODE",{});var x=E(p);m=f(x,"pushConstantRange"),x.forEach(l),_=g(V,"BR",{}),v=f(V,`
            A `),S(P.$$.fragment,V),R=f(V,"-structure defining the size and offset of the push constant."),V.forEach(l),F.forEach(l),this.h()},h(){z(e,"slot","params")},m(T,F){h(T,e,F),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),P.$set(B)},i(T){A||(b(P.$$.fragment,T),A=!0)},o(T){w(P.$$.fragment,T),A=!1},d(T){T&&l(e),C(P)}}}function S5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void addPushConstant(std::string name, VkPushConstantRange pushConstantRange);"}}),r=new Ce({props:{$$slots:{params:[C5],details:[I5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class P5 extends ve{constructor(e){super(),Ee(this,e,null,S5,be,{})}}function A5(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R5(c){let e,t,r,$,n;return r=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[A5]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the pipeline."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," for the pipeline."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function B5(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L5(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k5(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T5(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V5(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O5(c){let e;return{c(){e=i("pipelines")},l(t){e=f(t,"pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F5(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y5(c){let e;return{c(){e=i("pipeline cache")},l(t){e=f(t,"pipeline cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M5(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k;return a=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[B5]},$$scope:{ctx:c}}}),_=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[L5]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[k5]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[T5]},$$scope:{ctx:c}}}),F=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[V5]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[O5]},$$scope:{ctx:c}}}),x=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[F5]},$$scope:{ctx:c}}}),O=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[y5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineCache"),n=d("br"),s=i(`
            A handle to a `),I(a.$$.fragment),u=i(" object."),p=d("br"),m=i(`
            Allows the result of `),I(_.$$.fragment),v=i(" construction to be reused between "),I(P.$$.fragment),R=i(`
            and between runs of an application. Reuse between `),I(A.$$.fragment),T=i(" is achieved by passing the same "),I(F.$$.fragment),B=i(` object when creating multiple related
            `),I(y.$$.fragment),V=i(`.
            Reuse across runs of an application is achieved by retrieving
            `),I(x.$$.fragment),M=i(` contents in one run of an application, saving the contents, and using
            them to preinitialize a `),I(O.$$.fragment),H=i(" on a subsequent run."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"pipelineCache"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            A handle to a `),S(a.$$.fragment,X),u=f(X," object."),p=g(X,"BR",{}),m=f(X,`
            Allows the result of `),S(_.$$.fragment,X),v=f(X," construction to be reused between "),S(P.$$.fragment,X),R=f(X,`
            and between runs of an application. Reuse between `),S(A.$$.fragment,X),T=f(X," is achieved by passing the same "),S(F.$$.fragment,X),B=f(X,` object when creating multiple related
            `),S(y.$$.fragment,X),V=f(X,`.
            Reuse across runs of an application is achieved by retrieving
            `),S(x.$$.fragment,X),M=f(X,` contents in one run of an application, saving the contents, and using
            them to preinitialize a `),S(O.$$.fragment,X),H=f(X," on a subsequent run."),X.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),D(_,t,null),o(t,v),D(P,t,null),o(t,R),D(A,t,null),o(t,T),D(F,t,null),o(t,B),D(y,t,null),o(t,V),D(x,t,null),o(t,M),D(O,t,null),o(t,H),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),_.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),P.$set(K);const W={};Q&1&&(W.$$scope={dirty:Q,ctx:N}),A.$set(W);const q={};Q&1&&(q.$$scope={dirty:Q,ctx:N}),F.$set(q);const U={};Q&1&&(U.$$scope={dirty:Q,ctx:N}),y.$set(U);const te={};Q&1&&(te.$$scope={dirty:Q,ctx:N}),x.$set(te);const ee={};Q&1&&(ee.$$scope={dirty:Q,ctx:N}),O.$set(ee)},i(N){k||(b(a.$$.fragment,N),b(_.$$.fragment,N),b(P.$$.fragment,N),b(A.$$.fragment,N),b(F.$$.fragment,N),b(y.$$.fragment,N),b(x.$$.fragment,N),b(O.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(_.$$.fragment,N),w(P.$$.fragment,N),w(A.$$.fragment,N),w(F.$$.fragment,N),w(y.$$.fragment,N),w(x.$$.fragment,N),w(O.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(_),C(P),C(A),C(F),C(y),C(x),C(O)}}}function x5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setPipelineCache(VkPipelineCache pipelineCache);"}}),r=new Ce({props:{$$slots:{params:[M5],details:[R5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class N5 extends ve{constructor(e){super(),Ee(this,e,null,x5,be,{})}}function U5(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G5(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function H5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[G5],default:[U5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class q5 extends ve{constructor(e){super(),Ee(this,e,null,H5,be,{})}}function W5(c){let e,t;return{c(){e=d("span"),t=i("Set the base pipeline for the pipeline."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the base pipeline for the pipeline."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Q5(c){let e;return{c(){e=i("pipeline")},l(t){e=f(t,"pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K5(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[Q5]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pBasePipeline"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" to derive from."),p=d("br"),m=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pBasePipeline"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," to derive from."),p=g(R,"BR",{}),m=f(R,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R)},i(v){_||(b(a.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),_=!1},d(v){v&&l(e),C(a)}}}function z5(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setPipelineCache(VkPipelineCache pipelineCache);"}}),r=new Ce({props:{$$slots:{params:[K5],details:[W5]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Y5 extends ve{constructor(e){super(),Ee(this,e,null,z5,be,{})}}function j5(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X5(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Z5(c){let e;return{c(){e=i("VkPhysicalDeviceProperties")},l(t){e=f(t,"VkPhysicalDeviceProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J5(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eH(c){let e;return{c(){e=i("vkCmdDispatch")},l(t){e=f(t,"vkCmdDispatch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tH(c){let e;return{c(){e=i("vkCmdDispatch")},l(t){e=f(t,"vkCmdDispatch")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rH(c){let e;return{c(){e=i("vkCmdDispatchIndirect")},l(t){e=f(t,"vkCmdDispatchIndirect")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nH(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie;return e=new $e({props:{language:ue,code:"#include <fillcan/computing/compute_pipeline.hpp>"}}),a=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[j5]},$$scope:{ctx:c}}}),F=new $e({props:{language:ue,code:`#version 450 core
layout (local_size_x = 2, local_size_y, local_size = 4) in;

void main(void)
{
    // Do something
}`}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html",target:"_blank",$$slots:{default:[X5]},$$scope:{ctx:c}}}),Z=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html",target:"_blank",$$slots:{default:[Z5]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[J5]},$$scope:{ctx:c}}}),ae=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html",target:"_blank",$$slots:{default:[eH]},$$scope:{ctx:c}}}),me=new $e({props:{language:hn,code:`#version 450 core

layout (local_size_x=256, local_size_y=1, local_size_z=1) in;

layout (set=0, binding=0) uniform Config
{
    int transform;
    int integerCount;
} configData;
        
layout (set=0, binding=1) readonly buffer InputBuffer
{
    int integers[4096];
} inputData;
        
layout (set=0, binding=2) buffer OutputBuffer
{
    int integers[4096];
} outputData;
        
void main(void)
{
    // Grab global ID
    uint globalID = gl_GlobalInvocationID.x;
        
    // Don't access past the buffer size
    if (globalID < configData.integerCount)
    {
        // Perform some calculations
        outputData.integers[globalID] = inputData.integers[globalID] * configData.transform;
    }
}`}}),_e=new $e({props:{language:ue,code:`// Create recording to gain access to a primary commandbuffer
fillcan::CommandRecording* pComputeCommandRecording = fillcan.getCurrentDevice()->getComputeQueue()->createRecording(1, 0);
fillcan::CommandBuffer* pComputePrimaryCommandBuffer = pComputeCommandRecording->pPrimaryCommandBuffers.at(0);

// Begin compute recording commands
pComputePrimaryCommandBuffer->begin();

// Bind a command buffer to the compute pipeline
upComputePipeline->bindToCommandBuffer(pComputePrimaryCommandBuffer);

// Bind the descriptor sets to the bound command buffer
upComputePipeline->bindDescriptorSets();

// Define the amount of local workgroups for the x-dimension
// (the amount of computations to execute divided by the size of the local workgroup)
int groupCount = ((4096) / 256) + 1;

// Dispatch all the work
vkCmdDispatch(pComputePrimaryCommandBuffer->getCommandBufferHandle(), groupCount, 1, 1);

// End the recording
pComputePrimaryCommandBuffer->end();`}}),ge=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html",target:"_blank",$$slots:{default:[tH]},$$scope:{ctx:c}}}),Pe=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html",target:"_blank",$$slots:{default:[rH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Compute Pipeline"),n=i(` class extends the
`),s=d("code"),I(a.$$.fragment),u=i(`
class.`),p=d("br"),m=d("br"),_=i(`
The compute shader provides direct access to the computing capabilities of the Vulkan
device. The device can be thought of as a collection of broad vector processing units
operating on related data. A compute shader is written as if it were a serial, single
run track. However, many of these run tracks can run simultaneously. This is how
most Vulkan devices are built. Each track of execution is called an invocation.`),v=d("br"),P=i(`
When a compute shader is running, many calls are made at once. The invocations are
grouped into fixed size local workgroups, then one or more of these groups are run
together in what is sometimes known as a global workgroup. Logically, both the local
and global workgroups are three-dimensional. However, if the size of one of the three
dimensions is set to one, the dimensionality of the group is reduced.`),R=d("br"),A=d("br"),T=i(`
Once a pipeline is tied, it can be used to perform work. Compute shaders that run
as part of a compute pipeline run in groups called local workgroups. The size of
the local workgroup is set in the compute shader. In GLSL this is done using a layout
qualifier:
`),I(F.$$.fragment),B=i(`
The maximum size of a local workgroup for a compute shader is generally quite small
and only needs to be a minimum of 128 calls in the x and y dimensions and 64 calls
in the z dimension. Furthermore, the total "volume" of the workgroup (the product
of the limit in x, y, and z directions) is subject to a further limit, which may
only be a minimum of 128 x 128 x 64 invocations. While many implementations support
higher limits, the limits should always be queried if the required minimums are to
be exceeded.`),y=d("br"),V=i(`
The maximum size of a workgroup and the maximum total calls in the workgroup can
be determined from the `),x=d("code"),M=i("maxComputeWorkGroupSize"),O=i(` field and
`),H=d("code"),k=i("maxComputeWorkGroupInvocations"),N=i(`
field, respectively, of the `),I(Q.$$.fragment),X=i("-structure within the "),I(Z.$$.fragment),K=i("-structure returned by a call to "),I(W.$$.fragment),q=i("."),U=d("br"),te=d("br"),ee=i(`
Because there are limitations to the use of some local workgroups, local workgroups
are started in larger groups, also called the global workgroup or "dispatch". Kicking
off work in a compute shader is therefore called dispatch work or a dispatch (or
"dispatch"). The local workgroup is logically a 3D construct, or a volume of invocations,
although as many as one or two of the dimensions may have a single invocation in
size, flattening the workgroup in that direction. Likewise, these local workgroups
are sent together in three dimensions, even if one or more of those dimensions is
a single workgroup deep (so 32 x 32 x 1 and 64 x 1 x 1 workgroups is valid).`),se=d("br"),ie=i(`
The command to dispatch a global workgroup using a compute pipeline is `),I(ae.$$.fragment),J=i("."),pe=d("br"),Se=d("br"),de=i(`

Example:
`),I(me.$$.fragment),De=Y(),I(_e.$$.fragment),ne=d("br"),le=i(`
In addition to being able to specify the number of workgroups in the dispatch using
parameters to `),I(ge.$$.fragment),we=i(`, it is possible to perform an indirect dispatch, where the size of the
dispatch in workgroups comes from a buffer object. This allows the calculation
of send sizes after a command buffer is built by performing an indirect dispatch
using a buffer and then overwriting the contents of the buffer using the host.
The contents of the buffer can even be updated using the device itself to
provide a limited means for the device to feed itself work. This can be done
with `),I(Pe.$$.fragment),Be=i(".")},l(re){S(e.$$.fragment,re),t=f(re,`

The `),r=g(re,"CODE",{});var he=E(r);$=f(he,"Compute Pipeline"),he.forEach(l),n=f(re,` class extends the
`),s=g(re,"CODE",{});var Le=E(s);S(a.$$.fragment,Le),Le.forEach(l),u=f(re,`
class.`),p=g(re,"BR",{}),m=g(re,"BR",{}),_=f(re,`
The compute shader provides direct access to the computing capabilities of the Vulkan
device. The device can be thought of as a collection of broad vector processing units
operating on related data. A compute shader is written as if it were a serial, single
run track. However, many of these run tracks can run simultaneously. This is how
most Vulkan devices are built. Each track of execution is called an invocation.`),v=g(re,"BR",{}),P=f(re,`
When a compute shader is running, many calls are made at once. The invocations are
grouped into fixed size local workgroups, then one or more of these groups are run
together in what is sometimes known as a global workgroup. Logically, both the local
and global workgroups are three-dimensional. However, if the size of one of the three
dimensions is set to one, the dimensionality of the group is reduced.`),R=g(re,"BR",{}),A=g(re,"BR",{}),T=f(re,`
Once a pipeline is tied, it can be used to perform work. Compute shaders that run
as part of a compute pipeline run in groups called local workgroups. The size of
the local workgroup is set in the compute shader. In GLSL this is done using a layout
qualifier:
`),S(F.$$.fragment,re),B=f(re,`
The maximum size of a local workgroup for a compute shader is generally quite small
and only needs to be a minimum of 128 calls in the x and y dimensions and 64 calls
in the z dimension. Furthermore, the total "volume" of the workgroup (the product
of the limit in x, y, and z directions) is subject to a further limit, which may
only be a minimum of 128 x 128 x 64 invocations. While many implementations support
higher limits, the limits should always be queried if the required minimums are to
be exceeded.`),y=g(re,"BR",{}),V=f(re,`
The maximum size of a workgroup and the maximum total calls in the workgroup can
be determined from the `),x=g(re,"CODE",{});var Oe=E(x);M=f(Oe,"maxComputeWorkGroupSize"),Oe.forEach(l),O=f(re,` field and
`),H=g(re,"CODE",{});var oe=E(H);k=f(oe,"maxComputeWorkGroupInvocations"),oe.forEach(l),N=f(re,`
field, respectively, of the `),S(Q.$$.fragment,re),X=f(re,"-structure within the "),S(Z.$$.fragment,re),K=f(re,"-structure returned by a call to "),S(W.$$.fragment,re),q=f(re,"."),U=g(re,"BR",{}),te=g(re,"BR",{}),ee=f(re,`
Because there are limitations to the use of some local workgroups, local workgroups
are started in larger groups, also called the global workgroup or "dispatch". Kicking
off work in a compute shader is therefore called dispatch work or a dispatch (or
"dispatch"). The local workgroup is logically a 3D construct, or a volume of invocations,
although as many as one or two of the dimensions may have a single invocation in
size, flattening the workgroup in that direction. Likewise, these local workgroups
are sent together in three dimensions, even if one or more of those dimensions is
a single workgroup deep (so 32 x 32 x 1 and 64 x 1 x 1 workgroups is valid).`),se=g(re,"BR",{}),ie=f(re,`
The command to dispatch a global workgroup using a compute pipeline is `),S(ae.$$.fragment,re),J=f(re,"."),pe=g(re,"BR",{}),Se=g(re,"BR",{}),de=f(re,`

Example:
`),S(me.$$.fragment,re),De=j(re),S(_e.$$.fragment,re),ne=g(re,"BR",{}),le=f(re,`
In addition to being able to specify the number of workgroups in the dispatch using
parameters to `),S(ge.$$.fragment,re),we=f(re,`, it is possible to perform an indirect dispatch, where the size of the
dispatch in workgroups comes from a buffer object. This allows the calculation
of send sizes after a command buffer is built by performing an indirect dispatch
using a buffer and then overwriting the contents of the buffer using the host.
The contents of the buffer can even be updated using the device itself to
provide a limited means for the device to feed itself work. This can be done
with `),S(Pe.$$.fragment,re),Be=f(re,".")},m(re,he){D(e,re,he),h(re,t,he),h(re,r,he),o(r,$),h(re,n,he),h(re,s,he),D(a,s,null),h(re,u,he),h(re,p,he),h(re,m,he),h(re,_,he),h(re,v,he),h(re,P,he),h(re,R,he),h(re,A,he),h(re,T,he),D(F,re,he),h(re,B,he),h(re,y,he),h(re,V,he),h(re,x,he),o(x,M),h(re,O,he),h(re,H,he),o(H,k),h(re,N,he),D(Q,re,he),h(re,X,he),D(Z,re,he),h(re,K,he),D(W,re,he),h(re,q,he),h(re,U,he),h(re,te,he),h(re,ee,he),h(re,se,he),h(re,ie,he),D(ae,re,he),h(re,J,he),h(re,pe,he),h(re,Se,he),h(re,de,he),D(me,re,he),h(re,De,he),D(_e,re,he),h(re,ne,he),h(re,le,he),D(ge,re,he),h(re,we,he),D(Pe,re,he),h(re,Be,he),Ie=!0},p(re,[he]){const Le={};he&1&&(Le.$$scope={dirty:he,ctx:re}),a.$set(Le);const Oe={};he&1&&(Oe.$$scope={dirty:he,ctx:re}),Q.$set(Oe);const oe={};he&1&&(oe.$$scope={dirty:he,ctx:re}),Z.$set(oe);const ce={};he&1&&(ce.$$scope={dirty:he,ctx:re}),W.$set(ce);const Ae={};he&1&&(Ae.$$scope={dirty:he,ctx:re}),ae.$set(Ae);const ye={};he&1&&(ye.$$scope={dirty:he,ctx:re}),ge.$set(ye);const Fe={};he&1&&(Fe.$$scope={dirty:he,ctx:re}),Pe.$set(Fe)},i(re){Ie||(b(e.$$.fragment,re),b(a.$$.fragment,re),b(F.$$.fragment,re),b(Q.$$.fragment,re),b(Z.$$.fragment,re),b(W.$$.fragment,re),b(ae.$$.fragment,re),b(me.$$.fragment,re),b(_e.$$.fragment,re),b(ge.$$.fragment,re),b(Pe.$$.fragment,re),Ie=!0)},o(re){w(e.$$.fragment,re),w(a.$$.fragment,re),w(F.$$.fragment,re),w(Q.$$.fragment,re),w(Z.$$.fragment,re),w(W.$$.fragment,re),w(ae.$$.fragment,re),w(me.$$.fragment,re),w(_e.$$.fragment,re),w(ge.$$.fragment,re),w(Pe.$$.fragment,re),Ie=!1},d(re){C(e,re),re&&l(t),re&&l(r),re&&l(n),re&&l(s),C(a),re&&l(u),re&&l(p),re&&l(m),re&&l(_),re&&l(v),re&&l(P),re&&l(R),re&&l(A),re&&l(T),C(F,re),re&&l(B),re&&l(y),re&&l(V),re&&l(x),re&&l(O),re&&l(H),re&&l(N),C(Q,re),re&&l(X),C(Z,re),re&&l(K),C(W,re),re&&l(q),re&&l(U),re&&l(te),re&&l(ee),re&&l(se),re&&l(ie),C(ae,re),re&&l(J),re&&l(pe),re&&l(Se),re&&l(de),C(me,re),re&&l(De),C(_e,re),re&&l(ne),re&&l(le),C(ge,re),re&&l(we),C(Pe,re),re&&l(Be)}}}class sH extends ve{constructor(e){super(),Ee(this,e,null,nH,be,{})}}function aH(c){let e;return{c(){e=i("Compute Pipeline Builder")},l(t){e=f(t,"Compute Pipeline Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oH(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.COMPUTE_PIPELINE_BUILDER,$$slots:{default:[aH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Compute Pipeline."),r=d("br"),$=i(`
        It is recommended to not create a Compute Pipeline by it's Constructor, but
        to use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Compute Pipeline."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Compute Pipeline by it's Constructor, but
        to use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function lH(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iH(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fH(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cH(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $H(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uH(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[lH]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[iH]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[fH]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[cH]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[$H]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),F=Y(),B=d("li"),y=d("code"),V=i("shaderStages"),x=d("br"),M=i(`
            A list of `),I(O.$$.fragment),H=i("-structures each of which defining a shader stage of the pipeline."),k=Y(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),q=i(" to be bound to the pipeline."),U=Y(),te=d("li"),ee=d("code"),se=i("pipelineCache"),ie=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),pe=i(" object."),Se=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=Y(),De=d("li"),_e=d("code"),ne=i("pBasePipeline"),le=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Pe=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),this.h()},l(Ie){e=g(Ie,"DIV",{slot:!0});var re=E(e);t=g(re,"LI",{});var he=E(t);r=g(he,"CODE",{});var Le=E(r);$=f(Le,"pLogicalDevice"),Le.forEach(l),n=g(he,"BR",{}),s=f(he,`
            A pointer to the `),S(a.$$.fragment,he),u=f(he," the Pipeline should be associated with."),he.forEach(l),p=j(re),m=g(re,"LI",{});var Oe=E(m);_=g(Oe,"CODE",{});var oe=E(_);v=f(oe,"flags"),oe.forEach(l),P=g(Oe,"BR",{}),R=f(Oe,`
            A bitmask of `),S(A.$$.fragment,Oe),T=f(Oe," controlling how the pipeline is created."),Oe.forEach(l),F=j(re),B=g(re,"LI",{});var ce=E(B);y=g(ce,"CODE",{});var Ae=E(y);V=f(Ae,"shaderStages"),Ae.forEach(l),x=g(ce,"BR",{}),M=f(ce,`
            A list of `),S(O.$$.fragment,ce),H=f(ce,"-structures each of which defining a shader stage of the pipeline."),ce.forEach(l),k=j(re),N=g(re,"LI",{});var ye=E(N);Q=g(ye,"CODE",{});var Fe=E(Q);X=f(Fe,"pushConstants"),Fe.forEach(l),Z=g(ye,"BR",{}),K=f(ye,`
            A list of `),S(W.$$.fragment,ye),q=f(ye," to be bound to the pipeline."),ye.forEach(l),U=j(re),te=g(re,"LI",{});var Ve=E(te);ee=g(Ve,"CODE",{});var Ge=E(ee);se=f(Ge,"pipelineCache"),Ge.forEach(l),ie=g(Ve,"BR",{}),ae=f(Ve,`
            A handle to a `),S(J.$$.fragment,Ve),pe=f(Ve," object."),Se=g(Ve,"BR",{}),de=f(Ve,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),Ve.forEach(l),me=j(re),De=g(re,"LI",{});var He=E(De);_e=g(He,"CODE",{});var ze=E(_e);ne=f(ze,"pBasePipeline"),ze.forEach(l),le=g(He,"BR",{}),ge=f(He,`
            A pointer to the pipeline to derive from.`),we=g(He,"BR",{}),Pe=f(He,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),He.forEach(l),re.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ie,re){h(Ie,e,re),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),D(J,te,null),o(te,pe),o(te,Se),o(te,de),o(e,me),o(e,De),o(De,_e),o(_e,ne),o(De,le),o(De,ge),o(De,we),o(De,Pe),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),a.$set(he);const Le={};re&1&&(Le.$$scope={dirty:re,ctx:Ie}),A.$set(Le);const Oe={};re&1&&(Oe.$$scope={dirty:re,ctx:Ie}),O.$set(Oe);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),W.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),J.$set(ce)},i(Ie){Be||(b(a.$$.fragment,Ie),b(A.$$.fragment,Ie),b(O.$$.fragment,Ie),b(W.$$.fragment,Ie),b(J.$$.fragment,Ie),Be=!0)},o(Ie){w(a.$$.fragment,Ie),w(A.$$.fragment,Ie),w(O.$$.fragment,Ie),w(W.$$.fragment,Ie),w(J.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(a),C(A),C(O),C(W),C(J)}}}function pH(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mH(c){let e;return{c(){e=i("Vulkan Compute Pipeline")},l(t){e=f(t,"Vulkan Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function hH(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[pH]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[mH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        Also throws std::runtime_error if the `),I(p.$$.fragment),m=i(" couldn't be created."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var R=E(t);r=f(R,"std::runtime_error"),R.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P," couldn't be created."),a=g(P,"BR",{}),u=f(P,`
        Also throws std::runtime_error if the `),S(p.$$.fragment,P),m=f(P," couldn't be created."),P.forEach(l),this.h()},h(){z(e,"slot","throws")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),n.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(p)}}}function dH(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`ComputePipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags, 
    std::vector<PipelineShaderStage> shaderStages,
    std::vector<PushConstant> pushConstants, 
    VkPipelineCache pipelineCache = VK_NULL_HANDLE, 
    Pipeline* pBasePipeline = nullptr
);`}}),r=new Ce({props:{$$slots:{throws:[hH],params:[uH],details:[oH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class gH extends ve{constructor(e){super(),Ee(this,e,null,dH,be,{})}}function _H(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return e=new $e({props:{language:ue,code:"#include <fillcan/computing/compute_pipeline_builder.hpp>"}}),P=new $e({props:{language:ue,code:"PipelineShaderStage pipelineShaderStage = {};"}}),T=new $e({props:{language:ue,code:`// Create Shader Module
std::unique_ptr<fillcan::ShaderModule> upComputeShaderModule = fillcan.createShaderModule(...);

fillcan::ComputePipelineBuilder computePipelineBuilder{};
computePipelineBuilder.setLogicalDevice(fillcan.getCurrentDevice());
computePipelineBuilder.setFlags(0);
computePipelineBuilder.setBasePipeline(nullptr);

// Set the compute shader stage
computePipelineBuilder.setShaderStage({
    .stage = VK_SHADER_STAGE_COMPUTE_BIT,
    .pShaderModule = upComputeShaderModule.get(),
    .name = "main",
});

this->upComputePipeline = computePipelineBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Command Pipeline Builder"),n=i(` class extends the
`),s=d("code"),a=i("Pipeline Builder"),u=i(`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=d("br"),m=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=d("br"),v=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(P.$$.fragment),R=d("br"),A=i(`
Example:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var y=E(r);$=f(y,"Command Pipeline Builder"),y.forEach(l),n=f(B,` class extends the
`),s=g(B,"CODE",{});var V=E(s);a=f(V,"Pipeline Builder"),V.forEach(l),u=f(B,`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=g(B,"BR",{}),m=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=g(B,"BR",{}),v=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(P.$$.fragment,B),R=g(B,"BR",{}),A=f(B,`
Example:
`),S(T.$$.fragment,B)},m(B,y){D(e,B,y),h(B,t,y),h(B,r,y),o(r,$),h(B,n,y),h(B,s,y),o(s,a),h(B,u,y),h(B,p,y),h(B,m,y),h(B,_,y),h(B,v,y),D(P,B,y),h(B,R,y),h(B,A,y),D(T,B,y),F=!0},p:ke,i(B){F||(b(e.$$.fragment,B),b(P.$$.fragment,B),b(T.$$.fragment,B),F=!0)},o(B){w(e.$$.fragment,B),w(P.$$.fragment,B),w(T.$$.fragment,B),F=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(u),B&&l(p),B&&l(m),B&&l(_),B&&l(v),C(P,B),B&&l(R),B&&l(A),C(T,B)}}}class vH extends ve{constructor(e){super(),Ee(this,e,null,_H,be,{})}}function EH(c){let e,t;return{c(){e=d("span"),t=i("Create a new Compute Pipeline Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Compute Pipeline Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function bH(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"ComputePipelineBuilder();"}}),r=new Ce({props:{$$slots:{details:[EH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class wH extends ve{constructor(e){super(),Ee(this,e,null,bH,be,{})}}function IH(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function DH(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function CH(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[IH]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[DH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function SH(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function PH(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[SH]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineShaderStage"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i("."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pipelineShaderStage"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v,"."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function AH(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setShaderStage(PipelineShaderStage pipelineShaderStage);"}}),r=new Ce({props:{$$slots:{params:[PH],details:[CH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RH extends ve{constructor(e){super(),Ee(this,e,null,AH,be,{})}}function BH(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LH(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[BH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function kH(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TH(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VH(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[kH]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[TH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function OH(c){let e;return{c(){e=i("Compute Pipeline")},l(t){e=f(t,"Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FH(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[OH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function yH(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<ComputePipeline> getResult();"}}),r=new Ce({props:{$$slots:{throws:[FH],return:[VH],details:[LH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class MH extends ve{constructor(e){super(),Ee(this,e,null,yH,be,{})}}function xH(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NH(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function UH(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset() override;"}}),r=new Ce({props:{$$slots:{details:[NH],default:[xH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class GH extends ve{constructor(e){super(),Ee(this,e,null,UH,be,{})}}function HH(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qH(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WH(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QH(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KH(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zH(c){let e;return{c(){e=i("graphics pipelines")},l(t){e=f(t,"graphics pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YH(c){let e;return{c(){e=i("graphics pipeline")},l(t){e=f(t,"graphics pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jH(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/render_pass.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[HH]},$$scope:{ctx:c}}}),u=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",$$slots:{default:[qH]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[WH]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[QH]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[KH]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[zH]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[YH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Render Pass"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(` along with lists to attachments, the subpasses in which these attachments are used
and which attachments are dependent on eachother. It will use this information to
create a `),I(u.$$.fragment),p=i(" which it will wrap around to offer the ability to begin and end a rendering."),m=d("br"),_=d("br"),v=i(`
One of the things that distinguishes a Vulkan `),I(P.$$.fragment),R=i(" from a "),I(A.$$.fragment),T=i(`
is that the `),I(F.$$.fragment),B=i(` is usually used to convert pixels into images that can be further processed or
presented to the user. In complex graphics applications, the image is built over
many passes with each pass responsible for producing a different part of the scene,
applying full-frame effects such as post-processing or compositing, rendering user
interface elements, and so on. These passages can be rendered in Vulkan using a renderpass
object.`),y=d("br"),V=d("br"),x=i(`
A single renderpass object spans multiple passes or render stages over a single set
of output images. Each pass within the render pass is known as a subpass. Renderpass
objects can contain many subpasses, but even in simple applications with only a single
pass over a single output image, the renderpass object contains information about
that output image.`),M=d("br"),O=d("br"),H=i(`
All drawings must be in a render pass. Furthermore, `),I(k.$$.fragment),N=i(` need to know where they are being rendered; therefore it is necessary to create
a renderpass object before creating a `),I(Q.$$.fragment),X=i(" so that the pipeline can be told about the images it will produce.")},l(K){S(e.$$.fragment,K),t=f(K,`

The `),r=g(K,"CODE",{});var W=E(r);$=f(W,"Render Pass"),W.forEach(l),n=f(K," class takes a pointer to a "),S(s.$$.fragment,K),a=f(K,` along with lists to attachments, the subpasses in which these attachments are used
and which attachments are dependent on eachother. It will use this information to
create a `),S(u.$$.fragment,K),p=f(K," which it will wrap around to offer the ability to begin and end a rendering."),m=g(K,"BR",{}),_=g(K,"BR",{}),v=f(K,`
One of the things that distinguishes a Vulkan `),S(P.$$.fragment,K),R=f(K," from a "),S(A.$$.fragment,K),T=f(K,`
is that the `),S(F.$$.fragment,K),B=f(K,` is usually used to convert pixels into images that can be further processed or
presented to the user. In complex graphics applications, the image is built over
many passes with each pass responsible for producing a different part of the scene,
applying full-frame effects such as post-processing or compositing, rendering user
interface elements, and so on. These passages can be rendered in Vulkan using a renderpass
object.`),y=g(K,"BR",{}),V=g(K,"BR",{}),x=f(K,`
A single renderpass object spans multiple passes or render stages over a single set
of output images. Each pass within the render pass is known as a subpass. Renderpass
objects can contain many subpasses, but even in simple applications with only a single
pass over a single output image, the renderpass object contains information about
that output image.`),M=g(K,"BR",{}),O=g(K,"BR",{}),H=f(K,`
All drawings must be in a render pass. Furthermore, `),S(k.$$.fragment,K),N=f(K,` need to know where they are being rendered; therefore it is necessary to create
a renderpass object before creating a `),S(Q.$$.fragment,K),X=f(K," so that the pipeline can be told about the images it will produce.")},m(K,W){D(e,K,W),h(K,t,W),h(K,r,W),o(r,$),h(K,n,W),D(s,K,W),h(K,a,W),D(u,K,W),h(K,p,W),h(K,m,W),h(K,_,W),h(K,v,W),D(P,K,W),h(K,R,W),D(A,K,W),h(K,T,W),D(F,K,W),h(K,B,W),h(K,y,W),h(K,V,W),h(K,x,W),h(K,M,W),h(K,O,W),h(K,H,W),D(k,K,W),h(K,N,W),D(Q,K,W),h(K,X,W),Z=!0},p(K,[W]){const q={};W&1&&(q.$$scope={dirty:W,ctx:K}),s.$set(q);const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),u.$set(U);const te={};W&1&&(te.$$scope={dirty:W,ctx:K}),P.$set(te);const ee={};W&1&&(ee.$$scope={dirty:W,ctx:K}),A.$set(ee);const se={};W&1&&(se.$$scope={dirty:W,ctx:K}),F.$set(se);const ie={};W&1&&(ie.$$scope={dirty:W,ctx:K}),k.$set(ie);const ae={};W&1&&(ae.$$scope={dirty:W,ctx:K}),Q.$set(ae)},i(K){Z||(b(e.$$.fragment,K),b(s.$$.fragment,K),b(u.$$.fragment,K),b(P.$$.fragment,K),b(A.$$.fragment,K),b(F.$$.fragment,K),b(k.$$.fragment,K),b(Q.$$.fragment,K),Z=!0)},o(K){w(e.$$.fragment,K),w(s.$$.fragment,K),w(u.$$.fragment,K),w(P.$$.fragment,K),w(A.$$.fragment,K),w(F.$$.fragment,K),w(k.$$.fragment,K),w(Q.$$.fragment,K),Z=!1},d(K){C(e,K),K&&l(t),K&&l(r),K&&l(n),C(s,K),K&&l(a),C(u,K),K&&l(p),K&&l(m),K&&l(_),K&&l(v),C(P,K),K&&l(R),C(A,K),K&&l(T),C(F,K),K&&l(B),K&&l(y),K&&l(V),K&&l(x),K&&l(M),K&&l(O),K&&l(H),C(k,K),K&&l(N),C(Q,K),K&&l(X)}}}class XH extends ve{constructor(e){super(),Ee(this,e,null,jH,be,{})}}function ZH(c){let e;return{c(){e=i("Render Pass Builder")},l(t){e=f(t,"Render Pass Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function JH(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.RENDER_PASS_BUILDER,$$slots:{default:[ZH]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Render Pass."),r=d("br"),$=i(`
        It is recommended to not create a Render Pass by it's Constructor, but to
        use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Render Pass."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Render Pass by it's Constructor, but to
        use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function e6(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function t6(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r6(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n6(c){let e;return{c(){e=i("VkSubpassDescription")},l(t){e=f(t,"VkSubpassDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s6(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a6(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[e6]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html",target:"_blank",$$slots:{default:[t6]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.IMAGE,$$slots:{default:[r6]},$$scope:{ctx:c}}}),Q=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html",target:"_blank",$$slots:{default:[n6]},$$scope:{ctx:c}}}),pe=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html",target:"_blank",$$slots:{default:[s6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Render Pass should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("attachments"),P=d("br"),R=i(`
            A list of `),I(A.$$.fragment),T=i("-structures."),F=d("br"),B=i(`
            Each of these structures defines a single `),I(y.$$.fragment),V=i(` to be used as input, output, or both within one or more of the subpasses
            in the render pass.`),x=Y(),M=d("li"),O=d("code"),H=i("subpasses"),k=d("br"),N=i(`
            A list of `),I(Q.$$.fragment),X=i("-structures."),Z=d("br"),K=i(`
            Each of these structures defines a single subpass. Each subpass refers
            to a number of attachments (from the list given in the
            `),W=d("code"),q=i("attachments"),U=i(" field) as input or output."),te=Y(),ee=d("li"),se=d("code"),ie=i("dependencies"),ae=d("br"),J=i(`
            A list of `),I(pe.$$.fragment),Se=i("-structures."),de=d("br"),me=i(`
            When there is more than one subpass in a render pass, Vulkan can figure
            out which subpasses are dependent on each other by following the attachment
            references and looking for inputs and outputs that make subpasses dependent
            on each other. However, there are cases where dependencies cannot be
            easily represented by a simple input-to-output relationship. This generally
            happens when a subpass writes directly to a resource, such as an image
            or buffer, and a subsequent subpass reads that data back. Vulkan cannot
            figure this out automatically, so it must explicitly indicate such dependency
            information.`),this.h()},l(_e){e=g(_e,"DIV",{slot:!0});var ne=E(e);t=g(ne,"LI",{});var le=E(t);r=g(le,"CODE",{});var ge=E(r);$=f(ge,"pLogicalDevice"),ge.forEach(l),n=g(le,"BR",{}),s=f(le,`
            A pointer to the `),S(a.$$.fragment,le),u=f(le," the Render Pass should be associated with."),le.forEach(l),p=j(ne),m=g(ne,"LI",{});var we=E(m);_=g(we,"CODE",{});var Pe=E(_);v=f(Pe,"attachments"),Pe.forEach(l),P=g(we,"BR",{}),R=f(we,`
            A list of `),S(A.$$.fragment,we),T=f(we,"-structures."),F=g(we,"BR",{}),B=f(we,`
            Each of these structures defines a single `),S(y.$$.fragment,we),V=f(we,` to be used as input, output, or both within one or more of the subpasses
            in the render pass.`),we.forEach(l),x=j(ne),M=g(ne,"LI",{});var Be=E(M);O=g(Be,"CODE",{});var Ie=E(O);H=f(Ie,"subpasses"),Ie.forEach(l),k=g(Be,"BR",{}),N=f(Be,`
            A list of `),S(Q.$$.fragment,Be),X=f(Be,"-structures."),Z=g(Be,"BR",{}),K=f(Be,`
            Each of these structures defines a single subpass. Each subpass refers
            to a number of attachments (from the list given in the
            `),W=g(Be,"CODE",{});var re=E(W);q=f(re,"attachments"),re.forEach(l),U=f(Be," field) as input or output."),Be.forEach(l),te=j(ne),ee=g(ne,"LI",{});var he=E(ee);se=g(he,"CODE",{});var Le=E(se);ie=f(Le,"dependencies"),Le.forEach(l),ae=g(he,"BR",{}),J=f(he,`
            A list of `),S(pe.$$.fragment,he),Se=f(he,"-structures."),de=g(he,"BR",{}),me=f(he,`
            When there is more than one subpass in a render pass, Vulkan can figure
            out which subpasses are dependent on each other by following the attachment
            references and looking for inputs and outputs that make subpasses dependent
            on each other. However, there are cases where dependencies cannot be
            easily represented by a simple input-to-output relationship. This generally
            happens when a subpass writes directly to a resource, such as an image
            or buffer, and a subsequent subpass reads that data back. Vulkan cannot
            figure this out automatically, so it must explicitly indicate such dependency
            information.`),he.forEach(l),ne.forEach(l),this.h()},h(){z(e,"slot","params")},m(_e,ne){h(_e,e,ne),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(m,F),o(m,B),D(y,m,null),o(m,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),o(M,Z),o(M,K),o(M,W),o(W,q),o(M,U),o(e,te),o(e,ee),o(ee,se),o(se,ie),o(ee,ae),o(ee,J),D(pe,ee,null),o(ee,Se),o(ee,de),o(ee,me),De=!0},p(_e,ne){const le={};ne&1&&(le.$$scope={dirty:ne,ctx:_e}),a.$set(le);const ge={};ne&1&&(ge.$$scope={dirty:ne,ctx:_e}),A.$set(ge);const we={};ne&1&&(we.$$scope={dirty:ne,ctx:_e}),y.$set(we);const Pe={};ne&1&&(Pe.$$scope={dirty:ne,ctx:_e}),Q.$set(Pe);const Be={};ne&1&&(Be.$$scope={dirty:ne,ctx:_e}),pe.$set(Be)},i(_e){De||(b(a.$$.fragment,_e),b(A.$$.fragment,_e),b(y.$$.fragment,_e),b(Q.$$.fragment,_e),b(pe.$$.fragment,_e),De=!0)},o(_e){w(a.$$.fragment,_e),w(A.$$.fragment,_e),w(y.$$.fragment,_e),w(Q.$$.fragment,_e),w(pe.$$.fragment,_e),De=!1},d(_e){_e&&l(e),C(a),C(A),C(y),C(Q),C(pe)}}}function o6(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l6(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkRenderPass",version:1.3,$$slots:{default:[o6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(`
        couldn't be created.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,`
        couldn't be created.`),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function i6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`RenderPass(
    LogicalDevice* pLogicalDevice, 
    std::vector<VkAttachmentDescription> attachments, 
    std::vector<VkSubpassDescription> subpasses,
    std::vector<VkSubpassDependency> dependencies
);`}}),r=new Ce({props:{$$slots:{throws:[l6],params:[a6],details:[JH]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class f6 extends ve{constructor(e){super(),Ee(this,e,null,i6,be,{})}}function c6(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $6(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",target:"_blank",$$slots:{default:[c6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function u6(c){let e;return{c(){e=i("Vulkan Render Pass")},l(t){e=f(t,"Vulkan Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function p6(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html",target:"_blank",$$slots:{default:[u6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function m6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkRenderPass getRenderPassHandle() const;"}}),r=new Ce({props:{$$slots:{return:[p6],details:[$6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class h6 extends ve{constructor(e){super(),Ee(this,e,null,m6,be,{})}}function d6(c){let e,t;return{c(){e=d("span"),t=i("Get all the attachments."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the attachments."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function g6(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _6(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkAttachmentDescription",version:1.3,$$slots:{default:[g6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the attachments."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the attachments."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function v6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkAttachmentDescription>& getAttachments() const;"}}),r=new Ce({props:{$$slots:{return:[_6],details:[d6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class E6 extends ve{constructor(e){super(),Ee(this,e,null,v6,be,{})}}function b6(c){let e,t;return{c(){e=d("span"),t=i("Get all the subpasses."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the subpasses."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function w6(c){let e;return{c(){e=i("VkSubpassDescription")},l(t){e=f(t,"VkSubpassDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I6(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkSubpassDescription",version:1.3,$$slots:{default:[w6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the subpasses."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the subpasses."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function D6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkSubpassDescription>& getSubpasses() const;"}}),r=new Ce({props:{$$slots:{return:[I6],details:[b6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class C6 extends ve{constructor(e){super(),Ee(this,e,null,D6,be,{})}}function S6(c){let e,t;return{c(){e=d("span"),t=i("Get all the dependencies."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get all the dependencies."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function P6(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A6(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkSubpassDependency",version:1.3,$$slots:{default:[P6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A list of "),I(r.$$.fragment),$=i("-structures describing the dependencies."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"A list of "),S(r.$$.fragment,a),$=f(a,"-structures describing the dependencies."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function R6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const std::vector<VkSubpassDependency>& getDependencies() const;"}}),r=new Ce({props:{$$slots:{return:[A6],details:[S6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class B6 extends ve{constructor(e){super(),Ee(this,e,null,R6,be,{})}}function L6(c){let e,t,r,$;return{c(){e=d("span"),t=i("Prepare to render."),r=d("br"),$=i(`
        All drawings are in a render pass. While renderpass objects can encapsulate
        many subpasses, even a simple rendering that is included in a single output
        image must be part of a renderpass.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Prepare to render."),r=g(s,"BR",{}),$=f(s,`
        All drawings are in a render pass. While renderpass objects can encapsulate
        many subpasses, even a simple rendering that is included in a single output
        image must be part of a renderpass.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function k6(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T6(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V6(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O6(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F6(c){let e;return{c(){e=i("VkClearValue")},l(t){e=f(t,"VkClearValue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y6(c){let e;return{c(){e=i("VkClearValue")},l(t){e=f(t,"VkClearValue")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M6(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge;return a=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[k6]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[T6]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[V6]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.IMAGE,$$slots:{default:[O6]},$$scope:{ctx:c}}}),Q=new Bt({props:{reference:"VkClearValue",version:1.3,$$slots:{default:[F6]},$$scope:{ctx:c}}}),ie=new Bt({props:{reference:"VkClearValue",version:1.3,$$slots:{default:[y6]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pCommandBuffer"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" that contains the commands specified in the render pass."),p=Y(),m=d("li"),_=d("code"),v=i("pFramebuffer"),P=d("br"),R=i(`
            The `),I(A.$$.fragment),T=i(" in which to render. The "),I(F.$$.fragment),B=i(" is the collection of "),I(y.$$.fragment),V=i(" rendered to by graphics commands."),x=Y(),M=d("li"),O=d("code"),H=i("pClearValues"),k=d("br"),N=i(`
            A list of `),I(Q.$$.fragment),X=i(`-unions. If one of the attachments in the render pass has a load of
            `),Z=d("code"),K=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),W=i(`, then the colors or values
            to which they are cleared are specified in this array.`),q=d("br"),U=i(`
            The index of each attachment of the `),te=d("code"),ee=i("attachments"),se=i(` field
            given in the constructor is used to index into the array of
            `),I(ie.$$.fragment),ae=i(`-unions. This means that if only some of the attachments have a
            load of `),J=d("code"),pe=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),Se=i(`, there may be
            unused items in the array. There must be at least as many items in
            the `),de=d("code"),me=i("pClearValues"),De=i(` list as the highest indexed attachment
            with a load of `),_e=d("code"),ne=i("VK_ATTACHMENT_LOAD_OP_CLEAR"),le=i("."),this.h()},l(we){e=g(we,"DIV",{slot:!0});var Pe=E(e);t=g(Pe,"LI",{});var Be=E(t);r=g(Be,"CODE",{});var Ie=E(r);$=f(Ie,"pCommandBuffer"),Ie.forEach(l),n=g(Be,"BR",{}),s=f(Be,`
            The `),S(a.$$.fragment,Be),u=f(Be," that contains the commands specified in the render pass."),Be.forEach(l),p=j(Pe),m=g(Pe,"LI",{});var re=E(m);_=g(re,"CODE",{});var he=E(_);v=f(he,"pFramebuffer"),he.forEach(l),P=g(re,"BR",{}),R=f(re,`
            The `),S(A.$$.fragment,re),T=f(re," in which to render. The "),S(F.$$.fragment,re),B=f(re," is the collection of "),S(y.$$.fragment,re),V=f(re," rendered to by graphics commands."),re.forEach(l),x=j(Pe),M=g(Pe,"LI",{});var Le=E(M);O=g(Le,"CODE",{});var Oe=E(O);H=f(Oe,"pClearValues"),Oe.forEach(l),k=g(Le,"BR",{}),N=f(Le,`
            A list of `),S(Q.$$.fragment,Le),X=f(Le,`-unions. If one of the attachments in the render pass has a load of
            `),Z=g(Le,"CODE",{});var oe=E(Z);K=f(oe,"VK_ATTACHMENT_LOAD_OP_CLEAR"),oe.forEach(l),W=f(Le,`, then the colors or values
            to which they are cleared are specified in this array.`),q=g(Le,"BR",{}),U=f(Le,`
            The index of each attachment of the `),te=g(Le,"CODE",{});var ce=E(te);ee=f(ce,"attachments"),ce.forEach(l),se=f(Le,` field
            given in the constructor is used to index into the array of
            `),S(ie.$$.fragment,Le),ae=f(Le,`-unions. This means that if only some of the attachments have a
            load of `),J=g(Le,"CODE",{});var Ae=E(J);pe=f(Ae,"VK_ATTACHMENT_LOAD_OP_CLEAR"),Ae.forEach(l),Se=f(Le,`, there may be
            unused items in the array. There must be at least as many items in
            the `),de=g(Le,"CODE",{});var ye=E(de);me=f(ye,"pClearValues"),ye.forEach(l),De=f(Le,` list as the highest indexed attachment
            with a load of `),_e=g(Le,"CODE",{});var Fe=E(_e);ne=f(Fe,"VK_ATTACHMENT_LOAD_OP_CLEAR"),Fe.forEach(l),le=f(Le,"."),Le.forEach(l),Pe.forEach(l),this.h()},h(){z(e,"slot","params")},m(we,Pe){h(we,e,Pe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),D(y,m,null),o(m,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),o(M,Z),o(Z,K),o(M,W),o(M,q),o(M,U),o(M,te),o(te,ee),o(M,se),D(ie,M,null),o(M,ae),o(M,J),o(J,pe),o(M,Se),o(M,de),o(de,me),o(M,De),o(M,_e),o(_e,ne),o(M,le),ge=!0},p(we,Pe){const Be={};Pe&1&&(Be.$$scope={dirty:Pe,ctx:we}),a.$set(Be);const Ie={};Pe&1&&(Ie.$$scope={dirty:Pe,ctx:we}),A.$set(Ie);const re={};Pe&1&&(re.$$scope={dirty:Pe,ctx:we}),F.$set(re);const he={};Pe&1&&(he.$$scope={dirty:Pe,ctx:we}),y.$set(he);const Le={};Pe&1&&(Le.$$scope={dirty:Pe,ctx:we}),Q.$set(Le);const Oe={};Pe&1&&(Oe.$$scope={dirty:Pe,ctx:we}),ie.$set(Oe)},i(we){ge||(b(a.$$.fragment,we),b(A.$$.fragment,we),b(F.$$.fragment,we),b(y.$$.fragment,we),b(Q.$$.fragment,we),b(ie.$$.fragment,we),ge=!0)},o(we){w(a.$$.fragment,we),w(A.$$.fragment,we),w(F.$$.fragment,we),w(y.$$.fragment,we),w(Q.$$.fragment,we),w(ie.$$.fragment,we),ge=!1},d(we){we&&l(e),C(a),C(A),C(F),C(y),C(Q),C(ie)}}}function x6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`void begin(
    CommandBuffer* pCommandBuffer, 
    Framebuffer* pFramebuffer, 
    std::vector<VkClearValue>* pClearValues = nullptr,
    VkRect2D* pRenderArea = nullptr
);`}}),r=new Ce({props:{$$slots:{params:[M6],details:[L6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class N6 extends ve{constructor(e){super(),Ee(this,e,null,x6,be,{})}}function U6(c){let e;return{c(){e=i("command buffer")},l(t){e=f(t,"command buffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G6(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function H6(c){let e;return{c(){e=i("begin")},l(t){e=f(t,"begin")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q6(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return n=new G({props:{sectionID:L.COMMAND_BUFFER,$$slots:{default:[U6]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[G6]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.RENDER_PASS_begin,$$slots:{default:[H6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Terminate the rendering in the render pass."),r=d("br"),$=i(`
        Once the render pass has started, drawing commands can be placed in the `),I(n.$$.fragment),s=i(". All rendering is directed to the "),I(a.$$.fragment),u=i(` specified in the
        `),p=d("code"),m=i("framebuffer"),_=i(" field passed to "),I(v.$$.fragment),P=i("."),this.h()},l(A){e=g(A,"SPAN",{slot:!0});var T=E(e);t=f(T,"Terminate the rendering in the render pass."),r=g(T,"BR",{}),$=f(T,`
        Once the render pass has started, drawing commands can be placed in the `),S(n.$$.fragment,T),s=f(T,". All rendering is directed to the "),S(a.$$.fragment,T),u=f(T,` specified in the
        `),p=g(T,"CODE",{});var F=E(p);m=f(F,"framebuffer"),F.forEach(l),_=f(T," field passed to "),S(v.$$.fragment,T),P=f(T,"."),T.forEach(l),this.h()},h(){z(e,"slot","details")},m(A,T){h(A,e,T),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),D(a,e,null),o(e,u),o(e,p),o(p,m),o(e,_),D(v,e,null),o(e,P),R=!0},p(A,T){const F={};T&1&&(F.$$scope={dirty:T,ctx:A}),n.$set(F);const B={};T&1&&(B.$$scope={dirty:T,ctx:A}),a.$set(B);const y={};T&1&&(y.$$scope={dirty:T,ctx:A}),v.$set(y)},i(A){R||(b(n.$$.fragment,A),b(a.$$.fragment,A),b(v.$$.fragment,A),R=!0)},o(A){w(n.$$.fragment,A),w(a.$$.fragment,A),w(v.$$.fragment,A),R=!1},d(A){A&&l(e),C(n),C(a),C(v)}}}function W6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void end();"}}),r=new Ce({props:{$$slots:{details:[q6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Q6 extends ve{constructor(e){super(),Ee(this,e,null,W6,be,{})}}function K6(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/render_pass_builder.hpp>"}}),m=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
std::vector<VkAttachmentDescription> attachmentDescriptions = {};
std::vector<VkAttachmentReference> inputAttachments = {};
std::vector<VkAttachmentReference> colorAttachments = {};
std::unique_ptr<VkAttachmentReference> upDepthStencilAttachment = nullptr;
std::vector<uint32_t> preserveAttachments = {};
bool resolveCurrentBatch = false;
std::vector<VkSubpassDescription> subpassDescriptions = {};
std::vector<VkSubpassDependency> dependencyDescriptions = {};`}}),P=new $e({props:{language:ue,code:`fillcan::RenderPassBuilder renderPassBuilder = {};
renderPassBuilder.setLogicalDevice(fillcan.getCurrentDevice());

// Add attachment for subpass 1 describing the swapchain image
unsigned int swapChainAttachmentIndex = renderPassBuilder.addAttachment(
    {
        .flags = 0,
        .format = fillcan.getSwapchain()->getSurfaceFormat().format,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    }
);
// Add the attachment to the subpass 1 as a color attachment
renderPassBuilder.addColorAttachment(swapChainAttachmentIndex, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, false);

// Add attachment for subpass 1 describing the depth image
std::optional<VkFormat> depthImageFormat = fillcan.getCurrentDevice()->getPhysicalDevice()->findSupportedFormat(
    { VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT }, 
    VK_IMAGE_TILING_OPTIMAL,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
);
if (!depthImageFormat.has_value()) {
    throw std::runtime_error("Failed to find a supported format for the depth image attachment.");
}
unsigned int depthImageAttachmentIndex = renderPassBuilder.addAttachment(
    {
        .flags = 0,
        .format = depthImageFormat.value(),
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
    }
);
// Add the attachment to subpass 1 as a depthstencil attachment
renderPassBuilder.setDepthStencilAttachment(depthImageAttachmentIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, false);

// Construct subpass 1, this will combine any attachments described before into a new subpass
unsigned int subpassIndex = renderPassBuilder.constructSubpass();

// Add a dependency for subpass 1 to make sure the subpass waits for the previous stages before executing
renderPassBuilder.addDependency(
    {
        .srcSubpass = VK_SUBPASS_EXTERNAL,
        .dstSubpass = subpassIndex,
        .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .srcAccessMask = 0,
        .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
    }
);

std::unique_ptr<fillcan::RenderPass> upRenderPass = renderPassBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Render Pass Builder"),n=i(` class is part of the creational design
pattern to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(P.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Render Pass Builder"),T.forEach(l),n=f(A,` class is part of the creational design
pattern to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(P.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(P,A,T),R=!0},p:ke,i(A){R||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(P.$$.fragment,A),R=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(P.$$.fragment,A),R=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(P,A)}}}class z6 extends ve{constructor(e){super(),Ee(this,e,null,K6,be,{})}}function Y6(c){let e,t;return{c(){e=d("span"),t=i("Create a new Render Pass Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Render Pass Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function j6(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"RenderPassBuilder();"}}),r=new Ce({props:{$$slots:{details:[Y6]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class X6 extends ve{constructor(e){super(),Ee(this,e,null,j6,be,{})}}function Z6(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function J6(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function e7(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Z6]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[J6]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function t7(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r7(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function n7(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[t7]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[r7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(" should be associated with."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R," should be associated with."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function s7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[n7],details:[e7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class a7 extends ve{constructor(e){super(),Ee(this,e,null,s7,be,{})}}function o7(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l7(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function i7(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[o7]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[l7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function f7(c){let e;return{c(){e=i("VkAttachmentDescription")},l(t){e=f(t,"VkAttachmentDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function c7(c){let e,t,r,$,n,s,a,u,p;return a=new Bt({props:{reference:"VkAttachmentDescription",version:1.3,$$slots:{default:[f7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescription"),n=d("br"),s=i(`
            A `),I(a.$$.fragment),u=i(`-structure. this structure defines a single image to be used as
            input, output, or both within one or more of the subpasses in the
            render pass.`),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"attachmentDescription"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            A `),S(a.$$.fragment,v),u=f(v,`-structure. this structure defines a single image to be used as
            input, output, or both within one or more of the subpasses in the
            render pass.`),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function $7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[c7],details:[i7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class u7 extends ve{constructor(e){super(),Ee(this,e,null,$7,be,{})}}function p7(c){let e,t;return{c(){e=d("span"),t=i(`Define a single input attachment, which is an attachment from which data
        can be read.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Define a single input attachment, which is an attachment from which data
        can be read.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function m7(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h7(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return m=new G({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[m7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=Y(),P=d("li"),R=d("code"),A=i("layout"),T=d("br"),F=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=Y(),y=d("li"),V=d("code"),x=i("preserve"),M=d("br"),O=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=j(N),P=g(N,"LI",{});var K=E(P);R=g(K,"CODE",{});var W=E(R);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),F=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=j(N),y=g(N,"LI",{});var q=E(y);V=g(q,"CODE",{});var U=E(V);x=f(U,"preserve"),U.forEach(l),M=g(q,"BR",{}),O=f(q,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),q.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,P),o(P,R),o(R,A),o(P,T),o(P,F),o(e,B),o(e,y),o(y,V),o(V,x),o(y,M),o(y,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){H||(b(m.$$.fragment,k),H=!0)},o(k){w(m.$$.fragment,k),H=!1},d(k){k&&l(e),C(m)}}}function d7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void addInputAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Ce({props:{$$slots:{params:[h7],details:[p7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class g7 extends ve{constructor(e){super(),Ee(this,e,null,d7,be,{})}}function _7(c){let e,t;return{c(){e=d("span"),t=i(`Define a single color attachment, which is an attachment to which the
        output of the subpass is written.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Define a single color attachment, which is an attachment to which the
        output of the subpass is written.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function v7(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function E7(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return m=new G({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[v7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=Y(),P=d("li"),R=d("code"),A=i("layout"),T=d("br"),F=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=Y(),y=d("li"),V=d("code"),x=i("preserve"),M=d("br"),O=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=j(N),P=g(N,"LI",{});var K=E(P);R=g(K,"CODE",{});var W=E(R);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),F=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=j(N),y=g(N,"LI",{});var q=E(y);V=g(q,"CODE",{});var U=E(V);x=f(U,"preserve"),U.forEach(l),M=g(q,"BR",{}),O=f(q,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),q.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,P),o(P,R),o(R,A),o(P,T),o(P,F),o(e,B),o(e,y),o(y,V),o(V,x),o(y,M),o(y,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){H||(b(m.$$.fragment,k),H=!0)},o(k){w(m.$$.fragment,k),H=!1},d(k){k&&l(e),C(m)}}}function b7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void addColorAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Ce({props:{$$slots:{params:[E7],details:[_7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class w7 extends ve{constructor(e){super(),Ee(this,e,null,b7,be,{})}}function I7(c){let e,t;return{c(){e=d("span"),t=i("Define the depth and stencil buffer for this subpass."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Define the depth and stencil buffer for this subpass."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function D7(c){let e;return{c(){e=i("addAttachment")},l(t){e=f(t,"addAttachment")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C7(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H;return m=new G({props:{sectionID:L.RENDER_PASS_BUILDER_addAttachment,$$slots:{default:[D7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("attachmentDescriptionIndex"),n=d("br"),s=i(`
            The index of the attachment within the
            `),a=d("code"),u=i("attachmentDescriptions"),p=i(`-list. This index was returned
            when the attachment was added using `),I(m.$$.fragment),_=i("."),v=Y(),P=d("li"),R=d("code"),A=i("layout"),T=d("br"),F=i(`
            The image layout which the attachment is expected to be in within this
            subpass.`),B=Y(),y=d("li"),V=d("code"),x=i("preserve"),M=d("br"),O=i(`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),this.h()},l(k){e=g(k,"DIV",{slot:!0});var N=E(e);t=g(N,"LI",{});var Q=E(t);r=g(Q,"CODE",{});var X=E(r);$=f(X,"attachmentDescriptionIndex"),X.forEach(l),n=g(Q,"BR",{}),s=f(Q,`
            The index of the attachment within the
            `),a=g(Q,"CODE",{});var Z=E(a);u=f(Z,"attachmentDescriptions"),Z.forEach(l),p=f(Q,`-list. This index was returned
            when the attachment was added using `),S(m.$$.fragment,Q),_=f(Q,"."),Q.forEach(l),v=j(N),P=g(N,"LI",{});var K=E(P);R=g(K,"CODE",{});var W=E(R);A=f(W,"layout"),W.forEach(l),T=g(K,"BR",{}),F=f(K,`
            The image layout which the attachment is expected to be in within this
            subpass.`),K.forEach(l),B=j(N),y=g(N,"LI",{});var q=E(y);V=g(q,"CODE",{});var U=E(V);x=f(U,"preserve"),U.forEach(l),M=g(q,"BR",{}),O=f(q,`
            If there are attachments that should persist for the time in a subpass,
            but are not directly referenced by the subpass, they should be referenced
            as preserved. This reference prevents Vulkan from performing optimizations
            that could disrupt the content of those attachments.`),q.forEach(l),N.forEach(l),this.h()},h(){z(e,"slot","params")},m(k,N){h(k,e,N),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),D(m,t,null),o(t,_),o(e,v),o(e,P),o(P,R),o(R,A),o(P,T),o(P,F),o(e,B),o(e,y),o(y,V),o(V,x),o(y,M),o(y,O),H=!0},p(k,N){const Q={};N&1&&(Q.$$scope={dirty:N,ctx:k}),m.$set(Q)},i(k){H||(b(m.$$.fragment,k),H=!0)},o(k){w(m.$$.fragment,k),H=!1},d(k){k&&l(e),C(m)}}}function S7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setDepthStencilAttachment(unsigned int attachmentDescriptionIndex, VkImageLayout layout, bool preserve);"}}),r=new Ce({props:{$$slots:{params:[C7],details:[I7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class P7 extends ve{constructor(e){super(),Ee(this,e,null,S7,be,{})}}function A7(c){let e,t;return{c(){e=d("span"),t=i(`Mark the current batch of color attachments as resolved, these are
        attachments to which multisample image data is converted.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Mark the current batch of color attachments as resolved, these are
        attachments to which multisample image data is converted.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function R7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void resolveCurrentAttachments();"}}),r=new Ce({props:{$$slots:{details:[A7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class B7 extends ve{constructor(e){super(),Ee(this,e,null,R7,be,{})}}function L7(c){let e,t;return{c(){e=d("span"),t=i(`Construct a new subpass from the current batch of attachments. The
        current batch contains all the attachments added after the last subpass
        construction or after the initialization of the builder.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Construct a new subpass from the current batch of attachments. The
        current batch contains all the attachments added after the last subpass
        construction or after the initialization of the builder.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function k7(c){let e,t;return{c(){e=d("span"),t=i("The index of the newly constructed subpass."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The index of the newly constructed subpass."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function T7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int constructSubpass();"}}),r=new Ce({props:{$$slots:{return:[k7],details:[L7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class V7 extends ve{constructor(e){super(),Ee(this,e,null,T7,be,{})}}function O7(c){let e,t,r,$,n;return{c(){e=d("span"),t=i("Add a subpass dependency."),r=d("br"),$=d("br"),n=i(`
        When there is more than one subpass in a render pass, Vulkan can figure out
        which subpasses are dependent on each other by following the attachment references
        and looking for inputs and outputs that make subpasses dependent on each
        other. However, there are cases where dependencies cannot be easily represented
        by a simple input-to-output relationship. This generally happens when a subpass
        writes directly to a resource, such as an image or buffer, and a subsequent
        subpass reads that data back. Vulkan cannot figure this out automatically,
        so it must explicitly indicate such dependency information.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Add a subpass dependency."),r=g(a,"BR",{}),$=g(a,"BR",{}),n=f(a,`
        When there is more than one subpass in a render pass, Vulkan can figure out
        which subpasses are dependent on each other by following the attachment references
        and looking for inputs and outputs that make subpasses dependent on each
        other. However, there are cases where dependencies cannot be easily represented
        by a simple input-to-output relationship. This generally happens when a subpass
        writes directly to a resource, such as an image or buffer, and a subsequent
        subpass reads that data back. Vulkan cannot figure this out automatically,
        so it must explicitly indicate such dependency information.`),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),o(e,r),o(e,$),o(e,n)},p:ke,d(s){s&&l(e)}}}function F7(c){let e;return{c(){e=i("VkSubpassDependency")},l(t){e=f(t,"VkSubpassDependency")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y7(c){let e;return{c(){e=i("constructSubpass")},l(t){e=f(t,"constructSubpass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function M7(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new Bt({props:{reference:"VkSubpassDependency",version:1.3,$$slots:{default:[F7]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.RENDER_PASS_BUILDER_constructSubpass,$$slots:{default:[y7]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dependencyDescription"),n=d("br"),s=i(`
            A `),I(a.$$.fragment),u=i(`-structure. The indices of both the source subpass and the
            destination subpass can be determined using the index return by `),I(p.$$.fragment),m=i("."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"dependencyDescription"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A `),S(a.$$.fragment,R),u=f(R,`-structure. The indices of both the source subpass and the
            destination subpass can be determined using the index return by `),S(p.$$.fragment,R),m=f(R,"."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function x7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void addDependency(VkSubpassDependency dependencyDescription);"}}),r=new Ce({props:{$$slots:{params:[M7],details:[O7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class N7 extends ve{constructor(e){super(),Ee(this,e,null,x7,be,{})}}function U7(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function G7(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[U7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function H7(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q7(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function W7(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[H7]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[q7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Q7(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function K7(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Q7]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function z7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<RenderPass> getResult();"}}),r=new Ce({props:{$$slots:{throws:[K7],return:[W7],details:[G7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Y7 extends ve{constructor(e){super(),Ee(this,e,null,z7,be,{})}}function j7(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function X7(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Z7(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[X7],default:[j7]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class J7 extends ve{constructor(e){super(),Ee(this,e,null,Z7,be,{})}}function eq(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tq(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rq(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nq(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $q(c){let e;return{c(){e=i("graphics pipelines")},l(t){e=f(t,"graphics pipelines")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pq(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/framebuffer.hpp>"}}),s=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[eq]},$$scope:{ctx:c}}}),u=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[tq]},$$scope:{ctx:c}}}),m=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",$$slots:{default:[rq]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[nq]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[sq]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[aq]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.IMAGE,$$slots:{default:[oq]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[lq]},$$scope:{ctx:c}}}),k=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[iq]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[fq]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.IMAGE,$$slots:{default:[cq]},$$scope:{ctx:c}}}),te=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[$q]},$$scope:{ctx:c}}}),se=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[uq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Frambuffer"),n=i(" class takes a pointer to a "),I(s.$$.fragment),a=i(", a pointer to a "),I(u.$$.fragment),p=i(` along with lists of attachments, the width, the height and a number of array layers.
It uses this information to create a `),I(m.$$.fragment),_=i("."),v=d("br"),P=d("br"),R=i(`
A `),I(A.$$.fragment),T=i(` renders to
a Framebuffer. The framebuffer links to the `),I(F.$$.fragment),B=i(" being rendered to and is used when starting a "),I(y.$$.fragment),V=i(" to set the target "),I(x.$$.fragment),M=i(` for
rendering. Once the `),I(O.$$.fragment),H=i(` is created, it can be used to create the framebuffers. Frame buffers are created
based on a particular `),I(k.$$.fragment),N=i(" and they act as a link between the "),I(Q.$$.fragment),X=i(" attachments and the real "),I(Z.$$.fragment),K=i(" to be rendered to."),W=d("br"),q=d("br"),U=i(`
The framebuffer is an object that represents the set of images into which `),I(te.$$.fragment),ee=i(` render. These affect the last few stages in the pipeline: depth- and stencil testing,
blending, logical operations, multisampling, and so on. A framebuffer object is created
by using a reference to a `),I(se.$$.fragment),ie=i(" and can be used with any render pass that has a similar arrangement of attachments.")},l(J){S(e.$$.fragment,J),t=f(J,`

The `),r=g(J,"CODE",{});var pe=E(r);$=f(pe,"Frambuffer"),pe.forEach(l),n=f(J," class takes a pointer to a "),S(s.$$.fragment,J),a=f(J,", a pointer to a "),S(u.$$.fragment,J),p=f(J,` along with lists of attachments, the width, the height and a number of array layers.
It uses this information to create a `),S(m.$$.fragment,J),_=f(J,"."),v=g(J,"BR",{}),P=g(J,"BR",{}),R=f(J,`
A `),S(A.$$.fragment,J),T=f(J,` renders to
a Framebuffer. The framebuffer links to the `),S(F.$$.fragment,J),B=f(J," being rendered to and is used when starting a "),S(y.$$.fragment,J),V=f(J," to set the target "),S(x.$$.fragment,J),M=f(J,` for
rendering. Once the `),S(O.$$.fragment,J),H=f(J,` is created, it can be used to create the framebuffers. Frame buffers are created
based on a particular `),S(k.$$.fragment,J),N=f(J," and they act as a link between the "),S(Q.$$.fragment,J),X=f(J," attachments and the real "),S(Z.$$.fragment,J),K=f(J," to be rendered to."),W=g(J,"BR",{}),q=g(J,"BR",{}),U=f(J,`
The framebuffer is an object that represents the set of images into which `),S(te.$$.fragment,J),ee=f(J,` render. These affect the last few stages in the pipeline: depth- and stencil testing,
blending, logical operations, multisampling, and so on. A framebuffer object is created
by using a reference to a `),S(se.$$.fragment,J),ie=f(J," and can be used with any render pass that has a similar arrangement of attachments.")},m(J,pe){D(e,J,pe),h(J,t,pe),h(J,r,pe),o(r,$),h(J,n,pe),D(s,J,pe),h(J,a,pe),D(u,J,pe),h(J,p,pe),D(m,J,pe),h(J,_,pe),h(J,v,pe),h(J,P,pe),h(J,R,pe),D(A,J,pe),h(J,T,pe),D(F,J,pe),h(J,B,pe),D(y,J,pe),h(J,V,pe),D(x,J,pe),h(J,M,pe),D(O,J,pe),h(J,H,pe),D(k,J,pe),h(J,N,pe),D(Q,J,pe),h(J,X,pe),D(Z,J,pe),h(J,K,pe),h(J,W,pe),h(J,q,pe),h(J,U,pe),D(te,J,pe),h(J,ee,pe),D(se,J,pe),h(J,ie,pe),ae=!0},p(J,[pe]){const Se={};pe&1&&(Se.$$scope={dirty:pe,ctx:J}),s.$set(Se);const de={};pe&1&&(de.$$scope={dirty:pe,ctx:J}),u.$set(de);const me={};pe&1&&(me.$$scope={dirty:pe,ctx:J}),m.$set(me);const De={};pe&1&&(De.$$scope={dirty:pe,ctx:J}),A.$set(De);const _e={};pe&1&&(_e.$$scope={dirty:pe,ctx:J}),F.$set(_e);const ne={};pe&1&&(ne.$$scope={dirty:pe,ctx:J}),y.$set(ne);const le={};pe&1&&(le.$$scope={dirty:pe,ctx:J}),x.$set(le);const ge={};pe&1&&(ge.$$scope={dirty:pe,ctx:J}),O.$set(ge);const we={};pe&1&&(we.$$scope={dirty:pe,ctx:J}),k.$set(we);const Pe={};pe&1&&(Pe.$$scope={dirty:pe,ctx:J}),Q.$set(Pe);const Be={};pe&1&&(Be.$$scope={dirty:pe,ctx:J}),Z.$set(Be);const Ie={};pe&1&&(Ie.$$scope={dirty:pe,ctx:J}),te.$set(Ie);const re={};pe&1&&(re.$$scope={dirty:pe,ctx:J}),se.$set(re)},i(J){ae||(b(e.$$.fragment,J),b(s.$$.fragment,J),b(u.$$.fragment,J),b(m.$$.fragment,J),b(A.$$.fragment,J),b(F.$$.fragment,J),b(y.$$.fragment,J),b(x.$$.fragment,J),b(O.$$.fragment,J),b(k.$$.fragment,J),b(Q.$$.fragment,J),b(Z.$$.fragment,J),b(te.$$.fragment,J),b(se.$$.fragment,J),ae=!0)},o(J){w(e.$$.fragment,J),w(s.$$.fragment,J),w(u.$$.fragment,J),w(m.$$.fragment,J),w(A.$$.fragment,J),w(F.$$.fragment,J),w(y.$$.fragment,J),w(x.$$.fragment,J),w(O.$$.fragment,J),w(k.$$.fragment,J),w(Q.$$.fragment,J),w(Z.$$.fragment,J),w(te.$$.fragment,J),w(se.$$.fragment,J),ae=!1},d(J){C(e,J),J&&l(t),J&&l(r),J&&l(n),C(s,J),J&&l(a),C(u,J),J&&l(p),C(m,J),J&&l(_),J&&l(v),J&&l(P),J&&l(R),C(A,J),J&&l(T),C(F,J),J&&l(B),C(y,J),J&&l(V),C(x,J),J&&l(M),C(O,J),J&&l(H),C(k,J),J&&l(N),C(Q,J),J&&l(X),C(Z,J),J&&l(K),J&&l(W),J&&l(q),J&&l(U),C(te,J),J&&l(ee),C(se,J),J&&l(ie)}}}class mq extends ve{constructor(e){super(),Ee(this,e,null,pq,be,{})}}function hq(c){let e,t;return{c(){e=d("span"),t=i("Create a new Framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function dq(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _q(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function vq(c){let e;return{c(){e=i("render passes")},l(t){e=f(t,"render passes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Eq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bq(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wq(c){let e;return{c(){e=i("Render Pass Constructor")},l(t){e=f(t,"Render Pass Constructor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Iq(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Dq(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[dq]},$$scope:{ctx:c}}}),A=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[gq]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[_q]},$$scope:{ctx:c}}}),y=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[vq]},$$scope:{ctx:c}}}),Q=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Eq]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.IMAGE,$$slots:{default:[bq]},$$scope:{ctx:c}}}),te=new G({props:{sectionID:L.RENDER_PASS_Constructor,$$slots:{default:[wq]},$$scope:{ctx:c}}}),se=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Iq]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Framebuffer should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("pRenderPass"),P=d("br"),R=i(`
            A pointer to a `),I(A.$$.fragment),T=i(" that defines which "),I(F.$$.fragment),B=i(" the framebuffer will be compatible with. Two "),I(y.$$.fragment),V=i(` are compatible with the same framebuffer if their attachment references
            are the same.`),x=Y(),M=d("li"),O=d("code"),H=i("pAttachments"),k=d("br"),N=i(`
            The set of `),I(Q.$$.fragment),X=i(`
            to be bound into the framebuffer object. Each `),I(Z.$$.fragment),K=i(`
            (/attachment) will be used as the corresponding attachment in the
            `),W=d("code"),q=i("attachments"),U=i(`
            list of the `),I(te.$$.fragment),ee=i(" of a "),I(se.$$.fragment),ie=i(" instance."),ae=Y(),J=d("li"),pe=d("code"),Se=i("width"),de=d("br"),me=i(`
            The width of the framebuffer.`),De=Y(),_e=d("li"),ne=d("code"),le=i("height"),ge=d("br"),we=i(`
            The height of the framebuffer.`),Pe=Y(),Be=d("li"),Ie=d("code"),re=i("layers"),he=d("br"),Le=i(`
            The number of layers of the framebuffer.`),this.h()},l(oe){e=g(oe,"DIV",{slot:!0});var ce=E(e);t=g(ce,"LI",{});var Ae=E(t);r=g(Ae,"CODE",{});var ye=E(r);$=f(ye,"pLogicalDevice"),ye.forEach(l),n=g(Ae,"BR",{}),s=f(Ae,`
            A pointer to the `),S(a.$$.fragment,Ae),u=f(Ae," the Framebuffer should be associated with."),Ae.forEach(l),p=j(ce),m=g(ce,"LI",{});var Fe=E(m);_=g(Fe,"CODE",{});var Ve=E(_);v=f(Ve,"pRenderPass"),Ve.forEach(l),P=g(Fe,"BR",{}),R=f(Fe,`
            A pointer to a `),S(A.$$.fragment,Fe),T=f(Fe," that defines which "),S(F.$$.fragment,Fe),B=f(Fe," the framebuffer will be compatible with. Two "),S(y.$$.fragment,Fe),V=f(Fe,` are compatible with the same framebuffer if their attachment references
            are the same.`),Fe.forEach(l),x=j(ce),M=g(ce,"LI",{});var Ge=E(M);O=g(Ge,"CODE",{});var He=E(O);H=f(He,"pAttachments"),He.forEach(l),k=g(Ge,"BR",{}),N=f(Ge,`
            The set of `),S(Q.$$.fragment,Ge),X=f(Ge,`
            to be bound into the framebuffer object. Each `),S(Z.$$.fragment,Ge),K=f(Ge,`
            (/attachment) will be used as the corresponding attachment in the
            `),W=g(Ge,"CODE",{});var ze=E(W);q=f(ze,"attachments"),ze.forEach(l),U=f(Ge,`
            list of the `),S(te.$$.fragment,Ge),ee=f(Ge," of a "),S(se.$$.fragment,Ge),ie=f(Ge," instance."),Ge.forEach(l),ae=j(ce),J=g(ce,"LI",{});var xe=E(J);pe=g(xe,"CODE",{});var Ne=E(pe);Se=f(Ne,"width"),Ne.forEach(l),de=g(xe,"BR",{}),me=f(xe,`
            The width of the framebuffer.`),xe.forEach(l),De=j(ce),_e=g(ce,"LI",{});var Te=E(_e);ne=g(Te,"CODE",{});var qe=E(ne);le=f(qe,"height"),qe.forEach(l),ge=g(Te,"BR",{}),we=f(Te,`
            The height of the framebuffer.`),Te.forEach(l),Pe=j(ce),Be=g(ce,"LI",{});var Ke=E(Be);Ie=g(Ke,"CODE",{});var je=E(Ie);re=f(je,"layers"),je.forEach(l),he=g(Ke,"BR",{}),Le=f(Ke,`
            The number of layers of the framebuffer.`),Ke.forEach(l),ce.forEach(l),this.h()},h(){z(e,"slot","params")},m(oe,ce){h(oe,e,ce),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),D(F,m,null),o(m,B),D(y,m,null),o(m,V),o(e,x),o(e,M),o(M,O),o(O,H),o(M,k),o(M,N),D(Q,M,null),o(M,X),D(Z,M,null),o(M,K),o(M,W),o(W,q),o(M,U),D(te,M,null),o(M,ee),D(se,M,null),o(M,ie),o(e,ae),o(e,J),o(J,pe),o(pe,Se),o(J,de),o(J,me),o(e,De),o(e,_e),o(_e,ne),o(ne,le),o(_e,ge),o(_e,we),o(e,Pe),o(e,Be),o(Be,Ie),o(Ie,re),o(Be,he),o(Be,Le),Oe=!0},p(oe,ce){const Ae={};ce&1&&(Ae.$$scope={dirty:ce,ctx:oe}),a.$set(Ae);const ye={};ce&1&&(ye.$$scope={dirty:ce,ctx:oe}),A.$set(ye);const Fe={};ce&1&&(Fe.$$scope={dirty:ce,ctx:oe}),F.$set(Fe);const Ve={};ce&1&&(Ve.$$scope={dirty:ce,ctx:oe}),y.$set(Ve);const Ge={};ce&1&&(Ge.$$scope={dirty:ce,ctx:oe}),Q.$set(Ge);const He={};ce&1&&(He.$$scope={dirty:ce,ctx:oe}),Z.$set(He);const ze={};ce&1&&(ze.$$scope={dirty:ce,ctx:oe}),te.$set(ze);const xe={};ce&1&&(xe.$$scope={dirty:ce,ctx:oe}),se.$set(xe)},i(oe){Oe||(b(a.$$.fragment,oe),b(A.$$.fragment,oe),b(F.$$.fragment,oe),b(y.$$.fragment,oe),b(Q.$$.fragment,oe),b(Z.$$.fragment,oe),b(te.$$.fragment,oe),b(se.$$.fragment,oe),Oe=!0)},o(oe){w(a.$$.fragment,oe),w(A.$$.fragment,oe),w(F.$$.fragment,oe),w(y.$$.fragment,oe),w(Q.$$.fragment,oe),w(Z.$$.fragment,oe),w(te.$$.fragment,oe),w(se.$$.fragment,oe),Oe=!1},d(oe){oe&&l(e),C(a),C(A),C(F),C(y),C(Q),C(Z),C(te),C(se)}}}function Cq(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Sq(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkFramebuffer",version:1.3,$$slots:{default:[Cq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(`
        couldn't be created.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p,`
        couldn't be created.`),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Pq(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Framebuffer(
    LogicalDevice* pLogicalDevice, 
    RenderPass* pRenderPass, 
    std::vector<ImageView*> pAttachments, 
    unsigned int width,
    unsigned int height, 
    unsigned int layers
);`}}),r=new Ce({props:{$$slots:{throws:[Sq],params:[Dq],details:[hq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Aq extends ve{constructor(e){super(),Ee(this,e,null,Pq,be,{})}}function Rq(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bq(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",target:"_blank",$$slots:{default:[Rq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Lq(c){let e;return{c(){e=i("Vulkan Framebuffer")},l(t){e=f(t,"Vulkan Framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kq(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html",target:"_blank",$$slots:{default:[Lq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Tq(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkFramebuffer getFramebufferHandle() const;"}}),r=new Ce({props:{$$slots:{return:[kq],details:[Bq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Vq extends ve{constructor(e){super(),Ee(this,e,null,Tq,be,{})}}function Oq(c){let e,t;return{c(){e=d("span"),t=i("Get the extent of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the extent of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Fq(c){let e;return{c(){e=i("VkExtent2D")},l(t){e=f(t,"VkExtent2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yq(c){let e,t,r,$,n;return r=new Bt({props:{reference:"VkExtent2D",version:1.3,$$slots:{default:[Fq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The extent of the framebuffer, this is a "),I(r.$$.fragment),$=i("-structure."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The extent of the framebuffer, this is a "),S(r.$$.fragment,a),$=f(a,"-structure."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Mq(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"VkExtent2D getExtent();"}}),r=new Ce({props:{$$slots:{return:[yq],details:[Oq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class xq extends ve{constructor(e){super(),Ee(this,e,null,Mq,be,{})}}function Nq(c){let e,t;return{c(){e=d("span"),t=i("Get the number of layers of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Get the number of layers of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Uq(c){let e,t;return{c(){e=d("span"),t=i("The number of layers of the framebuffer."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"The number of layers of the framebuffer."),$.forEach(l),this.h()},h(){z(e,"slot","return")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Gq(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"unsigned int getLayers();"}}),r=new Ce({props:{$$slots:{return:[Uq],details:[Nq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Hq extends ve{constructor(e){super(),Ee(this,e,null,Gq,be,{})}}function qq(c){let e;return{c(){e=i("images")},l(t){e=f(t,"images")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wq(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Qq(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Kq(c){let e,t,r,$,n,s,a,u,p,m;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/sampler.hpp>"}}),r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[qq]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Wq]},$$scope:{ctx:c}}}),a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[Qq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=i(`
When shaders read from `),I(r.$$.fragment),$=i(`, they can do so in two ways. The first is to load the
`),I(n.$$.fragment),s=i(` raw, which reads formatted
or unformatted data directly from a specific location in the image. The second way
is to sample the `),I(a.$$.fragment),u=i(` using a
sampler. Sampling can include operations such as performing basic transformations
on the image-coordinates or filtering texels to smooth out the image-data returned
to the shader. The sampler is a separate object that provides an interface to extract
colors from a texture. It can be applied to any image be it 1D, 2D or 3D.`),p=d("br")},l(_){S(e.$$.fragment,_),t=f(_,`
When shaders read from `),S(r.$$.fragment,_),$=f(_,`, they can do so in two ways. The first is to load the
`),S(n.$$.fragment,_),s=f(_,` raw, which reads formatted
or unformatted data directly from a specific location in the image. The second way
is to sample the `),S(a.$$.fragment,_),u=f(_,` using a
sampler. Sampling can include operations such as performing basic transformations
on the image-coordinates or filtering texels to smooth out the image-data returned
to the shader. The sampler is a separate object that provides an interface to extract
colors from a texture. It can be applied to any image be it 1D, 2D or 3D.`),p=g(_,"BR",{})},m(_,v){D(e,_,v),h(_,t,v),D(r,_,v),h(_,$,v),D(n,_,v),h(_,s,v),D(a,_,v),h(_,u,v),h(_,p,v),m=!0},p(_,[v]){const P={};v&1&&(P.$$scope={dirty:v,ctx:_}),r.$set(P);const R={};v&1&&(R.$$scope={dirty:v,ctx:_}),n.$set(R);const A={};v&1&&(A.$$scope={dirty:v,ctx:_}),a.$set(A)},i(_){m||(b(e.$$.fragment,_),b(r.$$.fragment,_),b(n.$$.fragment,_),b(a.$$.fragment,_),m=!0)},o(_){w(e.$$.fragment,_),w(r.$$.fragment,_),w(n.$$.fragment,_),w(a.$$.fragment,_),m=!1},d(_){C(e,_),_&&l(t),C(r,_),_&&l($),C(n,_),_&&l(s),C(a,_),_&&l(u),_&&l(p)}}}class zq extends ve{constructor(e){super(),Ee(this,e,null,Kq,be,{})}}function Yq(c){let e;return{c(){e=i("Sampler Builder")},l(t){e=f(t,"Sampler Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jq(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SAMPLER_BUILDER,$$slots:{default:[Yq]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Sampler."),r=d("br"),$=i(`
        It is recommended to not create a Sampler by it's Constructor, but to use
        a
        `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Sampler."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Sampler by it's Constructor, but to use
        a
        `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Xq(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Zq(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Jq(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function eW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tW(c){let e;return{c(){e=i("VkSamplerMipmapMode")},l(t){e=f(t,"VkSamplerMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rW(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nW(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sW(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function aW(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function oW(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function lW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function iW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function fW(c){let e;return{c(){e=i("VkCompareOp")},l(t){e=f(t,"VkCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cW(c){let e;return{c(){e=i("graphical pipeline")},l(t){e=f(t,"graphical pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $W(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pW(c){let e;return{c(){e=i("VkBorderColor")},l(t){e=f(t,"VkBorderColor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mW(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,Ft,mt,Vt,Rt,Tt,vt,gt,kt,Mt,yt,Ht,$r,Ut,or,Xt,Ot,Zt,Ar,br,ur,Qt,Or,rr,Kr,lr,gr,Fr,Kt,ir,yr,Re,lt,Jt,_r,Yt,nr,vr,Tr,fr,cr,sr,er,zr,_t,ft,qt,Mr,wr,Nt,Wt,xr,pr,Vr,jt,Rr,Ir,Nr,mr,Dr,hr,Br,Cr,en,Ur,tr,Gr,tn,jr,ln,Er,fn,Lr,cn,Yr,Lt,It,Hr,kr,qr,dn,Sr,gn,_n,Xr,vn,nn,xt,ar,Nn,Un,Gn,Cn,Hn,qn,$n,Wn,Sn,Pn,un,Qn,Wr,Kn,zn,An,pn,Yn,Gt,jn,Xn,Rn,Zn,Jn,Bn,es,ts,rn,rs,dr,Ln,ns,ss,kn,as,os,ls,bs,ws,_s;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[Xq]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[Zq]},$$scope:{ctx:c}}}),O=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[Jq]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.IMAGE,$$slots:{default:[eW]},$$scope:{ctx:c}}}),U=new Bt({props:{reference:"VkSamplerMipmapMode",version:1.3,$$slots:{default:[tW]},$$scope:{ctx:c}}}),Ie=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[rW]},$$scope:{ctx:c}}}),Ve=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[nW]},$$scope:{ctx:c}}}),rt=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[sW]},$$scope:{ctx:c}}}),kt=new G({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[aW]},$$scope:{ctx:c}}}),Ut=new Bt({props:{reference:"VkPhysicalDeviceLimits",version:1.3,$$slots:{default:[oW]},$$scope:{ctx:c}}}),Qt=new G({props:{sectionID:L.IMAGE,$$slots:{default:[lW]},$$scope:{ctx:c}}}),rr=new G({props:{sectionID:L.IMAGE,$$slots:{default:[iW]},$$scope:{ctx:c}}}),cr=new Bt({props:{reference:"VkCompareOp",version:1.3,$$slots:{default:[fW]},$$scope:{ctx:c}}}),er=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[cW]},$$scope:{ctx:c}}}),Wt=new G({props:{sectionID:L.IMAGE,$$slots:{default:[$W]},$$scope:{ctx:c}}}),Er=new G({props:{sectionID:L.IMAGE,$$slots:{default:[uW]},$$scope:{ctx:c}}}),Xr=new Bt({props:{reference:"VkBorderColor",version:1.3,$$slots:{default:[pW]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Sampler should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("magFilter"),P=d("br"),R=i(`
            The filter mode to use when the image is magnified. This is a member
            of the `),I(A.$$.fragment),T=i("-enumerant."),F=Y(),B=d("li"),y=d("code"),V=i("minFilter"),x=d("br"),M=i(`
            The filter mode to use when the image is minified. This is a member of
            the `),I(O.$$.fragment),H=i("-enumerant."),k=Y(),N=d("li"),Q=d("code"),X=i("mipmapMode"),Z=d("br"),K=i(`
            How mipmaps are used in the `),I(W.$$.fragment),q=i(" when it is sampled. This is a member of the "),I(U.$$.fragment),te=i(`-enumerant. If the mipmap mode is
            `),ee=d("code"),se=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),ie=i(`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),ae=d("code"),J=i("VK_SAMPLER_MIPMAP_MODE_LINEAR"),pe=i(`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),Se=d("code"),de=i("minFilter"),me=i(` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),De=d("br"),_e=i(`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),ne=Y(),le=d("li"),ge=d("code"),we=i("addressModeU"),Pe=d("br"),Be=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(Ie.$$.fragment),re=i("-enumerant."),he=d("br"),Le=i(`
            U is the X within the convention of texture space coordinates.`),Oe=Y(),oe=d("li"),ce=d("code"),Ae=i("addressModeV"),ye=d("br"),Fe=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(Ve.$$.fragment),Ge=i("-enumerant."),He=d("br"),ze=i(`
            V is the Y within the convention of texture space coordinates.`),xe=Y(),Ne=d("li"),Te=d("code"),qe=i("addressModeW"),Ke=d("br"),je=i(`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),I(rt.$$.fragment),Me=i("-enumerant."),Ue=d("br"),$t=i(`
            W is the Z within the convention of texture space coordinates.`),ut=Y(),ht=d("li"),Je=d("code"),dt=i("mipLodBias"),et=d("br"),Ze=i(`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),nt=Y(),Qe=d("li"),ct=d("code"),st=i("anisotropyEnable"),We=d("br"),at=i(`
            If anisotropic filtering is to be used, it can be set to
            `),bt=d("code"),wt=i("VK_TRUE"),St=i(`. If not, it can be set to
            `),tt=d("code"),ot=i("VK_FALSE"),At=i(`. Anisotropic filtering generally works by
            considering a projected footprint of the area to be sampled (or
            "sampled") rather than using a fixed 2x2 footprint. An approximation
            of a surface sample is formed by taking many samples within the
            footprint.`),it=Y(),Xe=d("li"),Dt=d("code"),Ct=i("maxAnisotropy"),pt=d("br"),Ft=i(`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),mt=d("code"),Vt=i("maxAnisotropy"),Rt=i(`
            to a value between `),Tt=d("code"),vt=i("1.0f"),gt=i(` and the maximum value supported
            by the device. The maximum values can be determined by calling `),I(kt.$$.fragment),Mt=i(`
            and inspecting the `),yt=d("code"),Ht=i("maxSamplerAnisotropy"),$r=i(` member of the
            embedded `),I(Ut.$$.fragment),or=i(`
            structure.`),Xt=Y(),Ot=d("li"),Zt=d("code"),Ar=i("compareEnable"),br=d("br"),ur=i(`
            of the comparison instead of the raw values stored in the `),I(Qt.$$.fragment),Or=i(`. When this mode is enabled, the comparison is performed on each
            sample taken from the `),I(rr.$$.fragment),Kr=i(`, and the resulting value is the fraction of the total number of
            samples taken that passed the test. This can be used to implement a
            technique known as percentage closer filtering or PCF. To enable
            this mode, `),lr=d("code"),gr=i("compareEnable"),Fr=i(`
            must be set to `),Kt=d("code"),ir=i("VK_TRUE"),yr=i(`
            and the compare operation must be set to `),Re=d("code"),lt=i("compareOp"),Jt=i("."),_r=Y(),Yt=d("li"),nr=d("code"),vr=i("compareOp"),Tr=d("br"),fr=i(`
            A member of the `),I(cr.$$.fragment),sr=i(`-enumeration, which is used in many places in Vulkan, including the
            `),I(er.$$.fragment),zr=i(". This is the enumeration used to specify the depth test operation."),_t=Y(),ft=d("li"),qt=d("code"),Mr=i("minLod"),wr=d("br"),Nt=i(`
            The lowest mipmaps (highest resolution) to sample from. The sampler can
            be configured to limit sampling to a subset of the mip levels in an `),I(Wt.$$.fragment),xr=i(`
            with mipmaps. The range of mipmaps to sample from is specified in
            `),pr=d("code"),Vr=i("minLod"),jt=i(`
            and `),Rr=d("code"),Ir=i("maxLod"),Nr=i("."),mr=Y(),Dr=d("li"),hr=d("code"),Br=i("maxLod"),Cr=d("br"),en=i(`
            The highest mipmaps (lowest resolution) to sample from.`),Ur=Y(),tr=d("li"),Gr=d("code"),tn=i("borderColor"),jr=d("br"),ln=i(`
            The border color used in place of data from the `),I(Er.$$.fragment),fn=i(` if
            `),Lr=d("code"),cn=i("addressmodeU"),Yr=i(`,
            `),Lt=d("code"),It=i("addressmodeV"),Hr=i(" and/or "),kr=d("code"),qr=i("addressmodeW"),dn=i(` is set to
            `),Sr=d("code"),gn=i("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),_n=i(`. This is a
            member of the `),I(Xr.$$.fragment),vn=i("-enumerant."),nn=Y(),xt=d("li"),ar=d("code"),Nn=i("unnormalizedCoordinates"),Un=d("br"),Gn=i(`
            A flag that, when set to `),Cn=d("code"),Hn=i("VK_TRUE"),qn=i(`, indicates that the
            coordinates used to extract from the image are in raw texel units,
            rather than a value normalized between `),$n=d("code"),Wn=i("0.0"),Sn=i(` and
            `),Pn=d("code"),un=i("1.0"),Qn=i(`
            for each dimension of the texture. This allows texels to be explicitly
            extracted from the image. However, there are several limitations in this
            mode. When `),Wr=d("code"),Kn=i("unnormalizedCoordinates"),zn=i(`
            is set to `),An=d("code"),pn=i("VK_TRUE"),Yn=i(`,
            `),Gt=d("code"),jn=i("minFilter"),Xn=i(" and "),Rn=d("code"),Zn=i("magFilter"),Jn=i(` must be the same,
            `),Bn=d("code"),es=i("mipmapMode"),ts=i(`
            must be set to `),rn=d("code"),rs=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),dr=i(` and
            `),Ln=d("code"),ns=i("anisotropyEnable"),ss=i(`
            and
            `),kn=d("code"),as=i("compareEnable"),os=i(" must be set to "),ls=d("code"),bs=i("VK_FALSE"),ws=i("."),this.h()},l(Pt){e=g(Pt,"DIV",{slot:!0});var Et=E(e);t=g(Et,"LI",{});var En=E(t);r=g(En,"CODE",{});var is=E(r);$=f(is,"pLogicalDevice"),is.forEach(l),n=g(En,"BR",{}),s=f(En,`
            A pointer to the `),S(a.$$.fragment,En),u=f(En," the Sampler should be associated with."),En.forEach(l),p=j(Et),m=g(Et,"LI",{});var bn=E(m);_=g(bn,"CODE",{});var fs=E(_);v=f(fs,"magFilter"),fs.forEach(l),P=g(bn,"BR",{}),R=f(bn,`
            The filter mode to use when the image is magnified. This is a member
            of the `),S(A.$$.fragment,bn),T=f(bn,"-enumerant."),bn.forEach(l),F=j(Et),B=g(Et,"LI",{});var wn=E(B);y=g(wn,"CODE",{});var cs=E(y);V=f(cs,"minFilter"),cs.forEach(l),x=g(wn,"BR",{}),M=f(wn,`
            The filter mode to use when the image is minified. This is a member of
            the `),S(O.$$.fragment,wn),H=f(wn,"-enumerant."),wn.forEach(l),k=j(Et),N=g(Et,"LI",{});var Pr=E(N);Q=g(Pr,"CODE",{});var $s=E(Q);X=f($s,"mipmapMode"),$s.forEach(l),Z=g(Pr,"BR",{}),K=f(Pr,`
            How mipmaps are used in the `),S(W.$$.fragment,Pr),q=f(Pr," when it is sampled. This is a member of the "),S(U.$$.fragment,Pr),te=f(Pr,`-enumerant. If the mipmap mode is
            `),ee=g(Pr,"CODE",{});var us=E(ee);se=f(us,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),us.forEach(l),ie=f(Pr,`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),ae=g(Pr,"CODE",{});var ps=E(ae);J=f(ps,"VK_SAMPLER_MIPMAP_MODE_LINEAR"),ps.forEach(l),pe=f(Pr,`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),Se=g(Pr,"CODE",{});var ms=E(Se);de=f(ms,"minFilter"),ms.forEach(l),me=f(Pr,` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),De=g(Pr,"BR",{}),_e=f(Pr,`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),Pr.forEach(l),ne=j(Et),le=g(Et,"LI",{});var sn=E(le);ge=g(sn,"CODE",{});var hs=E(ge);we=f(hs,"addressModeU"),hs.forEach(l),Pe=g(sn,"BR",{}),Be=f(sn,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(Ie.$$.fragment,sn),re=f(sn,"-enumerant."),he=g(sn,"BR",{}),Le=f(sn,`
            U is the X within the convention of texture space coordinates.`),sn.forEach(l),Oe=j(Et),oe=g(Et,"LI",{});var an=E(oe);ce=g(an,"CODE",{});var ds=E(ce);Ae=f(ds,"addressModeV"),ds.forEach(l),ye=g(an,"BR",{}),Fe=f(an,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(Ve.$$.fragment,an),Ge=f(an,"-enumerant."),He=g(an,"BR",{}),ze=f(an,`
            V is the Y within the convention of texture space coordinates.`),an.forEach(l),xe=j(Et),Ne=g(Et,"LI",{});var on=E(Ne);Te=g(on,"CODE",{});var gs=E(Te);qe=f(gs,"addressModeW"),gs.forEach(l),Ke=g(on,"BR",{}),je=f(on,`
            Used to select the transformer applied to texture coordinates that would
            otherwise be sampled outside the image. This is a member of the `),S(rt.$$.fragment,on),Me=f(on,"-enumerant."),Ue=g(on,"BR",{}),$t=f(on,`
            W is the Z within the convention of texture space coordinates.`),on.forEach(l),ut=j(Et),ht=g(Et,"LI",{});var vs=E(ht);Je=g(vs,"CODE",{});var Ss=E(Je);dt=f(Ss,"mipLodBias"),Ss.forEach(l),et=g(vs,"BR",{}),Ze=f(vs,`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),vs.forEach(l),nt=j(Et),Qe=g(Et,"LI",{});var Tn=E(Qe);ct=g(Tn,"CODE",{});var Ps=E(ct);st=f(Ps,"anisotropyEnable"),Ps.forEach(l),We=g(Tn,"BR",{}),at=f(Tn,`
            If anisotropic filtering is to be used, it can be set to
            `),bt=g(Tn,"CODE",{});var As=E(bt);wt=f(As,"VK_TRUE"),As.forEach(l),St=f(Tn,`. If not, it can be set to
            `),tt=g(Tn,"CODE",{});var Rs=E(tt);ot=f(Rs,"VK_FALSE"),Rs.forEach(l),At=f(Tn,`. Anisotropic filtering generally works by
            considering a projected footprint of the area to be sampled (or
            "sampled") rather than using a fixed 2x2 footprint. An approximation
            of a surface sample is formed by taking many samples within the
            footprint.`),Tn.forEach(l),it=j(Et),Xe=g(Et,"LI",{});var Zr=E(Xe);Dt=g(Zr,"CODE",{});var Bs=E(Dt);Ct=f(Bs,"maxAnisotropy"),Bs.forEach(l),pt=g(Zr,"BR",{}),Ft=f(Zr,`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),mt=g(Zr,"CODE",{});var Ls=E(mt);Vt=f(Ls,"maxAnisotropy"),Ls.forEach(l),Rt=f(Zr,`
            to a value between `),Tt=g(Zr,"CODE",{});var ks=E(Tt);vt=f(ks,"1.0f"),ks.forEach(l),gt=f(Zr,` and the maximum value supported
            by the device. The maximum values can be determined by calling `),S(kt.$$.fragment,Zr),Mt=f(Zr,`
            and inspecting the `),yt=g(Zr,"CODE",{});var Ts=E(yt);Ht=f(Ts,"maxSamplerAnisotropy"),Ts.forEach(l),$r=f(Zr,` member of the
            embedded `),S(Ut.$$.fragment,Zr),or=f(Zr,`
            structure.`),Zr.forEach(l),Xt=j(Et),Ot=g(Et,"LI",{});var Jr=E(Ot);Zt=g(Jr,"CODE",{});var Vs=E(Zt);Ar=f(Vs,"compareEnable"),Vs.forEach(l),br=g(Jr,"BR",{}),ur=f(Jr,`
            of the comparison instead of the raw values stored in the `),S(Qt.$$.fragment,Jr),Or=f(Jr,`. When this mode is enabled, the comparison is performed on each
            sample taken from the `),S(rr.$$.fragment,Jr),Kr=f(Jr,`, and the resulting value is the fraction of the total number of
            samples taken that passed the test. This can be used to implement a
            technique known as percentage closer filtering or PCF. To enable
            this mode, `),lr=g(Jr,"CODE",{});var Os=E(lr);gr=f(Os,"compareEnable"),Os.forEach(l),Fr=f(Jr,`
            must be set to `),Kt=g(Jr,"CODE",{});var Fs=E(Kt);ir=f(Fs,"VK_TRUE"),Fs.forEach(l),yr=f(Jr,`
            and the compare operation must be set to `),Re=g(Jr,"CODE",{});var ys=E(Re);lt=f(ys,"compareOp"),ys.forEach(l),Jt=f(Jr,"."),Jr.forEach(l),_r=j(Et),Yt=g(Et,"LI",{});var Vn=E(Yt);nr=g(Vn,"CODE",{});var Ms=E(nr);vr=f(Ms,"compareOp"),Ms.forEach(l),Tr=g(Vn,"BR",{}),fr=f(Vn,`
            A member of the `),S(cr.$$.fragment,Vn),sr=f(Vn,`-enumeration, which is used in many places in Vulkan, including the
            `),S(er.$$.fragment,Vn),zr=f(Vn,". This is the enumeration used to specify the depth test operation."),Vn.forEach(l),_t=j(Et),ft=g(Et,"LI",{});var mn=E(ft);qt=g(mn,"CODE",{});var xs=E(qt);Mr=f(xs,"minLod"),xs.forEach(l),wr=g(mn,"BR",{}),Nt=f(mn,`
            The lowest mipmaps (highest resolution) to sample from. The sampler can
            be configured to limit sampling to a subset of the mip levels in an `),S(Wt.$$.fragment,mn),xr=f(mn,`
            with mipmaps. The range of mipmaps to sample from is specified in
            `),pr=g(mn,"CODE",{});var Ns=E(pr);Vr=f(Ns,"minLod"),Ns.forEach(l),jt=f(mn,`
            and `),Rr=g(mn,"CODE",{});var Us=E(Rr);Ir=f(Us,"maxLod"),Us.forEach(l),Nr=f(mn,"."),mn.forEach(l),mr=j(Et),Dr=g(Et,"LI",{});var Es=E(Dr);hr=g(Es,"CODE",{});var Gs=E(hr);Br=f(Gs,"maxLod"),Gs.forEach(l),Cr=g(Es,"BR",{}),en=f(Es,`
            The highest mipmaps (lowest resolution) to sample from.`),Es.forEach(l),Ur=j(Et),tr=g(Et,"LI",{});var Qr=E(tr);Gr=g(Qr,"CODE",{});var Hs=E(Gr);tn=f(Hs,"borderColor"),Hs.forEach(l),jr=g(Qr,"BR",{}),ln=f(Qr,`
            The border color used in place of data from the `),S(Er.$$.fragment,Qr),fn=f(Qr,` if
            `),Lr=g(Qr,"CODE",{});var qs=E(Lr);cn=f(qs,"addressmodeU"),qs.forEach(l),Yr=f(Qr,`,
            `),Lt=g(Qr,"CODE",{});var Ws=E(Lt);It=f(Ws,"addressmodeV"),Ws.forEach(l),Hr=f(Qr," and/or "),kr=g(Qr,"CODE",{});var Qs=E(kr);qr=f(Qs,"addressmodeW"),Qs.forEach(l),dn=f(Qr,` is set to
            `),Sr=g(Qr,"CODE",{});var Ks=E(Sr);gn=f(Ks,"VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),Ks.forEach(l),_n=f(Qr,`. This is a
            member of the `),S(Xr.$$.fragment,Qr),vn=f(Qr,"-enumerant."),Qr.forEach(l),nn=j(Et),xt=g(Et,"LI",{});var zt=E(xt);ar=g(zt,"CODE",{});var zs=E(ar);Nn=f(zs,"unnormalizedCoordinates"),zs.forEach(l),Un=g(zt,"BR",{}),Gn=f(zt,`
            A flag that, when set to `),Cn=g(zt,"CODE",{});var Ys=E(Cn);Hn=f(Ys,"VK_TRUE"),Ys.forEach(l),qn=f(zt,`, indicates that the
            coordinates used to extract from the image are in raw texel units,
            rather than a value normalized between `),$n=g(zt,"CODE",{});var js=E($n);Wn=f(js,"0.0"),js.forEach(l),Sn=f(zt,` and
            `),Pn=g(zt,"CODE",{});var Xs=E(Pn);un=f(Xs,"1.0"),Xs.forEach(l),Qn=f(zt,`
            for each dimension of the texture. This allows texels to be explicitly
            extracted from the image. However, there are several limitations in this
            mode. When `),Wr=g(zt,"CODE",{});var Zs=E(Wr);Kn=f(Zs,"unnormalizedCoordinates"),Zs.forEach(l),zn=f(zt,`
            is set to `),An=g(zt,"CODE",{});var Js=E(An);pn=f(Js,"VK_TRUE"),Js.forEach(l),Yn=f(zt,`,
            `),Gt=g(zt,"CODE",{});var ea=E(Gt);jn=f(ea,"minFilter"),ea.forEach(l),Xn=f(zt," and "),Rn=g(zt,"CODE",{});var ta=E(Rn);Zn=f(ta,"magFilter"),ta.forEach(l),Jn=f(zt,` must be the same,
            `),Bn=g(zt,"CODE",{});var ra=E(Bn);es=f(ra,"mipmapMode"),ra.forEach(l),ts=f(zt,`
            must be set to `),rn=g(zt,"CODE",{});var na=E(rn);rs=f(na,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),na.forEach(l),dr=f(zt,` and
            `),Ln=g(zt,"CODE",{});var sa=E(Ln);ns=f(sa,"anisotropyEnable"),sa.forEach(l),ss=f(zt,`
            and
            `),kn=g(zt,"CODE",{});var aa=E(kn);as=f(aa,"compareEnable"),aa.forEach(l),os=f(zt," must be set to "),ls=g(zt,"CODE",{});var oa=E(ls);bs=f(oa,"VK_FALSE"),oa.forEach(l),ws=f(zt,"."),zt.forEach(l),Et.forEach(l),this.h()},h(){z(e,"slot","params")},m(Pt,Et){h(Pt,e,Et),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),D(U,N,null),o(N,te),o(N,ee),o(ee,se),o(N,ie),o(N,ae),o(ae,J),o(N,pe),o(N,Se),o(Se,de),o(N,me),o(N,De),o(N,_e),o(e,ne),o(e,le),o(le,ge),o(ge,we),o(le,Pe),o(le,Be),D(Ie,le,null),o(le,re),o(le,he),o(le,Le),o(e,Oe),o(e,oe),o(oe,ce),o(ce,Ae),o(oe,ye),o(oe,Fe),D(Ve,oe,null),o(oe,Ge),o(oe,He),o(oe,ze),o(e,xe),o(e,Ne),o(Ne,Te),o(Te,qe),o(Ne,Ke),o(Ne,je),D(rt,Ne,null),o(Ne,Me),o(Ne,Ue),o(Ne,$t),o(e,ut),o(e,ht),o(ht,Je),o(Je,dt),o(ht,et),o(ht,Ze),o(e,nt),o(e,Qe),o(Qe,ct),o(ct,st),o(Qe,We),o(Qe,at),o(Qe,bt),o(bt,wt),o(Qe,St),o(Qe,tt),o(tt,ot),o(Qe,At),o(e,it),o(e,Xe),o(Xe,Dt),o(Dt,Ct),o(Xe,pt),o(Xe,Ft),o(Xe,mt),o(mt,Vt),o(Xe,Rt),o(Xe,Tt),o(Tt,vt),o(Xe,gt),D(kt,Xe,null),o(Xe,Mt),o(Xe,yt),o(yt,Ht),o(Xe,$r),D(Ut,Xe,null),o(Xe,or),o(e,Xt),o(e,Ot),o(Ot,Zt),o(Zt,Ar),o(Ot,br),o(Ot,ur),D(Qt,Ot,null),o(Ot,Or),D(rr,Ot,null),o(Ot,Kr),o(Ot,lr),o(lr,gr),o(Ot,Fr),o(Ot,Kt),o(Kt,ir),o(Ot,yr),o(Ot,Re),o(Re,lt),o(Ot,Jt),o(e,_r),o(e,Yt),o(Yt,nr),o(nr,vr),o(Yt,Tr),o(Yt,fr),D(cr,Yt,null),o(Yt,sr),D(er,Yt,null),o(Yt,zr),o(e,_t),o(e,ft),o(ft,qt),o(qt,Mr),o(ft,wr),o(ft,Nt),D(Wt,ft,null),o(ft,xr),o(ft,pr),o(pr,Vr),o(ft,jt),o(ft,Rr),o(Rr,Ir),o(ft,Nr),o(e,mr),o(e,Dr),o(Dr,hr),o(hr,Br),o(Dr,Cr),o(Dr,en),o(e,Ur),o(e,tr),o(tr,Gr),o(Gr,tn),o(tr,jr),o(tr,ln),D(Er,tr,null),o(tr,fn),o(tr,Lr),o(Lr,cn),o(tr,Yr),o(tr,Lt),o(Lt,It),o(tr,Hr),o(tr,kr),o(kr,qr),o(tr,dn),o(tr,Sr),o(Sr,gn),o(tr,_n),D(Xr,tr,null),o(tr,vn),o(e,nn),o(e,xt),o(xt,ar),o(ar,Nn),o(xt,Un),o(xt,Gn),o(xt,Cn),o(Cn,Hn),o(xt,qn),o(xt,$n),o($n,Wn),o(xt,Sn),o(xt,Pn),o(Pn,un),o(xt,Qn),o(xt,Wr),o(Wr,Kn),o(xt,zn),o(xt,An),o(An,pn),o(xt,Yn),o(xt,Gt),o(Gt,jn),o(xt,Xn),o(xt,Rn),o(Rn,Zn),o(xt,Jn),o(xt,Bn),o(Bn,es),o(xt,ts),o(xt,rn),o(rn,rs),o(xt,dr),o(xt,Ln),o(Ln,ns),o(xt,ss),o(xt,kn),o(kn,as),o(xt,os),o(xt,ls),o(ls,bs),o(xt,ws),_s=!0},p(Pt,Et){const En={};Et&1&&(En.$$scope={dirty:Et,ctx:Pt}),a.$set(En);const is={};Et&1&&(is.$$scope={dirty:Et,ctx:Pt}),A.$set(is);const bn={};Et&1&&(bn.$$scope={dirty:Et,ctx:Pt}),O.$set(bn);const fs={};Et&1&&(fs.$$scope={dirty:Et,ctx:Pt}),W.$set(fs);const wn={};Et&1&&(wn.$$scope={dirty:Et,ctx:Pt}),U.$set(wn);const cs={};Et&1&&(cs.$$scope={dirty:Et,ctx:Pt}),Ie.$set(cs);const Pr={};Et&1&&(Pr.$$scope={dirty:Et,ctx:Pt}),Ve.$set(Pr);const $s={};Et&1&&($s.$$scope={dirty:Et,ctx:Pt}),rt.$set($s);const us={};Et&1&&(us.$$scope={dirty:Et,ctx:Pt}),kt.$set(us);const ps={};Et&1&&(ps.$$scope={dirty:Et,ctx:Pt}),Ut.$set(ps);const ms={};Et&1&&(ms.$$scope={dirty:Et,ctx:Pt}),Qt.$set(ms);const sn={};Et&1&&(sn.$$scope={dirty:Et,ctx:Pt}),rr.$set(sn);const hs={};Et&1&&(hs.$$scope={dirty:Et,ctx:Pt}),cr.$set(hs);const an={};Et&1&&(an.$$scope={dirty:Et,ctx:Pt}),er.$set(an);const ds={};Et&1&&(ds.$$scope={dirty:Et,ctx:Pt}),Wt.$set(ds);const on={};Et&1&&(on.$$scope={dirty:Et,ctx:Pt}),Er.$set(on);const gs={};Et&1&&(gs.$$scope={dirty:Et,ctx:Pt}),Xr.$set(gs)},i(Pt){_s||(b(a.$$.fragment,Pt),b(A.$$.fragment,Pt),b(O.$$.fragment,Pt),b(W.$$.fragment,Pt),b(U.$$.fragment,Pt),b(Ie.$$.fragment,Pt),b(Ve.$$.fragment,Pt),b(rt.$$.fragment,Pt),b(kt.$$.fragment,Pt),b(Ut.$$.fragment,Pt),b(Qt.$$.fragment,Pt),b(rr.$$.fragment,Pt),b(cr.$$.fragment,Pt),b(er.$$.fragment,Pt),b(Wt.$$.fragment,Pt),b(Er.$$.fragment,Pt),b(Xr.$$.fragment,Pt),_s=!0)},o(Pt){w(a.$$.fragment,Pt),w(A.$$.fragment,Pt),w(O.$$.fragment,Pt),w(W.$$.fragment,Pt),w(U.$$.fragment,Pt),w(Ie.$$.fragment,Pt),w(Ve.$$.fragment,Pt),w(rt.$$.fragment,Pt),w(kt.$$.fragment,Pt),w(Ut.$$.fragment,Pt),w(Qt.$$.fragment,Pt),w(rr.$$.fragment,Pt),w(cr.$$.fragment,Pt),w(er.$$.fragment,Pt),w(Wt.$$.fragment,Pt),w(Er.$$.fragment,Pt),w(Xr.$$.fragment,Pt),_s=!1},d(Pt){Pt&&l(e),C(a),C(A),C(O),C(W),C(U),C(Ie),C(Ve),C(rt),C(kt),C(Ut),C(Qt),C(rr),C(cr),C(er),C(Wt),C(Er),C(Xr)}}}function hW(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function dW(c){let e,t,r,$,n,s,a;return n=new Bt({props:{reference:"VkSampler",version:1.3,$$slots:{default:[hW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function gW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`Sampler(
    LogicalDevice* pLogicalDevice, 
    VkFilter magFilter, 
    VkFilter minFilter, 
    VkSamplerMipmapMode mipmapMode,
    VkSamplerAddressMode addressModeU, 
    VkSamplerAddressMode addressModeV, 
    VkSamplerAddressMode addressModeW, 
    float mipLodBias,
    VkBool32 anisotropyEnable, 
    float maxAnisotropy, 
    VkBool32 compareEnable, 
    VkCompareOp compareOp, 
    float minLod, 
    float maxLod,
    VkBorderColor borderColor, 
    VkBool32 unnormalizedCoordinates
);`}}),r=new Ce({props:{$$slots:{throws:[dW],params:[mW],details:[jq]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _W extends ve{constructor(e){super(),Ee(this,e,null,gW,be,{})}}function vW(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function EW(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html",target:"_blank",$$slots:{default:[vW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function bW(c){let e;return{c(){e=i("Vulkan Sampler")},l(t){e=f(t,"Vulkan Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wW(c){let e,t,r,$,n;return r=new fe({props:{href:"https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html",target:"_blank",$$slots:{default:[bW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The handle to the "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The handle to the "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function IW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"const VkSampler getSamplerHandle() const;"}}),r=new Ce({props:{$$slots:{return:[wW],details:[EW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DW extends ve{constructor(e){super(),Ee(this,e,null,IW,be,{})}}function CW(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/sampler_builder.hpp>"}}),m=new $e({props:{language:ue,code:`LogicalDevice* pLogicalDevice = nullptr;
VkFilter magFilter = VK_FILTER_LINEAR;
VkFilter minFilter = VK_FILTER_LINEAR;
VkSamplerMipmapMode mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
VkSamplerAddressMode addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
VkSamplerAddressMode addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
VkSamplerAddressMode addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
float mipLodBias = 0.f;
VkBool32 anisotropyEnable = VK_FALSE;
float maxAnisotropy = 1.0f;
VkBool32 compareEnable = VK_FALSE;
VkCompareOp compareOp = VK_COMPARE_OP_ALWAYS;
float minLod = 0.f;
float maxLod = 0.f;
VkBorderColor borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
VkBool32 unnormalizedCoordinates = VK_FALSE;`}}),P=new $e({props:{language:ue,code:`fillcan::SamplerBuilder samplerBuilder = fillcan::SamplerBuilder();
samplerBuilder.setLogicalDevice(fillcan.getCurrentDevice());
samplerBuilder.setFilters(VK_FILTER_LINEAR, VK_FILTER_LINEAR);
samplerBuilder.setMipmapMode(VK_SAMPLER_MIPMAP_MODE_LINEAR);
samplerBuilder.setAddressModes(VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT);
samplerBuilder.setMipLodBias(0.0f);
samplerBuilder.setMaxAnisotropy(1.0f);
samplerBuilder.setCompareOp(VK_COMPARE_OP_ALWAYS);
samplerBuilder.setLod(0.0f, 0.0f);
samplerBuilder.setBorderColor(VK_BORDER_COLOR_INT_OPAQUE_BLACK);
std::unique_ptr<fillcan::Sampler> upSampler = samplerBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Sampler Builder"),n=i(` class is part of the creational design pattern
to construct complex objects step by step.`),s=d("br"),a=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=d("br"),p=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(m.$$.fragment),_=d("br"),v=i(`
Example:
`),I(P.$$.fragment)},l(A){S(e.$$.fragment,A),t=f(A,`
The `),r=g(A,"CODE",{});var T=E(r);$=f(T,"Sampler Builder"),T.forEach(l),n=f(A,` class is part of the creational design pattern
to construct complex objects step by step.`),s=g(A,"BR",{}),a=f(A,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),u=g(A,"BR",{}),p=f(A,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(m.$$.fragment,A),_=g(A,"BR",{}),v=f(A,`
Example:
`),S(P.$$.fragment,A)},m(A,T){D(e,A,T),h(A,t,T),h(A,r,T),o(r,$),h(A,n,T),h(A,s,T),h(A,a,T),h(A,u,T),h(A,p,T),D(m,A,T),h(A,_,T),h(A,v,T),D(P,A,T),R=!0},p:ke,i(A){R||(b(e.$$.fragment,A),b(m.$$.fragment,A),b(P.$$.fragment,A),R=!0)},o(A){w(e.$$.fragment,A),w(m.$$.fragment,A),w(P.$$.fragment,A),R=!1},d(A){C(e,A),A&&l(t),A&&l(r),A&&l(n),A&&l(s),A&&l(a),A&&l(u),A&&l(p),C(m,A),A&&l(_),A&&l(v),C(P,A)}}}class SW extends ve{constructor(e){super(),Ee(this,e,null,CW,be,{})}}function PW(c){let e,t;return{c(){e=d("span"),t=i("Create a new Sampler Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Sampler Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function AW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"SamplerBuilder();"}}),r=new Ce({props:{$$slots:{details:[PW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class RW extends ve{constructor(e){super(),Ee(this,e,null,AW,be,{})}}function BW(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function LW(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kW(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[BW]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[LW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" for the "),I(n.$$.fragment),s=i("."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Set the "),S(r.$$.fragment,p),$=f(p," for the "),S(n.$$.fragment,p),s=f(p,"."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function TW(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function VW(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function OW(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[TW]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[VW]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the "),I(p.$$.fragment),m=i(` should
            be associated with.`),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"pLogicalDevice"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A pointer to the `),S(a.$$.fragment,R),u=f(R," the "),S(p.$$.fragment,R),m=f(R,` should
            be associated with.`),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function FW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLogicalDevice(LogicalDevice* pLogicalDevice);"}}),r=new Ce({props:{$$slots:{params:[OW],details:[kW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class yW extends ve{constructor(e){super(),Ee(this,e,null,FW,be,{})}}function MW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xW(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[MW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the filter modes to use when the "),I(r.$$.fragment),$=i(" is magnified or minified."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the filter modes to use when the "),S(r.$$.fragment,a),$=f(a," is magnified or minified."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function NW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UW(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HW(c){let e;return{c(){e=i("VkFilter")},l(t){e=f(t,"VkFilter")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qW(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[NW]},$$scope:{ctx:c}}}),p=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[UW]},$$scope:{ctx:c}}}),F=new G({props:{sectionID:L.IMAGE,$$slots:{default:[GW]},$$scope:{ctx:c}}}),y=new Bt({props:{reference:"VkFilter",version:1.3,$$slots:{default:[HW]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("magFilter"),n=d("br"),s=i(`
            The filter mode to use when the `),I(a.$$.fragment),u=i(" is magnified. This is a member of the "),I(p.$$.fragment),m=i("-enumerant."),_=Y(),v=d("li"),P=d("code"),R=i("minFilter"),A=d("br"),T=i(`
            The filter mode to use when the `),I(F.$$.fragment),B=i(" is minified. This is a member of the "),I(y.$$.fragment),V=i("-enumerant."),this.h()},l(M){e=g(M,"DIV",{slot:!0});var O=E(e);t=g(O,"LI",{});var H=E(t);r=g(H,"CODE",{});var k=E(r);$=f(k,"magFilter"),k.forEach(l),n=g(H,"BR",{}),s=f(H,`
            The filter mode to use when the `),S(a.$$.fragment,H),u=f(H," is magnified. This is a member of the "),S(p.$$.fragment,H),m=f(H,"-enumerant."),H.forEach(l),_=j(O),v=g(O,"LI",{});var N=E(v);P=g(N,"CODE",{});var Q=E(P);R=f(Q,"minFilter"),Q.forEach(l),A=g(N,"BR",{}),T=f(N,`
            The filter mode to use when the `),S(F.$$.fragment,N),B=f(N," is minified. This is a member of the "),S(y.$$.fragment,N),V=f(N,"-enumerant."),N.forEach(l),O.forEach(l),this.h()},h(){z(e,"slot","params")},m(M,O){h(M,e,O),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(e,_),o(e,v),o(v,P),o(P,R),o(v,A),o(v,T),D(F,v,null),o(v,B),D(y,v,null),o(v,V),x=!0},p(M,O){const H={};O&1&&(H.$$scope={dirty:O,ctx:M}),a.$set(H);const k={};O&1&&(k.$$scope={dirty:O,ctx:M}),p.$set(k);const N={};O&1&&(N.$$scope={dirty:O,ctx:M}),F.$set(N);const Q={};O&1&&(Q.$$scope={dirty:O,ctx:M}),y.$set(Q)},i(M){x||(b(a.$$.fragment,M),b(p.$$.fragment,M),b(F.$$.fragment,M),b(y.$$.fragment,M),x=!0)},o(M){w(a.$$.fragment,M),w(p.$$.fragment,M),w(F.$$.fragment,M),w(y.$$.fragment,M),x=!1},d(M){M&&l(e),C(a),C(p),C(F),C(y)}}}function WW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setFilters(VkFilter magFilter, VkFilter minFilter);"}}),r=new Ce({props:{$$slots:{params:[qW],details:[xW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class QW extends ve{constructor(e){super(),Ee(this,e,null,WW,be,{})}}function KW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zW(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[KW]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set how mipmaps are used in the "),I(r.$$.fragment),$=i(" when it is sampled."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set how mipmaps are used in the "),S(r.$$.fragment,a),$=f(a," when it is sampled."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function YW(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jW(c){let e;return{c(){e=i("VkSamplerMipmapMode")},l(t){e=f(t,"VkSamplerMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function XW(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[YW]},$$scope:{ctx:c}}}),p=new Bt({props:{reference:"VkSamplerMipmapMode",version:1.3,$$slots:{default:[jW]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipmapMode"),n=d("br"),s=i(`
            How mipmaps are used in the `),I(a.$$.fragment),u=i(" when it is sampled. This is a member of the "),I(p.$$.fragment),m=i(`-enumerant. If the mipmap mode is
            `),_=d("code"),v=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),P=i(`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),R=d("code"),A=i("VK_SAMPLER_MIPMAP_MODE_LINEAR"),T=i(`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),F=d("code"),B=i("minFilter"),y=i(` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),V=d("br"),x=i(`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),this.h()},l(O){e=g(O,"DIV",{slot:!0});var H=E(e);t=g(H,"LI",{});var k=E(t);r=g(k,"CODE",{});var N=E(r);$=f(N,"mipmapMode"),N.forEach(l),n=g(k,"BR",{}),s=f(k,`
            How mipmaps are used in the `),S(a.$$.fragment,k),u=f(k," when it is sampled. This is a member of the "),S(p.$$.fragment,k),m=f(k,`-enumerant. If the mipmap mode is
            `),_=g(k,"CODE",{});var Q=E(_);v=f(Q,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),Q.forEach(l),P=f(k,`, the selected mipmap
            level is rounded down to the next lowest integer, and then that
            level is sampled as if it were a single-level image. When the mipmap
            mode is `),R=g(k,"CODE",{});var X=E(R);A=f(X,"VK_SAMPLER_MIPMAP_MODE_LINEAR"),X.forEach(l),T=f(k,`, a sample is
            taken from each of the next-lower and next-higher levels using the
            filter mode selected by the `),F=g(k,"CODE",{});var Z=E(F);B=f(Z,"minFilter"),Z.forEach(l),y=f(k,` field, and then
            those two samples are further combined using a weighted average,
            similar to how the samples are combined during linear sampling, as
            previously described.`),V=g(k,"BR",{}),x=f(k,`
            Note that this filter mode only applies to minification, which is the
            process of sampling from a different mipmap level than the base level.`),k.forEach(l),H.forEach(l),this.h()},h(){z(e,"slot","params")},m(O,H){h(O,e,H),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),o(t,_),o(_,v),o(t,P),o(t,R),o(R,A),o(t,T),o(t,F),o(F,B),o(t,y),o(t,V),o(t,x),M=!0},p(O,H){const k={};H&1&&(k.$$scope={dirty:H,ctx:O}),a.$set(k);const N={};H&1&&(N.$$scope={dirty:H,ctx:O}),p.$set(N)},i(O){M||(b(a.$$.fragment,O),b(p.$$.fragment,O),M=!0)},o(O){w(a.$$.fragment,O),w(p.$$.fragment,O),M=!1},d(O){O&&l(e),C(a),C(p)}}}function ZW(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setMipmapMode(VkSamplerMipmapMode mipmapMode);"}}),r=new Ce({props:{$$slots:{params:[XW],details:[zW]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class JW extends ve{constructor(e){super(),Ee(this,e,null,ZW,be,{})}}function eQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tQ(c){let e;return{c(){e=i("VkSamplerAddressMode")},l(t){e=f(t,"VkSamplerAddressMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function rQ(c){let e,t,r,$,n,s,a;return r=new G({props:{sectionID:L.IMAGE,$$slots:{default:[eQ]},$$scope:{ctx:c}}}),n=new Bt({props:{reference:"VkSamplerAddressMode",version:1.3,$$slots:{default:[tQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i(`Set the address modes which are used to select the transformer applied
        to texture coordinates that would otherwise be sampled outside the
        `),I(r.$$.fragment),$=i(`. These are
        members of the `),I(n.$$.fragment),s=i("-enumerant."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,`Set the address modes which are used to select the transformer applied
        to texture coordinates that would otherwise be sampled outside the
        `),S(r.$$.fragment,p),$=f(p,`. These are
        members of the `),S(n.$$.fragment,p),s=f(p,"-enumerant."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function nQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("addressModeU"),n=d("br"),s=i(`
            U is the X within the convention of texture space coordinates.`),a=Y(),u=d("li"),p=d("code"),m=i("addressModeV"),_=d("br"),v=i(`
            V is the Y within the convention of texture space coordinates.`),P=Y(),R=d("li"),A=d("code"),T=i("addressModeW"),F=d("br"),B=i(`
            W is the Z within the convention of texture space coordinates.`),this.h()},l(y){e=g(y,"DIV",{slot:!0});var V=E(e);t=g(V,"LI",{});var x=E(t);r=g(x,"CODE",{});var M=E(r);$=f(M,"addressModeU"),M.forEach(l),n=g(x,"BR",{}),s=f(x,`
            U is the X within the convention of texture space coordinates.`),x.forEach(l),a=j(V),u=g(V,"LI",{});var O=E(u);p=g(O,"CODE",{});var H=E(p);m=f(H,"addressModeV"),H.forEach(l),_=g(O,"BR",{}),v=f(O,`
            V is the Y within the convention of texture space coordinates.`),O.forEach(l),P=j(V),R=g(V,"LI",{});var k=E(R);A=g(k,"CODE",{});var N=E(A);T=f(N,"addressModeW"),N.forEach(l),F=g(k,"BR",{}),B=f(k,`
            W is the Z within the convention of texture space coordinates.`),k.forEach(l),V.forEach(l),this.h()},h(){z(e,"slot","params")},m(y,V){h(y,e,V),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(e,P),o(e,R),o(R,A),o(A,T),o(R,F),o(R,B)},p:ke,d(y){y&&l(e)}}}function sQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setAddressModes(VkSamplerAddressMode addressModeU, VkSamplerAddressMode addressModeV, VkSamplerAddressMode addressModeW);"}}),r=new Ce({props:{$$slots:{params:[nQ],details:[rQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aQ extends ve{constructor(e){super(),Ee(this,e,null,sQ,be,{})}}function oQ(c){let e,t;return{c(){e=d("span"),t=i("Set the bias for the mip Lod."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the bias for the mip Lod."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function lQ(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("mipLodBias"),n=d("br"),s=i(`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"mipLodBias"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            A floating-point bias that is added to the computed level of detail before
            making mipmap selection. This can push the level of detail up or down
            in the mipmap chain to make the resulting filtered texture look sharper
            or fainter than it would otherwise.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function iQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setMipLodBias(float mipLodBias);"}}),r=new Ce({props:{$$slots:{params:[lQ],details:[oQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class fQ extends ve{constructor(e){super(),Ee(this,e,null,iQ,be,{})}}function cQ(c){let e,t;return{c(){e=d("span"),t=i(`Set the max anisotropy if anisotropic filtering is to be used, also
        enables anisotropic filtering.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Set the max anisotropy if anisotropic filtering is to be used, also
        enables anisotropic filtering.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function $Q(c){let e;return{c(){e=i("getProperties")},l(t){e=f(t,"getProperties")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function uQ(c){let e;return{c(){e=i("VkPhysicalDeviceLimits")},l(t){e=f(t,"VkPhysicalDeviceLimits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V;return P=new G({props:{sectionID:L.PHYSICAL_DEVICE_getProperties,$$slots:{default:[$Q]},$$scope:{ctx:c}}}),B=new Bt({props:{reference:"VkPhysicalDeviceLimits",version:1.3,$$slots:{default:[uQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("maxAnisotropy"),n=d("br"),s=i(`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),a=d("code"),u=i("maxAnisotropy"),p=i(`
            to a value between `),m=d("code"),_=i("1.0f"),v=i(` and the maximum value supported
            by the device. The maximum values can be determined by calling `),I(P.$$.fragment),R=i(`
            and inspecting the `),A=d("code"),T=i("maxSamplerAnisotropy"),F=i(` member of the
            embedded `),I(B.$$.fragment),y=i(`
            structure.`),this.h()},l(x){e=g(x,"DIV",{slot:!0});var M=E(e);t=g(M,"LI",{});var O=E(t);r=g(O,"CODE",{});var H=E(r);$=f(H,"maxAnisotropy"),H.forEach(l),n=g(O,"BR",{}),s=f(O,`
            Because the number of samples taken can be quite large, anisotropic filtering
            can have a negative effect on performance. Also, in extreme cases, the
            projected footprint can be quite large, and this can result in a large
            area and a correspondingly blurry filter result. To mitigate these effects,
            the maximum amount of anisotropy can be locked by setting
            `),a=g(O,"CODE",{});var k=E(a);u=f(k,"maxAnisotropy"),k.forEach(l),p=f(O,`
            to a value between `),m=g(O,"CODE",{});var N=E(m);_=f(N,"1.0f"),N.forEach(l),v=f(O,` and the maximum value supported
            by the device. The maximum values can be determined by calling `),S(P.$$.fragment,O),R=f(O,`
            and inspecting the `),A=g(O,"CODE",{});var Q=E(A);T=f(Q,"maxSamplerAnisotropy"),Q.forEach(l),F=f(O,` member of the
            embedded `),S(B.$$.fragment,O),y=f(O,`
            structure.`),O.forEach(l),M.forEach(l),this.h()},h(){z(e,"slot","params")},m(x,M){h(x,e,M),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(t,m),o(m,_),o(t,v),D(P,t,null),o(t,R),o(t,A),o(A,T),o(t,F),D(B,t,null),o(t,y),V=!0},p(x,M){const O={};M&1&&(O.$$scope={dirty:M,ctx:x}),P.$set(O);const H={};M&1&&(H.$$scope={dirty:M,ctx:x}),B.$set(H)},i(x){V||(b(P.$$.fragment,x),b(B.$$.fragment,x),V=!0)},o(x){w(P.$$.fragment,x),w(B.$$.fragment,x),V=!1},d(x){x&&l(e),C(P),C(B)}}}function mQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setMaxAnisotropy(float maxAnisotropy);"}}),r=new Ce({props:{$$slots:{params:[pQ],details:[cQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class hQ extends ve{constructor(e){super(),Ee(this,e,null,mQ,be,{})}}function dQ(c){let e,t;return{c(){e=d("span"),t=i(`Reset the max anisotropy to it's default value and disable anisotropic
        filtering.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Reset the max anisotropy to it's default value and disable anisotropic
        filtering.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function gQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void unsetMaxAnisotropy();"}}),r=new Ce({props:{$$slots:{details:[dQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class _Q extends ve{constructor(e){super(),Ee(this,e,null,gQ,be,{})}}function vQ(c){let e,t;return{c(){e=d("span"),t=i(`When a sampler is used with a depth image, it can be configured to
        perform a compare operation and return the result of the comparison
        instead of the raw values stored in the image. When this mode is
        enabled, the comparison is performed on each sample taken from the
        image, and the resulting value is the fraction of the total number of
        samples taken that passed the test. This can be used to implement a
        technique known as percentage closer filtering or PCF. This enables this
        mode.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`When a sampler is used with a depth image, it can be configured to
        perform a compare operation and return the result of the comparison
        instead of the raw values stored in the image. When this mode is
        enabled, the comparison is performed on each sample taken from the
        image, and the resulting value is the fraction of the total number of
        samples taken that passed the test. This can be used to implement a
        technique known as percentage closer filtering or PCF. This enables this
        mode.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function EQ(c){let e;return{c(){e=i("VkCompareOp")},l(t){e=f(t,"VkCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bQ(c){let e;return{c(){e=i("graphical pipeline")},l(t){e=f(t,"graphical pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function wQ(c){let e,t,r,$,n,s,a,u,p,m,_;return a=new Bt({props:{reference:"VkCompareOp",version:1.3,$$slots:{default:[EQ]},$$scope:{ctx:c}}}),p=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[bQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("compareOp"),n=d("br"),s=i(`
            A member of the `),I(a.$$.fragment),u=i(`-enumeration, which is used in many places in Vulkan, including the
            `),I(p.$$.fragment),m=i(". This is the enumeration used to specify the depth test operation."),this.h()},l(v){e=g(v,"DIV",{slot:!0});var P=E(e);t=g(P,"LI",{});var R=E(t);r=g(R,"CODE",{});var A=E(r);$=f(A,"compareOp"),A.forEach(l),n=g(R,"BR",{}),s=f(R,`
            A member of the `),S(a.$$.fragment,R),u=f(R,`-enumeration, which is used in many places in Vulkan, including the
            `),S(p.$$.fragment,R),m=f(R,". This is the enumeration used to specify the depth test operation."),R.forEach(l),P.forEach(l),this.h()},h(){z(e,"slot","params")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),D(p,t,null),o(t,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),a.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(a.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(a.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(a),C(p)}}}function IQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setCompareOp(VkCompareOp compareOp);"}}),r=new Ce({props:{$$slots:{params:[wQ],details:[vQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class DQ extends ve{constructor(e){super(),Ee(this,e,null,IQ,be,{})}}function CQ(c){let e,t;return{c(){e=d("span"),t=i(`Reset the compare operation to it's default value and disable
        comparing.`),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,`Reset the compare operation to it's default value and disable
        comparing.`),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function SQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void unsetCompareOp();"}}),r=new Ce({props:{$$slots:{details:[CQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class PQ extends ve{constructor(e){super(),Ee(this,e,null,SQ,be,{})}}function AQ(c){let e;return{c(){e=i("sampler")},l(t){e=f(t,"sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function RQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,P;return r=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[AQ]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[RQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(` can be configured
        to limit sampling to a subset of the mip levels in an `),I(n.$$.fragment),s=i(` with mipmaps. The range of mipmaps to sample from is specified in
        `),a=d("code"),u=i("minLod"),p=i(`
        and `),m=d("code"),_=i("maxLod"),v=i("."),this.h()},l(R){e=g(R,"SPAN",{slot:!0});var A=E(e);t=f(A,"The "),S(r.$$.fragment,A),$=f(A,` can be configured
        to limit sampling to a subset of the mip levels in an `),S(n.$$.fragment,A),s=f(A,` with mipmaps. The range of mipmaps to sample from is specified in
        `),a=g(A,"CODE",{});var T=E(a);u=f(T,"minLod"),T.forEach(l),p=f(A,`
        and `),m=g(A,"CODE",{});var F=E(m);_=f(F,"maxLod"),F.forEach(l),v=f(A,"."),A.forEach(l),this.h()},h(){z(e,"slot","details")},m(R,A){h(R,e,A),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),P=!0},p(R,A){const T={};A&1&&(T.$$scope={dirty:A,ctx:R}),r.$set(T);const F={};A&1&&(F.$$scope={dirty:A,ctx:R}),n.$set(F)},i(R){P||(b(r.$$.fragment,R),b(n.$$.fragment,R),P=!0)},o(R){w(r.$$.fragment,R),w(n.$$.fragment,R),P=!1},d(R){R&&l(e),C(r),C(n)}}}function LQ(c){let e,t,r,$,n,s,a,u,p,m,_,v;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("minLod"),n=d("br"),s=i(`
            The lowest mipmaps (highest resolution) to sample from.`),a=Y(),u=d("li"),p=d("code"),m=i("maxLod"),_=d("br"),v=i(`
            The highest mipmaps (lowest resolution) to sample from.`),this.h()},l(P){e=g(P,"DIV",{slot:!0});var R=E(e);t=g(R,"LI",{});var A=E(t);r=g(A,"CODE",{});var T=E(r);$=f(T,"minLod"),T.forEach(l),n=g(A,"BR",{}),s=f(A,`
            The lowest mipmaps (highest resolution) to sample from.`),A.forEach(l),a=j(R),u=g(R,"LI",{});var F=E(u);p=g(F,"CODE",{});var B=E(p);m=f(B,"maxLod"),B.forEach(l),_=g(F,"BR",{}),v=f(F,`
            The highest mipmaps (lowest resolution) to sample from.`),F.forEach(l),R.forEach(l),this.h()},h(){z(e,"slot","params")},m(P,R){h(P,e,R),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v)},p:ke,d(P){P&&l(e)}}}function kQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setLod(float minLod, float maxLod);"}}),r=new Ce({props:{$$slots:{params:[LQ],details:[BQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class TQ extends ve{constructor(e){super(),Ee(this,e,null,kQ,be,{})}}function VQ(c){let e,t;return{c(){e=d("span"),t=i("Set the border color."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the border color."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function OQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function FQ(c){let e;return{c(){e=i("setAddressModes")},l(t){e=f(t,"setAddressModes")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function yQ(c){let e;return{c(){e=i("VkBorderColor")},l(t){e=f(t,"VkBorderColor")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function MQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k;return a=new G({props:{sectionID:L.IMAGE,$$slots:{default:[OQ]},$$scope:{ctx:c}}}),x=new G({props:{sectionID:L.SAMPLER_BUILDER_setAddressModes,$$slots:{default:[FQ]},$$scope:{ctx:c}}}),O=new Bt({props:{reference:"VkBorderColor",version:1.3,$$slots:{default:[yQ]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("borderColor"),n=d("br"),s=i(`
            The border color used in place of data from the `),I(a.$$.fragment),u=i(` if
            `),p=d("code"),m=i("addressmodeU"),_=i(`,
            `),v=d("code"),P=i("addressmodeV"),R=i(" and/or "),A=d("code"),T=i("addressmodeW"),F=i(` is set to
            `),B=d("code"),y=i("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),V=i(" using "),I(x.$$.fragment),M=i(". This is a member of the "),I(O.$$.fragment),H=i("-enumerant."),this.h()},l(N){e=g(N,"DIV",{slot:!0});var Q=E(e);t=g(Q,"LI",{});var X=E(t);r=g(X,"CODE",{});var Z=E(r);$=f(Z,"borderColor"),Z.forEach(l),n=g(X,"BR",{}),s=f(X,`
            The border color used in place of data from the `),S(a.$$.fragment,X),u=f(X,` if
            `),p=g(X,"CODE",{});var K=E(p);m=f(K,"addressmodeU"),K.forEach(l),_=f(X,`,
            `),v=g(X,"CODE",{});var W=E(v);P=f(W,"addressmodeV"),W.forEach(l),R=f(X," and/or "),A=g(X,"CODE",{});var q=E(A);T=f(q,"addressmodeW"),q.forEach(l),F=f(X,` is set to
            `),B=g(X,"CODE",{});var U=E(B);y=f(U,"VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),U.forEach(l),V=f(X," using "),S(x.$$.fragment,X),M=f(X,". This is a member of the "),S(O.$$.fragment,X),H=f(X,"-enumerant."),X.forEach(l),Q.forEach(l),this.h()},h(){z(e,"slot","params")},m(N,Q){h(N,e,Q),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(t,p),o(p,m),o(t,_),o(t,v),o(v,P),o(t,R),o(t,A),o(A,T),o(t,F),o(t,B),o(B,y),o(t,V),D(x,t,null),o(t,M),D(O,t,null),o(t,H),k=!0},p(N,Q){const X={};Q&1&&(X.$$scope={dirty:Q,ctx:N}),a.$set(X);const Z={};Q&1&&(Z.$$scope={dirty:Q,ctx:N}),x.$set(Z);const K={};Q&1&&(K.$$scope={dirty:Q,ctx:N}),O.$set(K)},i(N){k||(b(a.$$.fragment,N),b(x.$$.fragment,N),b(O.$$.fragment,N),k=!0)},o(N){w(a.$$.fragment,N),w(x.$$.fragment,N),w(O.$$.fragment,N),k=!1},d(N){N&&l(e),C(a),C(x),C(O)}}}function xQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setBorderColor(VkBorderColor borderColor);"}}),r=new Ce({props:{$$slots:{params:[MQ],details:[VQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class NQ extends ve{constructor(e){super(),Ee(this,e,null,xQ,be,{})}}function UQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GQ(c){let e;return{c(){e=i("image")},l(t){e=f(t,"image")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function HQ(c){let e;return{c(){e=i("setFilters")},l(t){e=f(t,"setFilters")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function qQ(c){let e;return{c(){e=i("setMipmapMode")},l(t){e=f(t,"setMipmapMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function WQ(c){let e;return{c(){e=i("setMaxAnisotropy")},l(t){e=f(t,"setMaxAnisotropy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function QQ(c){let e;return{c(){e=i("unsetMaxAnisotropy")},l(t){e=f(t,"unsetMaxAnisotropy")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function KQ(c){let e;return{c(){e=i("setCompareOp")},l(t){e=f(t,"setCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function zQ(c){let e;return{c(){e=i("unsetCompareOp")},l(t){e=f(t,"unsetCompareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YQ(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be;return n=new G({props:{sectionID:L.IMAGE,$$slots:{default:[UQ]},$$scope:{ctx:c}}}),P=new G({props:{sectionID:L.IMAGE,$$slots:{default:[GQ]},$$scope:{ctx:c}}}),H=new G({props:{sectionID:L.SAMPLER_BUILDER_setFilters,$$slots:{default:[HQ]},$$scope:{ctx:c}}}),Z=new G({props:{sectionID:L.SAMPLER_BUILDER_setMipmapMode,$$slots:{default:[qQ]},$$scope:{ctx:c}}}),ie=new G({props:{sectionID:L.SAMPLER_BUILDER_setMaxAnisotropy,$$slots:{default:[WQ]},$$scope:{ctx:c}}}),J=new G({props:{sectionID:L.SAMPLER_BUILDER_unsetMaxAnisotropy,$$slots:{default:[QQ]},$$scope:{ctx:c}}}),De=new G({props:{sectionID:L.SAMPLER_BUILDER_setCompareOp,$$slots:{default:[KQ]},$$scope:{ctx:c}}}),ne=new G({props:{sectionID:L.SAMPLER_BUILDER_unsetCompareOp,$$slots:{default:[zQ]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Enable unnormalized coordinates."),r=d("br"),$=i(`
        When enabled, indicates that the coordinates used to extract from the `),I(n.$$.fragment),s=i(` are in raw texel units, rather than a value normalized between
        `),a=d("code"),u=i("0.0"),p=i(`
        and
        `),m=d("code"),_=i("1.0"),v=i(`
        for each dimension of the texture. This allows texels to be explicitly extracted
        from the `),I(P.$$.fragment),R=i(`.
        However, there are several limitations in this mode. When
        `),A=d("code"),T=i("unnormalizedCoordinates"),F=i(`
        is enabled,
        `),B=d("code"),y=i("minFilter"),V=i(" and "),x=d("code"),M=i("magFilter"),O=i(" (see "),I(H.$$.fragment),k=i(") must be the same, "),N=d("code"),Q=i("mipmapMode"),X=i(" (see "),I(Z.$$.fragment),K=i(") must be set to "),W=d("code"),q=i("VK_SAMPLER_MIPMAP_MODE_NEAREST"),U=i(` and
        `),te=d("code"),ee=i("anisotropyEnable"),se=i(`
        (see `),I(ie.$$.fragment),ae=i(" and "),I(J.$$.fragment),pe=i(`) and
        `),Se=d("code"),de=i("compareEnable"),me=i(" (see "),I(De.$$.fragment),_e=i(" and "),I(ne.$$.fragment),le=i(") must be set to "),ge=d("code"),we=i("VK_FALSE"),Pe=i("."),this.h()},l(Ie){e=g(Ie,"SPAN",{slot:!0});var re=E(e);t=f(re,"Enable unnormalized coordinates."),r=g(re,"BR",{}),$=f(re,`
        When enabled, indicates that the coordinates used to extract from the `),S(n.$$.fragment,re),s=f(re,` are in raw texel units, rather than a value normalized between
        `),a=g(re,"CODE",{});var he=E(a);u=f(he,"0.0"),he.forEach(l),p=f(re,`
        and
        `),m=g(re,"CODE",{});var Le=E(m);_=f(Le,"1.0"),Le.forEach(l),v=f(re,`
        for each dimension of the texture. This allows texels to be explicitly extracted
        from the `),S(P.$$.fragment,re),R=f(re,`.
        However, there are several limitations in this mode. When
        `),A=g(re,"CODE",{});var Oe=E(A);T=f(Oe,"unnormalizedCoordinates"),Oe.forEach(l),F=f(re,`
        is enabled,
        `),B=g(re,"CODE",{});var oe=E(B);y=f(oe,"minFilter"),oe.forEach(l),V=f(re," and "),x=g(re,"CODE",{});var ce=E(x);M=f(ce,"magFilter"),ce.forEach(l),O=f(re," (see "),S(H.$$.fragment,re),k=f(re,") must be the same, "),N=g(re,"CODE",{});var Ae=E(N);Q=f(Ae,"mipmapMode"),Ae.forEach(l),X=f(re," (see "),S(Z.$$.fragment,re),K=f(re,") must be set to "),W=g(re,"CODE",{});var ye=E(W);q=f(ye,"VK_SAMPLER_MIPMAP_MODE_NEAREST"),ye.forEach(l),U=f(re,` and
        `),te=g(re,"CODE",{});var Fe=E(te);ee=f(Fe,"anisotropyEnable"),Fe.forEach(l),se=f(re,`
        (see `),S(ie.$$.fragment,re),ae=f(re," and "),S(J.$$.fragment,re),pe=f(re,`) and
        `),Se=g(re,"CODE",{});var Ve=E(Se);de=f(Ve,"compareEnable"),Ve.forEach(l),me=f(re," (see "),S(De.$$.fragment,re),_e=f(re," and "),S(ne.$$.fragment,re),le=f(re,") must be set to "),ge=g(re,"CODE",{});var Ge=E(ge);we=f(Ge,"VK_FALSE"),Ge.forEach(l),Pe=f(re,"."),re.forEach(l),this.h()},h(){z(e,"slot","details")},m(Ie,re){h(Ie,e,re),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(a,u),o(e,p),o(e,m),o(m,_),o(e,v),D(P,e,null),o(e,R),o(e,A),o(A,T),o(e,F),o(e,B),o(B,y),o(e,V),o(e,x),o(x,M),o(e,O),D(H,e,null),o(e,k),o(e,N),o(N,Q),o(e,X),D(Z,e,null),o(e,K),o(e,W),o(W,q),o(e,U),o(e,te),o(te,ee),o(e,se),D(ie,e,null),o(e,ae),D(J,e,null),o(e,pe),o(e,Se),o(Se,de),o(e,me),D(De,e,null),o(e,_e),D(ne,e,null),o(e,le),o(e,ge),o(ge,we),o(e,Pe),Be=!0},p(Ie,re){const he={};re&1&&(he.$$scope={dirty:re,ctx:Ie}),n.$set(he);const Le={};re&1&&(Le.$$scope={dirty:re,ctx:Ie}),P.$set(Le);const Oe={};re&1&&(Oe.$$scope={dirty:re,ctx:Ie}),H.$set(Oe);const oe={};re&1&&(oe.$$scope={dirty:re,ctx:Ie}),Z.$set(oe);const ce={};re&1&&(ce.$$scope={dirty:re,ctx:Ie}),ie.$set(ce);const Ae={};re&1&&(Ae.$$scope={dirty:re,ctx:Ie}),J.$set(Ae);const ye={};re&1&&(ye.$$scope={dirty:re,ctx:Ie}),De.$set(ye);const Fe={};re&1&&(Fe.$$scope={dirty:re,ctx:Ie}),ne.$set(Fe)},i(Ie){Be||(b(n.$$.fragment,Ie),b(P.$$.fragment,Ie),b(H.$$.fragment,Ie),b(Z.$$.fragment,Ie),b(ie.$$.fragment,Ie),b(J.$$.fragment,Ie),b(De.$$.fragment,Ie),b(ne.$$.fragment,Ie),Be=!0)},o(Ie){w(n.$$.fragment,Ie),w(P.$$.fragment,Ie),w(H.$$.fragment,Ie),w(Z.$$.fragment,Ie),w(ie.$$.fragment,Ie),w(J.$$.fragment,Ie),w(De.$$.fragment,Ie),w(ne.$$.fragment,Ie),Be=!1},d(Ie){Ie&&l(e),C(n),C(P),C(H),C(Z),C(ie),C(J),C(De),C(ne)}}}function jQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void enableUnnormalizedCoordinates();"}}),r=new Ce({props:{$$slots:{details:[YQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class XQ extends ve{constructor(e){super(),Ee(this,e,null,jQ,be,{})}}function ZQ(c){let e,t;return{c(){e=d("span"),t=i("Disable unnormalized coordinates."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Disable unnormalized coordinates."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function JQ(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void disableUnnormalizedCoordinates();"}}),r=new Ce({props:{$$slots:{details:[ZQ]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class e8 extends ve{constructor(e){super(),Ee(this,e,null,JQ,be,{})}}function t8(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function r8(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[t8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function n8(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function s8(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function a8(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[n8]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[s8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(`,
        it's ownership will be moved.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,`,
        it's ownership will be moved.`),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function o8(c){let e;return{c(){e=i("Sampler")},l(t){e=f(t,"Sampler")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function l8(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.SAMPLER,$$slots:{default:[o8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function i8(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<Sampler> getResult();"}}),r=new Ce({props:{$$slots:{throws:[l8],return:[a8],details:[r8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class f8 extends ve{constructor(e){super(),Ee(this,e,null,i8,be,{})}}function c8(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $8(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function u8(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset();"}}),r=new Ce({props:{$$slots:{details:[$8],default:[c8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class p8 extends ve{constructor(e){super(),Ee(this,e,null,u8,be,{})}}function m8(c){let e;return{c(){e=i("Pipeline")},l(t){e=f(t,"Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function h8(c){let e;return{c(){e=i("compute pipeline")},l(t){e=f(t,"compute pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function d8(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/graphics_pipeline.hpp>"}}),a=new G({props:{sectionID:L.PIPELINE,$$slots:{default:[m8]},$$scope:{ctx:c}}}),v=new G({props:{sectionID:L.COMPUTE_PIPELINE,$$slots:{default:[h8]},$$scope:{ctx:c}}}),O=new $e({props:{language:ue,code:`#version 450

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inColor;
        
layout(location = 0) out vec3 outColor;
        
layout(push_constant) uniform PushConstant {
    mat4 transform;
    vec3 color;
} push_constant;
        
void main() {
    gl_Position = push_constant.transform * vec4(inPosition, 1.0);
    outColor = inColor;
}`}}),k=new $e({props:{language:hn,code:`#version 450

layout(location = 0) in vec3 inColor;
    
layout(location = 0) out vec4 outColor;
    
layout(push_constant) uniform PushConstant {
    mat4 transform;
    vec3 color;
} push_constant;
    
void main() {
    outColor = vec4(inColor, 1.0);
}`}}),Q=new $e({props:{language:hn,code:`// Bind the pipeline to a command buffer
upGraphicsPipeline->bindToCommandBuffer(pCommandBuffer);

// Bind any descriptor sets to the pipeline
upGraphicsPipeline->bindDescriptorSets(std::vector<std::string>{"ExampleDescriptorSet"}, 0);

// Update any push constant data
upGraphicsPipeline->pushConstantData("ExamplePushConstant", std::move(examplePushConstantData));
`}}),Z=new $e({props:{language:ue,code:`struct SimplePushConstantData : public fillcan::PushConstantData {
    glm::mat4 transform{1.f};
    alignas(16) glm::vec3 color;
};
...
{
    // Create recording to gain access to a primary commandbuffer
    fillcan::CommandRecording* pGraphicsCommandRecording = fillcan.getCurrentDevice()->getGraphicsQueue()->createRecording(1, 0);
    fillcan::CommandBuffer* pGraphicsPrimaryCommandBuffer = pGraphicsCommandRecording->pPrimaryCommandBuffers.at(0);

    // Begin compute recording commands
    pGraphicsPrimaryCommandBuffer->begin();

    // Bind the pipeline to a command buffer
    upGraphicsPipeline->bindToCommandBuffer(pGraphicsPrimaryCommandBuffer);

    // Bind the descriptor sets to the bound command buffer
    upGraphicsPipeline->bindDescriptorSets();

    for (fillcan::GameObject& gameObject : gameObjects) {
        gameObject.transform.rotation.y = glm::mod(gameObject.transform.rotation.y + (0.5f * this->deltaTimef), glm::two_pi<float>());
        gameObject.transform.rotation.x = glm::mod(gameObject.transform.rotation.x + (0.25f * this->deltaTimef), glm::two_pi<float>());

        SimplePushConstantData data = {.transform = gameObject.transform.mat4(), .color = gameObject.color};
    
        // Update the push constant data
        std::unique_ptr<SimplePushConstantData> simplePushConstantData = std::make_unique<SimplePushConstantData>(data);
        upGraphicsPipeline->pushConstantData("SimplePushConstant", std::move(simplePushConstantData));

        gameObject.model->bind(pGraphicsPrimaryCommandBuffer);
        gameObject.model->drawIndexed();
    }

    // End the recording
    pGraphicsPrimaryCommandBuffer->end();
}`}}),{c(){I(e.$$.fragment),t=i(`

The `),r=d("code"),$=i("Graphics Pipeline"),n=i(` class extends the
`),s=d("code"),I(a.$$.fragment),u=i(`
class.`),p=d("br"),m=d("br"),_=i(`
Creating a graphics pipeline is accomplished using a method similar to that of creating
a `),I(v.$$.fragment),P=i(`. However, the graphics pipeline contains many shader stages and fixed function
processing blocks, so the description of a graphics pipeline is much more
complex.`),R=d("br"),A=d("br"),T=i(`
The most basic rendering will contain at least a vertex and a fragment shader. Each
shader stage can consume data from the previous stage or pass data to the next, forming
a pipeline. In some cases, the inputs to a shader are provided by fixed function
blocks, and sometimes the outputs of a shader are consumed by fixed function blocks.
Regardless of the source or destination of data, the way to declare the *input and
output to shaders is the same.`),F=d("br"),B=d("br"),y=i(`
Example:`),V=d("br"),x=d("br"),M=i(`

Vertex Shader:
`),I(O.$$.fragment),H=i(`

Fragment Shader:
`),I(k.$$.fragment),N=Y(),I(Q.$$.fragment),X=i(`
C++ Code:
`),I(Z.$$.fragment)},l(W){S(e.$$.fragment,W),t=f(W,`

The `),r=g(W,"CODE",{});var q=E(r);$=f(q,"Graphics Pipeline"),q.forEach(l),n=f(W,` class extends the
`),s=g(W,"CODE",{});var U=E(s);S(a.$$.fragment,U),U.forEach(l),u=f(W,`
class.`),p=g(W,"BR",{}),m=g(W,"BR",{}),_=f(W,`
Creating a graphics pipeline is accomplished using a method similar to that of creating
a `),S(v.$$.fragment,W),P=f(W,`. However, the graphics pipeline contains many shader stages and fixed function
processing blocks, so the description of a graphics pipeline is much more
complex.`),R=g(W,"BR",{}),A=g(W,"BR",{}),T=f(W,`
The most basic rendering will contain at least a vertex and a fragment shader. Each
shader stage can consume data from the previous stage or pass data to the next, forming
a pipeline. In some cases, the inputs to a shader are provided by fixed function
blocks, and sometimes the outputs of a shader are consumed by fixed function blocks.
Regardless of the source or destination of data, the way to declare the *input and
output to shaders is the same.`),F=g(W,"BR",{}),B=g(W,"BR",{}),y=f(W,`
Example:`),V=g(W,"BR",{}),x=g(W,"BR",{}),M=f(W,`

Vertex Shader:
`),S(O.$$.fragment,W),H=f(W,`

Fragment Shader:
`),S(k.$$.fragment,W),N=j(W),S(Q.$$.fragment,W),X=f(W,`
C++ Code:
`),S(Z.$$.fragment,W)},m(W,q){D(e,W,q),h(W,t,q),h(W,r,q),o(r,$),h(W,n,q),h(W,s,q),D(a,s,null),h(W,u,q),h(W,p,q),h(W,m,q),h(W,_,q),D(v,W,q),h(W,P,q),h(W,R,q),h(W,A,q),h(W,T,q),h(W,F,q),h(W,B,q),h(W,y,q),h(W,V,q),h(W,x,q),h(W,M,q),D(O,W,q),h(W,H,q),D(k,W,q),h(W,N,q),D(Q,W,q),h(W,X,q),D(Z,W,q),K=!0},p(W,[q]){const U={};q&1&&(U.$$scope={dirty:q,ctx:W}),a.$set(U);const te={};q&1&&(te.$$scope={dirty:q,ctx:W}),v.$set(te)},i(W){K||(b(e.$$.fragment,W),b(a.$$.fragment,W),b(v.$$.fragment,W),b(O.$$.fragment,W),b(k.$$.fragment,W),b(Q.$$.fragment,W),b(Z.$$.fragment,W),K=!0)},o(W){w(e.$$.fragment,W),w(a.$$.fragment,W),w(v.$$.fragment,W),w(O.$$.fragment,W),w(k.$$.fragment,W),w(Q.$$.fragment,W),w(Z.$$.fragment,W),K=!1},d(W){C(e,W),W&&l(t),W&&l(r),W&&l(n),W&&l(s),C(a),W&&l(u),W&&l(p),W&&l(m),W&&l(_),C(v,W),W&&l(P),W&&l(R),W&&l(A),W&&l(T),W&&l(F),W&&l(B),W&&l(y),W&&l(V),W&&l(x),W&&l(M),C(O,W),W&&l(H),C(k,W),W&&l(N),C(Q,W),W&&l(X),C(Z,W)}}}class g8 extends ve{constructor(e){super(),Ee(this,e,null,d8,be,{})}}function _8(c){let e;return{c(){e=i("Graphics Pipeline Builder")},l(t){e=f(t,"Graphics Pipeline Builder")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function v8(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.GRAPHICS_PIPELINE_BUILDER,$$slots:{default:[_8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Create a new Graphics Pipeline."),r=d("br"),$=i(`
        It is recommended to not create a Graphics Pipeline by it's Constructor,
        but to use a `),I(n.$$.fragment),s=i(" instead."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Create a new Graphics Pipeline."),r=g(p,"BR",{}),$=f(p,`
        It is recommended to not create a Graphics Pipeline by it's Constructor,
        but to use a `),S(n.$$.fragment,p),s=f(p," instead."),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function E8(c){let e;return{c(){e=i("Logical Device")},l(t){e=f(t,"Logical Device")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function b8(c){let e;return{c(){e=i("VkPipelineCreateFlagBits")},l(t){e=f(t,"VkPipelineCreateFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function w8(c){let e;return{c(){e=i("PipelineShaderStage")},l(t){e=f(t,"PipelineShaderStage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function I8(c){let e;return{c(){e=i("push constants")},l(t){e=f(t,"push constants")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function D8(c){let e;return{c(){e=i("Vulkan Pipeline Cache")},l(t){e=f(t,"Vulkan Pipeline Cache")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function C8(c){let e;return{c(){e=i("VkPipelineInputAssemblyStateCreateInfo")},l(t){e=f(t,"VkPipelineInputAssemblyStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function S8(c){let e;return{c(){e=i("VkPipelineVertexInputStateCreateInfo")},l(t){e=f(t,"VkPipelineVertexInputStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function P8(c){let e;return{c(){e=i("VkPipelineTessellationStateCreateInfo")},l(t){e=f(t,"VkPipelineTessellationStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function A8(c){let e;return{c(){e=i("VkPipelineViewportStateCreateInfo")},l(t){e=f(t,"VkPipelineViewportStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function R8(c){let e;return{c(){e=i("VkPipelineRasterizationStateCreateInfo")},l(t){e=f(t,"VkPipelineRasterizationStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function B8(c){let e;return{c(){e=i("VkPipelineMultisampleStateCreateInfo")},l(t){e=f(t,"VkPipelineMultisampleStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function L8(c){let e;return{c(){e=i("VkPipelineDepthStencilStateCreateInfo")},l(t){e=f(t,"VkPipelineDepthStencilStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function k8(c){let e;return{c(){e=i("VkPipelineColorBlendStateCreateInfo")},l(t){e=f(t,"VkPipelineColorBlendStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function T8(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function V8(c){let e;return{c(){e=i("VkPipelineDynamicStateCreateInfo")},l(t){e=f(t,"VkPipelineDynamicStateCreateInfo")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function O8(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function F8(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function y8(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze,nt,Qe,ct,st,We,at,bt,wt,St,tt,ot,At,it,Xe,Dt,Ct,pt,Ft,mt,Vt,Rt,Tt,vt,gt,kt,Mt,yt,Ht,$r,Ut,or,Xt,Ot,Zt,Ar,br,ur,Qt,Or,rr,Kr,lr,gr,Fr,Kt,ir,yr,Re,lt,Jt,_r,Yt,nr,vr,Tr,fr,cr,sr,er,zr;return a=new G({props:{sectionID:L.LOGICAL_DEVICE,$$slots:{default:[E8]},$$scope:{ctx:c}}}),A=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html",target:"_blank",$$slots:{default:[b8]},$$scope:{ctx:c}}}),O=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[w8]},$$scope:{ctx:c}}}),W=new G({props:{sectionID:L.PIPELINE_LAYOUT_PUSH_CONSTANT,$$slots:{default:[I8]},$$scope:{ctx:c}}}),J=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html",target:"_blank",$$slots:{default:[D8]},$$scope:{ctx:c}}}),oe=new Bt({props:{reference:"VkPipelineInputAssemblyStateCreateInfo",version:1.3,$$slots:{default:[C8]},$$scope:{ctx:c}}}),ze=new Bt({props:{reference:"VkPipelineVertexInputStateCreateInfo",version:1.3,$$slots:{default:[S8]},$$scope:{ctx:c}}}),Me=new Bt({props:{reference:"VkPipelineTessellationStateCreateInfo",version:1.3,$$slots:{default:[P8]},$$scope:{ctx:c}}}),Ze=new Bt({props:{reference:"VkPipelineViewportStateCreateInfo",version:1.3,$$slots:{default:[A8]},$$scope:{ctx:c}}}),wt=new Bt({props:{reference:"VkPipelineRasterizationStateCreateInfo",version:1.3,$$slots:{default:[R8]},$$scope:{ctx:c}}}),Ct=new Bt({props:{reference:"VkPipelineMultisampleStateCreateInfo",version:1.3,$$slots:{default:[B8]},$$scope:{ctx:c}}}),gt=new Bt({props:{reference:"VkPipelineDepthStencilStateCreateInfo",version:1.3,$$slots:{default:[L8]},$$scope:{ctx:c}}}),Xt=new Bt({props:{reference:"VkPipelineColorBlendStateCreateInfo",version:1.3,$$slots:{default:[k8]},$$scope:{ctx:c}}}),Zt=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[T8]},$$scope:{ctx:c}}}),lr=new Bt({props:{reference:"VkPipelineDynamicStateCreateInfo",version:1.3,$$slots:{default:[V8]},$$scope:{ctx:c}}}),Jt=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[O8]},$$scope:{ctx:c}}}),sr=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[F8]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pLogicalDevice"),n=d("br"),s=i(`
            A pointer to the `),I(a.$$.fragment),u=i(" the Pipeline should be associated with."),p=Y(),m=d("li"),_=d("code"),v=i("flags"),P=d("br"),R=i(`
            A bitmask of `),I(A.$$.fragment),T=i(" controlling how the pipeline is created."),F=Y(),B=d("li"),y=d("code"),V=i("shaderStages"),x=d("br"),M=i(`
            A list of `),I(O.$$.fragment),H=i("-structures each of which defining a shader stage of the pipeline."),k=Y(),N=d("li"),Q=d("code"),X=i("pushConstants"),Z=d("br"),K=i(`
            A list of `),I(W.$$.fragment),q=i(" to be bound to the pipeline."),U=Y(),te=d("li"),ee=d("code"),se=i("pipelineCache"),ie=d("br"),ae=i(`
            A handle to a `),I(J.$$.fragment),pe=i(" object."),Se=d("br"),de=i(`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),me=Y(),De=d("li"),_e=d("code"),ne=i("pBasePipeline"),le=d("br"),ge=i(`
            A pointer to the pipeline to derive from.`),we=d("br"),Pe=i(`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Be=Y(),Ie=d("li"),re=d("code"),he=i("pInputAssemblyState"),Le=d("br"),Oe=i(`
            A pointer to a `),I(oe.$$.fragment),ce=i(`-structure describing the input assembly state. The input assembly
            stage reads the index and vertex buffers that contain information
            about the vertices making up the draw sent in the draw command.`),Ae=Y(),ye=d("li"),Fe=d("code"),Ve=i("pVertexInputState"),Ge=d("br"),He=i(`
            A pointer to a `),I(ze.$$.fragment),xe=i(`-structure describing the vertex input state. The vertex input
            stage inputs vertex-data into the vertex shader.`),Ne=Y(),Te=d("li"),qe=d("code"),Ke=i("pTessellationState"),je=d("br"),rt=i(`
            A pointer to a `),I(Me.$$.fragment),Ue=i(`-structure describing the tessellation state. The Tessellation
            control shader is responsible for producing tessellation factors and
            other pre-patch data. that is used by the fixed-function
            tessellation engine. The tessellation evaluation shader runs on each
            new vertex produced by the tessellation primitive generator. It
            operates similarly to a vertex shader except that incoming vertices
            are generated rather than read from memory.`),$t=Y(),ut=d("li"),ht=d("code"),Je=i("viewportState"),dt=d("br"),et=i(`
            A list of `),I(Ze.$$.fragment),nt=i(`-structures each of which describing a viewport state.
            Viewport-transformation is the last co\xF6rdinate transformation in the
            Graphics Pipeline before rasterization. It transforms the normalized
            device-co\xF6rdinates to window-co\xF6rdinates.`),Qe=Y(),ct=d("li"),st=d("code"),We=i("pRasterizationState"),at=d("br"),bt=i(`
            A pointer to a `),I(wt.$$.fragment),St=i(`-structure describing the rasterization state. Rasterization is the
            fundamental core of all graphics in Vulkan. The rasterizer takes
            assembled primitives that are still represented by a sequence of
            vertices and turns them into individual fratments, which may become
            pixels that make up the output image.`),tt=Y(),ot=d("li"),At=d("code"),it=i("pMultisampleState"),Xe=d("br"),Dt=i(`
            A pointer to a `),I(Ct.$$.fragment),pt=i(`-structure describing the multisample state. Multisampling is the
            process of generating multiple samples for each pixel in an image.
            It is used to counteract aliasing and can significantly improve
            image quality when used effectively.`),Ft=Y(),mt=d("li"),Vt=d("code"),Rt=i("pDepthStencilState"),Tt=d("br"),vt=i(`
            A pointer to a `),I(gt.$$.fragment),kt=i(`-structure describing the depth- stencil state. The depth stencil
            state determines how the depth and stencil tests are performed and
            what happens to a snippet if it passes or fails one of these tests.
            The depth and stencil tests can be performed before or after the
            fragment shader has been run. By default, the tests take place after
            the fragment shader.`),Mt=Y(),yt=d("li"),Ht=d("code"),$r=i("pColorBlendState"),Ut=d("br"),or=i(`
            A pointer to a `),I(Xt.$$.fragment),Ot=i(`-structure describing the color blend state. The color operations
            take the final results of the fragment shader and postfragment
            operations and use them to update the `),I(Zt.$$.fragment),Ar=i(`. The color operations include blending and logic operations. This
            stage is responsible for writing fragments in the color attachments.`),br=Y(),ur=d("li"),Qt=d("code"),Or=i("pDynamicState"),rr=d("br"),Kr=i(`
            A pointer to a `),I(lr.$$.fragment),gr=i(`-structure describing the dynamic state. To make fine-grained state
            changes more manageable, Vulkan provides the ability to mark certain
            parts of the graphics pipeline as dynamic, meaning they can be
            updated directly using commands directly in the command buffer
            rather than using an object. Since this reduces the chance for
            Vulkan to optimize or absorb parts of the state, it is necessary to
            specify exactly which state to make dynamically.`),Fr=Y(),Kt=d("li"),ir=d("code"),yr=i("pRenderPass"),Re=d("br"),lt=i(`
            A pointer to a `),I(Jt.$$.fragment),_r=i(" that describes the environment in which the pipeline will be used."),Yt=Y(),nr=d("li"),vr=d("code"),Tr=i("subpass"),fr=d("br"),cr=i(`
            The index of the subpass in the `),I(sr.$$.fragment),er=i(" where this pipeline will be used."),this.h()},l(_t){e=g(_t,"DIV",{slot:!0});var ft=E(e);t=g(ft,"LI",{});var qt=E(t);r=g(qt,"CODE",{});var Mr=E(r);$=f(Mr,"pLogicalDevice"),Mr.forEach(l),n=g(qt,"BR",{}),s=f(qt,`
            A pointer to the `),S(a.$$.fragment,qt),u=f(qt," the Pipeline should be associated with."),qt.forEach(l),p=j(ft),m=g(ft,"LI",{});var wr=E(m);_=g(wr,"CODE",{});var Nt=E(_);v=f(Nt,"flags"),Nt.forEach(l),P=g(wr,"BR",{}),R=f(wr,`
            A bitmask of `),S(A.$$.fragment,wr),T=f(wr," controlling how the pipeline is created."),wr.forEach(l),F=j(ft),B=g(ft,"LI",{});var Wt=E(B);y=g(Wt,"CODE",{});var xr=E(y);V=f(xr,"shaderStages"),xr.forEach(l),x=g(Wt,"BR",{}),M=f(Wt,`
            A list of `),S(O.$$.fragment,Wt),H=f(Wt,"-structures each of which defining a shader stage of the pipeline."),Wt.forEach(l),k=j(ft),N=g(ft,"LI",{});var pr=E(N);Q=g(pr,"CODE",{});var Vr=E(Q);X=f(Vr,"pushConstants"),Vr.forEach(l),Z=g(pr,"BR",{}),K=f(pr,`
            A list of `),S(W.$$.fragment,pr),q=f(pr," to be bound to the pipeline."),pr.forEach(l),U=j(ft),te=g(ft,"LI",{});var jt=E(te);ee=g(jt,"CODE",{});var Rr=E(ee);se=f(Rr,"pipelineCache"),Rr.forEach(l),ie=g(jt,"BR",{}),ae=f(jt,`
            A handle to a `),S(J.$$.fragment,jt),pe=f(jt," object."),Se=g(jt,"BR",{}),de=f(jt,`
            Allows the result of pipeline construction to be reused between pipelines
            and between runs of an application. Reuse between pipelines is achieved
            by passing the same pipeline cache object when creating multiple related
            pipelines. Reuse across runs of an application is achieved by retrieving
            pipeline cache contents in one run of an application, saving the contents,
            and using them to preinitialize a pipeline cache on a subsequent run.`),jt.forEach(l),me=j(ft),De=g(ft,"LI",{});var Ir=E(De);_e=g(Ir,"CODE",{});var Nr=E(_e);ne=f(Nr,"pBasePipeline"),Nr.forEach(l),le=g(Ir,"BR",{}),ge=f(Ir,`
            A pointer to the pipeline to derive from.`),we=g(Ir,"BR",{}),Pe=f(Ir,`
            A pipeline derivative is a child pipeline created from a parent pipeline,
            where the child and parent pipeline are expected to have a lot of commonality.
            The purpose of derived pipelines is that they can be made cheaper with
            the parent in mind, and that it is more efficient (on host or device)
            to switch/bind between.`),Ir.forEach(l),Be=j(ft),Ie=g(ft,"LI",{});var mr=E(Ie);re=g(mr,"CODE",{});var Dr=E(re);he=f(Dr,"pInputAssemblyState"),Dr.forEach(l),Le=g(mr,"BR",{}),Oe=f(mr,`
            A pointer to a `),S(oe.$$.fragment,mr),ce=f(mr,`-structure describing the input assembly state. The input assembly
            stage reads the index and vertex buffers that contain information
            about the vertices making up the draw sent in the draw command.`),mr.forEach(l),Ae=j(ft),ye=g(ft,"LI",{});var hr=E(ye);Fe=g(hr,"CODE",{});var Br=E(Fe);Ve=f(Br,"pVertexInputState"),Br.forEach(l),Ge=g(hr,"BR",{}),He=f(hr,`
            A pointer to a `),S(ze.$$.fragment,hr),xe=f(hr,`-structure describing the vertex input state. The vertex input
            stage inputs vertex-data into the vertex shader.`),hr.forEach(l),Ne=j(ft),Te=g(ft,"LI",{});var Cr=E(Te);qe=g(Cr,"CODE",{});var en=E(qe);Ke=f(en,"pTessellationState"),en.forEach(l),je=g(Cr,"BR",{}),rt=f(Cr,`
            A pointer to a `),S(Me.$$.fragment,Cr),Ue=f(Cr,`-structure describing the tessellation state. The Tessellation
            control shader is responsible for producing tessellation factors and
            other pre-patch data. that is used by the fixed-function
            tessellation engine. The tessellation evaluation shader runs on each
            new vertex produced by the tessellation primitive generator. It
            operates similarly to a vertex shader except that incoming vertices
            are generated rather than read from memory.`),Cr.forEach(l),$t=j(ft),ut=g(ft,"LI",{});var Ur=E(ut);ht=g(Ur,"CODE",{});var tr=E(ht);Je=f(tr,"viewportState"),tr.forEach(l),dt=g(Ur,"BR",{}),et=f(Ur,`
            A list of `),S(Ze.$$.fragment,Ur),nt=f(Ur,`-structures each of which describing a viewport state.
            Viewport-transformation is the last co\xF6rdinate transformation in the
            Graphics Pipeline before rasterization. It transforms the normalized
            device-co\xF6rdinates to window-co\xF6rdinates.`),Ur.forEach(l),Qe=j(ft),ct=g(ft,"LI",{});var Gr=E(ct);st=g(Gr,"CODE",{});var tn=E(st);We=f(tn,"pRasterizationState"),tn.forEach(l),at=g(Gr,"BR",{}),bt=f(Gr,`
            A pointer to a `),S(wt.$$.fragment,Gr),St=f(Gr,`-structure describing the rasterization state. Rasterization is the
            fundamental core of all graphics in Vulkan. The rasterizer takes
            assembled primitives that are still represented by a sequence of
            vertices and turns them into individual fratments, which may become
            pixels that make up the output image.`),Gr.forEach(l),tt=j(ft),ot=g(ft,"LI",{});var jr=E(ot);At=g(jr,"CODE",{});var ln=E(At);it=f(ln,"pMultisampleState"),ln.forEach(l),Xe=g(jr,"BR",{}),Dt=f(jr,`
            A pointer to a `),S(Ct.$$.fragment,jr),pt=f(jr,`-structure describing the multisample state. Multisampling is the
            process of generating multiple samples for each pixel in an image.
            It is used to counteract aliasing and can significantly improve
            image quality when used effectively.`),jr.forEach(l),Ft=j(ft),mt=g(ft,"LI",{});var Er=E(mt);Vt=g(Er,"CODE",{});var fn=E(Vt);Rt=f(fn,"pDepthStencilState"),fn.forEach(l),Tt=g(Er,"BR",{}),vt=f(Er,`
            A pointer to a `),S(gt.$$.fragment,Er),kt=f(Er,`-structure describing the depth- stencil state. The depth stencil
            state determines how the depth and stencil tests are performed and
            what happens to a snippet if it passes or fails one of these tests.
            The depth and stencil tests can be performed before or after the
            fragment shader has been run. By default, the tests take place after
            the fragment shader.`),Er.forEach(l),Mt=j(ft),yt=g(ft,"LI",{});var Lr=E(yt);Ht=g(Lr,"CODE",{});var cn=E(Ht);$r=f(cn,"pColorBlendState"),cn.forEach(l),Ut=g(Lr,"BR",{}),or=f(Lr,`
            A pointer to a `),S(Xt.$$.fragment,Lr),Ot=f(Lr,`-structure describing the color blend state. The color operations
            take the final results of the fragment shader and postfragment
            operations and use them to update the `),S(Zt.$$.fragment,Lr),Ar=f(Lr,`. The color operations include blending and logic operations. This
            stage is responsible for writing fragments in the color attachments.`),Lr.forEach(l),br=j(ft),ur=g(ft,"LI",{});var Yr=E(ur);Qt=g(Yr,"CODE",{});var Lt=E(Qt);Or=f(Lt,"pDynamicState"),Lt.forEach(l),rr=g(Yr,"BR",{}),Kr=f(Yr,`
            A pointer to a `),S(lr.$$.fragment,Yr),gr=f(Yr,`-structure describing the dynamic state. To make fine-grained state
            changes more manageable, Vulkan provides the ability to mark certain
            parts of the graphics pipeline as dynamic, meaning they can be
            updated directly using commands directly in the command buffer
            rather than using an object. Since this reduces the chance for
            Vulkan to optimize or absorb parts of the state, it is necessary to
            specify exactly which state to make dynamically.`),Yr.forEach(l),Fr=j(ft),Kt=g(ft,"LI",{});var It=E(Kt);ir=g(It,"CODE",{});var Hr=E(ir);yr=f(Hr,"pRenderPass"),Hr.forEach(l),Re=g(It,"BR",{}),lt=f(It,`
            A pointer to a `),S(Jt.$$.fragment,It),_r=f(It," that describes the environment in which the pipeline will be used."),It.forEach(l),Yt=j(ft),nr=g(ft,"LI",{});var kr=E(nr);vr=g(kr,"CODE",{});var qr=E(vr);Tr=f(qr,"subpass"),qr.forEach(l),fr=g(kr,"BR",{}),cr=f(kr,`
            The index of the subpass in the `),S(sr.$$.fragment,kr),er=f(kr," where this pipeline will be used."),kr.forEach(l),ft.forEach(l),this.h()},h(){z(e,"slot","params")},m(_t,ft){h(_t,e,ft),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),o(e,F),o(e,B),o(B,y),o(y,V),o(B,x),o(B,M),D(O,B,null),o(B,H),o(e,k),o(e,N),o(N,Q),o(Q,X),o(N,Z),o(N,K),D(W,N,null),o(N,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),D(J,te,null),o(te,pe),o(te,Se),o(te,de),o(e,me),o(e,De),o(De,_e),o(_e,ne),o(De,le),o(De,ge),o(De,we),o(De,Pe),o(e,Be),o(e,Ie),o(Ie,re),o(re,he),o(Ie,Le),o(Ie,Oe),D(oe,Ie,null),o(Ie,ce),o(e,Ae),o(e,ye),o(ye,Fe),o(Fe,Ve),o(ye,Ge),o(ye,He),D(ze,ye,null),o(ye,xe),o(e,Ne),o(e,Te),o(Te,qe),o(qe,Ke),o(Te,je),o(Te,rt),D(Me,Te,null),o(Te,Ue),o(e,$t),o(e,ut),o(ut,ht),o(ht,Je),o(ut,dt),o(ut,et),D(Ze,ut,null),o(ut,nt),o(e,Qe),o(e,ct),o(ct,st),o(st,We),o(ct,at),o(ct,bt),D(wt,ct,null),o(ct,St),o(e,tt),o(e,ot),o(ot,At),o(At,it),o(ot,Xe),o(ot,Dt),D(Ct,ot,null),o(ot,pt),o(e,Ft),o(e,mt),o(mt,Vt),o(Vt,Rt),o(mt,Tt),o(mt,vt),D(gt,mt,null),o(mt,kt),o(e,Mt),o(e,yt),o(yt,Ht),o(Ht,$r),o(yt,Ut),o(yt,or),D(Xt,yt,null),o(yt,Ot),D(Zt,yt,null),o(yt,Ar),o(e,br),o(e,ur),o(ur,Qt),o(Qt,Or),o(ur,rr),o(ur,Kr),D(lr,ur,null),o(ur,gr),o(e,Fr),o(e,Kt),o(Kt,ir),o(ir,yr),o(Kt,Re),o(Kt,lt),D(Jt,Kt,null),o(Kt,_r),o(e,Yt),o(e,nr),o(nr,vr),o(vr,Tr),o(nr,fr),o(nr,cr),D(sr,nr,null),o(nr,er),zr=!0},p(_t,ft){const qt={};ft&1&&(qt.$$scope={dirty:ft,ctx:_t}),a.$set(qt);const Mr={};ft&1&&(Mr.$$scope={dirty:ft,ctx:_t}),A.$set(Mr);const wr={};ft&1&&(wr.$$scope={dirty:ft,ctx:_t}),O.$set(wr);const Nt={};ft&1&&(Nt.$$scope={dirty:ft,ctx:_t}),W.$set(Nt);const Wt={};ft&1&&(Wt.$$scope={dirty:ft,ctx:_t}),J.$set(Wt);const xr={};ft&1&&(xr.$$scope={dirty:ft,ctx:_t}),oe.$set(xr);const pr={};ft&1&&(pr.$$scope={dirty:ft,ctx:_t}),ze.$set(pr);const Vr={};ft&1&&(Vr.$$scope={dirty:ft,ctx:_t}),Me.$set(Vr);const jt={};ft&1&&(jt.$$scope={dirty:ft,ctx:_t}),Ze.$set(jt);const Rr={};ft&1&&(Rr.$$scope={dirty:ft,ctx:_t}),wt.$set(Rr);const Ir={};ft&1&&(Ir.$$scope={dirty:ft,ctx:_t}),Ct.$set(Ir);const Nr={};ft&1&&(Nr.$$scope={dirty:ft,ctx:_t}),gt.$set(Nr);const mr={};ft&1&&(mr.$$scope={dirty:ft,ctx:_t}),Xt.$set(mr);const Dr={};ft&1&&(Dr.$$scope={dirty:ft,ctx:_t}),Zt.$set(Dr);const hr={};ft&1&&(hr.$$scope={dirty:ft,ctx:_t}),lr.$set(hr);const Br={};ft&1&&(Br.$$scope={dirty:ft,ctx:_t}),Jt.$set(Br);const Cr={};ft&1&&(Cr.$$scope={dirty:ft,ctx:_t}),sr.$set(Cr)},i(_t){zr||(b(a.$$.fragment,_t),b(A.$$.fragment,_t),b(O.$$.fragment,_t),b(W.$$.fragment,_t),b(J.$$.fragment,_t),b(oe.$$.fragment,_t),b(ze.$$.fragment,_t),b(Me.$$.fragment,_t),b(Ze.$$.fragment,_t),b(wt.$$.fragment,_t),b(Ct.$$.fragment,_t),b(gt.$$.fragment,_t),b(Xt.$$.fragment,_t),b(Zt.$$.fragment,_t),b(lr.$$.fragment,_t),b(Jt.$$.fragment,_t),b(sr.$$.fragment,_t),zr=!0)},o(_t){w(a.$$.fragment,_t),w(A.$$.fragment,_t),w(O.$$.fragment,_t),w(W.$$.fragment,_t),w(J.$$.fragment,_t),w(oe.$$.fragment,_t),w(ze.$$.fragment,_t),w(Me.$$.fragment,_t),w(Ze.$$.fragment,_t),w(wt.$$.fragment,_t),w(Ct.$$.fragment,_t),w(gt.$$.fragment,_t),w(Xt.$$.fragment,_t),w(Zt.$$.fragment,_t),w(lr.$$.fragment,_t),w(Jt.$$.fragment,_t),w(sr.$$.fragment,_t),zr=!1},d(_t){_t&&l(e),C(a),C(A),C(O),C(W),C(J),C(oe),C(ze),C(Me),C(Ze),C(wt),C(Ct),C(gt),C(Xt),C(Zt),C(lr),C(Jt),C(sr)}}}function M8(c){let e;return{c(){e=i("Vulkan Pipeline Layout")},l(t){e=f(t,"Vulkan Pipeline Layout")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function x8(c){let e;return{c(){e=i("Vulkan Compute Pipeline")},l(t){e=f(t,"Vulkan Compute Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function N8(c){let e,t,r,$,n,s,a,u,p,m,_;return n=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html",target:"_blank",$$slots:{default:[M8]},$$scope:{ctx:c}}}),p=new fe({props:{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html",target:"_blank",$$slots:{default:[x8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),a=d("br"),u=i(`
        Also throws std::runtime_error if the `),I(p.$$.fragment),m=i(" couldn't be created."),this.h()},l(v){e=g(v,"SPAN",{slot:!0});var P=E(e);t=g(P,"CODE",{});var R=E(t);r=f(R,"std::runtime_error"),R.forEach(l),$=f(P," if the "),S(n.$$.fragment,P),s=f(P," couldn't be created."),a=g(P,"BR",{}),u=f(P,`
        Also throws std::runtime_error if the `),S(p.$$.fragment,P),m=f(P," couldn't be created."),P.forEach(l),this.h()},h(){z(e,"slot","throws")},m(v,P){h(v,e,P),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),o(e,a),o(e,u),D(p,e,null),o(e,m),_=!0},p(v,P){const R={};P&1&&(R.$$scope={dirty:P,ctx:v}),n.$set(R);const A={};P&1&&(A.$$scope={dirty:P,ctx:v}),p.$set(A)},i(v){_||(b(n.$$.fragment,v),b(p.$$.fragment,v),_=!0)},o(v){w(n.$$.fragment,v),w(p.$$.fragment,v),_=!1},d(v){v&&l(e),C(n),C(p)}}}function U8(c){let e,t,r,$;return e=new $e({props:{language:ue,code:`GraphicsPipeline(
    LogicalDevice* pLogicalDevice, 
    VkPipelineCreateFlags flags, 
    std::vector<PipelineShaderStage> shaderStages,
    std::vector<PushConstant> pushConstants, 
    VkPipelineCache pipelineCache, 
    Pipeline* pBasePipeline,
    VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState, 
    VkPipelineVertexInputStateCreateInfo* pVertexInputState,
    VkPipelineTessellationStateCreateInfo* pTessellationState, 
    std::vector<VkPipelineViewportStateCreateInfo>& viewportState,
    VkPipelineRasterizationStateCreateInfo* pRasterizationState, 
    VkPipelineMultisampleStateCreateInfo* pMultisampleState,
    VkPipelineDepthStencilStateCreateInfo* pDepthStencilState, 
    VkPipelineColorBlendStateCreateInfo* pColorBlendState,
    VkPipelineDynamicStateCreateInfo* pDynamicState, 
    RenderPass* pRenderPass, 
    unsigned int subpass
);`}}),r=new Ce({props:{$$slots:{throws:[N8],params:[y8],details:[v8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class G8 extends ve{constructor(e){super(),Ee(this,e,null,U8,be,{})}}function H8(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function q8(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[H8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the "),I(r.$$.fragment),$=i(" that describes the environment in which this pipeline is used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the "),S(r.$$.fragment,a),$=f(a," that describes the environment in which this pipeline is used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function W8(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Q8(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[W8]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("The "),I(r.$$.fragment),$=i(`
        with which this pipeline associates.`),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"The "),S(r.$$.fragment,a),$=f(a,`
        with which this pipeline associates.`),a.forEach(l),this.h()},h(){z(e,"slot","return")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function K8(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"RenderPass* getRenderPass();"}}),r=new Ce({props:{$$slots:{return:[Q8],details:[q8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class z8 extends ve{constructor(e){super(),Ee(this,e,null,K8,be,{})}}function Y8(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return e=new $e({props:{language:ue,code:"#include <fillcan/graphics/graphics_pipeline_builder.hpp>"}}),P=new $e({props:{language:ue,code:`std::vector<PipelineShaderStage> shaderStages = {};
std::unique_ptr<PipelineVertexInputState> upVertexInputState = nullptr;
std::unique_ptr<PipelineInputAssemblyState> upInputAssemblyState = nullptr;
std::unique_ptr<PipelineTessellationState> upTessellationState = nullptr;
std::vector<std::unique_ptr<PipelineViewPortState>> upViewPortStates = {};
std::unique_ptr<PipelineRasterizationState> upRasterizationState = nullptr;
std::unique_ptr<PipelineMultisampleState> upMultisampleState = nullptr;
std::unique_ptr<PipelineDepthStencilState> upDepthStencilState = nullptr;
std::unique_ptr<PipelineColorBlendState> upColorBlendState = nullptr;
std::unique_ptr<PipelineDynamicState> upDynamicState = nullptr;
RenderPass* pRenderPass = nullptr;
unsigned int subpass = 0;`}}),T=new $e({props:{language:ue,code:`fillcan::GraphicsPipelineBuilder graphicsPipelineBuilder{};
graphicsPipelineBuilder.setLogicalDevice(fillcan.getCurrentDevice());
graphicsPipelineBuilder.addShaderStage(
    {
        .stage = VK_SHADER_STAGE_VERTEX_BIT, 
        .pShaderModule = pVertexShaderModule, 
        .name = "main"
    }
);
graphicsPipelineBuilder.addShaderStage({.stage = VK_SHADER_STAGE_FRAGMENT_BIT, .pShaderModule = pFragmentShaderModule, .name = "main"});

graphicsPipelineBuilder.addPushConstant(
    "SimplePushConstant",
    {
        .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 
        .offset = 0, 
        .size = sizeof(SimplePushConstantData)
    }
);

graphicsPipelineBuilder.setInputAssemblyState({.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = VK_FALSE});

// Describe the vertex shader
graphicsPipelineBuilder.setVertexInputState(
    {
        fillcan::Model::Vertex::getBindingDescriptions(),
        {
            fillcan::Model::Vertex::getPositionAttributeDescription(0), 
            fillcan::Model::Vertex::getColorAttributeDescription(1)
        }
    }
);

// The viewports and scissors are dynamic, but the amount of viewports and scissors should still be defined
std::vector<VkViewport> viewports = {};
viewports.resize(1);
std::vector<VkRect2D> scissors = {};
scissors.resize(1);
graphicsPipelineBuilder.addViewportState({viewports, scissors});

graphicsPipelineBuilder.setRasterizationState(
    {
        .depthClampEnable = VK_FALSE,
        .rasterizerDiscardEnable = VK_FALSE,
        .polygonMode = VK_POLYGON_MODE_FILL,
        .cullmode = VK_CULL_MODE_NONE,
        .frontFace = VK_FRONT_FACE_CLOCKWISE,
        .depthBiasEnable = VK_FALSE,
        .depthBiasConstantFactor = 0.0f,
        .depthBiasClamp = 0.0f,
        .depthBiasSlopeFactor = 0.0f,
        .lineWidth = 1.0f
    }
);

graphicsPipelineBuilder.setMultisampleState(
    {
        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
        .sampleShadingEnable = VK_FALSE,
        .minSampleShading = 1.0f,
        .sampleMask = {},
        .alphaToCoverageEnable = VK_FALSE,
        .alphaToOneEnable = VK_FALSE
    }
);

// Enable z-testing
graphicsPipelineBuilder.setDepthStencilState(
    {
        .depthTestEnable = VK_TRUE,
        .depthWriteEnable = VK_TRUE,
        .depthCompareOp = VK_COMPARE_OP_LESS,
        .depthBoundsTestEnable = VK_FALSE,
        .stencilTestEnable = VK_FALSE,
        .front = {},
        .back = {},
        .minDepthBounds = 0.0f,
        .maxDepthBounds = 1.0f
    }
);

VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
colorBlendAttachment.blendEnable = VK_FALSE;
colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
colorBlendAttachment.colorWriteMask =
    VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
std::vector<VkPipelineColorBlendAttachmentState> colorBlendAttachments = {colorBlendAttachment};
graphicsPipelineBuilder.setColorBlendState(
    {
        .logicOpEnable = VK_FALSE,
        .logicOp = VK_LOGIC_OP_COPY,
        .attachments = colorBlendAttachments,
        .blendConstants = std::array<float, 4>{0.0f, 0.0f, 0.0f, 0.0f}
    }
);

// Set the viewports and scissors to dynamic to allow for window resizing
std::vector<VkDynamicState> dynamicStates = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
graphicsPipelineBuilder.setDynamicState({.dynamicStates = dynamicStates});
graphicsPipelineBuilder.setRenderPass(this->upRenderPass.get());

std::unique_ptr<fillcan::GraphicsPipeline> upGraphicsPipeline = graphicsPipelineBuilder.getResult();`}}),{c(){I(e.$$.fragment),t=i(`
The `),r=d("code"),$=i("Graphics Pipeline Builder"),n=i(` class extends the
`),s=d("code"),a=i("Pipeline Builder"),u=i(`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=d("br"),m=i(`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=d("br"),v=i(`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),I(P.$$.fragment),R=d("br"),A=i(`
Example:
`),I(T.$$.fragment)},l(B){S(e.$$.fragment,B),t=f(B,`
The `),r=g(B,"CODE",{});var y=E(r);$=f(y,"Graphics Pipeline Builder"),y.forEach(l),n=f(B,` class extends the
`),s=g(B,"CODE",{});var V=E(s);a=f(V,"Pipeline Builder"),V.forEach(l),u=f(B,`
class and is part of the creational design pattern to construct complex objects step
by step.`),p=g(B,"BR",{}),m=f(B,`
The Builder pattern allows you to produce different types and representations of
an object using the same construction code.`),_=g(B,"BR",{}),v=f(B,`
The builder has the following default values, these can be overridden by calling
their respective methods:
`),S(P.$$.fragment,B),R=g(B,"BR",{}),A=f(B,`
Example:
`),S(T.$$.fragment,B)},m(B,y){D(e,B,y),h(B,t,y),h(B,r,y),o(r,$),h(B,n,y),h(B,s,y),o(s,a),h(B,u,y),h(B,p,y),h(B,m,y),h(B,_,y),h(B,v,y),D(P,B,y),h(B,R,y),h(B,A,y),D(T,B,y),F=!0},p:ke,i(B){F||(b(e.$$.fragment,B),b(P.$$.fragment,B),b(T.$$.fragment,B),F=!0)},o(B){w(e.$$.fragment,B),w(P.$$.fragment,B),w(T.$$.fragment,B),F=!1},d(B){C(e,B),B&&l(t),B&&l(r),B&&l(n),B&&l(s),B&&l(u),B&&l(p),B&&l(m),B&&l(_),B&&l(v),C(P,B),B&&l(R),B&&l(A),C(T,B)}}}class j8 extends ve{constructor(e){super(),Ee(this,e,null,Y8,be,{})}}function X8(c){let e,t;return{c(){e=d("span"),t=i("Create a new Graphics Pipeline Builder."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Create a new Graphics Pipeline Builder."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Z8(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"GraphicsPipelineBuilder();"}}),r=new Ce({props:{$$slots:{details:[X8]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class J8 extends ve{constructor(e){super(),Ee(this,e,null,Z8,be,{})}}function eK(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function tK(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[eK]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Add a "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Add a "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function rK(c){let e;return{c(){e=i("pipeline shader stage")},l(t){e=f(t,"pipeline shader stage")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nK(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.PIPELINE_PIPELINE_SHADER_STAGE,$$slots:{default:[rK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pipelineShaderStage"),n=d("br"),s=i(`
            The `),I(a.$$.fragment),u=i(" to add."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"pipelineShaderStage"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The `),S(a.$$.fragment,v),u=f(v," to add."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function sK(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setShaderStage(PipelineShaderStage pipelineShaderStage);"}}),r=new Ce({props:{$$slots:{params:[nK],details:[tK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class aK extends ve{constructor(e){super(),Ee(this,e,null,sK,be,{})}}function oK(c){let e,t;return{c(){e=d("span"),t=i("Set the Input Assembly State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Input Assembly State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function lK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("inputAssemblyState"),n=d("br"),s=i(`
            The input assembly state, this is a `),a=d("code"),u=i("PipelineInputAssemblyState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"inputAssemblyState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The input assembly state, this is a `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineInputAssemblyState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function iK(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the input assembly state."),r=d("br"),$=i(`
        The input assembly stage reads the index and vertex buffers that contain
        information about the vertices making up the draw sent in the draw command.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the input assembly state."),r=g(s,"BR",{}),$=f(s,`
        The input assembly stage reads the index and vertex buffers that contain
        information about the vertices making up the draw sent in the draw command.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function fK(c){let e;return{c(){e=i("VkPrimitiveTopology")},l(t){e=f(t,"VkPrimitiveTopology")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function cK(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A;return a=new Bt({props:{reference:"VkPrimitiveTopology",version:1.3,$$slots:{default:[fK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("topology"),n=d("br"),s=i(`
            The primitive topology. This is a member of the `),I(a.$$.fragment),u=i("-enumeration."),p=Y(),m=d("li"),_=d("code"),v=i("primitiveRestartEnable"),P=d("br"),R=i(`
            Used to restart primitive topologies of type "strip" and "fan". Requires
            an indexed draw.`),this.h()},l(T){e=g(T,"DIV",{slot:!0});var F=E(e);t=g(F,"LI",{});var B=E(t);r=g(B,"CODE",{});var y=E(r);$=f(y,"topology"),y.forEach(l),n=g(B,"BR",{}),s=f(B,`
            The primitive topology. This is a member of the `),S(a.$$.fragment,B),u=f(B,"-enumeration."),B.forEach(l),p=j(F),m=g(F,"LI",{});var V=E(m);_=g(V,"CODE",{});var x=E(_);v=f(x,"primitiveRestartEnable"),x.forEach(l),P=g(V,"BR",{}),R=f(V,`
            Used to restart primitive topologies of type "strip" and "fan". Requires
            an indexed draw.`),V.forEach(l),F.forEach(l),this.h()},h(){z(e,"slot","params")},m(T,F){h(T,e,F),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),A=!0},p(T,F){const B={};F&1&&(B.$$scope={dirty:F,ctx:T}),a.$set(B)},i(T){A||(b(a.$$.fragment,T),A=!0)},o(T){w(a.$$.fragment,T),A=!1},d(T){T&&l(e),C(a)}}}function $K(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setInputAssemblyState(PipelineInputAssemblyState inputAssemblyState);"}}),r=new Ce({props:{$$slots:{params:[lK],details:[oK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineInputAssemblyState {
    VkPrimitiveTopology topology;
    VkBool32 primitiveRestartEnable;
};`}}),u=new Ce({props:{$$slots:{params:[cK],details:[iK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class uK extends ve{constructor(e){super(),Ee(this,e,null,$K,be,{})}}function pK(c){let e,t;return{c(){e=d("span"),t=i("Set the Vertex Input State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Vertex Input State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function mK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("vertexInputState"),n=d("br"),s=i(`
            The vertex input state, this is a
            `),a=d("code"),u=i("PipelineVertexInputState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"vertexInputState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The vertex input state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineVertexInputState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function hK(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the vertex input state."),r=d("br"),$=i(`
        The vertex input stage inputs vertex-data into the vertex shader.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the vertex input state."),r=g(s,"BR",{}),$=f(s,`
        The vertex input stage inputs vertex-data into the vertex shader.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function dK(c){let e;return{c(){e=i("VkVertexInputBindingDescription")},l(t){e=f(t,"VkVertexInputBindingDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function gK(c){let e;return{c(){e=i("VkVertexInputAttributeDescription")},l(t){e=f(t,"VkVertexInputAttributeDescription")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function _K(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new Bt({props:{reference:"VkVertexInputBindingDescription",version:1.3,$$slots:{default:[dK]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkVertexInputAttributeDescription",version:1.3,$$slots:{default:[gK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("vertexInputBindingDescriptions"),n=d("br"),s=i(`
            Descriptions of the vertex-bindings. This is a list of `),I(a.$$.fragment),u=i("-structures."),p=Y(),m=d("li"),_=d("code"),v=i("vertexInputAttributeDescriptions"),P=d("br"),R=i(`
            Descriptions of the vertex-attributes. This is a list of `),I(A.$$.fragment),T=i("-structures."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"vertexInputBindingDescriptions"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            Descriptions of the vertex-bindings. This is a list of `),S(a.$$.fragment,V),u=f(V,"-structures."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"vertexInputAttributeDescriptions"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            Descriptions of the vertex-attributes. This is a list of `),S(A.$$.fragment,M),T=f(M,"-structures."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function vK(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"bool setVertexInputState(PipelineVertexInputState vertexInputState);"}}),r=new Ce({props:{$$slots:{params:[mK],details:[pK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineVertexInputState {
    std::vector<VkVertexInputBindingDescription> vertexInputBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription> vertexInputAttributeDescriptions;
};`}}),u=new Ce({props:{$$slots:{params:[_K],details:[hK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class EK extends ve{constructor(e){super(),Ee(this,e,null,vK,be,{})}}function bK(c){let e,t;return{c(){e=d("span"),t=i("Set the Tessellation State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Tessellation State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function wK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("tessellationState"),n=d("br"),s=i(`
            The tessellation state, this is a
            `),a=d("code"),u=i("PipelineTessellationState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"tessellationState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The tessellation state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineTessellationState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function IK(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the tessellation control and evaluation stage."),r=d("br"),$=i(`
        The Tessellation control shader is responsible for producing tessellation
        factors and other pre-patch data. that is used by the fixed-function tessellation
        engine. The tessellation evaluation shader runs on each new vertex produced
        by the tessellation primitive generator. It operates similarly to a vertex
        shader except that incoming vertices are generated rather than read from
        memory.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the tessellation control and evaluation stage."),r=g(s,"BR",{}),$=f(s,`
        The Tessellation control shader is responsible for producing tessellation
        factors and other pre-patch data. that is used by the fixed-function tessellation
        engine. The tessellation evaluation shader runs on each new vertex produced
        by the tessellation primitive generator. It operates similarly to a vertex
        shader except that incoming vertices are generated rather than read from
        memory.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function DK(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("patchControlPoints"),n=d("br"),s=i(`
            The amount of controlpoints that will be grouped in a single primitive.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"patchControlPoints"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            The amount of controlpoints that will be grouped in a single primitive.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function CK(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"bool setVertexInputState(PipelineVertexInputState vertexInputState);"}}),r=new Ce({props:{$$slots:{params:[wK],details:[bK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineTessellationState {
    unsigned int patchControlPoints;
};`}}),u=new Ce({props:{$$slots:{params:[DK],details:[IK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class SK extends ve{constructor(e){super(),Ee(this,e,null,CK,be,{})}}function PK(c){let e,t;return{c(){e=d("span"),t=i("Add a Viewport State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Add a Viewport State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function AK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewportState"),n=d("br"),s=i(`
            The viewport state, this is a
            `),a=d("code"),u=i("PipelineViewPortState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"viewportState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The viewport state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineViewPortState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function RK(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function BK(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[RK]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A description of a viewport state."),r=d("br"),$=i(`
        Viewport-transformation is the last co\xF6rdinate transformation in the `),I(n.$$.fragment),s=i(` before rasterization. It transforms the normalized device-co\xF6rdinates to
        window-co\xF6rdinates.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A description of a viewport state."),r=g(p,"BR",{}),$=f(p,`
        Viewport-transformation is the last co\xF6rdinate transformation in the `),S(n.$$.fragment,p),s=f(p,` before rasterization. It transforms the normalized device-co\xF6rdinates to
        window-co\xF6rdinates.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function LK(c){let e;return{c(){e=i("VkViewport")},l(t){e=f(t,"VkViewport")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kK(c){let e;return{c(){e=i("VkRect2D")},l(t){e=f(t,"VkRect2D")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function TK(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F;return a=new Bt({props:{reference:"VkViewport",version:1.3,$$slots:{default:[LK]},$$scope:{ctx:c}}}),A=new Bt({props:{reference:"VkRect2D",version:1.3,$$slots:{default:[kK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("viewports"),n=d("br"),s=i(`
            The dimensions of each viewport. This is a `),I(a.$$.fragment),u=i("-structure."),p=Y(),m=d("li"),_=d("code"),v=i("scissors"),P=d("br"),R=i(`
            The scissor rectangles of each viewport. This is a `),I(A.$$.fragment),T=i("-structure."),this.h()},l(B){e=g(B,"DIV",{slot:!0});var y=E(e);t=g(y,"LI",{});var V=E(t);r=g(V,"CODE",{});var x=E(r);$=f(x,"viewports"),x.forEach(l),n=g(V,"BR",{}),s=f(V,`
            The dimensions of each viewport. This is a `),S(a.$$.fragment,V),u=f(V,"-structure."),V.forEach(l),p=j(y),m=g(y,"LI",{});var M=E(m);_=g(M,"CODE",{});var O=E(_);v=f(O,"scissors"),O.forEach(l),P=g(M,"BR",{}),R=f(M,`
            The scissor rectangles of each viewport. This is a `),S(A.$$.fragment,M),T=f(M,"-structure."),M.forEach(l),y.forEach(l),this.h()},h(){z(e,"slot","params")},m(B,y){h(B,e,y),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),D(A,m,null),o(m,T),F=!0},p(B,y){const V={};y&1&&(V.$$scope={dirty:y,ctx:B}),a.$set(V);const x={};y&1&&(x.$$scope={dirty:y,ctx:B}),A.$set(x)},i(B){F||(b(a.$$.fragment,B),b(A.$$.fragment,B),F=!0)},o(B){w(a.$$.fragment,B),w(A.$$.fragment,B),F=!1},d(B){B&&l(e),C(a),C(A)}}}function VK(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void addViewportState(PipelineViewPortState viewportState);"}}),r=new Ce({props:{$$slots:{params:[AK],details:[PK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineViewPortState {
    std::vector<VkViewport> viewports;
    std::vector<VkRect2D> scissors;
};`}}),u=new Ce({props:{$$slots:{params:[TK],details:[BK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class OK extends ve{constructor(e){super(),Ee(this,e,null,VK,be,{})}}function FK(c){let e,t;return{c(){e=d("span"),t=i("Set the Rasterization State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Rasterization State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function yK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("rasterizationState"),n=d("br"),s=i(`
            The rasterization state, this is a
            `),a=d("code"),u=i("PipelineRasterizationState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"rasterizationState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The rasterization state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineRasterizationState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function MK(c){let e,t;return{c(){e=d("span"),t=d("br"),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=g($,"BR",{}),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function xK(c){let e;return{c(){e=i("VkPolygonMode")},l(t){e=f(t,"VkPolygonMode")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function NK(c){let e;return{c(){e=i("VkCullModeFlagBits")},l(t){e=f(t,"VkCullModeFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function UK(c){let e;return{c(){e=i("VkFrontFace")},l(t){e=f(t,"VkFrontFace")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function GK(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe,Ke,je,rt,Me,Ue,$t,ut,ht,Je,dt,et,Ze;return M=new Bt({props:{reference:"VkPolygonMode",version:1.3,$$slots:{default:[xK]},$$scope:{ctx:c}}}),K=new Bt({props:{reference:"VkCullModeFlagBits",version:1.3,$$slots:{default:[NK]},$$scope:{ctx:c}}}),ae=new Bt({props:{reference:"VkFrontFace",version:1.3,$$slots:{default:[UK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthClampEnable"),n=d("br"),s=i(`
            Used to enable or disable depth clamping. This means that fragments that
            are outside the near and far planes are clamped instead of thrown out.
            This requires the
            `),a=d("code"),u=i("VkPipelineRasterizationDepthClipStateCreateInfoEXT"),p=i(`
            extension.`),m=Y(),_=d("li"),v=d("code"),P=i("rasterizerDiscardEnable"),R=d("br"),A=i(`
            Used to disable rasterization altogether. When this flag is set, the
            rasterizer will not run and no fragments will be produced.`),T=Y(),F=d("li"),B=d("code"),y=i("polygonMode"),V=d("br"),x=i(`
            Can be used to have Vulkan automatically turn triangles into points or
            lines. This a member of the `),I(M.$$.fragment),O=i("-enumeration."),H=Y(),k=d("li"),N=d("code"),Q=i("cullmode"),X=d("br"),Z=i(`
            Controls what parts of the input will be discarded. This is a bitmask
            of `),I(K.$$.fragment),W=i("."),q=Y(),U=d("li"),te=d("code"),ee=i("frontFace"),se=d("br"),ie=i(`
            Which direction a triangle faces is determined by the winding order of
            its vertice - whether they go clockwise or counterclockwise in the window
            space. This is a member of the `),I(ae.$$.fragment),J=i("-enumerant."),pe=Y(),Se=d("li"),de=d("code"),me=i("depthBiasEnable"),De=d("br"),_e=i(`
            This feature allows fragments to be depth compensated for before the
            depth test. This can be used to avoid depth fights.`),ne=Y(),le=d("li"),ge=d("code"),we=i("depthBiasConstantFactor"),Pe=d("br"),Be=i(`
            A scalar factor that determines the constant depth value added to each
            clip.`),Ie=Y(),re=d("li"),he=d("code"),Le=i("depthBiasClamp"),Oe=d("br"),oe=i(`
            The maximum (or minimum) depth bias of a fragment.`),ce=Y(),Ae=d("li"),ye=d("code"),Fe=i("depthBiasSlopeFactor"),Ve=d("br"),Ge=i(`
            A scalar factor applied to the slope of a fragment in depth bias calculations.`),He=Y(),ze=d("li"),xe=d("code"),Ne=i("lineWidth"),Te=d("br"),qe=i(`
            The width of line primitives, in pixels. This applies to all lines gridded
            with the pipeline.`),Ke=d("br"),je=i(`
            Some Vulkan implementations do not support broad strokes and may ignore
            this field. Others can work very slowly if this field is not
            `),rt=d("code"),Me=i("1.0f"),Ue=i(`; still others can fully respect this field and
            discard all lines if lineWidth is set to `),$t=d("code"),ut=i("0.0f"),ht=i(`.
            Therefore, this field should always be set to `),Je=d("code"),dt=i("1.0f"),et=i(`,
            unless it is certain that it should be otherwise.`),this.h()},l(nt){e=g(nt,"DIV",{slot:!0});var Qe=E(e);t=g(Qe,"LI",{});var ct=E(t);r=g(ct,"CODE",{});var st=E(r);$=f(st,"depthClampEnable"),st.forEach(l),n=g(ct,"BR",{}),s=f(ct,`
            Used to enable or disable depth clamping. This means that fragments that
            are outside the near and far planes are clamped instead of thrown out.
            This requires the
            `),a=g(ct,"CODE",{});var We=E(a);u=f(We,"VkPipelineRasterizationDepthClipStateCreateInfoEXT"),We.forEach(l),p=f(ct,`
            extension.`),ct.forEach(l),m=j(Qe),_=g(Qe,"LI",{});var at=E(_);v=g(at,"CODE",{});var bt=E(v);P=f(bt,"rasterizerDiscardEnable"),bt.forEach(l),R=g(at,"BR",{}),A=f(at,`
            Used to disable rasterization altogether. When this flag is set, the
            rasterizer will not run and no fragments will be produced.`),at.forEach(l),T=j(Qe),F=g(Qe,"LI",{});var wt=E(F);B=g(wt,"CODE",{});var St=E(B);y=f(St,"polygonMode"),St.forEach(l),V=g(wt,"BR",{}),x=f(wt,`
            Can be used to have Vulkan automatically turn triangles into points or
            lines. This a member of the `),S(M.$$.fragment,wt),O=f(wt,"-enumeration."),wt.forEach(l),H=j(Qe),k=g(Qe,"LI",{});var tt=E(k);N=g(tt,"CODE",{});var ot=E(N);Q=f(ot,"cullmode"),ot.forEach(l),X=g(tt,"BR",{}),Z=f(tt,`
            Controls what parts of the input will be discarded. This is a bitmask
            of `),S(K.$$.fragment,tt),W=f(tt,"."),tt.forEach(l),q=j(Qe),U=g(Qe,"LI",{});var At=E(U);te=g(At,"CODE",{});var it=E(te);ee=f(it,"frontFace"),it.forEach(l),se=g(At,"BR",{}),ie=f(At,`
            Which direction a triangle faces is determined by the winding order of
            its vertice - whether they go clockwise or counterclockwise in the window
            space. This is a member of the `),S(ae.$$.fragment,At),J=f(At,"-enumerant."),At.forEach(l),pe=j(Qe),Se=g(Qe,"LI",{});var Xe=E(Se);de=g(Xe,"CODE",{});var Dt=E(de);me=f(Dt,"depthBiasEnable"),Dt.forEach(l),De=g(Xe,"BR",{}),_e=f(Xe,`
            This feature allows fragments to be depth compensated for before the
            depth test. This can be used to avoid depth fights.`),Xe.forEach(l),ne=j(Qe),le=g(Qe,"LI",{});var Ct=E(le);ge=g(Ct,"CODE",{});var pt=E(ge);we=f(pt,"depthBiasConstantFactor"),pt.forEach(l),Pe=g(Ct,"BR",{}),Be=f(Ct,`
            A scalar factor that determines the constant depth value added to each
            clip.`),Ct.forEach(l),Ie=j(Qe),re=g(Qe,"LI",{});var Ft=E(re);he=g(Ft,"CODE",{});var mt=E(he);Le=f(mt,"depthBiasClamp"),mt.forEach(l),Oe=g(Ft,"BR",{}),oe=f(Ft,`
            The maximum (or minimum) depth bias of a fragment.`),Ft.forEach(l),ce=j(Qe),Ae=g(Qe,"LI",{});var Vt=E(Ae);ye=g(Vt,"CODE",{});var Rt=E(ye);Fe=f(Rt,"depthBiasSlopeFactor"),Rt.forEach(l),Ve=g(Vt,"BR",{}),Ge=f(Vt,`
            A scalar factor applied to the slope of a fragment in depth bias calculations.`),Vt.forEach(l),He=j(Qe),ze=g(Qe,"LI",{});var Tt=E(ze);xe=g(Tt,"CODE",{});var vt=E(xe);Ne=f(vt,"lineWidth"),vt.forEach(l),Te=g(Tt,"BR",{}),qe=f(Tt,`
            The width of line primitives, in pixels. This applies to all lines gridded
            with the pipeline.`),Ke=g(Tt,"BR",{}),je=f(Tt,`
            Some Vulkan implementations do not support broad strokes and may ignore
            this field. Others can work very slowly if this field is not
            `),rt=g(Tt,"CODE",{});var gt=E(rt);Me=f(gt,"1.0f"),gt.forEach(l),Ue=f(Tt,`; still others can fully respect this field and
            discard all lines if lineWidth is set to `),$t=g(Tt,"CODE",{});var kt=E($t);ut=f(kt,"0.0f"),kt.forEach(l),ht=f(Tt,`.
            Therefore, this field should always be set to `),Je=g(Tt,"CODE",{});var Mt=E(Je);dt=f(Mt,"1.0f"),Mt.forEach(l),et=f(Tt,`,
            unless it is certain that it should be otherwise.`),Tt.forEach(l),Qe.forEach(l),this.h()},h(){z(e,"slot","params")},m(nt,Qe){h(nt,e,Qe),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m),o(e,_),o(_,v),o(v,P),o(_,R),o(_,A),o(e,T),o(e,F),o(F,B),o(B,y),o(F,V),o(F,x),D(M,F,null),o(F,O),o(e,H),o(e,k),o(k,N),o(N,Q),o(k,X),o(k,Z),D(K,k,null),o(k,W),o(e,q),o(e,U),o(U,te),o(te,ee),o(U,se),o(U,ie),D(ae,U,null),o(U,J),o(e,pe),o(e,Se),o(Se,de),o(de,me),o(Se,De),o(Se,_e),o(e,ne),o(e,le),o(le,ge),o(ge,we),o(le,Pe),o(le,Be),o(e,Ie),o(e,re),o(re,he),o(he,Le),o(re,Oe),o(re,oe),o(e,ce),o(e,Ae),o(Ae,ye),o(ye,Fe),o(Ae,Ve),o(Ae,Ge),o(e,He),o(e,ze),o(ze,xe),o(xe,Ne),o(ze,Te),o(ze,qe),o(ze,Ke),o(ze,je),o(ze,rt),o(rt,Me),o(ze,Ue),o(ze,$t),o($t,ut),o(ze,ht),o(ze,Je),o(Je,dt),o(ze,et),Ze=!0},p(nt,Qe){const ct={};Qe&1&&(ct.$$scope={dirty:Qe,ctx:nt}),M.$set(ct);const st={};Qe&1&&(st.$$scope={dirty:Qe,ctx:nt}),K.$set(st);const We={};Qe&1&&(We.$$scope={dirty:Qe,ctx:nt}),ae.$set(We)},i(nt){Ze||(b(M.$$.fragment,nt),b(K.$$.fragment,nt),b(ae.$$.fragment,nt),Ze=!0)},o(nt){w(M.$$.fragment,nt),w(K.$$.fragment,nt),w(ae.$$.fragment,nt),Ze=!1},d(nt){nt&&l(e),C(M),C(K),C(ae)}}}function HK(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setRasterizationState(PipelineRasterizationState rasterizationState);"}}),r=new Ce({props:{$$slots:{params:[yK],details:[FK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineRasterizationState {
    VkBool32 depthClampEnable = VK_FALSE;
    VkBool32 rasterizerDiscardEnable = VK_FALSE;
    VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL;
    VkCullModeFlags cullmode = VK_CULL_MODE_NONE;
    VkFrontFace frontFace = VK_FRONT_FACE_CLOCKWISE;
    VkBool32 depthBiasEnable = VK_FALSE;
    float depthBiasConstantFactor = 0.0f;
    float depthBiasClamp = 0.0f;
    float depthBiasSlopeFactor = 0.0f;
    float lineWidth = 1.0f;
};`}}),u=new Ce({props:{$$slots:{params:[GK],details:[MK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class qK extends ve{constructor(e){super(),Ee(this,e,null,HK,be,{})}}function WK(c){let e,t;return{c(){e=d("span"),t=i("Set the Multisample State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Multisample State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function QK(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("multisampleState"),n=d("br"),s=i(`
            The multisample state, this is a
            `),a=d("code"),u=i("PipelineMultisampleState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"multisampleState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The multisample state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineMultisampleState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function KK(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the multisampling stage."),r=d("br"),$=i(`
        Multisampling is the process of generating multiple samples for each pixel
        in an image. It is used to counteract aliasing and can significantly improve
        image quality when used effectively.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the multisampling stage."),r=g(s,"BR",{}),$=f(s,`
        Multisampling is the process of generating multiple samples for each pixel
        in an image. It is used to counteract aliasing and can significantly improve
        image quality when used effectively.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function zK(c){let e;return{c(){e=i("VkSampleCountFlagBits")},l(t){e=f(t,"VkSampleCountFlagBits")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function YK(c){let e;return{c(){e=i("VkSampleMask")},l(t){e=f(t,"VkSampleMask")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function jK(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se;return a=new Bt({props:{reference:"VkSampleCountFlagBits",version:1.3,$$slots:{default:[zK]},$$scope:{ctx:c}}}),x=new Bt({props:{reference:"VkSampleMask",version:1.3,$$slots:{default:[YK]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("rasterizationSamples"),n=d("br"),s=i(`
            Not yet researched. This is a member of `),I(a.$$.fragment),u=i("."),p=Y(),m=d("li"),_=d("code"),v=i("sampleShadingEnable"),P=d("br"),R=i(`
            Not yet researched.`),A=Y(),T=d("li"),F=d("code"),B=i("minSampleShading"),y=d("br"),V=i(`
            Not yet researched. This is a list of `),I(x.$$.fragment),M=i("-structure."),O=Y(),H=d("li"),k=d("code"),N=i("sampleMask"),Q=d("br"),X=i(`
            Not yet researched.`),Z=Y(),K=d("li"),W=d("code"),q=i("alphaToCoverageEnable"),U=d("br"),te=i(`
            Not yet researched.`),ee=Y(),se=d("li"),ie=d("code"),ae=i("alphaToOneEnable"),J=d("br"),pe=i(`
            Not yet researched.`),this.h()},l(de){e=g(de,"DIV",{slot:!0});var me=E(e);t=g(me,"LI",{});var De=E(t);r=g(De,"CODE",{});var _e=E(r);$=f(_e,"rasterizationSamples"),_e.forEach(l),n=g(De,"BR",{}),s=f(De,`
            Not yet researched. This is a member of `),S(a.$$.fragment,De),u=f(De,"."),De.forEach(l),p=j(me),m=g(me,"LI",{});var ne=E(m);_=g(ne,"CODE",{});var le=E(_);v=f(le,"sampleShadingEnable"),le.forEach(l),P=g(ne,"BR",{}),R=f(ne,`
            Not yet researched.`),ne.forEach(l),A=j(me),T=g(me,"LI",{});var ge=E(T);F=g(ge,"CODE",{});var we=E(F);B=f(we,"minSampleShading"),we.forEach(l),y=g(ge,"BR",{}),V=f(ge,`
            Not yet researched. This is a list of `),S(x.$$.fragment,ge),M=f(ge,"-structure."),ge.forEach(l),O=j(me),H=g(me,"LI",{});var Pe=E(H);k=g(Pe,"CODE",{});var Be=E(k);N=f(Be,"sampleMask"),Be.forEach(l),Q=g(Pe,"BR",{}),X=f(Pe,`
            Not yet researched.`),Pe.forEach(l),Z=j(me),K=g(me,"LI",{});var Ie=E(K);W=g(Ie,"CODE",{});var re=E(W);q=f(re,"alphaToCoverageEnable"),re.forEach(l),U=g(Ie,"BR",{}),te=f(Ie,`
            Not yet researched.`),Ie.forEach(l),ee=j(me),se=g(me,"LI",{});var he=E(se);ie=g(he,"CODE",{});var Le=E(ie);ae=f(Le,"alphaToOneEnable"),Le.forEach(l),J=g(he,"BR",{}),pe=f(he,`
            Not yet researched.`),he.forEach(l),me.forEach(l),this.h()},h(){z(e,"slot","params")},m(de,me){h(de,e,me),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),o(e,p),o(e,m),o(m,_),o(_,v),o(m,P),o(m,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),o(e,O),o(e,H),o(H,k),o(k,N),o(H,Q),o(H,X),o(e,Z),o(e,K),o(K,W),o(W,q),o(K,U),o(K,te),o(e,ee),o(e,se),o(se,ie),o(ie,ae),o(se,J),o(se,pe),Se=!0},p(de,me){const De={};me&1&&(De.$$scope={dirty:me,ctx:de}),a.$set(De);const _e={};me&1&&(_e.$$scope={dirty:me,ctx:de}),x.$set(_e)},i(de){Se||(b(a.$$.fragment,de),b(x.$$.fragment,de),Se=!0)},o(de){w(a.$$.fragment,de),w(x.$$.fragment,de),Se=!1},d(de){de&&l(e),C(a),C(x)}}}function XK(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setMultisampleState(PipelineMultisampleState multisampleState);"}}),r=new Ce({props:{$$slots:{params:[QK],details:[WK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineMultisampleState {
    VkSampleCountFlagBits rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    VkBool32 sampleShadingEnable = VK_FALSE;
    float minSampleShading = 1.0f;
    std::vector<VkSampleMask> sampleMask = {};
    VkBool32 alphaToCoverageEnable = VK_FALSE;
    VkBool32 alphaToOneEnable = VK_FALSE;
};`}}),u=new Ce({props:{$$slots:{params:[jK],details:[KK]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class ZK extends ve{constructor(e){super(),Ee(this,e,null,XK,be,{})}}function JK(c){let e,t;return{c(){e=d("span"),t=i("Set the Depth Stencil State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Depth Stencil State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function ez(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthStencilState"),n=d("br"),s=i(`
            The multisample state, this is a
            `),a=d("code"),u=i("PipelineDepthStencilState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"depthStencilState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The multisample state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineDepthStencilState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function tz(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the depth- stencil state."),r=d("br"),$=i(`
        The depth stencil state determines how the depth and stencil tests are performed
        and what happens to a snippet if it passes or fails one of these tests. The
        depth and stencil tests can be performed before or after the fragment shader
        has been run. By default, the tests take place after the fragment shader.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the depth- stencil state."),r=g(s,"BR",{}),$=f(s,`
        The depth stencil state determines how the depth and stencil tests are performed
        and what happens to a snippet if it passes or fails one of these tests. The
        depth and stencil tests can be performed before or after the fragment shader
        has been run. By default, the tests take place after the fragment shader.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function rz(c){let e;return{c(){e=i("VkComareOp")},l(t){e=f(t,"VkComareOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function nz(c){let e;return{c(){e=i("VkStencilOpState")},l(t){e=f(t,"VkStencilOpState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function sz(c){let e;return{c(){e=i("VkStencilOpState")},l(t){e=f(t,"VkStencilOpState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function az(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z,K,W,q,U,te,ee,se,ie,ae,J,pe,Se,de,me,De,_e,ne,le,ge,we,Pe,Be,Ie,re,he,Le,Oe,oe,ce,Ae,ye,Fe,Ve,Ge,He,ze,xe,Ne,Te,qe;return k=new Bt({props:{reference:"VkComareOp",version:1.3,$$slots:{default:[rz]},$$scope:{ctx:c}}}),le=new Bt({props:{reference:"VkStencilOpState",version:1.3,$$slots:{default:[nz]},$$scope:{ctx:c}}}),Le=new Bt({props:{reference:"VkStencilOpState",version:1.3,$$slots:{default:[sz]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("depthTestEnable"),n=d("br"),s=i(`
            Whether depth testing is enabled.`),a=Y(),u=d("li"),p=d("code"),m=i("depthWriteEnable"),_=d("br"),v=i(`
            Whether depth writing is enabled. Depth writes are always disabled when
            `),P=d("code"),R=i("depthTestEnable"),A=i(`
            is `),T=d("code"),F=i("VK_FALSE"),B=i("."),y=Y(),V=d("li"),x=d("code"),M=i("depthCompareOp"),O=d("br"),H=i(`
            The test to use. This is a member of the `),I(k.$$.fragment),N=i("-enumerant."),Q=Y(),X=d("li"),Z=d("code"),K=i("depthBoundsTestEnable"),W=d("br"),q=i(`
            Whether depth limits tests are enabled.`),U=Y(),te=d("li"),ee=d("code"),se=i("stencilTestEnable"),ie=d("br"),ae=i(`
            Whether stencil testing is enabled.`),J=d("br"),pe=i(`
            If the depth test passes (or if the depth test is disabled), the snippet
            advances to the stencil test.`),Se=Y(),de=d("li"),me=d("code"),De=i("front"),_e=d("br"),ne=i(`
            Determines the parameters of the stencil test. This is a member of the
            `),I(le.$$.fragment),ge=i("-enumerant."),we=Y(),Pe=d("li"),Be=d("code"),Ie=i("back"),re=d("br"),he=i(`
            Determines the parameters of the stencil test. This is a member of the
            `),I(Le.$$.fragment),Oe=i("-enumerant."),oe=Y(),ce=d("li"),Ae=d("code"),ye=i("minDepthBounds"),Fe=d("br"),Ve=i(`
            The minimum depth limit used in the depth limit test.`),Ge=Y(),He=d("li"),ze=d("code"),xe=i("maxDepthBounds"),Ne=d("br"),Te=i(`
            The maximum depth limit used in the depth limit test.`),this.h()},l(Ke){e=g(Ke,"DIV",{slot:!0});var je=E(e);t=g(je,"LI",{});var rt=E(t);r=g(rt,"CODE",{});var Me=E(r);$=f(Me,"depthTestEnable"),Me.forEach(l),n=g(rt,"BR",{}),s=f(rt,`
            Whether depth testing is enabled.`),rt.forEach(l),a=j(je),u=g(je,"LI",{});var Ue=E(u);p=g(Ue,"CODE",{});var $t=E(p);m=f($t,"depthWriteEnable"),$t.forEach(l),_=g(Ue,"BR",{}),v=f(Ue,`
            Whether depth writing is enabled. Depth writes are always disabled when
            `),P=g(Ue,"CODE",{});var ut=E(P);R=f(ut,"depthTestEnable"),ut.forEach(l),A=f(Ue,`
            is `),T=g(Ue,"CODE",{});var ht=E(T);F=f(ht,"VK_FALSE"),ht.forEach(l),B=f(Ue,"."),Ue.forEach(l),y=j(je),V=g(je,"LI",{});var Je=E(V);x=g(Je,"CODE",{});var dt=E(x);M=f(dt,"depthCompareOp"),dt.forEach(l),O=g(Je,"BR",{}),H=f(Je,`
            The test to use. This is a member of the `),S(k.$$.fragment,Je),N=f(Je,"-enumerant."),Je.forEach(l),Q=j(je),X=g(je,"LI",{});var et=E(X);Z=g(et,"CODE",{});var Ze=E(Z);K=f(Ze,"depthBoundsTestEnable"),Ze.forEach(l),W=g(et,"BR",{}),q=f(et,`
            Whether depth limits tests are enabled.`),et.forEach(l),U=j(je),te=g(je,"LI",{});var nt=E(te);ee=g(nt,"CODE",{});var Qe=E(ee);se=f(Qe,"stencilTestEnable"),Qe.forEach(l),ie=g(nt,"BR",{}),ae=f(nt,`
            Whether stencil testing is enabled.`),J=g(nt,"BR",{}),pe=f(nt,`
            If the depth test passes (or if the depth test is disabled), the snippet
            advances to the stencil test.`),nt.forEach(l),Se=j(je),de=g(je,"LI",{});var ct=E(de);me=g(ct,"CODE",{});var st=E(me);De=f(st,"front"),st.forEach(l),_e=g(ct,"BR",{}),ne=f(ct,`
            Determines the parameters of the stencil test. This is a member of the
            `),S(le.$$.fragment,ct),ge=f(ct,"-enumerant."),ct.forEach(l),we=j(je),Pe=g(je,"LI",{});var We=E(Pe);Be=g(We,"CODE",{});var at=E(Be);Ie=f(at,"back"),at.forEach(l),re=g(We,"BR",{}),he=f(We,`
            Determines the parameters of the stencil test. This is a member of the
            `),S(Le.$$.fragment,We),Oe=f(We,"-enumerant."),We.forEach(l),oe=j(je),ce=g(je,"LI",{});var bt=E(ce);Ae=g(bt,"CODE",{});var wt=E(Ae);ye=f(wt,"minDepthBounds"),wt.forEach(l),Fe=g(bt,"BR",{}),Ve=f(bt,`
            The minimum depth limit used in the depth limit test.`),bt.forEach(l),Ge=j(je),He=g(je,"LI",{});var St=E(He);ze=g(St,"CODE",{});var tt=E(ze);xe=f(tt,"maxDepthBounds"),tt.forEach(l),Ne=g(St,"BR",{}),Te=f(St,`
            The maximum depth limit used in the depth limit test.`),St.forEach(l),je.forEach(l),this.h()},h(){z(e,"slot","params")},m(Ke,je){h(Ke,e,je),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),o(u,P),o(P,R),o(u,A),o(u,T),o(T,F),o(u,B),o(e,y),o(e,V),o(V,x),o(x,M),o(V,O),o(V,H),D(k,V,null),o(V,N),o(e,Q),o(e,X),o(X,Z),o(Z,K),o(X,W),o(X,q),o(e,U),o(e,te),o(te,ee),o(ee,se),o(te,ie),o(te,ae),o(te,J),o(te,pe),o(e,Se),o(e,de),o(de,me),o(me,De),o(de,_e),o(de,ne),D(le,de,null),o(de,ge),o(e,we),o(e,Pe),o(Pe,Be),o(Be,Ie),o(Pe,re),o(Pe,he),D(Le,Pe,null),o(Pe,Oe),o(e,oe),o(e,ce),o(ce,Ae),o(Ae,ye),o(ce,Fe),o(ce,Ve),o(e,Ge),o(e,He),o(He,ze),o(ze,xe),o(He,Ne),o(He,Te),qe=!0},p(Ke,je){const rt={};je&1&&(rt.$$scope={dirty:je,ctx:Ke}),k.$set(rt);const Me={};je&1&&(Me.$$scope={dirty:je,ctx:Ke}),le.$set(Me);const Ue={};je&1&&(Ue.$$scope={dirty:je,ctx:Ke}),Le.$set(Ue)},i(Ke){qe||(b(k.$$.fragment,Ke),b(le.$$.fragment,Ke),b(Le.$$.fragment,Ke),qe=!0)},o(Ke){w(k.$$.fragment,Ke),w(le.$$.fragment,Ke),w(Le.$$.fragment,Ke),qe=!1},d(Ke){Ke&&l(e),C(k),C(le),C(Le)}}}function oz(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setDepthStencilState(PipelineDepthStencilState depthStencilState);"}}),r=new Ce({props:{$$slots:{params:[ez],details:[JK]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineDepthStencilState {
    VkBool32 depthTestEnable = VK_TRUE;
    VkBool32 depthWriteEnable = VK_TRUE;
    VkCompareOp depthCompareOp = VK_COMPARE_OP_LESS;
    VkBool32 depthBoundsTestEnable = VK_FALSE;
    VkBool32 stencilTestEnable = VK_FALSE;
    VkStencilOpState front = {};
    VkStencilOpState back = {};
    float minDepthBounds = 0.0f;
    float maxDepthBounds = 1.0f;
};`}}),u=new Ce({props:{$$slots:{params:[az],details:[tz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class lz extends ve{constructor(e){super(),Ee(this,e,null,oz,be,{})}}function iz(c){let e,t;return{c(){e=d("span"),t=i("Set the Color Blend State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Color Blend State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function fz(c){let e,t,r,$,n,s,a,u,p,m;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("colorBlendState"),n=d("br"),s=i(`
            The color blend state, this is a
            `),a=d("code"),u=i("PipelineColorBlendState"),p=i("-structure."),m=Y(),this.h()},l(_){e=g(_,"DIV",{slot:!0});var v=E(e);t=g(v,"LI",{});var P=E(t);r=g(P,"CODE",{});var R=E(r);$=f(R,"colorBlendState"),R.forEach(l),n=g(P,"BR",{}),s=f(P,`
            The color blend state, this is a
            `),a=g(P,"CODE",{});var A=E(a);u=f(A,"PipelineColorBlendState"),A.forEach(l),p=f(P,"-structure."),P.forEach(l),m=j(v),v.forEach(l),this.h()},h(){z(e,"slot","params")},m(_,v){h(_,e,v),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(t,a),o(a,u),o(t,p),o(e,m)},p:ke,d(_){_&&l(e)}}}function cz(c){let e;return{c(){e=i("framebuffer")},l(t){e=f(t,"framebuffer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function $z(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.FRAMEBUFFER,$$slots:{default:[cz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Describe the color blend state."),r=d("br"),$=i(`
        The color operations take the final results of the fragment shader and postfragment
        operations and use them to update the `),I(n.$$.fragment),s=i(`. The color operations include blending and logic operations. This
        stage is responsible for writing fragments in the color attachments.`),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"Describe the color blend state."),r=g(p,"BR",{}),$=f(p,`
        The color operations take the final results of the fragment shader and postfragment
        operations and use them to update the `),S(n.$$.fragment,p),s=f(p,`. The color operations include blending and logic operations. This
        stage is responsible for writing fragments in the color attachments.`),p.forEach(l),this.h()},h(){z(e,"slot","details")},m(u,p){h(u,e,p),o(e,t),o(e,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function uz(c){let e;return{c(){e=i("VkLogicOp")},l(t){e=f(t,"VkLogicOp")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function pz(c){let e;return{c(){e=i("VkPipelineColorBlendAttachmentState")},l(t){e=f(t,"VkPipelineColorBlendAttachmentState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function mz(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T,F,B,y,V,x,M,O,H,k,N,Q,X,Z;return P=new Bt({props:{reference:"VkLogicOp",version:1.3,$$slots:{default:[uz]},$$scope:{ctx:c}}}),x=new Bt({props:{reference:"VkPipelineColorBlendAttachmentState",version:1.3,$$slots:{default:[pz]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("logicOpEnable"),n=d("br"),s=i(`
            Whether to perform logical operations between the fragment shader output
            and the contents of the color attachments.`),a=Y(),u=d("li"),p=d("code"),m=i("logicOp"),_=d("br"),v=i(`
            The logical operation to apply. This is a member of the `),I(P.$$.fragment),R=i("-enumerant."),A=Y(),T=d("li"),F=d("code"),B=i("attachments"),y=d("br"),V=i(`
            The color attachments to blend. This is a list of `),I(x.$$.fragment),M=i("-structures."),O=Y(),H=d("li"),k=d("code"),N=i("blendConstants"),Q=d("br"),X=i(`
            A matrix of four values used as the R, G, B, and A components of the
            blending constant used in mixing, depending on the mixing factor.`),this.h()},l(K){e=g(K,"DIV",{slot:!0});var W=E(e);t=g(W,"LI",{});var q=E(t);r=g(q,"CODE",{});var U=E(r);$=f(U,"logicOpEnable"),U.forEach(l),n=g(q,"BR",{}),s=f(q,`
            Whether to perform logical operations between the fragment shader output
            and the contents of the color attachments.`),q.forEach(l),a=j(W),u=g(W,"LI",{});var te=E(u);p=g(te,"CODE",{});var ee=E(p);m=f(ee,"logicOp"),ee.forEach(l),_=g(te,"BR",{}),v=f(te,`
            The logical operation to apply. This is a member of the `),S(P.$$.fragment,te),R=f(te,"-enumerant."),te.forEach(l),A=j(W),T=g(W,"LI",{});var se=E(T);F=g(se,"CODE",{});var ie=E(F);B=f(ie,"attachments"),ie.forEach(l),y=g(se,"BR",{}),V=f(se,`
            The color attachments to blend. This is a list of `),S(x.$$.fragment,se),M=f(se,"-structures."),se.forEach(l),O=j(W),H=g(W,"LI",{});var ae=E(H);k=g(ae,"CODE",{});var J=E(k);N=f(J,"blendConstants"),J.forEach(l),Q=g(ae,"BR",{}),X=f(ae,`
            A matrix of four values used as the R, G, B, and A components of the
            blending constant used in mixing, depending on the mixing factor.`),ae.forEach(l),W.forEach(l),this.h()},h(){z(e,"slot","params")},m(K,W){h(K,e,W),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a),o(e,u),o(u,p),o(p,m),o(u,_),o(u,v),D(P,u,null),o(u,R),o(e,A),o(e,T),o(T,F),o(F,B),o(T,y),o(T,V),D(x,T,null),o(T,M),o(e,O),o(e,H),o(H,k),o(k,N),o(H,Q),o(H,X),Z=!0},p(K,W){const q={};W&1&&(q.$$scope={dirty:W,ctx:K}),P.$set(q);const U={};W&1&&(U.$$scope={dirty:W,ctx:K}),x.$set(U)},i(K){Z||(b(P.$$.fragment,K),b(x.$$.fragment,K),Z=!0)},o(K){w(P.$$.fragment,K),w(x.$$.fragment,K),Z=!1},d(K){K&&l(e),C(P),C(x)}}}function hz(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setColorBlendState(PipelineColorBlendState colorBlendState);"}}),r=new Ce({props:{$$slots:{params:[fz],details:[iz]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineColorBlendState {
    VkBool32 logicOpEnable = VK_FALSE;
    VkLogicOp logicOp = VK_LOGIC_OP_COPY;
    std::vector<VkPipelineColorBlendAttachmentState> attachments = {};
    std::array<float, 4> blendConstants = {};
};`}}),u=new Ce({props:{$$slots:{params:[mz],details:[$z]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class dz extends ve{constructor(e){super(),Ee(this,e,null,hz,be,{})}}function gz(c){let e,t;return{c(){e=d("span"),t=i("Set the Dynamic State."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Set the Dynamic State."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function _z(c){let e,t,r,$,n,s,a;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dynamicState"),n=d("br"),s=i(`
            The dynamic state, this is a PipelineDynamicState-structure.`),a=Y(),this.h()},l(u){e=g(u,"DIV",{slot:!0});var p=E(e);t=g(p,"LI",{});var m=E(t);r=g(m,"CODE",{});var _=E(r);$=f(_,"dynamicState"),_.forEach(l),n=g(m,"BR",{}),s=f(m,`
            The dynamic state, this is a PipelineDynamicState-structure.`),m.forEach(l),a=j(p),p.forEach(l),this.h()},h(){z(e,"slot","params")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),o(e,a)},p:ke,d(u){u&&l(e)}}}function vz(c){let e,t,r,$;return{c(){e=d("span"),t=i("Describe the dynamic state."),r=d("br"),$=i(`
        To make fine-grained state changes more manageable, Vulkan provides the ability
        to mark certain parts of the graphics pipeline as dynamic, meaning they can
        be updated directly using commands directly in the command buffer rather
        than using an object. Since this reduces the chance for Vulkan to optimize
        or absorb parts of the state, it is necessary to specify exactly which state
        to make dynamically.`),this.h()},l(n){e=g(n,"SPAN",{slot:!0});var s=E(e);t=f(s,"Describe the dynamic state."),r=g(s,"BR",{}),$=f(s,`
        To make fine-grained state changes more manageable, Vulkan provides the ability
        to mark certain parts of the graphics pipeline as dynamic, meaning they can
        be updated directly using commands directly in the command buffer rather
        than using an object. Since this reduces the chance for Vulkan to optimize
        or absorb parts of the state, it is necessary to specify exactly which state
        to make dynamically.`),s.forEach(l),this.h()},h(){z(e,"slot","details")},m(n,s){h(n,e,s),o(e,t),o(e,r),o(e,$)},p:ke,d(n){n&&l(e)}}}function Ez(c){let e;return{c(){e=i("VkDynamicState")},l(t){e=f(t,"VkDynamicState")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function bz(c){let e,t,r,$,n,s,a,u,p;return a=new Bt({props:{reference:"VkDynamicState",version:1.3,$$slots:{default:[Ez]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("dynamicStates"),n=d("br"),s=i(`
            The states to make dynamic. This is a list of `),I(a.$$.fragment),u=i("-structures."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"dynamicStates"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The states to make dynamic. This is a list of `),S(a.$$.fragment,v),u=f(v,"-structures."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function wz(c){let e,t,r,$,n,s,a,u,p;return e=new $e({props:{language:ue,code:"void setDynamicState(PipelineDynamicState dynamicState);"}}),r=new Ce({props:{$$slots:{params:[_z],details:[gz]},$$scope:{ctx:c}}}),s=new $e({props:{language:ue,code:`struct PipelineDynamicState {
    std::vector<VkDynamicState> dynamicStates;
};`}}),u=new Ce({props:{$$slots:{params:[bz],details:[vz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment),$=d("br"),n=Y(),I(s.$$.fragment),a=Y(),I(u.$$.fragment)},l(m){S(e.$$.fragment,m),t=j(m),S(r.$$.fragment,m),$=g(m,"BR",{}),n=j(m),S(s.$$.fragment,m),a=j(m),S(u.$$.fragment,m)},m(m,_){D(e,m,_),h(m,t,_),D(r,m,_),h(m,$,_),h(m,n,_),D(s,m,_),h(m,a,_),D(u,m,_),p=!0},p(m,[_]){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),r.$set(v);const P={};_&1&&(P.$$scope={dirty:_,ctx:m}),u.$set(P)},i(m){p||(b(e.$$.fragment,m),b(r.$$.fragment,m),b(s.$$.fragment,m),b(u.$$.fragment,m),p=!0)},o(m){w(e.$$.fragment,m),w(r.$$.fragment,m),w(s.$$.fragment,m),w(u.$$.fragment,m),p=!1},d(m){C(e,m),m&&l(t),C(r,m),m&&l($),m&&l(n),C(s,m),m&&l(a),C(u,m)}}}class Iz extends ve{constructor(e){super(),Ee(this,e,null,wz,be,{})}}function Dz(c){let e;return{c(){e=i("Render Pass")},l(t){e=f(t,"Render Pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Cz(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Dz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the "),I(r.$$.fragment),$=i(" that describes the environment in which the pipeline will be used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the "),S(r.$$.fragment,a),$=f(a," that describes the environment in which the pipeline will be used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Sz(c){let e,t,r,$,n,s;return{c(){e=d("div"),t=d("li"),r=d("code"),$=i("pRenderPass"),n=d("br"),s=i(`
            A pointer to a render pass that describes the environment in which the
            pipeline will be used.`),this.h()},l(a){e=g(a,"DIV",{slot:!0});var u=E(e);t=g(u,"LI",{});var p=E(t);r=g(p,"CODE",{});var m=E(r);$=f(m,"pRenderPass"),m.forEach(l),n=g(p,"BR",{}),s=f(p,`
            A pointer to a render pass that describes the environment in which the
            pipeline will be used.`),p.forEach(l),u.forEach(l),this.h()},h(){z(e,"slot","params")},m(a,u){h(a,e,u),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s)},p:ke,d(a){a&&l(e)}}}function Pz(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setRenderPass(RenderPass* pRenderPass);"}}),r=new Ce({props:{$$slots:{params:[Sz],details:[Cz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Az extends ve{constructor(e){super(),Ee(this,e,null,Pz,be,{})}}function Rz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Bz(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Rz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Set the subpass in the "),I(r.$$.fragment),$=i(" where this pipeline will be used."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Set the subpass in the "),S(r.$$.fragment,a),$=f(a," where this pipeline will be used."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function Lz(c){let e;return{c(){e=i("render pass")},l(t){e=f(t,"render pass")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function kz(c){let e,t,r,$,n,s,a,u,p;return a=new G({props:{sectionID:L.RENDER_PASS,$$slots:{default:[Lz]},$$scope:{ctx:c}}}),{c(){e=d("div"),t=d("li"),r=d("code"),$=i("subpass"),n=d("br"),s=i(`
            The index of the subpass in the `),I(a.$$.fragment),u=i(" where this pipeline will be used."),this.h()},l(m){e=g(m,"DIV",{slot:!0});var _=E(e);t=g(_,"LI",{});var v=E(t);r=g(v,"CODE",{});var P=E(r);$=f(P,"subpass"),P.forEach(l),n=g(v,"BR",{}),s=f(v,`
            The index of the subpass in the `),S(a.$$.fragment,v),u=f(v," where this pipeline will be used."),v.forEach(l),_.forEach(l),this.h()},h(){z(e,"slot","params")},m(m,_){h(m,e,_),o(e,t),o(t,r),o(r,$),o(t,n),o(t,s),D(a,t,null),o(t,u),p=!0},p(m,_){const v={};_&1&&(v.$$scope={dirty:_,ctx:m}),a.$set(v)},i(m){p||(b(a.$$.fragment,m),p=!0)},o(m){w(a.$$.fragment,m),p=!1},d(m){m&&l(e),C(a)}}}function Tz(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void setSubpass(unsigned int subpass);"}}),r=new Ce({props:{$$slots:{params:[kz],details:[Bz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Vz extends ve{constructor(e){super(),Ee(this,e,null,Tz,be,{})}}function Oz(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Fz(c){let e,t,r,$,n;return r=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[Oz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("Get the resulting "),I(r.$$.fragment),$=i("."),this.h()},l(s){e=g(s,"SPAN",{slot:!0});var a=E(e);t=f(a,"Get the resulting "),S(r.$$.fragment,a),$=f(a,"."),a.forEach(l),this.h()},h(){z(e,"slot","details")},m(s,a){h(s,e,a),o(e,t),D(r,e,null),o(e,$),n=!0},p(s,a){const u={};a&1&&(u.$$scope={dirty:a,ctx:s}),r.$set(u)},i(s){n||(b(r.$$.fragment,s),n=!0)},o(s){w(r.$$.fragment,s),n=!1},d(s){s&&l(e),C(r)}}}function yz(c){let e;return{c(){e=i("unique pointer")},l(t){e=f(t,"unique pointer")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Mz(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function xz(c){let e,t,r,$,n,s,a;return r=new fe({props:{href:"https://en.cppreference.com/w/cpp/memory/unique_ptr",target:"_blank",$$slots:{default:[yz]},$$scope:{ctx:c}}}),n=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[Mz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=i("A "),I(r.$$.fragment),$=i(" to the "),I(n.$$.fragment),s=i(", it's ownership will be moved."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=f(p,"A "),S(r.$$.fragment,p),$=f(p," to the "),S(n.$$.fragment,p),s=f(p,", it's ownership will be moved."),p.forEach(l),this.h()},h(){z(e,"slot","return")},m(u,p){h(u,e,p),o(e,t),D(r,e,null),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),r.$set(m);const _={};p&1&&(_.$$scope={dirty:p,ctx:u}),n.$set(_)},i(u){a||(b(r.$$.fragment,u),b(n.$$.fragment,u),a=!0)},o(u){w(r.$$.fragment,u),w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(r),C(n)}}}function Nz(c){let e;return{c(){e=i("Graphics Pipeline")},l(t){e=f(t,"Graphics Pipeline")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Uz(c){let e,t,r,$,n,s,a;return n=new G({props:{sectionID:L.GRAPHICS_PIPELINE,$$slots:{default:[Nz]},$$scope:{ctx:c}}}),{c(){e=d("span"),t=d("code"),r=i("std::runtime_error"),$=i(" if the "),I(n.$$.fragment),s=i(" couldn't be created."),this.h()},l(u){e=g(u,"SPAN",{slot:!0});var p=E(e);t=g(p,"CODE",{});var m=E(t);r=f(m,"std::runtime_error"),m.forEach(l),$=f(p," if the "),S(n.$$.fragment,p),s=f(p," couldn't be created."),p.forEach(l),this.h()},h(){z(e,"slot","throws")},m(u,p){h(u,e,p),o(e,t),o(t,r),o(e,$),D(n,e,null),o(e,s),a=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),n.$set(m)},i(u){a||(b(n.$$.fragment,u),a=!0)},o(u){w(n.$$.fragment,u),a=!1},d(u){u&&l(e),C(n)}}}function Gz(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"std::unique_ptr<GraphicsPipeline> getResult();"}}),r=new Ce({props:{$$slots:{throws:[Uz],return:[xz],details:[Fz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Hz extends ve{constructor(e){super(),Ee(this,e,null,Gz,be,{})}}function qz(c){let e;return{c(){e=i(">")},l(t){e=f(t,">")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Wz(c){let e,t;return{c(){e=d("span"),t=i("Reset the Builder to it's default values."),this.h()},l(r){e=g(r,"SPAN",{slot:!0});var $=E(e);t=f($,"Reset the Builder to it's default values."),$.forEach(l),this.h()},h(){z(e,"slot","details")},m(r,$){h(r,e,$),o(e,t)},p:ke,d(r){r&&l(e)}}}function Qz(c){let e,t,r,$;return e=new $e({props:{language:ue,code:"void reset() override;"}}),r=new Ce({props:{$$slots:{details:[Wz],default:[qz]},$$scope:{ctx:c}}}),{c(){I(e.$$.fragment),t=Y(),I(r.$$.fragment)},l(n){S(e.$$.fragment,n),t=j(n),S(r.$$.fragment,n)},m(n,s){D(e,n,s),h(n,t,s),D(r,n,s),$=!0},p(n,[s]){const a={};s&1&&(a.$$scope={dirty:s,ctx:n}),r.$set(a)},i(n){$||(b(e.$$.fragment,n),b(r.$$.fragment,n),$=!0)},o(n){w(e.$$.fragment,n),w(r.$$.fragment,n),$=!1},d(n){C(e,n),n&&l(t),C(r,n)}}}class Kz extends ve{constructor(e){super(),Ee(this,e,null,Qz,be,{})}}function ba(c,e,t){const r=c.slice();return r[7]=e[t],r[8]=e,r[9]=t,r}function wa(c){let e,t,r,$,n,s,a,u;return $=new Wa({}),{c(){e=d("div"),t=d("div"),r=d("button"),I($.$$.fragment),this.h()},l(p){e=g(p,"DIV",{class:!0});var m=E(e);t=g(m,"DIV",{class:!0});var _=E(t);r=g(_,"BUTTON",{class:!0});var v=E(r);S($.$$.fragment,v),v.forEach(l),_.forEach(l),m.forEach(l),this.h()},h(){z(r,"class",n="hamburger-menu-button "+(c[1]?"activated":"")+" svelte-1usu7je"),z(t,"class","documentation-pop-in-inner svelte-1usu7je"),z(e,"class","documentation-pop-in svelte-1usu7je")},m(p,m){h(p,e,m),o(e,t),o(t,r),D($,r,null),s=!0,a||(u=Ds(r,"click",c[3]),a=!0)},p(p,m){(!s||m&2&&n!==(n="hamburger-menu-button "+(p[1]?"activated":"")+" svelte-1usu7je"))&&z(r,"class",n)},i(p){s||(b($.$$.fragment,p),s=!0)},o(p){w($.$$.fragment,p),s=!1},d(p){p&&l(e),C($),a=!1,u()}}}function Ia(c){let e,t,r,$,n;return t=new Ra({props:{sections:c[0],onReferenceClick:c[4]}}),{c(){e=d("div"),I(t.$$.fragment),this.h()},l(s){e=g(s,"DIV",{class:!0});var a=E(e);S(t.$$.fragment,a),a.forEach(l),this.h()},h(){z(e,"class","documentation-pop-in-content svelte-1usu7je")},m(s,a){h(s,e,a),D(t,e,null),n=!0},p(s,a){const u={};a&1&&(u.sections=s[0]),t.$set(u)},i(s){n||(b(t.$$.fragment,s),Ta(()=>{$&&$.end(1),r=Na(e,la,{y:-10,duration:500,opacity:0}),r.start()}),n=!0)},o(s){w(t.$$.fragment,s),r&&r.invalidate(),$=Va(e,la,{y:-20,duration:250,opacity:0}),n=!1},d(s){s&&l(e),C(t),s&&$&&$.end()}}}function zz(c){let e,t,r;const $=[c[7].props];var n=c[7].content;function s(a){let u={};for(let p=0;p<$.length;p+=1)u=qa(u,$[p]);return{props:u}}return n&&(e=new n(s())),{c(){e&&I(e.$$.fragment),t=On()},l(a){e&&S(e.$$.fragment,a),t=On()},m(a,u){e&&D(e,a,u),h(a,t,u),r=!0},p(a,u){const p=u&1?Ga($,[Ha(a[7].props)]):{};if(n!==(n=a[7].content)){if(e){In();const m=e;w(m.$$.fragment,1,0,()=>{C(m,1)}),Dn()}n?(e=new n(s()),I(e.$$.fragment),b(e.$$.fragment,1),D(e,t.parentNode,t)):e=null}else n&&e.$set(p)},i(a){r||(e&&b(e.$$.fragment,a),r=!0)},o(a){e&&w(e.$$.fragment,a),r=!1},d(a){a&&l(t),e&&C(e,a)}}}function Da(c){let e;return{c(){e=d("hr"),this.h()},l(t){e=g(t,"HR",{class:!0}),this.h()},h(){z(e,"class","svelte-1usu7je")},m(t,r){h(t,e,r)},d(t){t&&l(e)}}}function Ca(c){var v;let e,t,r,$,n,s=c[9]!==0&&c[9]<c[0].length-1&&((v=c[0].at(c[9]+1))==null?void 0:v.heading)===2,a,u;function p(P){c[5](P,c[7])}let m={id:c[7].id,label:c[7].label,heading:c[7].heading,$$slots:{default:[zz]},$$scope:{ctx:c}};c[7].visible!==void 0&&(m.visible=c[7].visible),e=new Ka({props:m}),Aa.push(()=>Ua(e,"visible",p));let _=s&&Da();return{c(){I(e.$$.fragment),r=Y(),$=d("br"),n=Y(),_&&_.c(),a=On()},l(P){S(e.$$.fragment,P),r=j(P),$=g(P,"BR",{}),n=j(P),_&&_.l(P),a=On()},m(P,R){D(e,P,R),h(P,r,R),h(P,$,R),h(P,n,R),_&&_.m(P,R),h(P,a,R),u=!0},p(P,R){var T;c=P;const A={};R&1&&(A.id=c[7].id),R&1&&(A.label=c[7].label),R&1&&(A.heading=c[7].heading),R&1025&&(A.$$scope={dirty:R,ctx:c}),!t&&R&1&&(t=!0,A.visible=c[7].visible,Oa(()=>t=!1)),e.$set(A),R&1&&(s=c[9]!==0&&c[9]<c[0].length-1&&((T=c[0].at(c[9]+1))==null?void 0:T.heading)===2),s?_||(_=Da(),_.c(),_.m(a.parentNode,a)):_&&(_.d(1),_=null)},i(P){u||(b(e.$$.fragment,P),u=!0)},o(P){w(e.$$.fragment,P),u=!1},d(P){C(e,P),P&&l(r),P&&l($),P&&l(n),_&&_.d(P),P&&l(a)}}}function Yz(c){let e,t,r,$,n,s,a,u,p,m,_,v,P,R,A,T=Ye().Fillcan.version+"",F,B,y,V,x,M,O,H,k,N,Q,X,Z;s=new Ra({props:{sections:c[0],onReferenceClick:c[4]}});let K=c[2]&&wa(c),W=c[2]&&c[1]&&Ia(c),q=c[0],U=[];for(let ee=0;ee<q.length;ee+=1)U[ee]=Ca(ba(c,q,ee));const te=ee=>w(U[ee],1,1,()=>{U[ee]=null});return{c(){e=new Fa(!1),t=On(),r=Y(),$=d("div"),n=d("div"),I(s.$$.fragment),a=Y(),K&&K.c(),u=Y(),W&&W.c(),p=Y(),m=d("div"),_=d("h1"),v=i("Documentation"),P=Y(),R=d("p"),A=i("This page contains the documentation for Fillcan (v"),F=i(T),B=i(`). It's intended for people who are familiar
            with C++ and Vulkan. `),y=d("br"),V=i(`
            Some concepts within C++ and Vulkan will be elaborated upon if I think
            they are interesting.`),x=Y(),M=d("br"),O=d("br"),H=Y(),k=d("hr"),N=Y();for(let ee=0;ee<U.length;ee+=1)U[ee].c();this.h()},l(ee){const se=ya('[data-svelte="svelte-1k4j43e"]',document.head);e=Ma(se,!1),t=On(),se.forEach(l),r=j(ee),$=g(ee,"DIV",{class:!0,style:!0});var ie=E($);n=g(ie,"DIV",{class:!0});var ae=E(n);S(s.$$.fragment,ae),ae.forEach(l),a=j(ie),K&&K.l(ie),u=j(ie),W&&W.l(ie),p=j(ie),m=g(ie,"DIV",{class:!0});var J=E(m);_=g(J,"H1",{class:!0});var pe=E(_);v=f(pe,"Documentation"),pe.forEach(l),P=j(J),R=g(J,"P",{});var Se=E(R);A=f(Se,"This page contains the documentation for Fillcan (v"),F=f(Se,T),B=f(Se,`). It's intended for people who are familiar
            with C++ and Vulkan. `),y=g(Se,"BR",{}),V=f(Se,`
            Some concepts within C++ and Vulkan will be elaborated upon if I think
            they are interesting.`),Se.forEach(l),x=j(J),M=g(J,"BR",{}),O=g(J,"BR",{}),H=j(J),k=g(J,"HR",{class:!0}),N=j(J);for(let de=0;de<U.length;de+=1)U[de].l(J);J.forEach(l),ie.forEach(l),this.h()},h(){e.a=t,z(n,"class","documentation-sidebar svelte-1usu7je"),z(_,"class","svelte-1usu7je"),z(k,"class","svelte-1usu7je"),z(m,"class",Q="documentation-container "+(c[2]?"mobile":"desktop")+" svelte-1usu7je"),z($,"class",X="documentation "+(c[2]?"mobile":"")+" svelte-1usu7je"),xa($,"--sidebar-width","22.5rem")},m(ee,se){e.m(Qa,document.head),o(document.head,t),h(ee,r,se),h(ee,$,se),o($,n),D(s,n,null),o($,a),K&&K.m($,null),o($,u),W&&W.m($,null),o($,p),o($,m),o(m,_),o(_,v),o(m,P),o(m,R),o(R,A),o(R,F),o(R,B),o(R,y),o(R,V),o(m,x),o(m,M),o(m,O),o(m,H),o(m,k),o(m,N);for(let ie=0;ie<U.length;ie+=1)U[ie].m(m,null);Z=!0},p(ee,[se]){const ie={};if(se&1&&(ie.sections=ee[0]),s.$set(ie),ee[2]?K?(K.p(ee,se),se&4&&b(K,1)):(K=wa(ee),K.c(),b(K,1),K.m($,u)):K&&(In(),w(K,1,1,()=>{K=null}),Dn()),ee[2]&&ee[1]?W?(W.p(ee,se),se&6&&b(W,1)):(W=Ia(ee),W.c(),b(W,1),W.m($,p)):W&&(In(),w(W,1,1,()=>{W=null}),Dn()),se&1){q=ee[0];let ae;for(ae=0;ae<q.length;ae+=1){const J=ba(ee,q,ae);U[ae]?(U[ae].p(J,se),b(U[ae],1)):(U[ae]=Ca(J),U[ae].c(),b(U[ae],1),U[ae].m(m,null))}for(In(),ae=q.length;ae<U.length;ae+=1)te(ae);Dn()}(!Z||se&4&&Q!==(Q="documentation-container "+(ee[2]?"mobile":"desktop")+" svelte-1usu7je"))&&z(m,"class",Q),(!Z||se&4&&X!==(X="documentation "+(ee[2]?"mobile":"")+" svelte-1usu7je"))&&z($,"class",X)},i(ee){if(!Z){b(s.$$.fragment,ee),b(K),b(W);for(let se=0;se<q.length;se+=1)b(U[se]);Z=!0}},o(ee){w(s.$$.fragment,ee),w(K),w(W),U=U.filter(Boolean);for(let se=0;se<U.length;se+=1)w(U[se]);Z=!1},d(ee){l(t),ee&&e.d(),ee&&l(r),ee&&l($),C(s),K&&K.d(),W&&W.d(),Pa(U,ee)}}}function jz(c,e,t){const r=[{id:L.GETTING_STARTED,label:"Getting Started",heading:2,content:Ya,props:{},visible:!1},{id:L.CMAKE,label:"CMake",heading:3,content:to,props:{},visible:!1},{id:L.FILLCAN,label:"Fillcan",heading:2,content:no,props:{},visible:!1},{id:L.FILLCAN_Constructor,label:"Constructor",heading:3,content:Io,props:{},visible:!1},{id:L.FILLCAN_getSupportedPhysicalDevices,label:"getSupportedPhysicalDevices",heading:3,content:Ro,props:{},visible:!1},{id:L.FILLCAN_selectDevice,label:"selectDevice",heading:3,content:Mo,props:{},visible:!1},{id:L.FILLCAN_getCurrentDevice,label:"getCurrentDevice",heading:3,content:Wo,props:{},visible:!1},{id:L.FILLCAN_createShaderModule,label:"createShaderModule",heading:3,content:Pl,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS,label:"Fillcan Graphics",heading:2,content:Bl,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_Constructor,label:"Constructor",heading:3,content:ql,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getWindow,label:"getWindow",heading:3,content:Xo,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_mainLoop,label:"mainLoop",heading:3,content:zl,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_createSwapchain,label:"createSwapchain",heading:3,content:li,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_recreateSwapchain,label:"recreateSwapchain",heading:3,content:Li,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getSwapchain,label:"getSwapchain",heading:3,content:Ui,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getSwapchains,label:"getSwapchains",heading:3,content:Ki,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_destroySwapchain,label:"destroySwapchain",heading:3,content:tf,props:{},visible:!1},{id:L.FILLCAN_GRAPHICS_getAssetManager,label:"getAssetManager",heading:3,content:lf,props:{},visible:!1},{id:L.WINDOW,label:"Window",heading:2,content:uf,props:{},visible:!1},{id:L.WINDOW_Constructor,label:"Constructor",heading:3,content:gf,props:{},visible:!1},{id:L.WINDOW_shouldClose,label:"shouldClose",heading:3,content:bf,props:{},visible:!1},{id:L.WINDOW_wasResized,label:"wasResized",heading:3,content:Cf,props:{},visible:!1},{id:L.WINDOW_pollEvents,label:"pollEvents",heading:3,content:Af,props:{},visible:!1},{id:L.WINDOW_getRequiredExtensions,label:"getRequiredExtensions",heading:3,content:Tf,props:{},visible:!1},{id:L.WINDOW_createSurface,label:"createSurface",heading:3,content:Uf,props:{},visible:!1},{id:L.WINDOW_getSurface,label:"getSurface",heading:3,content:zf,props:{},visible:!1},{id:L.WINDOW_getExtent,label:"getExtent",heading:3,content:ec,props:{},visible:!1},{id:L.INSTANCE,label:"Instance",heading:2,content:sc,props:{},visible:!1},{id:L.INSTANCE_Constructor,label:"Constructor",heading:3,content:dc,props:{},visible:!1},{id:L.INSTANCE_getInstanceHandle,label:"getInstanceHandle",heading:3,content:wc,props:{},visible:!1},{id:L.DEVICE_POOL,label:"Device Pool",heading:2,content:Lc,props:{},visible:!1},{id:L.DEVICE_POOL_Constructor,label:"Constructor",heading:3,content:Qc,props:{},visible:!1},{id:L.DEVICE_POOL_getSupportedPhysicalDevices,label:"getSupportedPhysicalDevices",heading:3,content:Jc,props:{},visible:!1},{id:L.DEVICE_POOL_selectDevice,label:"selectDevice",heading:3,content:i$,props:{},visible:!1},{id:L.DEVICE_POOL_getCurrentDevice,label:"getCurrentDevice",heading:3,content:h$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE,label:"Physical Device",heading:2,content:b$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_Constructor,label:"Constructor",heading:3,content:L$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getPhysicalDeviceHandle,label:"getPhysicalDeviceHandle",heading:3,content:y$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getRequiredExtensions,label:"getRequiredExtensions",heading:3,content:G$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_areExtensionsSupported,label:"areExtensionsSupported",heading:3,content:K$,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getRequiredFeatures,label:"getRequiredFeatures",heading:3,content:ru,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_areFeaturesSupported,label:"areFeaturesSupported",heading:3,content:lu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getFeatures,label:"getFeatures",heading:3,content:uu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getProperties,label:"getProperties",heading:3,content:gu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfaceCapabilitiesKHR,label:"getSurfaceCapabilitiesKHR",heading:3,content:Cu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfaceFormatsKHR,label:"getSurfaceFormatsKHR",heading:3,content:Tu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getSurfacePresentModesKHR,label:"getSurfacePresentModesKHR",heading:3,content:Uu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getQueueFamilyProperties,label:"getQueueFamilyProperties",heading:3,content:zu,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getFormatProperties,label:"getFormatProperties",heading:3,content:ep,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_findSupportedFormat,label:"findSupportedFormat",heading:3,content:cp,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getGraphicsQueueFamilyIndices,label:"getGraphicsQueueFamilyIndices",heading:3,content:hp,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getPresentQueueFamilyIndices,label:"getPresentQueueFamilyIndices",heading:3,content:Ep,props:{},visible:!1},{id:L.PHYSICAL_DEVICE_getComputeQueueFamilyIndices,label:"getComputeQueueFamilyIndices",heading:3,content:Cp,props:{},visible:!1},{id:L.LOGICAL_DEVICE,label:"Logical Device",heading:2,content:Vp,props:{},visible:!1},{id:L.LOGICAL_DEVICE_Constructor,label:"Constructor",heading:3,content:Wp,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getLogicalDeviceHandle,label:"getLogicalDeviceHandle",heading:3,content:Xp,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getPhysicalDevice,label:"getPhysicalDevice",heading:3,content:nm,props:{},visible:!1},{id:L.LOGICAL_DEVICE_waitIdle,label:"waitIdle",heading:3,content:im,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getGraphicsQueue,label:"getGraphicsQueue",heading:3,content:hm,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getPresentQueue,label:"getPresentQueue",heading:3,content:Rm,props:{},visible:!1},{id:L.LOGICAL_DEVICE_getComputeQueue,label:"getComputeQueue",heading:3,content:wm,props:{},visible:!1},{id:L.LOGICAL_DEVICE_beginSingleTimeCommandRecording,label:"beginSingleTimeCommandRecording",heading:3,content:qm,props:{},visible:!1},{id:L.LOGICAL_DEVICE_endSingleTimeCommandRecording,label:"endSingleTimeCommandRecording",heading:3,content:Zm,props:{},visible:!1},{id:L.QUEUE,label:"Queue",heading:2,content:oh,props:{},visible:!1},{id:L.QUEUE_Constructor,label:"Constructor",heading:3,content:uh,props:{},visible:!1},{id:L.QUEUE_getQueueHandle,label:"getQueueHandle",heading:3,content:_h,props:{},visible:!1},{id:L.QUEUE_getQueueFamilyIndex,label:"getQueueFamilyIndex",heading:3,content:tP,props:{},visible:!1},{id:L.QUEUE_getQueueIndex,label:"getQueueIndex",heading:3,content:aP,props:{},visible:!1},{id:L.QUEUE_createCommandPool,label:"createCommandPool",heading:3,content:u_,props:{},visible:!1},{id:L.QUEUE_getCommandPools,label:"getCommandPools",heading:3,content:N_,props:{},visible:!1},{id:L.QUEUE_getCommandPool,label:"getCommandPool",heading:3,content:b_,props:{},visible:!1},{id:L.QUEUE_destroyCommandPool,label:"destroyCommandPool",heading:3,content:A_,props:{},visible:!1},{id:L.QUEUE_createRecording,label:"createRecording",heading:3,content:Th,props:{},visible:!1},{id:L.QUEUE_submitRecordings,label:"submitRecordings",heading:3,content:Gh,props:{},visible:!1},{id:L.QUEUE_resetRecording,label:"resetRecording",heading:3,content:rd,props:{},visible:!1},{id:L.QUEUE_freeRecording,label:"freeRecording",heading:3,content:ud,props:{},visible:!1},{id:L.QUEUE_waitIdle,label:"waitIdle",heading:3,content:gd,props:{},visible:!1},{id:L.COMMAND_POOL,label:"Command Pool",heading:2,content:Pd,props:{},visible:!1},{id:L.COMMAND_POOL_Constructor,label:"Constructor",heading:3,content:Nd,props:{},visible:!1},{id:L.COMMAND_POOL_getCommandPoolHandle,label:"getCommandPoolHandle",heading:3,content:pg,props:{},visible:!1},{id:L.COMMAND_POOL_allocateCommandBuffers,label:"allocateCommandBuffers",heading:3,content:zd,props:{},visible:!1},{id:L.COMMAND_POOL_freeCommandBuffers,label:"freeCommandBuffers",heading:3,content:eg,props:{},visible:!1},{id:L.COMMAND_POOL_reset,label:"reset",heading:3,content:lg,props:{},visible:!1},{id:L.COMMAND_BUFFER,label:"Command Buffer",heading:2,content:Xg,props:{},visible:!1},{id:L.COMMAND_BUFFER_Constructor,label:"Constructor",heading:3,content:V_,props:{},visible:!1},{id:L.COMMAND_BUFFER_getCommandBufferHandle,label:"getCommandBufferHandle",heading:3,content:vg,props:{},visible:!1},{id:L.COMMAND_BUFFER_getLevel,label:"getLevel",heading:3,content:Dg,props:{},visible:!1},{id:L.COMMAND_BUFFER_begin,label:"begin",heading:3,content:Lg,props:{},visible:!1},{id:L.COMMAND_BUFFER_end,label:"end",heading:3,content:Mg,props:{},visible:!1},{id:L.COMMAND_BUFFER_reset,label:"reset",heading:3,content:Qg,props:{},visible:!1},{id:L.COMMAND_RECORDING,label:"Command Recording",heading:2,content:ov,props:{},visible:!1},{id:L.COMMAND_RECORDING_endAll,label:"endAll",heading:3,content:hv,props:{},visible:!1},{id:L.COMMAND_RECORDING_submit,label:"submit",heading:3,content:Dv,props:{},visible:!1},{id:L.COMMAND_RECORDING_reset,label:"reset",heading:3,content:kv,props:{},visible:!1},{id:L.COMMAND_RECORDING_free,label:"free",heading:3,content:Fv,props:{},visible:!1},{id:L.COMMAND_RECORDING_createFence,label:"createFence",heading:3,content:Qv,props:{},visible:!1},{id:L.COMMAND_RECORDING_waitForFence,label:"waitForFence",heading:3,content:eE,props:{},visible:!1},{id:L.SWAPCHAIN,label:"Swapchain",heading:2,content:$E,props:{},visible:!1},{id:L.SWAPCHAIN_Swapchain_Image,label:"Swapchain Image",heading:3,content:u1,props:{},visible:!1},{id:L.SWAPCHAIN_Constructor,label:"Constructor",heading:3,content:DE,props:{},visible:!1},{id:L.SWAPCHAIN_getSwapchainHandle,label:"getSwapchainHandle",heading:3,content:BE,props:{},visible:!1},{id:L.SWAPCHAIN_getNextImage,label:"getNextImage",heading:3,content:xE,props:{},visible:!1},{id:L.SWAPCHAIN_getSurfaceFormat,label:"getSurfaceFormat",heading:3,content:qE,props:{},visible:!1},{id:L.SWAPCHAIN_getImageCount,label:"getImageCount",heading:3,content:jE,props:{},visible:!1},{id:L.SWAPCHAIN_getImageArrayLayers,label:"getImageArrayLayers",heading:3,content:rb,props:{},visible:!1},{id:L.SWAPCHAIN_getImageUsage,label:"getImageUsage",heading:3,content:fb,props:{},visible:!1},{id:L.SWAPCHAIN_getImageSharingMode,label:"getImageSharingMode",heading:3,content:vb,props:{},visible:!1},{id:L.SWAPCHAIN_getImageExtent,label:"getImageExtent",heading:3,content:Lb,props:{},visible:!1},{id:L.SWAPCHAIN_getPresentMode,label:"getPresentMode",heading:3,content:Db,props:{},visible:!1},{id:L.SWAPCHAIN_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:Ub,props:{},visible:!1},{id:L.SWAPCHAIN_present,label:"present",heading:3,content:Zb,props:{},visible:!1},{id:L.BUFFER_DIRECTOR,label:"Buffer Director",heading:2,content:RR,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_Constructor,label:"Constructor",heading:3,content:kR,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeVertexBuffer,label:"makeVertexBuffer",heading:3,content:KR,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeVertexTransferDestinationBuffer,label:"makeVertexTransferDestinationBuffer",heading:3,content:iB,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeUniformBuffer,label:"makeUniformBuffer",heading:3,content:IB,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStorageBuffer,label:"makeStorageBuffer",heading:3,content:MB,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeUniformTexelBuffer,label:"makeUniformTexelBuffer",heading:3,content:JB,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStorageTexelBuffer,label:"makeStorageTexelBuffer",heading:3,content:mL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndexBuffer,label:"makeIndexBuffer",heading:3,content:RL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndexTransferDestinationBuffer,label:"makeIndexTransferDestinationBuffer",heading:3,content:qL,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeIndirectBuffer,label:"makeIndirectBuffer",heading:3,content:ak,props:{},visible:!1},{id:L.BUFFER_DIRECTOR_makeStagingBuffer,label:"makeStagingBuffer",heading:3,content:Ek,props:{},visible:!1},{id:L.BUFFER_BUILDER,label:"Buffer Builder",heading:2,content:Dk,props:{},visible:!1},{id:L.BUFFER_BUILDER_Constructor,label:"Constructor",heading:3,content:Pk,props:{},visible:!1},{id:L.BUFFER_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:Ok,props:{},visible:!1},{id:L.BUFFER_BUILDER_setFlags,label:"setFlags",heading:3,content:Uk,props:{},visible:!1},{id:L.BUFFER_BUILDER_setSize,label:"setSize",heading:3,content:Qk,props:{},visible:!1},{id:L.BUFFER_BUILDER_setUsage,label:"setUsage",heading:3,content:Jk,props:{},visible:!1},{id:L.BUFFER_BUILDER_setSharingMode,label:"setSharingMode",heading:3,content:uT,props:{},visible:!1},{id:L.BUFFER_BUILDER_setQueueFamilyIndices,label:"setQueueFamilyIndices",heading:3,content:_T,props:{},visible:!1},{id:L.BUFFER_BUILDER_getResult,label:"getResult",heading:3,content:LT,props:{},visible:!1},{id:L.BUFFER_BUILDER_reset,label:"reset",heading:3,content:wT,props:{},visible:!1},{id:L.BUFFER,label:"Buffer",heading:2,content:E1,props:{},visible:!1},{id:L.BUFFER_Constructor,label:"Constructor",heading:3,content:x1,props:{},visible:!1},{id:L.BUFFER_getBufferHandle,label:"getBufferHandle",heading:3,content:W1,props:{},visible:!1},{id:L.BUFFER_getFlags,label:"getFlags",heading:3,content:Y1,props:{},visible:!1},{id:L.BUFFER_getSize,label:"getSize",heading:3,content:tw,props:{},visible:!1},{id:L.BUFFER_getUsage,label:"getUsage",heading:3,content:aw,props:{},visible:!1},{id:L.BUFFER_getSharingMode,label:"getSharingMode",heading:3,content:fw,props:{},visible:!1},{id:L.BUFFER_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:pw,props:{},visible:!1},{id:L.BUFFER_bindMemory,label:"bindMemory",heading:3,content:bw,props:{},visible:!1},{id:L.BUFFER_getMemory,label:"getMemory",heading:3,content:Aw,props:{},visible:!1},{id:L.BUFFER_createBufferView,label:"createBufferView",heading:3,content:qw,props:{},visible:!1},{id:L.BUFFER_getBufferViews,label:"getBufferViews",heading:3,content:rI,props:{},visible:!1},{id:L.BUFFER_getBufferView,label:"getBufferView",heading:3,content:jw,props:{},visible:!1},{id:L.BUFFER_destroyBufferViews,label:"destroyBufferViews",heading:3,content:uI,props:{},visible:!1},{id:L.BUFFER_destroyBufferView,label:"destroyBufferView",heading:3,content:iI,props:{},visible:!1},{id:L.BUFFER_copyTo,label:"copyTo",heading:3,content:SI,props:{},visible:!1},{id:L.BUFFER_VIEW,label:"Buffer View",heading:2,content:yP,props:{},visible:!1},{id:L.BUFFER_VIEW_Constructor,label:"Constructor",heading:3,content:BP,props:{},visible:!1},{id:L.BUFFER_VIEW_getBufferViewHandle,label:"getBufferViewHandle",heading:3,content:$P,props:{},visible:!1},{id:L.IMAGE_DIRECTOR,label:"Image Director",heading:2,content:WT,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_Constructor,label:"Constructor",heading:3,content:VT,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_make2DTexture,label:"make2DTexture",heading:3,content:iV,props:{},visible:!1},{id:L.IMAGE_DIRECTOR_makeDepthImage,label:"makeDepthImage",heading:3,content:CV,props:{},visible:!1},{id:L.IMAGE_BUILDER,label:"Image Builder",heading:2,content:RV,props:{},visible:!1},{id:L.IMAGE_BUILDER_Constructor,label:"Constructor",heading:3,content:kV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:NV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setFlags,label:"setFlags",heading:3,content:QV,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageType,label:"setImageType",heading:3,content:t0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setFormat,label:"setFormat",heading:3,content:o0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setExtent,label:"setExtent",heading:3,content:d0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setMipLevels,label:"setMipLevels",heading:3,content:w0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setArrayLayers,label:"setArrayLayers",heading:3,content:R0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setSamples,label:"setSamples",heading:3,content:F0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageTiling,label:"setImageTiling",heading:3,content:W0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setImageUsage,label:"setImageUsage",heading:3,content:Z0,props:{},visible:!1},{id:L.IMAGE_BUILDER_setSharingMode,label:"setSharingMode",heading:3,content:$O,props:{},visible:!1},{id:L.IMAGE_BUILDER_setQueueFamilyIndices,label:"setQueueFamilyIndices",heading:3,content:_O,props:{},visible:!1},{id:L.IMAGE_BUILDER_setInitialLayout,label:"setInitialLayout",heading:3,content:RO,props:{},visible:!1},{id:L.IMAGE_BUILDER_reset,label:"reset",heading:3,content:TO,props:{},visible:!1},{id:L.IMAGE_BUILDER_getResult,label:"getResult",heading:3,content:GO,props:{},visible:!1},{id:L.IMAGE,label:"Image",heading:2,content:VI,props:{},visible:!1},{id:L.IMAGE_Constructor,label:"Constructor",heading:3,content:$D,props:{},visible:!1},{id:L.IMAGE_getImageHandle,label:"getImageHandle",heading:3,content:gD,props:{},visible:!1},{id:L.IMAGE_getFlags,label:"getFlags",heading:3,content:bD,props:{},visible:!1},{id:L.IMAGE_getUsage,label:"getUsage",heading:3,content:CD,props:{},visible:!1},{id:L.IMAGE_getSharingMode,label:"getSharingMode",heading:3,content:RD,props:{},visible:!1},{id:L.IMAGE_getQueueFamilyIndices,label:"getQueueFamilyIndices",heading:3,content:TD,props:{},visible:!1},{id:L.IMAGE_getType,label:"getType",heading:3,content:XC,props:{},visible:!1},{id:L.IMAGE_getFormat,label:"getFormat",heading:3,content:tS,props:{},visible:!1},{id:L.IMAGE_getExtent,label:"getExtent",heading:3,content:aS,props:{},visible:!1},{id:L.IMAGE_getMipLevels,label:"getMipLevels",heading:3,content:fS,props:{},visible:!1},{id:L.IMAGE_getArrayLayers,label:"getArrayLayers",heading:3,content:pS,props:{},visible:!1},{id:L.IMAGE_getSamples,label:"getSamples",heading:3,content:gS,props:{},visible:!1},{id:L.IMAGE_getTiling,label:"getTiling",heading:3,content:bS,props:{},visible:!1},{id:L.IMAGE_getInitialLayout,label:"getInitialLayout",heading:3,content:CS,props:{},visible:!1},{id:L.IMAGE_bindMemory,label:"bindMemory",heading:3,content:UD,props:{},visible:!1},{id:L.IMAGE_getMemory,label:"getMemory",heading:3,content:zD,props:{},visible:!1},{id:L.IMAGE_createImageView,label:"createImageView",heading:3,content:uC,props:{},visible:!1},{id:L.IMAGE_getImageViews,label:"getImageViews",heading:3,content:XS,props:{},visible:!1},{id:L.IMAGE_getImageView,label:"getImageView",heading:3,content:EC,props:{},visible:!1},{id:L.IMAGE_destroyImageViews,label:"destroyImageViews",heading:3,content:DC,props:{},visible:!1},{id:L.IMAGE_destroyImageView,label:"destroyImageView",heading:3,content:BC,props:{},visible:!1},{id:L.IMAGE_copyTo,label:"copyTo",heading:3,content:KC,props:{},visible:!1},{id:L.IMAGE_transitionImageLayout,label:"transitionImageLayout",heading:3,content:WS,props:{},visible:!1},{id:L.IMAGE_VIEW,label:"Image View",heading:2,content:QP,props:{},visible:!1},{id:L.IMAGE_VIEW_Constructor,label:"Constructor",heading:3,content:fA,props:{},visible:!1},{id:L.IMAGE_VIEW_getImageViewHandle,label:"getImageViewHandle",heading:3,content:hA,props:{},visible:!1},{id:L.SAMPLER_BUILDER,label:"Sampler Builder",heading:2,content:SW,props:{},visible:!1},{id:L.SAMPLER_BUILDER_Constructor,label:"Constructor",heading:3,content:RW,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:yW,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setFilters,label:"setFilters",heading:3,content:QW,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMipmapMode,label:"setMipmapMode",heading:3,content:JW,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setAddressModes,label:"setAddressModes",heading:3,content:aQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMipLodBias,label:"setMipLodBias",heading:3,content:fQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setMaxAnisotropy,label:"setMaxAnisotropy",heading:3,content:hQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_unsetMaxAnisotropy,label:"unsetMaxAnisotropy",heading:3,content:_Q,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setCompareOp,label:"setCompareOp",heading:3,content:DQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_unsetCompareOp,label:"unsetCompareOp",heading:3,content:PQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setLod,label:"setLod",heading:3,content:TQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_setBorderColor,label:"setBorderColor",heading:3,content:NQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_enableUnnormalizedCoordinates,label:"enableUnnormalizedCoordinates",heading:3,content:XQ,props:{},visible:!1},{id:L.SAMPLER_BUILDER_disableUnnormalizedCoordinates,label:"disableUnnormalizedCoordinates",heading:3,content:e8,props:{},visible:!1},{id:L.SAMPLER_BUILDER_getResult,label:"getResult",heading:3,content:f8,props:{},visible:!1},{id:L.SAMPLER_BUILDER_reset,label:"reset",heading:3,content:p8,props:{},visible:!1},{id:L.SAMPLER,label:"Sampler",heading:2,content:zq,props:{},visible:!1},{id:L.SAMPLER_Constructor,label:"Constructor",heading:3,content:_W,props:{},visible:!1},{id:L.SAMPLER_getSamplerHandle,label:"getSamplerHandle",heading:3,content:DW,props:{},visible:!1},{id:L.MEMORY,label:"Memory",heading:2,content:CA,props:{},visible:!1},{id:L.MEMORY_Constructor,label:"Constructor",heading:3,content:HA,props:{},visible:!1},{id:L.MEMORY_getMemoryHandle,label:"getMemoryHandle",heading:3,content:YA,props:{},visible:!1},{id:L.MEMORY_map,label:"map",heading:3,content:tR,props:{},visible:!1},{id:L.MEMORY_unmap,label:"unmap",heading:3,content:sR,props:{},visible:!1},{id:L.MEMORY_getData,label:"getData",heading:3,content:fR,props:{},visible:!1},{id:L.MEMORY_flush,label:"flush",heading:3,content:mR,props:{},visible:!1},{id:L.MEMORY_invalidate,label:"invalidate",heading:3,content:vR,props:{},visible:!1},{id:L.SEMAPHORE,label:"Semaphore",heading:2,content:O3,props:{},visible:!1},{id:L.SEMAPHORE_Constructor,label:"Constructor",heading:3,content:G3,props:{},visible:!1},{id:L.SEMAPHORE_getSemaphoreHandle,label:"getSemaphoreHandle",heading:3,content:z3,props:{},visible:!1},{id:L.FENCE,label:"Fence",heading:2,content:QO,props:{},visible:!1},{id:L.FENCE_Constructor,label:"Constructor",heading:3,content:e3,props:{},visible:!1},{id:L.FENCE_getFenceHandle,label:"getFenceHandle",heading:3,content:o3,props:{},visible:!1},{id:L.FENCE_waitFor,label:"waitFor",heading:3,content:$3,props:{},visible:!1},{id:L.FENCE_reset,label:"reset",heading:3,content:R3,props:{},visible:!1},{id:L.FENCE_s_waitForAll,label:"s_waitForAll",heading:3,content:_3,props:{},visible:!1},{id:L.FENCE_s_resetAll,label:"s_resetAll",heading:3,content:C3,props:{},visible:!1},{id:L.SHADER_MODULE,label:"Shader Module",heading:2,content:m2,props:{},visible:!1},{id:L.SHADER_MODULE_Constructor,label:"Constructor",heading:3,content:G2,props:{},visible:!1},{id:L.SHADER_MODULE_getShaderModuleHandle,label:"getShaderModuleHandle",heading:3,content:z2,props:{},visible:!1},{id:L.SHADER_MODULE_getDescriptorSetLayouts,label:"getDescriptorSetLayouts",heading:3,content:eF,props:{},visible:!1},{id:L.SHADER_MODULE_getDescriptorPool,label:"getDescriptorPool",heading:3,content:oF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER,label:"Descriptor Set Layout Builder",heading:2,content:xF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_Constructor,label:"Constructor",heading:3,content:GF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:jF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_addBinding,label:"addBinding",heading:3,content:uy,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_getResult,label:"getResult",heading:3,content:by,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_BUILDER_reset,label:"reset",heading:3,content:Cy,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT,label:"Descriptor Set Layout",heading:2,content:_F,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_Constructor,label:"Constructor",heading:3,content:PF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_getDescriptorSetLayoutHandle,label:"getDescriptorSetLayoutHandle",heading:3,content:TF,props:{},visible:!1},{id:L.DESCRIPTOR_SET_LAYOUT_getBindings,label:"getBindings",heading:3,content:yF,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER,label:"Descriptor Pool Builder",heading:2,content:GM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_Constructor,label:"Constructor",heading:3,content:WM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:JM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_setFlags,label:"setFlags",heading:3,content:ox,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_addSet,label:"addSet",heading:3,content:ux,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_getResult,label:"getResult",heading:3,content:Dx,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_BUILDER_reset,label:"reset",heading:3,content:Ax,props:{},visible:!1},{id:L.DESCRIPTOR_POOL,label:"Descriptor Pool",heading:2,content:Ly,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_Constructor,label:"Constructor",heading:3,content:Hy,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorPoolHandle,label:"getDescriptorPoolHandle",heading:3,content:Yy,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_allocateDescriptorSet,label:"allocateDescriptorSet",heading:3,content:fM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorSets,label:"getDescriptorSets",heading:3,content:hM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_getDescriptorSet,label:"getDescriptorSet",heading:3,content:DM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_freeDescriptorSets,label:"freeDescriptorSets",heading:3,content:FM,props:{},visible:!1},{id:L.DESCRIPTOR_POOL_reset,label:"reset",heading:3,content:NM,props:{},visible:!1},{id:L.DESCRIPTOR_SET,label:"Descriptor Set",heading:2,content:qx,props:{},visible:!1},{id:L.DESCRIPTOR_SET_Constructor,label:"Constructor",heading:3,content:eN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getDescriptorSetHandle,label:"getDescriptorSetHandle",heading:3,content:oN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getLayout,label:"getLayout",heading:3,content:uN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_getName,label:"getName",heading:3,content:dN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeImage,label:"writeImage",heading:3,content:PN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeBuffer,label:"writeBuffer",heading:3,content:FN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_writeTexelBufferView,label:"writeTexelBufferView",heading:3,content:GN,props:{},visible:!1},{id:L.DESCRIPTOR_SET_copy,label:"copy",heading:3,content:QN,props:{},visible:!1},{id:L.PIPELINE_BUILDER,label:"Pipeline Builder",heading:2,content:n5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:l5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:h5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setFlags,label:"setFlags",heading:3,content:b5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_addPushConstant,label:"addPushConstant",heading:3,content:P5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setPipelineCache,label:"setPipelineCache",heading:3,content:N5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_setBasePipeline,label:"setBasePipeline",heading:3,content:Y5,props:{},visible:!1},{id:L.PIPELINE_BUILDER_reset,label:"reset",heading:3,content:q5,props:{},visible:!1},{id:L.PIPELINE,label:"Pipeline",heading:2,content:KU,props:{},visible:!1},{id:L.PIPELINE_PIPELINE_SHADER_STAGE,label:"Pipeline Shader Stage",heading:3,content:G4,props:{},visible:!1},{id:L.PIPELINE_Constructor,label:"Constructor",heading:3,content:sG,props:{},visible:!1},{id:L.PIPELINE_getPipelineHandle,label:"getPipelineHandle",heading:3,content:cG,props:{},visible:!1},{id:L.PIPELINE_getPipelineLayout,label:"getPipelineLayout",heading:3,content:dG,props:{},visible:!1},{id:L.PIPELINE_bindToCommandBuffer,label:"bindToCommandBuffer",heading:3,content:DG,props:{},visible:!1},{id:L.PIPELINE_getCommandBuffer,label:"getCommandBuffer",heading:3,content:LG,props:{},visible:!1},{id:L.PIPELINE_bindDescriptorSets,label:"bindDescriptorSets",heading:3,content:_4,props:{},visible:!1},{id:L.PIPELINE_getDescriptorSets,label:"getDescriptorSets",heading:3,content:C4,props:{},visible:!1},{id:L.PIPELINE_getDescriptorSet,label:"getDescriptorSet",heading:3,content:V4,props:{},visible:!1},{id:L.PIPELINE_pushConstantData,label:"pushConstantData",heading:3,content:t5,props:{},visible:!1},{id:L.PIPELINE_LAYOUT,label:"Pipeline Layout",heading:2,content:nU,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_PUSH_CONSTANT,label:"Push Constant",heading:3,content:xU,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_Constructor,label:"Constructor",heading:3,content:pU,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_getPipelineLayoutHandle,label:"getPipelineLayoutHandle",heading:3,content:vU,props:{},visible:!1},{id:L.PIPELINE_LAYOUT_pushConstantData,label:"pushConstantData",heading:3,content:LU,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER,label:"Compute Pipeline Builder",heading:2,content:vH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:wH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_setShaderStage,label:"setShaderStage",heading:3,content:RH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_getResult,label:"getResult",heading:3,content:MH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_BUILDER_reset,label:"reset",heading:3,content:GH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE,label:"Compute Pipeline",heading:2,content:sH,props:{},visible:!1},{id:L.COMPUTE_PIPELINE_Constructor,label:"Constructor",heading:3,content:gH,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER,label:"Render Pass Builder",heading:2,content:z6,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_Constructor,label:"Constructor",heading:3,content:X6,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_setLogicalDevice,label:"setLogicalDevice",heading:3,content:a7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addAttachment,label:"addAttachment",heading:3,content:u7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addInputAttachment,label:"addInputAttachment",heading:3,content:g7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addColorAttachment,label:"addColorAttachment",heading:3,content:w7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_setDepthStencilAttachment,label:"setDepthStencilAttachment",heading:3,content:P7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_resolveCurrentAttachments,label:"resolveCurrentAttachments",heading:3,content:B7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_constructSubpass,label:"constructSubpass",heading:3,content:V7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_addDependency,label:"addDependency",heading:3,content:N7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_getResult,label:"getResult",heading:3,content:Y7,props:{},visible:!1},{id:L.RENDER_PASS_BUILDER_reset,label:"reset",heading:3,content:J7,props:{},visible:!1},{id:L.RENDER_PASS,label:"Render Pass",heading:2,content:XH,props:{},visible:!1},{id:L.RENDER_PASS_Constructor,label:"Constructor",heading:3,content:f6,props:{},visible:!1},{id:L.RENDER_PASS_getRenderPassHandle,label:"getRenderPassHandle",heading:3,content:h6,props:{},visible:!1},{id:L.RENDER_PASS_getAttachments,label:"getAttachments",heading:3,content:E6,props:{},visible:!1},{id:L.RENDER_PASS_getSubpasses,label:"getSubpasses",heading:3,content:C6,props:{},visible:!1},{id:L.RENDER_PASS_getDependencies,label:"getDependencies",heading:3,content:B6,props:{},visible:!1},{id:L.RENDER_PASS_begin,label:"begin",heading:3,content:N6,props:{},visible:!1},{id:L.RENDER_PASS_end,label:"end",heading:3,content:Q6,props:{},visible:!1},{id:L.FRAMEBUFFER,label:"Framebuffer",heading:2,content:mq,props:{},visible:!1},{id:L.FRAMEBUFFER_Constructor,label:"Constructor",heading:3,content:Aq,props:{},visible:!1},{id:L.FRAMEBUFFER_getFramebufferHandle,label:"getFramebufferHandle",heading:3,content:Vq,props:{},visible:!1},{id:L.FRAMEBUFFER_getExtent,label:"getExtent",heading:3,content:xq,props:{},visible:!1},{id:L.FRAMEBUFFER_getLayers,label:"getLayers",heading:3,content:Hq,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER,label:"Graphics Pipeline Builder",heading:2,content:j8,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_Constructor,label:"Constructor",heading:3,content:J8,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_addShaderStage,label:"addShaderStage",heading:3,content:aK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setInputAssemblyState,label:"setInputAssemblyState",heading:3,content:uK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setVertexInputState,label:"setVertexInputState",heading:3,content:EK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setTessellationState,label:"setTessellationState",heading:3,content:SK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_addViewportState,label:"addViewportState",heading:3,content:OK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setRasterizationState,label:"setRasterizationState",heading:3,content:qK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setMultisampleState,label:"setMultisampleState",heading:3,content:ZK,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setDepthStencilState,label:"setDepthStencilState",heading:3,content:lz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setColorBlendState,label:"setColorBlendState",heading:3,content:dz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setDynamicState,label:"setDynamicState",heading:3,content:Iz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setRenderPass,label:"setRenderPass",heading:3,content:Az,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_setSubpass,label:"setSubpass",heading:3,content:Vz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_getResult,label:"getResult",heading:3,content:Hz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_BUILDER_reset,label:"reset",heading:3,content:Kz,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE,label:"Graphics Pipeline",heading:2,content:g8,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_Constructor,label:"Constructor",heading:3,content:G8,props:{},visible:!1},{id:L.GRAPHICS_PIPELINE_getRenderPass,label:"getRenderPass",heading:3,content:z8,props:{},visible:!1}];let $=!1;function n(p){t(1,$=!$)}function s(){t(1,$=!1)}let a=!1;Cs.subscribe(p=>{t(2,a=p.Screen.width<=1e3)});function u(p,m){c.$$.not_equal(m.visible,p)&&(m.visible=p,t(0,r))}return c.$$.update=()=>{if(c.$$.dirty&1){for(let p=0;p<r.length;p++)if(r[p].visible){r[p];break}}},[r,$,a,n,s,u]}class r9 extends ve{constructor(e){super(),Ee(this,e,jz,Yz,be,{})}}export{r9 as default};
